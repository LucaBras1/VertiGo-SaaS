// GigBook - Musicians Vertical Database Schema
// Extends the shared-core schema with musicians-specific fields

generator client {
  provider = "prisma-client-js"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
}

// ========================================
// EXTENDED ENUMS FOR MUSICIANS
// ========================================

enum Vertical {
  PHOTOGRAPHY
  MUSICIANS
  FITNESS
  EVENTS
  PERFORMING_ARTS
  TEAM_BUILDING
  KIDS_ENTERTAINMENT
}

enum GigStatus {
  INQUIRY      // Initial inquiry received
  QUOTE_SENT   // Quote sent to client
  CONFIRMED    // Gig confirmed by client
  COMPLETED    // Gig has been performed
  CANCELLED    // Gig cancelled
}

enum SetlistStatus {
  DRAFT
  FINALIZED
  PERFORMED
}

// ========================================
// BILLING ENUMS
// ========================================

enum BankProvider {
  FIO
  WISE
  REVOLUT
  PLAID
  NORDIGEN
  MANUAL
}

enum TransactionType {
  DEBIT
  CREDIT
}

enum PaymentMethod {
  BANK_TRANSFER
  CARD
  CASH
  PAYPAL
  STRIPE
  GOPAY
  CRYPTO
}

enum ExpenseStatus {
  DRAFT
  PENDING
  APPROVED
  REJECTED
  REIMBURSED
}

// ========================================
// GIG MODEL (replaces Performance)
// ========================================

model Gig {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Tenant isolation
  tenantId  String
  vertical  Vertical @default(MUSICIANS)

  // Basic Info
  title       String
  slug        String   @unique
  status      GigStatus @default(INQUIRY)
  featured    Boolean  @default(false)

  // Client Information
  clientName     String?
  clientEmail    String?
  clientPhone    String?

  // Event Details
  eventType      String?  // 'wedding' | 'corporate' | 'party' | 'concert' | 'festival'
  eventDate      DateTime?
  eventDuration  Int?     // Minutes
  venue          Json?    // { name, address, city, type: 'indoor' | 'outdoor' }
  audienceSize   Int?
  audienceAge    String?  // e.g., "25-45"

  // Musicians-Specific Fields
  repertoire     Json?    // Song[] - band's available songs
  setlistSongs   String[] // Selected songs for this gig
  bandMembers    Int?     // Number of performers
  instruments    String[] // Instruments used
  genres         String[] // Musical genres
  setDuration    Int?     // Minutes per set
  numberOfSets   Int?     // How many sets
  breakDuration  Int?     // Minutes between sets

  // Technical Requirements
  stageRider        Json?    // Technical rider details
  backlineNeeded    Boolean  @default(false)
  soundcheckTime    DateTime?
  soundSystemProvided Boolean @default(false)
  hasOwnPA          Boolean  @default(true)

  // Pricing
  basePrice      Int?     // Base price in cents
  travelCosts    Int?     // Travel costs in cents
  totalPrice     Int?     // Total price including extras
  deposit        Int?     // Deposit amount
  depositPaid    Boolean  @default(false)

  // Content
  description    Json?    // Tiptap JSON
  internalNotes  String?

  // Media
  featuredImageUrl String?
  featuredImageAlt String?
  galleryImages    Json?   // [{ url, alt, caption }]

  // Relations
  tenant     Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  setlists   Setlist[]
  extras     GigExtra[]
  invoices   Invoice[]

  @@index([tenantId])
  @@index([status])
  @@index([eventDate])
  @@index([slug])
  @@map("gigs")
}

// ========================================
// SETLIST MODEL (replaces Game)
// ========================================

model Setlist {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Tenant isolation
  tenantId  String
  vertical  Vertical @default(MUSICIANS)

  // Basic Info
  name        String
  status      SetlistStatus @default(DRAFT)

  // Linked to Gig
  gigId       String?
  gig         Gig?     @relation(fields: [gigId], references: [id])

  // Setlist Details
  totalDuration  Int      // Total duration in minutes
  mood           String?  // 'energetic' | 'romantic' | 'chill' | 'mixed'

  // Songs (ordered list)
  songs          Json     // Array of { title, artist, duration, key, bpm, notes, order }

  // AI Generation Metadata
  aiGenerated    Boolean  @default(false)
  aiPrompt       String?
  generatedAt    DateTime?

  // Notes
  notes          String?

  tenant         Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([gigId])
  @@index([status])
  @@map("setlists")
}

// ========================================
// GIG EXTRA MODEL (replaces Service)
// ========================================

model GigExtra {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Tenant isolation
  tenantId  String
  vertical  Vertical @default(MUSICIANS)

  // Linked to Gig
  gigId     String
  gig       Gig      @relation(fields: [gigId], references: [id], onDelete: Cascade)

  // Extra Details
  type        String   // 'dj_set' | 'sound_system' | 'lighting' | 'extra_musician' | 'other'
  description String
  price       Int      // Price in cents

  // Quantity
  quantity    Int      @default(1)

  tenant      Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([gigId])
  @@map("gig_extras")
}

// ========================================
// REPERTOIRE MODEL (Band's Song Database)
// ========================================

model RepertoireSong {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Tenant isolation
  tenantId  String
  vertical  Vertical @default(MUSICIANS)

  // Song Details
  title       String
  artist      String?
  genre       String?
  mood        String?  // 'energetic' | 'romantic' | 'chill' | 'party'
  duration    Int      // Duration in seconds

  // Technical Details
  key         String?  // e.g., "C major", "A minor"
  bpm         Int?     // Beats per minute

  // Performance Info
  difficulty  String?  // 'easy' | 'medium' | 'hard'
  instruments String[] // Instruments required
  vocals      String?  // 'lead' | 'harmony' | 'none'

  // Usage Tracking
  timesPerformed Int   @default(0)
  lastPerformed  DateTime?

  // Tags
  tags        String[] // Custom tags for filtering

  // External Links
  spotifyUrl  String?
  youtubeUrl  String?
  sheetMusicUrl String?

  // Notes
  notes       String?

  tenant      Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([genre])
  @@index([mood])
  @@map("repertoire_songs")
}

// ========================================
// STAGE RIDER TEMPLATE MODEL
// ========================================

model StageRiderTemplate {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Tenant isolation
  tenantId  String
  vertical  Vertical @default(MUSICIANS)

  // Template Details
  name        String
  description String?

  // Rider Content
  inputList      Json?  // [{ instrument, channels, notes }]
  monitorSetup   Json?  // { monitors: number, mixType: 'stereo' | 'mono' }
  backlineNeeds  Json?  // [{ item, specifications }]
  stagePlot      String? // Description or URL to diagram
  powerNeeds     String? // Power requirements

  // Timing
  soundcheckDuration Int? // Minutes needed for soundcheck
  setupTime          Int? // Setup time in minutes
  teardownTime       Int? // Teardown time in minutes

  // Additional Requirements
  greenRoomNeeds     String?
  parkingNeeds       String?
  otherRequirements  String?

  // Usage
  isDefault       Boolean @default(false)
  usageCount      Int     @default(0)

  tenant          Tenant  @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([isDefault])
  @@map("stage_rider_templates")
}

// ========================================
// TENANT MODEL (Multi-Tenancy)
// ========================================

model Tenant {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Basic Info
  name      String
  slug      String   @unique
  vertical  Vertical

  // Band/Artist Profile (for Musicians)
  bandName     String?
  bandBio      String?
  bandGenres   String[] // Main genres
  bandSize     Int?     // Number of members
  logoUrl      String?

  // Contact
  email        String
  phone        String?
  website      String?

  // Social Links
  socialLinks  Json?    // { spotify, youtube, facebook, instagram }

  // Settings
  settings     Json?    // Vertical-specific settings

  // Subscription & Billing
  subscriptionTier     String   @default("FREE") // FREE, STARTER, PROFESSIONAL, BUSINESS, ENTERPRISE
  subscriptionStatus   String?  // active, past_due, canceled, trialing, incomplete
  subscriptionEnds     DateTime?
  billingInterval      String?  // month, year
  trialEndsAt          DateTime?

  // Stripe Integration
  stripeCustomerId     String?  @unique
  stripeSubscriptionId String?  @unique

  // AI Usage (tier-based limits)
  aiCreditsUsed        Int      @default(0)
  aiCreditsLimit       Int      @default(100)  // FREE tier default

  // Legacy fields (deprecated, use subscriptionTier)
  plan         String   @default("starter") // 'starter' | 'professional' | 'business'
  planExpiry   DateTime?

  // Status
  isActive     Boolean  @default(true)

  // Relations
  users                     User[]
  gigs                      Gig[]
  setlists                  Setlist[]
  gigExtras                 GigExtra[]
  repertoireSongs           RepertoireSong[]
  stageRiderTemplates       StageRiderTemplate[]
  customers                 Customer[]
  invoices                  Invoice[]

  // Billing relations
  bankAccounts              BankAccount[]
  bankTransactions          BankTransaction[]
  invoicePayments           InvoicePayment[]
  paymentGatewayConfigs     PaymentGatewayConfig[]
  cryptoWallets             CryptoWallet[]
  expenseCategories         ExpenseCategory[]
  expenses                  Expense[]
  recurringInvoiceTemplates RecurringInvoiceTemplate[]

  @@index([slug])
  @@index([vertical])
  @@map("tenants")
}

// ========================================
// USER MODEL (extends for multi-tenancy)
// ========================================

model User {
  id            String    @id @default(cuid())
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Auth
  email         String    @unique
  emailVerified DateTime?
  password      String?

  // Password Reset
  resetToken        String?
  resetTokenExpiry  DateTime?

  // Profile
  name          String?
  role          String    @default("admin") // 'admin' | 'member' | 'viewer'
  avatar        String?

  // Multi-tenant
  tenantId      String
  tenant        Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  // Relations
  accounts      Account[]
  sessions      Session[]

  @@index([tenantId])
  @@index([email])
  @@map("users")
}

// ========================================
// CUSTOMER MODEL (shared across verticals)
// ========================================

model Customer {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Tenant isolation
  tenantId  String
  tenant    Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  // Basic Info
  email       String
  firstName   String
  lastName    String
  phone       String?
  company     String?

  // Address
  address     Json?  // { street, city, zip, country }

  // Tags & Notes
  tags        String[]
  notes       String?

  // Relations
  invoices    Invoice[]

  @@unique([tenantId, email])
  @@index([tenantId])
  @@index([email])
  @@map("customers")
}

// ========================================
// INVOICE MODEL (simplified for musicians)
// ========================================

model Invoice {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Tenant isolation
  tenantId  String
  tenant    Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  // Invoice Details
  invoiceNumber String   @unique
  status        String   @default("draft") // 'draft' | 'sent' | 'paid' | 'overdue'

  // Customer
  customerId    String
  customer      Customer @relation(fields: [customerId], references: [id])

  // Linked Gig
  gigId         String?
  gig           Gig?     @relation(fields: [gigId], references: [id])

  // Dates
  issueDate     DateTime @default(now())
  dueDate       DateTime
  paidDate      DateTime?

  // Amounts (in cents)
  subtotal      Int
  taxRate       Float    @default(0)
  taxAmount     Int      @default(0)
  totalAmount   Int
  paidAmount    Int      @default(0)

  // Line Items
  items         Json     // [{ description, quantity, unitPrice, total }]

  // Notes
  notes         String?

  // PDF
  pdfUrl        String?

  // Billing relations
  payments           InvoicePayment[]
  bankTransactions   BankTransaction[]
  cryptoPayments     CryptoPayment[]

  @@index([tenantId])
  @@index([customerId])
  @@index([gigId])
  @@index([status])
  @@index([invoiceNumber])
  @@map("invoices")
}

// ========================================
// BILLING MODELS - CURRENCY & EXCHANGE
// ========================================

model Currency {
  id              String   @id @default(cuid())
  code            String   @unique // CZK, EUR, USD, BTC, etc.
  name            String
  symbol          String
  decimals        Int      @default(2)
  isCrypto        Boolean  @default(false)
  isStablecoin    Boolean  @default(false)
  isActive        Boolean  @default(true)

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  exchangeRatesFrom ExchangeRate[] @relation("FromCurrency")
  exchangeRatesTo   ExchangeRate[] @relation("ToCurrency")

  @@index([code])
  @@map("currencies")
}

model ExchangeRate {
  id              String   @id @default(cuid())
  fromCurrencyId  String
  toCurrencyId    String
  rate            Decimal  @db.Decimal(20, 10)
  source          String   // ECB, CNB, OpenExchange, Coinbase, Manual
  timestamp       DateTime

  fromCurrency    Currency @relation("FromCurrency", fields: [fromCurrencyId], references: [id])
  toCurrency      Currency @relation("ToCurrency", fields: [toCurrencyId], references: [id])

  @@unique([fromCurrencyId, toCurrencyId, timestamp])
  @@index([timestamp])
  @@map("exchange_rates")
}

// ========================================
// BILLING MODELS - BANK ACCOUNTS
// ========================================

model BankAccount {
  id                String       @id @default(cuid())
  tenantId          String
  tenant            Tenant       @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  // Account details
  accountName       String
  accountNumber     String
  bankCode          String?
  iban              String?
  swift             String?

  // Provider
  provider          BankProvider
  providerAccountId String?

  // Currency & balance
  currency          String       @default("EUR")
  balance           Decimal?     @db.Decimal(12, 2)
  balanceUpdatedAt  DateTime?

  // Sync settings
  autoSync          Boolean      @default(false)
  lastSyncAt        DateTime?
  syncFrequency     String       @default("MANUAL") // MANUAL, HOURLY, DAILY, WEEKLY

  // Encrypted credentials (JSON)
  credentials       Json?        @db.JsonB

  // Status
  isActive          Boolean      @default(true)

  // Metadata
  metadata          Json?        @db.JsonB

  createdAt         DateTime     @default(now())
  updatedAt         DateTime     @updatedAt

  transactions      BankTransaction[]

  @@index([tenantId])
  @@index([provider])
  @@map("bank_accounts")
}

model BankTransaction {
  id                  String          @id @default(cuid())
  bankAccountId       String
  bankAccount         BankAccount     @relation(fields: [bankAccountId], references: [id], onDelete: Cascade)
  tenantId            String
  tenant              Tenant          @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  // Transaction details
  transactionId       String          // Bank's transaction ID
  date                DateTime
  amount              Decimal         @db.Decimal(12, 2)
  currency            String

  // Type
  type                TransactionType

  // Counterparty
  counterpartyName    String?
  counterpartyAccount String?
  counterpartyBankCode String?

  // Description
  description         String?         @db.Text
  note                String?         @db.Text
  variableSymbol      String?
  constantSymbol      String?
  specificSymbol      String?

  // Reference
  reference           String?

  // Matching
  isMatched           Boolean         @default(false)
  matchedInvoiceId    String?
  matchedInvoice      Invoice?        @relation(fields: [matchedInvoiceId], references: [id])
  matchedPaymentId    String?
  matchConfidence     Decimal?        @db.Decimal(3, 2) // 0.00 to 1.00

  // AI suggestions
  aiSuggestions       Json?           @db.JsonB

  // Metadata
  metadata            Json?           @db.JsonB

  createdAt           DateTime        @default(now())
  updatedAt           DateTime        @updatedAt

  @@unique([bankAccountId, transactionId])
  @@index([tenantId])
  @@index([date])
  @@index([isMatched])
  @@map("bank_transactions")
}

// ========================================
// BILLING MODELS - INVOICE PAYMENTS
// ========================================

model InvoicePayment {
  id                String   @id @default(cuid())
  tenantId          String
  tenant            Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  invoiceId         String
  invoice           Invoice  @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

  // Payment details
  amount            Decimal  @db.Decimal(10, 2)
  currency          String
  method            PaymentMethod
  status            String   @default("PENDING") // PENDING, PROCESSING, COMPLETED, FAILED, CANCELLED, REFUNDED

  // Gateway info
  gatewayProvider   String?
  gatewayPaymentId  String?
  gatewayFee        Decimal? @db.Decimal(10, 2)

  // Transaction details
  transactionId     String?
  reference         String?

  // Dates
  processedAt       DateTime?
  completedAt       DateTime?

  // Metadata
  metadata          Json?    @db.JsonB

  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  @@index([tenantId])
  @@index([invoiceId])
  @@index([status])
  @@map("invoice_payments")
}

// ========================================
// BILLING MODELS - PAYMENT GATEWAY
// ========================================

model PaymentGatewayConfig {
  id                String   @id @default(cuid())
  tenantId          String
  tenant            Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  // Provider
  provider          String   // STRIPE, PAYPAL, GOPAY, ADYEN, SQUARE

  // Config (encrypted)
  config            Json     @db.JsonB

  // Status
  isActive          Boolean  @default(true)
  isTest            Boolean  @default(false)

  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  @@unique([tenantId, provider])
  @@index([tenantId])
  @@map("payment_gateway_configs")
}

// ========================================
// BILLING MODELS - CRYPTO PAYMENTS
// ========================================

model CryptoWallet {
  id                String   @id @default(cuid())
  tenantId          String
  tenant            Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  // Wallet details
  currency          String   // BTC, ETH, USDC, USDT
  address           String
  network           String?  // mainnet, testnet, polygon, etc.

  // Provider
  provider          String   // COINBASE_COMMERCE, BTCPAY_SERVER, CIRCLE

  // Status
  isActive          Boolean  @default(true)

  // Metadata
  metadata          Json?    @db.JsonB

  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  payments          CryptoPayment[]

  @@unique([tenantId, currency, address])
  @@index([tenantId])
  @@map("crypto_wallets")
}

model CryptoPayment {
  id                String   @id @default(cuid())
  walletId          String
  wallet            CryptoWallet @relation(fields: [walletId], references: [id], onDelete: Cascade)
  invoiceId         String?
  invoice           Invoice?     @relation(fields: [invoiceId], references: [id])

  // Payment details
  amount            String   // Crypto amounts as strings for precision
  currency          String
  txHash            String?  // Transaction hash
  confirmations     Int      @default(0)

  // Status
  status            String   @default("PENDING") // PENDING, CONFIRMED, COMPLETED, FAILED

  // Dates
  detectedAt        DateTime?
  confirmedAt       DateTime?

  // Metadata
  metadata          Json?    @db.JsonB

  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  @@index([walletId])
  @@index([status])
  @@map("crypto_payments")
}

// ========================================
// BILLING MODELS - EXPENSES
// ========================================

model ExpenseCategory {
  id                String   @id @default(cuid())
  tenantId          String
  tenant            Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  name              String
  description       String?
  isDefault         Boolean  @default(false)

  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  expenses          Expense[]

  @@unique([tenantId, name])
  @@index([tenantId])
  @@map("expense_categories")
}

model Expense {
  id                String          @id @default(cuid())
  tenantId          String
  tenant            Tenant          @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  categoryId        String
  category          ExpenseCategory @relation(fields: [categoryId], references: [id])

  // Basic info
  description       String
  amount            Decimal         @db.Decimal(10, 2)
  currency          String

  // Date
  date              DateTime

  // Vendor
  vendor            String?

  // Receipt
  receiptUrl        String?
  receiptOcrData    Json?           @db.JsonB

  // Tax
  taxAmount         Decimal?        @db.Decimal(10, 2)
  isTaxDeductible   Boolean         @default(false)

  // Status
  status            ExpenseStatus

  // Approval
  approvedBy        String?
  approvedAt        DateTime?
  rejectedReason    String?

  // Reimbursement
  reimbursedAt      DateTime?
  reimbursedAmount  Decimal?        @db.Decimal(10, 2)

  // Notes
  notes             String?         @db.Text

  // Metadata
  metadata          Json?           @db.JsonB

  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt

  @@index([tenantId])
  @@index([status])
  @@index([date])
  @@map("expenses")
}

// ========================================
// BILLING MODELS - RECURRING INVOICES
// ========================================

model RecurringInvoiceTemplate {
  id                String   @id @default(cuid())
  tenantId          String
  tenant            Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  // Recurrence
  frequency         String   // WEEKLY, BIWEEKLY, MONTHLY, QUARTERLY, YEARLY
  nextInvoiceDate   DateTime
  isActive          Boolean  @default(true)

  // Invoice template (JSON)
  invoiceTemplate   Json     @db.JsonB

  // Metadata
  metadata          Json?    @db.JsonB

  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  @@index([tenantId])
  @@index([nextInvoiceDate])
  @@map("recurring_invoice_templates")
}

// ========================================
// NEXTAUTH MODELS
// ========================================

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}

// ========================================
// CALENDAR INTEGRATION MODELS
// ========================================

model CalendarIntegration {
  id           String   @id @default(cuid())
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  tenantId     String
  userId       String

  // Provider info
  provider     String   // 'google' | 'apple' | 'outlook'
  calendarId   String?  // Selected calendar ID

  // OAuth tokens (encrypted)
  accessToken  String?
  refreshToken String?
  tokenExpiry  DateTime?

  // Sync settings
  syncEnabled  Boolean  @default(true)
  lastSyncAt   DateTime?
  syncErrors   Json?    // Last sync errors if any

  @@unique([tenantId, userId, provider])
  @@index([tenantId])
  @@map("calendar_integrations")
}

model CalendarEventSync {
  id             String   @id @default(cuid())
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  integrationId  String
  entityType     String   // 'gig'
  entityId       String   // Gig ID
  externalEventId String  // Google/Apple event ID
  syncHash       String?  // Hash of synced data for change detection

  @@unique([integrationId, entityType, entityId])
  @@index([entityId])
  @@map("calendar_event_syncs")
}

model CalendarFeedToken {
  id         String   @id @default(cuid())
  createdAt  DateTime @default(now())

  tenantId   String
  userId     String
  token      String   @unique @default(cuid())
  expiresAt  DateTime?

  @@unique([tenantId, userId])
  @@index([token])
  @@map("calendar_feed_tokens")
}
