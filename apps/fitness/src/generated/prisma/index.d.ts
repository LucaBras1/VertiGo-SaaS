
/**
 * Client
**/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Tenant
 * 
 */
export type Tenant = $Result.DefaultSelection<Prisma.$TenantPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model UserSession
 * 
 */
export type UserSession = $Result.DefaultSelection<Prisma.$UserSessionPayload>
/**
 * Model VerificationToken
 * 
 */
export type VerificationToken = $Result.DefaultSelection<Prisma.$VerificationTokenPayload>
/**
 * Model PasswordResetToken
 * 
 */
export type PasswordResetToken = $Result.DefaultSelection<Prisma.$PasswordResetTokenPayload>
/**
 * Model Client
 * 
 */
export type Client = $Result.DefaultSelection<Prisma.$ClientPayload>
/**
 * Model ClientMeasurement
 * 
 */
export type ClientMeasurement = $Result.DefaultSelection<Prisma.$ClientMeasurementPayload>
/**
 * Model ProgressPhoto
 * 
 */
export type ProgressPhoto = $Result.DefaultSelection<Prisma.$ProgressPhotoPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Class
 * 
 */
export type Class = $Result.DefaultSelection<Prisma.$ClassPayload>
/**
 * Model ClassBooking
 * 
 */
export type ClassBooking = $Result.DefaultSelection<Prisma.$ClassBookingPayload>
/**
 * Model Package
 * 
 */
export type Package = $Result.DefaultSelection<Prisma.$PackagePayload>
/**
 * Model Order
 * 
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>
/**
 * Model Invoice
 * 
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>
/**
 * Model AILog
 * 
 */
export type AILog = $Result.DefaultSelection<Prisma.$AILogPayload>
/**
 * Model Currency
 * 
 */
export type Currency = $Result.DefaultSelection<Prisma.$CurrencyPayload>
/**
 * Model ExchangeRate
 * 
 */
export type ExchangeRate = $Result.DefaultSelection<Prisma.$ExchangeRatePayload>
/**
 * Model BankAccount
 * 
 */
export type BankAccount = $Result.DefaultSelection<Prisma.$BankAccountPayload>
/**
 * Model BankTransaction
 * 
 */
export type BankTransaction = $Result.DefaultSelection<Prisma.$BankTransactionPayload>
/**
 * Model InvoicePayment
 * 
 */
export type InvoicePayment = $Result.DefaultSelection<Prisma.$InvoicePaymentPayload>
/**
 * Model PaymentGatewayConfig
 * 
 */
export type PaymentGatewayConfig = $Result.DefaultSelection<Prisma.$PaymentGatewayConfigPayload>
/**
 * Model CryptoWallet
 * 
 */
export type CryptoWallet = $Result.DefaultSelection<Prisma.$CryptoWalletPayload>
/**
 * Model CryptoPayment
 * 
 */
export type CryptoPayment = $Result.DefaultSelection<Prisma.$CryptoPaymentPayload>
/**
 * Model ExpenseCategory
 * 
 */
export type ExpenseCategory = $Result.DefaultSelection<Prisma.$ExpenseCategoryPayload>
/**
 * Model Expense
 * 
 */
export type Expense = $Result.DefaultSelection<Prisma.$ExpensePayload>
/**
 * Model RecurringInvoiceTemplate
 * 
 */
export type RecurringInvoiceTemplate = $Result.DefaultSelection<Prisma.$RecurringInvoiceTemplatePayload>
/**
 * Model PushSubscription
 * 
 */
export type PushSubscription = $Result.DefaultSelection<Prisma.$PushSubscriptionPayload>
/**
 * Model NotificationPreference
 * 
 */
export type NotificationPreference = $Result.DefaultSelection<Prisma.$NotificationPreferencePayload>
/**
 * Model NotificationLog
 * 
 */
export type NotificationLog = $Result.DefaultSelection<Prisma.$NotificationLogPayload>
/**
 * Model CalendarIntegration
 * 
 */
export type CalendarIntegration = $Result.DefaultSelection<Prisma.$CalendarIntegrationPayload>
/**
 * Model CalendarEventSync
 * 
 */
export type CalendarEventSync = $Result.DefaultSelection<Prisma.$CalendarEventSyncPayload>
/**
 * Model CalendarFeedToken
 * 
 */
export type CalendarFeedToken = $Result.DefaultSelection<Prisma.$CalendarFeedTokenPayload>
/**
 * Model Badge
 * 
 */
export type Badge = $Result.DefaultSelection<Prisma.$BadgePayload>
/**
 * Model ClientBadge
 * 
 */
export type ClientBadge = $Result.DefaultSelection<Prisma.$ClientBadgePayload>
/**
 * Model WorkoutTemplate
 * 
 */
export type WorkoutTemplate = $Result.DefaultSelection<Prisma.$WorkoutTemplatePayload>
/**
 * Model ScheduleTemplate
 * 
 */
export type ScheduleTemplate = $Result.DefaultSelection<Prisma.$ScheduleTemplatePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Vertical: {
  MUSICIANS: 'MUSICIANS',
  PHOTOGRAPHY: 'PHOTOGRAPHY',
  FITNESS: 'FITNESS',
  EVENTS: 'EVENTS',
  PERFORMING_ARTS: 'PERFORMING_ARTS',
  TEAM_BUILDING: 'TEAM_BUILDING',
  KIDS_ENTERTAINMENT: 'KIDS_ENTERTAINMENT'
};

export type Vertical = (typeof Vertical)[keyof typeof Vertical]


export const BankProvider: {
  FIO: 'FIO',
  WISE: 'WISE',
  REVOLUT: 'REVOLUT',
  PLAID: 'PLAID',
  NORDIGEN: 'NORDIGEN',
  MANUAL: 'MANUAL'
};

export type BankProvider = (typeof BankProvider)[keyof typeof BankProvider]


export const TransactionType: {
  DEBIT: 'DEBIT',
  CREDIT: 'CREDIT'
};

export type TransactionType = (typeof TransactionType)[keyof typeof TransactionType]


export const PaymentMethod: {
  BANK_TRANSFER: 'BANK_TRANSFER',
  CARD: 'CARD',
  CASH: 'CASH',
  PAYPAL: 'PAYPAL',
  STRIPE: 'STRIPE',
  GOPAY: 'GOPAY',
  CRYPTO: 'CRYPTO'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const ExpenseStatus: {
  DRAFT: 'DRAFT',
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  REIMBURSED: 'REIMBURSED'
};

export type ExpenseStatus = (typeof ExpenseStatus)[keyof typeof ExpenseStatus]

}

export type Vertical = $Enums.Vertical

export const Vertical: typeof $Enums.Vertical

export type BankProvider = $Enums.BankProvider

export const BankProvider: typeof $Enums.BankProvider

export type TransactionType = $Enums.TransactionType

export const TransactionType: typeof $Enums.TransactionType

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type ExpenseStatus = $Enums.ExpenseStatus

export const ExpenseStatus: typeof $Enums.ExpenseStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Tenants
 * const tenants = await prisma.tenant.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Tenants
   * const tenants = await prisma.tenant.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.tenant`: Exposes CRUD operations for the **Tenant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tenants
    * const tenants = await prisma.tenant.findMany()
    * ```
    */
  get tenant(): Prisma.TenantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userSession`: Exposes CRUD operations for the **UserSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSessions
    * const userSessions = await prisma.userSession.findMany()
    * ```
    */
  get userSession(): Prisma.UserSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationTokens
    * const verificationTokens = await prisma.verificationToken.findMany()
    * ```
    */
  get verificationToken(): Prisma.VerificationTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.passwordResetToken`: Exposes CRUD operations for the **PasswordResetToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PasswordResetTokens
    * const passwordResetTokens = await prisma.passwordResetToken.findMany()
    * ```
    */
  get passwordResetToken(): Prisma.PasswordResetTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.client`: Exposes CRUD operations for the **Client** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clients
    * const clients = await prisma.client.findMany()
    * ```
    */
  get client(): Prisma.ClientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clientMeasurement`: Exposes CRUD operations for the **ClientMeasurement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClientMeasurements
    * const clientMeasurements = await prisma.clientMeasurement.findMany()
    * ```
    */
  get clientMeasurement(): Prisma.ClientMeasurementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.progressPhoto`: Exposes CRUD operations for the **ProgressPhoto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProgressPhotos
    * const progressPhotos = await prisma.progressPhoto.findMany()
    * ```
    */
  get progressPhoto(): Prisma.ProgressPhotoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.class`: Exposes CRUD operations for the **Class** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Classes
    * const classes = await prisma.class.findMany()
    * ```
    */
  get class(): Prisma.ClassDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.classBooking`: Exposes CRUD operations for the **ClassBooking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClassBookings
    * const classBookings = await prisma.classBooking.findMany()
    * ```
    */
  get classBooking(): Prisma.ClassBookingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.package`: Exposes CRUD operations for the **Package** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Packages
    * const packages = await prisma.package.findMany()
    * ```
    */
  get package(): Prisma.PackageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aILog`: Exposes CRUD operations for the **AILog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AILogs
    * const aILogs = await prisma.aILog.findMany()
    * ```
    */
  get aILog(): Prisma.AILogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.currency`: Exposes CRUD operations for the **Currency** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Currencies
    * const currencies = await prisma.currency.findMany()
    * ```
    */
  get currency(): Prisma.CurrencyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.exchangeRate`: Exposes CRUD operations for the **ExchangeRate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExchangeRates
    * const exchangeRates = await prisma.exchangeRate.findMany()
    * ```
    */
  get exchangeRate(): Prisma.ExchangeRateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bankAccount`: Exposes CRUD operations for the **BankAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BankAccounts
    * const bankAccounts = await prisma.bankAccount.findMany()
    * ```
    */
  get bankAccount(): Prisma.BankAccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bankTransaction`: Exposes CRUD operations for the **BankTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BankTransactions
    * const bankTransactions = await prisma.bankTransaction.findMany()
    * ```
    */
  get bankTransaction(): Prisma.BankTransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoicePayment`: Exposes CRUD operations for the **InvoicePayment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvoicePayments
    * const invoicePayments = await prisma.invoicePayment.findMany()
    * ```
    */
  get invoicePayment(): Prisma.InvoicePaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paymentGatewayConfig`: Exposes CRUD operations for the **PaymentGatewayConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentGatewayConfigs
    * const paymentGatewayConfigs = await prisma.paymentGatewayConfig.findMany()
    * ```
    */
  get paymentGatewayConfig(): Prisma.PaymentGatewayConfigDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cryptoWallet`: Exposes CRUD operations for the **CryptoWallet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CryptoWallets
    * const cryptoWallets = await prisma.cryptoWallet.findMany()
    * ```
    */
  get cryptoWallet(): Prisma.CryptoWalletDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cryptoPayment`: Exposes CRUD operations for the **CryptoPayment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CryptoPayments
    * const cryptoPayments = await prisma.cryptoPayment.findMany()
    * ```
    */
  get cryptoPayment(): Prisma.CryptoPaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.expenseCategory`: Exposes CRUD operations for the **ExpenseCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExpenseCategories
    * const expenseCategories = await prisma.expenseCategory.findMany()
    * ```
    */
  get expenseCategory(): Prisma.ExpenseCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.expense`: Exposes CRUD operations for the **Expense** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Expenses
    * const expenses = await prisma.expense.findMany()
    * ```
    */
  get expense(): Prisma.ExpenseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.recurringInvoiceTemplate`: Exposes CRUD operations for the **RecurringInvoiceTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RecurringInvoiceTemplates
    * const recurringInvoiceTemplates = await prisma.recurringInvoiceTemplate.findMany()
    * ```
    */
  get recurringInvoiceTemplate(): Prisma.RecurringInvoiceTemplateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pushSubscription`: Exposes CRUD operations for the **PushSubscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PushSubscriptions
    * const pushSubscriptions = await prisma.pushSubscription.findMany()
    * ```
    */
  get pushSubscription(): Prisma.PushSubscriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notificationPreference`: Exposes CRUD operations for the **NotificationPreference** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationPreferences
    * const notificationPreferences = await prisma.notificationPreference.findMany()
    * ```
    */
  get notificationPreference(): Prisma.NotificationPreferenceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notificationLog`: Exposes CRUD operations for the **NotificationLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationLogs
    * const notificationLogs = await prisma.notificationLog.findMany()
    * ```
    */
  get notificationLog(): Prisma.NotificationLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.calendarIntegration`: Exposes CRUD operations for the **CalendarIntegration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CalendarIntegrations
    * const calendarIntegrations = await prisma.calendarIntegration.findMany()
    * ```
    */
  get calendarIntegration(): Prisma.CalendarIntegrationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.calendarEventSync`: Exposes CRUD operations for the **CalendarEventSync** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CalendarEventSyncs
    * const calendarEventSyncs = await prisma.calendarEventSync.findMany()
    * ```
    */
  get calendarEventSync(): Prisma.CalendarEventSyncDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.calendarFeedToken`: Exposes CRUD operations for the **CalendarFeedToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CalendarFeedTokens
    * const calendarFeedTokens = await prisma.calendarFeedToken.findMany()
    * ```
    */
  get calendarFeedToken(): Prisma.CalendarFeedTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.badge`: Exposes CRUD operations for the **Badge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Badges
    * const badges = await prisma.badge.findMany()
    * ```
    */
  get badge(): Prisma.BadgeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clientBadge`: Exposes CRUD operations for the **ClientBadge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClientBadges
    * const clientBadges = await prisma.clientBadge.findMany()
    * ```
    */
  get clientBadge(): Prisma.ClientBadgeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workoutTemplate`: Exposes CRUD operations for the **WorkoutTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkoutTemplates
    * const workoutTemplates = await prisma.workoutTemplate.findMany()
    * ```
    */
  get workoutTemplate(): Prisma.WorkoutTemplateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.scheduleTemplate`: Exposes CRUD operations for the **ScheduleTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ScheduleTemplates
    * const scheduleTemplates = await prisma.scheduleTemplate.findMany()
    * ```
    */
  get scheduleTemplate(): Prisma.ScheduleTemplateDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.3.0
   * Query Engine version: 9d6ad21cbbceab97458517b147a6a09ff43aa735
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Tenant: 'Tenant',
    User: 'User',
    Account: 'Account',
    UserSession: 'UserSession',
    VerificationToken: 'VerificationToken',
    PasswordResetToken: 'PasswordResetToken',
    Client: 'Client',
    ClientMeasurement: 'ClientMeasurement',
    ProgressPhoto: 'ProgressPhoto',
    Session: 'Session',
    Class: 'Class',
    ClassBooking: 'ClassBooking',
    Package: 'Package',
    Order: 'Order',
    Invoice: 'Invoice',
    AILog: 'AILog',
    Currency: 'Currency',
    ExchangeRate: 'ExchangeRate',
    BankAccount: 'BankAccount',
    BankTransaction: 'BankTransaction',
    InvoicePayment: 'InvoicePayment',
    PaymentGatewayConfig: 'PaymentGatewayConfig',
    CryptoWallet: 'CryptoWallet',
    CryptoPayment: 'CryptoPayment',
    ExpenseCategory: 'ExpenseCategory',
    Expense: 'Expense',
    RecurringInvoiceTemplate: 'RecurringInvoiceTemplate',
    PushSubscription: 'PushSubscription',
    NotificationPreference: 'NotificationPreference',
    NotificationLog: 'NotificationLog',
    CalendarIntegration: 'CalendarIntegration',
    CalendarEventSync: 'CalendarEventSync',
    CalendarFeedToken: 'CalendarFeedToken',
    Badge: 'Badge',
    ClientBadge: 'ClientBadge',
    WorkoutTemplate: 'WorkoutTemplate',
    ScheduleTemplate: 'ScheduleTemplate'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "tenant" | "user" | "account" | "userSession" | "verificationToken" | "passwordResetToken" | "client" | "clientMeasurement" | "progressPhoto" | "session" | "class" | "classBooking" | "package" | "order" | "invoice" | "aILog" | "currency" | "exchangeRate" | "bankAccount" | "bankTransaction" | "invoicePayment" | "paymentGatewayConfig" | "cryptoWallet" | "cryptoPayment" | "expenseCategory" | "expense" | "recurringInvoiceTemplate" | "pushSubscription" | "notificationPreference" | "notificationLog" | "calendarIntegration" | "calendarEventSync" | "calendarFeedToken" | "badge" | "clientBadge" | "workoutTemplate" | "scheduleTemplate"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Tenant: {
        payload: Prisma.$TenantPayload<ExtArgs>
        fields: Prisma.TenantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findFirst: {
            args: Prisma.TenantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findMany: {
            args: Prisma.TenantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          create: {
            args: Prisma.TenantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          createMany: {
            args: Prisma.TenantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          delete: {
            args: Prisma.TenantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          update: {
            args: Prisma.TenantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          deleteMany: {
            args: Prisma.TenantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TenantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          upsert: {
            args: Prisma.TenantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          aggregate: {
            args: Prisma.TenantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenant>
          }
          groupBy: {
            args: Prisma.TenantGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenantCountArgs<ExtArgs>
            result: $Utils.Optional<TenantCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      UserSession: {
        payload: Prisma.$UserSessionPayload<ExtArgs>
        fields: Prisma.UserSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          findFirst: {
            args: Prisma.UserSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          findMany: {
            args: Prisma.UserSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>[]
          }
          create: {
            args: Prisma.UserSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          createMany: {
            args: Prisma.UserSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>[]
          }
          delete: {
            args: Prisma.UserSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          update: {
            args: Prisma.UserSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          deleteMany: {
            args: Prisma.UserSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>[]
          }
          upsert: {
            args: Prisma.UserSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          aggregate: {
            args: Prisma.UserSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSession>
          }
          groupBy: {
            args: Prisma.UserSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSessionCountArgs<ExtArgs>
            result: $Utils.Optional<UserSessionCountAggregateOutputType> | number
          }
        }
      }
      VerificationToken: {
        payload: Prisma.$VerificationTokenPayload<ExtArgs>
        fields: Prisma.VerificationTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findFirst: {
            args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findMany: {
            args: Prisma.VerificationTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          create: {
            args: Prisma.VerificationTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          createMany: {
            args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          delete: {
            args: Prisma.VerificationTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          update: {
            args: Prisma.VerificationTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          deleteMany: {
            args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          upsert: {
            args: Prisma.VerificationTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          aggregate: {
            args: Prisma.VerificationTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerificationToken>
          }
          groupBy: {
            args: Prisma.VerificationTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationTokenCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenCountAggregateOutputType> | number
          }
        }
      }
      PasswordResetToken: {
        payload: Prisma.$PasswordResetTokenPayload<ExtArgs>
        fields: Prisma.PasswordResetTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PasswordResetTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          findFirst: {
            args: Prisma.PasswordResetTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PasswordResetTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          findMany: {
            args: Prisma.PasswordResetTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          create: {
            args: Prisma.PasswordResetTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          createMany: {
            args: Prisma.PasswordResetTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PasswordResetTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          delete: {
            args: Prisma.PasswordResetTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          update: {
            args: Prisma.PasswordResetTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          deleteMany: {
            args: Prisma.PasswordResetTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PasswordResetTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PasswordResetTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          upsert: {
            args: Prisma.PasswordResetTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          aggregate: {
            args: Prisma.PasswordResetTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePasswordResetToken>
          }
          groupBy: {
            args: Prisma.PasswordResetTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.PasswordResetTokenCountArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetTokenCountAggregateOutputType> | number
          }
        }
      }
      Client: {
        payload: Prisma.$ClientPayload<ExtArgs>
        fields: Prisma.ClientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findFirst: {
            args: Prisma.ClientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findMany: {
            args: Prisma.ClientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          create: {
            args: Prisma.ClientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          createMany: {
            args: Prisma.ClientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          delete: {
            args: Prisma.ClientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          update: {
            args: Prisma.ClientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          deleteMany: {
            args: Prisma.ClientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClientUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          upsert: {
            args: Prisma.ClientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          aggregate: {
            args: Prisma.ClientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClient>
          }
          groupBy: {
            args: Prisma.ClientGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientCountArgs<ExtArgs>
            result: $Utils.Optional<ClientCountAggregateOutputType> | number
          }
        }
      }
      ClientMeasurement: {
        payload: Prisma.$ClientMeasurementPayload<ExtArgs>
        fields: Prisma.ClientMeasurementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientMeasurementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientMeasurementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientMeasurementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientMeasurementPayload>
          }
          findFirst: {
            args: Prisma.ClientMeasurementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientMeasurementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientMeasurementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientMeasurementPayload>
          }
          findMany: {
            args: Prisma.ClientMeasurementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientMeasurementPayload>[]
          }
          create: {
            args: Prisma.ClientMeasurementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientMeasurementPayload>
          }
          createMany: {
            args: Prisma.ClientMeasurementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClientMeasurementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientMeasurementPayload>[]
          }
          delete: {
            args: Prisma.ClientMeasurementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientMeasurementPayload>
          }
          update: {
            args: Prisma.ClientMeasurementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientMeasurementPayload>
          }
          deleteMany: {
            args: Prisma.ClientMeasurementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientMeasurementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClientMeasurementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientMeasurementPayload>[]
          }
          upsert: {
            args: Prisma.ClientMeasurementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientMeasurementPayload>
          }
          aggregate: {
            args: Prisma.ClientMeasurementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClientMeasurement>
          }
          groupBy: {
            args: Prisma.ClientMeasurementGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientMeasurementGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientMeasurementCountArgs<ExtArgs>
            result: $Utils.Optional<ClientMeasurementCountAggregateOutputType> | number
          }
        }
      }
      ProgressPhoto: {
        payload: Prisma.$ProgressPhotoPayload<ExtArgs>
        fields: Prisma.ProgressPhotoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProgressPhotoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressPhotoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProgressPhotoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressPhotoPayload>
          }
          findFirst: {
            args: Prisma.ProgressPhotoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressPhotoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProgressPhotoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressPhotoPayload>
          }
          findMany: {
            args: Prisma.ProgressPhotoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressPhotoPayload>[]
          }
          create: {
            args: Prisma.ProgressPhotoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressPhotoPayload>
          }
          createMany: {
            args: Prisma.ProgressPhotoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProgressPhotoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressPhotoPayload>[]
          }
          delete: {
            args: Prisma.ProgressPhotoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressPhotoPayload>
          }
          update: {
            args: Prisma.ProgressPhotoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressPhotoPayload>
          }
          deleteMany: {
            args: Prisma.ProgressPhotoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProgressPhotoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProgressPhotoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressPhotoPayload>[]
          }
          upsert: {
            args: Prisma.ProgressPhotoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressPhotoPayload>
          }
          aggregate: {
            args: Prisma.ProgressPhotoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProgressPhoto>
          }
          groupBy: {
            args: Prisma.ProgressPhotoGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProgressPhotoGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProgressPhotoCountArgs<ExtArgs>
            result: $Utils.Optional<ProgressPhotoCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Class: {
        payload: Prisma.$ClassPayload<ExtArgs>
        fields: Prisma.ClassFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClassFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClassFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          findFirst: {
            args: Prisma.ClassFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClassFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          findMany: {
            args: Prisma.ClassFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>[]
          }
          create: {
            args: Prisma.ClassCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          createMany: {
            args: Prisma.ClassCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClassCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>[]
          }
          delete: {
            args: Prisma.ClassDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          update: {
            args: Prisma.ClassUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          deleteMany: {
            args: Prisma.ClassDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClassUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClassUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>[]
          }
          upsert: {
            args: Prisma.ClassUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          aggregate: {
            args: Prisma.ClassAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClass>
          }
          groupBy: {
            args: Prisma.ClassGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClassGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClassCountArgs<ExtArgs>
            result: $Utils.Optional<ClassCountAggregateOutputType> | number
          }
        }
      }
      ClassBooking: {
        payload: Prisma.$ClassBookingPayload<ExtArgs>
        fields: Prisma.ClassBookingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClassBookingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassBookingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClassBookingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassBookingPayload>
          }
          findFirst: {
            args: Prisma.ClassBookingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassBookingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClassBookingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassBookingPayload>
          }
          findMany: {
            args: Prisma.ClassBookingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassBookingPayload>[]
          }
          create: {
            args: Prisma.ClassBookingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassBookingPayload>
          }
          createMany: {
            args: Prisma.ClassBookingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClassBookingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassBookingPayload>[]
          }
          delete: {
            args: Prisma.ClassBookingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassBookingPayload>
          }
          update: {
            args: Prisma.ClassBookingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassBookingPayload>
          }
          deleteMany: {
            args: Prisma.ClassBookingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClassBookingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClassBookingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassBookingPayload>[]
          }
          upsert: {
            args: Prisma.ClassBookingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassBookingPayload>
          }
          aggregate: {
            args: Prisma.ClassBookingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClassBooking>
          }
          groupBy: {
            args: Prisma.ClassBookingGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClassBookingGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClassBookingCountArgs<ExtArgs>
            result: $Utils.Optional<ClassBookingCountAggregateOutputType> | number
          }
        }
      }
      Package: {
        payload: Prisma.$PackagePayload<ExtArgs>
        fields: Prisma.PackageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PackageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PackageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePayload>
          }
          findFirst: {
            args: Prisma.PackageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PackageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePayload>
          }
          findMany: {
            args: Prisma.PackageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePayload>[]
          }
          create: {
            args: Prisma.PackageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePayload>
          }
          createMany: {
            args: Prisma.PackageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PackageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePayload>[]
          }
          delete: {
            args: Prisma.PackageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePayload>
          }
          update: {
            args: Prisma.PackageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePayload>
          }
          deleteMany: {
            args: Prisma.PackageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PackageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PackageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePayload>[]
          }
          upsert: {
            args: Prisma.PackageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePayload>
          }
          aggregate: {
            args: Prisma.PackageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePackage>
          }
          groupBy: {
            args: Prisma.PackageGroupByArgs<ExtArgs>
            result: $Utils.Optional<PackageGroupByOutputType>[]
          }
          count: {
            args: Prisma.PackageCountArgs<ExtArgs>
            result: $Utils.Optional<PackageCountAggregateOutputType> | number
          }
        }
      }
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>
        fields: Prisma.OrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: Prisma.$InvoicePayload<ExtArgs>
        fields: Prisma.InvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvoiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      AILog: {
        payload: Prisma.$AILogPayload<ExtArgs>
        fields: Prisma.AILogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AILogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AILogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AILogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AILogPayload>
          }
          findFirst: {
            args: Prisma.AILogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AILogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AILogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AILogPayload>
          }
          findMany: {
            args: Prisma.AILogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AILogPayload>[]
          }
          create: {
            args: Prisma.AILogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AILogPayload>
          }
          createMany: {
            args: Prisma.AILogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AILogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AILogPayload>[]
          }
          delete: {
            args: Prisma.AILogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AILogPayload>
          }
          update: {
            args: Prisma.AILogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AILogPayload>
          }
          deleteMany: {
            args: Prisma.AILogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AILogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AILogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AILogPayload>[]
          }
          upsert: {
            args: Prisma.AILogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AILogPayload>
          }
          aggregate: {
            args: Prisma.AILogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAILog>
          }
          groupBy: {
            args: Prisma.AILogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AILogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AILogCountArgs<ExtArgs>
            result: $Utils.Optional<AILogCountAggregateOutputType> | number
          }
        }
      }
      Currency: {
        payload: Prisma.$CurrencyPayload<ExtArgs>
        fields: Prisma.CurrencyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CurrencyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CurrencyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>
          }
          findFirst: {
            args: Prisma.CurrencyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CurrencyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>
          }
          findMany: {
            args: Prisma.CurrencyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>[]
          }
          create: {
            args: Prisma.CurrencyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>
          }
          createMany: {
            args: Prisma.CurrencyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CurrencyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>[]
          }
          delete: {
            args: Prisma.CurrencyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>
          }
          update: {
            args: Prisma.CurrencyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>
          }
          deleteMany: {
            args: Prisma.CurrencyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CurrencyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CurrencyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>[]
          }
          upsert: {
            args: Prisma.CurrencyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>
          }
          aggregate: {
            args: Prisma.CurrencyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCurrency>
          }
          groupBy: {
            args: Prisma.CurrencyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CurrencyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CurrencyCountArgs<ExtArgs>
            result: $Utils.Optional<CurrencyCountAggregateOutputType> | number
          }
        }
      }
      ExchangeRate: {
        payload: Prisma.$ExchangeRatePayload<ExtArgs>
        fields: Prisma.ExchangeRateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExchangeRateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangeRatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExchangeRateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangeRatePayload>
          }
          findFirst: {
            args: Prisma.ExchangeRateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangeRatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExchangeRateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangeRatePayload>
          }
          findMany: {
            args: Prisma.ExchangeRateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangeRatePayload>[]
          }
          create: {
            args: Prisma.ExchangeRateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangeRatePayload>
          }
          createMany: {
            args: Prisma.ExchangeRateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExchangeRateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangeRatePayload>[]
          }
          delete: {
            args: Prisma.ExchangeRateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangeRatePayload>
          }
          update: {
            args: Prisma.ExchangeRateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangeRatePayload>
          }
          deleteMany: {
            args: Prisma.ExchangeRateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExchangeRateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExchangeRateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangeRatePayload>[]
          }
          upsert: {
            args: Prisma.ExchangeRateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangeRatePayload>
          }
          aggregate: {
            args: Prisma.ExchangeRateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExchangeRate>
          }
          groupBy: {
            args: Prisma.ExchangeRateGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExchangeRateGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExchangeRateCountArgs<ExtArgs>
            result: $Utils.Optional<ExchangeRateCountAggregateOutputType> | number
          }
        }
      }
      BankAccount: {
        payload: Prisma.$BankAccountPayload<ExtArgs>
        fields: Prisma.BankAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BankAccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BankAccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>
          }
          findFirst: {
            args: Prisma.BankAccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BankAccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>
          }
          findMany: {
            args: Prisma.BankAccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>[]
          }
          create: {
            args: Prisma.BankAccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>
          }
          createMany: {
            args: Prisma.BankAccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BankAccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>[]
          }
          delete: {
            args: Prisma.BankAccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>
          }
          update: {
            args: Prisma.BankAccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>
          }
          deleteMany: {
            args: Prisma.BankAccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BankAccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BankAccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>[]
          }
          upsert: {
            args: Prisma.BankAccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>
          }
          aggregate: {
            args: Prisma.BankAccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBankAccount>
          }
          groupBy: {
            args: Prisma.BankAccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<BankAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.BankAccountCountArgs<ExtArgs>
            result: $Utils.Optional<BankAccountCountAggregateOutputType> | number
          }
        }
      }
      BankTransaction: {
        payload: Prisma.$BankTransactionPayload<ExtArgs>
        fields: Prisma.BankTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BankTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BankTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankTransactionPayload>
          }
          findFirst: {
            args: Prisma.BankTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BankTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankTransactionPayload>
          }
          findMany: {
            args: Prisma.BankTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankTransactionPayload>[]
          }
          create: {
            args: Prisma.BankTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankTransactionPayload>
          }
          createMany: {
            args: Prisma.BankTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BankTransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankTransactionPayload>[]
          }
          delete: {
            args: Prisma.BankTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankTransactionPayload>
          }
          update: {
            args: Prisma.BankTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankTransactionPayload>
          }
          deleteMany: {
            args: Prisma.BankTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BankTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BankTransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankTransactionPayload>[]
          }
          upsert: {
            args: Prisma.BankTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankTransactionPayload>
          }
          aggregate: {
            args: Prisma.BankTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBankTransaction>
          }
          groupBy: {
            args: Prisma.BankTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<BankTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.BankTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<BankTransactionCountAggregateOutputType> | number
          }
        }
      }
      InvoicePayment: {
        payload: Prisma.$InvoicePaymentPayload<ExtArgs>
        fields: Prisma.InvoicePaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoicePaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoicePaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePaymentPayload>
          }
          findFirst: {
            args: Prisma.InvoicePaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoicePaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePaymentPayload>
          }
          findMany: {
            args: Prisma.InvoicePaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePaymentPayload>[]
          }
          create: {
            args: Prisma.InvoicePaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePaymentPayload>
          }
          createMany: {
            args: Prisma.InvoicePaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoicePaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePaymentPayload>[]
          }
          delete: {
            args: Prisma.InvoicePaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePaymentPayload>
          }
          update: {
            args: Prisma.InvoicePaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePaymentPayload>
          }
          deleteMany: {
            args: Prisma.InvoicePaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoicePaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvoicePaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePaymentPayload>[]
          }
          upsert: {
            args: Prisma.InvoicePaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePaymentPayload>
          }
          aggregate: {
            args: Prisma.InvoicePaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoicePayment>
          }
          groupBy: {
            args: Prisma.InvoicePaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoicePaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoicePaymentCountArgs<ExtArgs>
            result: $Utils.Optional<InvoicePaymentCountAggregateOutputType> | number
          }
        }
      }
      PaymentGatewayConfig: {
        payload: Prisma.$PaymentGatewayConfigPayload<ExtArgs>
        fields: Prisma.PaymentGatewayConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentGatewayConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentGatewayConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentGatewayConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentGatewayConfigPayload>
          }
          findFirst: {
            args: Prisma.PaymentGatewayConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentGatewayConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentGatewayConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentGatewayConfigPayload>
          }
          findMany: {
            args: Prisma.PaymentGatewayConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentGatewayConfigPayload>[]
          }
          create: {
            args: Prisma.PaymentGatewayConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentGatewayConfigPayload>
          }
          createMany: {
            args: Prisma.PaymentGatewayConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentGatewayConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentGatewayConfigPayload>[]
          }
          delete: {
            args: Prisma.PaymentGatewayConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentGatewayConfigPayload>
          }
          update: {
            args: Prisma.PaymentGatewayConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentGatewayConfigPayload>
          }
          deleteMany: {
            args: Prisma.PaymentGatewayConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentGatewayConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentGatewayConfigUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentGatewayConfigPayload>[]
          }
          upsert: {
            args: Prisma.PaymentGatewayConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentGatewayConfigPayload>
          }
          aggregate: {
            args: Prisma.PaymentGatewayConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentGatewayConfig>
          }
          groupBy: {
            args: Prisma.PaymentGatewayConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGatewayConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentGatewayConfigCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentGatewayConfigCountAggregateOutputType> | number
          }
        }
      }
      CryptoWallet: {
        payload: Prisma.$CryptoWalletPayload<ExtArgs>
        fields: Prisma.CryptoWalletFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CryptoWalletFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoWalletPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CryptoWalletFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoWalletPayload>
          }
          findFirst: {
            args: Prisma.CryptoWalletFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoWalletPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CryptoWalletFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoWalletPayload>
          }
          findMany: {
            args: Prisma.CryptoWalletFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoWalletPayload>[]
          }
          create: {
            args: Prisma.CryptoWalletCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoWalletPayload>
          }
          createMany: {
            args: Prisma.CryptoWalletCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CryptoWalletCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoWalletPayload>[]
          }
          delete: {
            args: Prisma.CryptoWalletDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoWalletPayload>
          }
          update: {
            args: Prisma.CryptoWalletUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoWalletPayload>
          }
          deleteMany: {
            args: Prisma.CryptoWalletDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CryptoWalletUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CryptoWalletUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoWalletPayload>[]
          }
          upsert: {
            args: Prisma.CryptoWalletUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoWalletPayload>
          }
          aggregate: {
            args: Prisma.CryptoWalletAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCryptoWallet>
          }
          groupBy: {
            args: Prisma.CryptoWalletGroupByArgs<ExtArgs>
            result: $Utils.Optional<CryptoWalletGroupByOutputType>[]
          }
          count: {
            args: Prisma.CryptoWalletCountArgs<ExtArgs>
            result: $Utils.Optional<CryptoWalletCountAggregateOutputType> | number
          }
        }
      }
      CryptoPayment: {
        payload: Prisma.$CryptoPaymentPayload<ExtArgs>
        fields: Prisma.CryptoPaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CryptoPaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoPaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CryptoPaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoPaymentPayload>
          }
          findFirst: {
            args: Prisma.CryptoPaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoPaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CryptoPaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoPaymentPayload>
          }
          findMany: {
            args: Prisma.CryptoPaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoPaymentPayload>[]
          }
          create: {
            args: Prisma.CryptoPaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoPaymentPayload>
          }
          createMany: {
            args: Prisma.CryptoPaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CryptoPaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoPaymentPayload>[]
          }
          delete: {
            args: Prisma.CryptoPaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoPaymentPayload>
          }
          update: {
            args: Prisma.CryptoPaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoPaymentPayload>
          }
          deleteMany: {
            args: Prisma.CryptoPaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CryptoPaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CryptoPaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoPaymentPayload>[]
          }
          upsert: {
            args: Prisma.CryptoPaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoPaymentPayload>
          }
          aggregate: {
            args: Prisma.CryptoPaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCryptoPayment>
          }
          groupBy: {
            args: Prisma.CryptoPaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CryptoPaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CryptoPaymentCountArgs<ExtArgs>
            result: $Utils.Optional<CryptoPaymentCountAggregateOutputType> | number
          }
        }
      }
      ExpenseCategory: {
        payload: Prisma.$ExpenseCategoryPayload<ExtArgs>
        fields: Prisma.ExpenseCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExpenseCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExpenseCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>
          }
          findFirst: {
            args: Prisma.ExpenseCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExpenseCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>
          }
          findMany: {
            args: Prisma.ExpenseCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>[]
          }
          create: {
            args: Prisma.ExpenseCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>
          }
          createMany: {
            args: Prisma.ExpenseCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExpenseCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>[]
          }
          delete: {
            args: Prisma.ExpenseCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>
          }
          update: {
            args: Prisma.ExpenseCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>
          }
          deleteMany: {
            args: Prisma.ExpenseCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExpenseCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExpenseCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>[]
          }
          upsert: {
            args: Prisma.ExpenseCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>
          }
          aggregate: {
            args: Prisma.ExpenseCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExpenseCategory>
          }
          groupBy: {
            args: Prisma.ExpenseCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExpenseCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExpenseCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<ExpenseCategoryCountAggregateOutputType> | number
          }
        }
      }
      Expense: {
        payload: Prisma.$ExpensePayload<ExtArgs>
        fields: Prisma.ExpenseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExpenseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExpenseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          findFirst: {
            args: Prisma.ExpenseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExpenseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          findMany: {
            args: Prisma.ExpenseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>[]
          }
          create: {
            args: Prisma.ExpenseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          createMany: {
            args: Prisma.ExpenseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExpenseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>[]
          }
          delete: {
            args: Prisma.ExpenseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          update: {
            args: Prisma.ExpenseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          deleteMany: {
            args: Prisma.ExpenseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExpenseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExpenseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>[]
          }
          upsert: {
            args: Prisma.ExpenseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          aggregate: {
            args: Prisma.ExpenseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExpense>
          }
          groupBy: {
            args: Prisma.ExpenseGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExpenseGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExpenseCountArgs<ExtArgs>
            result: $Utils.Optional<ExpenseCountAggregateOutputType> | number
          }
        }
      }
      RecurringInvoiceTemplate: {
        payload: Prisma.$RecurringInvoiceTemplatePayload<ExtArgs>
        fields: Prisma.RecurringInvoiceTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecurringInvoiceTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringInvoiceTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecurringInvoiceTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringInvoiceTemplatePayload>
          }
          findFirst: {
            args: Prisma.RecurringInvoiceTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringInvoiceTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecurringInvoiceTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringInvoiceTemplatePayload>
          }
          findMany: {
            args: Prisma.RecurringInvoiceTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringInvoiceTemplatePayload>[]
          }
          create: {
            args: Prisma.RecurringInvoiceTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringInvoiceTemplatePayload>
          }
          createMany: {
            args: Prisma.RecurringInvoiceTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RecurringInvoiceTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringInvoiceTemplatePayload>[]
          }
          delete: {
            args: Prisma.RecurringInvoiceTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringInvoiceTemplatePayload>
          }
          update: {
            args: Prisma.RecurringInvoiceTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringInvoiceTemplatePayload>
          }
          deleteMany: {
            args: Prisma.RecurringInvoiceTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RecurringInvoiceTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RecurringInvoiceTemplateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringInvoiceTemplatePayload>[]
          }
          upsert: {
            args: Prisma.RecurringInvoiceTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringInvoiceTemplatePayload>
          }
          aggregate: {
            args: Prisma.RecurringInvoiceTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecurringInvoiceTemplate>
          }
          groupBy: {
            args: Prisma.RecurringInvoiceTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecurringInvoiceTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecurringInvoiceTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<RecurringInvoiceTemplateCountAggregateOutputType> | number
          }
        }
      }
      PushSubscription: {
        payload: Prisma.$PushSubscriptionPayload<ExtArgs>
        fields: Prisma.PushSubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PushSubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PushSubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>
          }
          findFirst: {
            args: Prisma.PushSubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PushSubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>
          }
          findMany: {
            args: Prisma.PushSubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>[]
          }
          create: {
            args: Prisma.PushSubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>
          }
          createMany: {
            args: Prisma.PushSubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PushSubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>[]
          }
          delete: {
            args: Prisma.PushSubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>
          }
          update: {
            args: Prisma.PushSubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.PushSubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PushSubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PushSubscriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>[]
          }
          upsert: {
            args: Prisma.PushSubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>
          }
          aggregate: {
            args: Prisma.PushSubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePushSubscription>
          }
          groupBy: {
            args: Prisma.PushSubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PushSubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PushSubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<PushSubscriptionCountAggregateOutputType> | number
          }
        }
      }
      NotificationPreference: {
        payload: Prisma.$NotificationPreferencePayload<ExtArgs>
        fields: Prisma.NotificationPreferenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationPreferenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationPreferenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          findFirst: {
            args: Prisma.NotificationPreferenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationPreferenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          findMany: {
            args: Prisma.NotificationPreferenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>[]
          }
          create: {
            args: Prisma.NotificationPreferenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          createMany: {
            args: Prisma.NotificationPreferenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationPreferenceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>[]
          }
          delete: {
            args: Prisma.NotificationPreferenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          update: {
            args: Prisma.NotificationPreferenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          deleteMany: {
            args: Prisma.NotificationPreferenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationPreferenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationPreferenceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>[]
          }
          upsert: {
            args: Prisma.NotificationPreferenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          aggregate: {
            args: Prisma.NotificationPreferenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationPreference>
          }
          groupBy: {
            args: Prisma.NotificationPreferenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationPreferenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationPreferenceCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationPreferenceCountAggregateOutputType> | number
          }
        }
      }
      NotificationLog: {
        payload: Prisma.$NotificationLogPayload<ExtArgs>
        fields: Prisma.NotificationLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>
          }
          findFirst: {
            args: Prisma.NotificationLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>
          }
          findMany: {
            args: Prisma.NotificationLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>[]
          }
          create: {
            args: Prisma.NotificationLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>
          }
          createMany: {
            args: Prisma.NotificationLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>[]
          }
          delete: {
            args: Prisma.NotificationLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>
          }
          update: {
            args: Prisma.NotificationLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>
          }
          deleteMany: {
            args: Prisma.NotificationLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>[]
          }
          upsert: {
            args: Prisma.NotificationLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>
          }
          aggregate: {
            args: Prisma.NotificationLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationLog>
          }
          groupBy: {
            args: Prisma.NotificationLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationLogCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationLogCountAggregateOutputType> | number
          }
        }
      }
      CalendarIntegration: {
        payload: Prisma.$CalendarIntegrationPayload<ExtArgs>
        fields: Prisma.CalendarIntegrationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CalendarIntegrationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarIntegrationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CalendarIntegrationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarIntegrationPayload>
          }
          findFirst: {
            args: Prisma.CalendarIntegrationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarIntegrationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CalendarIntegrationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarIntegrationPayload>
          }
          findMany: {
            args: Prisma.CalendarIntegrationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarIntegrationPayload>[]
          }
          create: {
            args: Prisma.CalendarIntegrationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarIntegrationPayload>
          }
          createMany: {
            args: Prisma.CalendarIntegrationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CalendarIntegrationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarIntegrationPayload>[]
          }
          delete: {
            args: Prisma.CalendarIntegrationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarIntegrationPayload>
          }
          update: {
            args: Prisma.CalendarIntegrationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarIntegrationPayload>
          }
          deleteMany: {
            args: Prisma.CalendarIntegrationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CalendarIntegrationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CalendarIntegrationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarIntegrationPayload>[]
          }
          upsert: {
            args: Prisma.CalendarIntegrationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarIntegrationPayload>
          }
          aggregate: {
            args: Prisma.CalendarIntegrationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCalendarIntegration>
          }
          groupBy: {
            args: Prisma.CalendarIntegrationGroupByArgs<ExtArgs>
            result: $Utils.Optional<CalendarIntegrationGroupByOutputType>[]
          }
          count: {
            args: Prisma.CalendarIntegrationCountArgs<ExtArgs>
            result: $Utils.Optional<CalendarIntegrationCountAggregateOutputType> | number
          }
        }
      }
      CalendarEventSync: {
        payload: Prisma.$CalendarEventSyncPayload<ExtArgs>
        fields: Prisma.CalendarEventSyncFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CalendarEventSyncFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventSyncPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CalendarEventSyncFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventSyncPayload>
          }
          findFirst: {
            args: Prisma.CalendarEventSyncFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventSyncPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CalendarEventSyncFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventSyncPayload>
          }
          findMany: {
            args: Prisma.CalendarEventSyncFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventSyncPayload>[]
          }
          create: {
            args: Prisma.CalendarEventSyncCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventSyncPayload>
          }
          createMany: {
            args: Prisma.CalendarEventSyncCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CalendarEventSyncCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventSyncPayload>[]
          }
          delete: {
            args: Prisma.CalendarEventSyncDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventSyncPayload>
          }
          update: {
            args: Prisma.CalendarEventSyncUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventSyncPayload>
          }
          deleteMany: {
            args: Prisma.CalendarEventSyncDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CalendarEventSyncUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CalendarEventSyncUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventSyncPayload>[]
          }
          upsert: {
            args: Prisma.CalendarEventSyncUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventSyncPayload>
          }
          aggregate: {
            args: Prisma.CalendarEventSyncAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCalendarEventSync>
          }
          groupBy: {
            args: Prisma.CalendarEventSyncGroupByArgs<ExtArgs>
            result: $Utils.Optional<CalendarEventSyncGroupByOutputType>[]
          }
          count: {
            args: Prisma.CalendarEventSyncCountArgs<ExtArgs>
            result: $Utils.Optional<CalendarEventSyncCountAggregateOutputType> | number
          }
        }
      }
      CalendarFeedToken: {
        payload: Prisma.$CalendarFeedTokenPayload<ExtArgs>
        fields: Prisma.CalendarFeedTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CalendarFeedTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarFeedTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CalendarFeedTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarFeedTokenPayload>
          }
          findFirst: {
            args: Prisma.CalendarFeedTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarFeedTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CalendarFeedTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarFeedTokenPayload>
          }
          findMany: {
            args: Prisma.CalendarFeedTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarFeedTokenPayload>[]
          }
          create: {
            args: Prisma.CalendarFeedTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarFeedTokenPayload>
          }
          createMany: {
            args: Prisma.CalendarFeedTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CalendarFeedTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarFeedTokenPayload>[]
          }
          delete: {
            args: Prisma.CalendarFeedTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarFeedTokenPayload>
          }
          update: {
            args: Prisma.CalendarFeedTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarFeedTokenPayload>
          }
          deleteMany: {
            args: Prisma.CalendarFeedTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CalendarFeedTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CalendarFeedTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarFeedTokenPayload>[]
          }
          upsert: {
            args: Prisma.CalendarFeedTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarFeedTokenPayload>
          }
          aggregate: {
            args: Prisma.CalendarFeedTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCalendarFeedToken>
          }
          groupBy: {
            args: Prisma.CalendarFeedTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<CalendarFeedTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.CalendarFeedTokenCountArgs<ExtArgs>
            result: $Utils.Optional<CalendarFeedTokenCountAggregateOutputType> | number
          }
        }
      }
      Badge: {
        payload: Prisma.$BadgePayload<ExtArgs>
        fields: Prisma.BadgeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BadgeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BadgeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          findFirst: {
            args: Prisma.BadgeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BadgeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          findMany: {
            args: Prisma.BadgeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>[]
          }
          create: {
            args: Prisma.BadgeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          createMany: {
            args: Prisma.BadgeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BadgeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>[]
          }
          delete: {
            args: Prisma.BadgeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          update: {
            args: Prisma.BadgeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          deleteMany: {
            args: Prisma.BadgeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BadgeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BadgeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>[]
          }
          upsert: {
            args: Prisma.BadgeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          aggregate: {
            args: Prisma.BadgeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBadge>
          }
          groupBy: {
            args: Prisma.BadgeGroupByArgs<ExtArgs>
            result: $Utils.Optional<BadgeGroupByOutputType>[]
          }
          count: {
            args: Prisma.BadgeCountArgs<ExtArgs>
            result: $Utils.Optional<BadgeCountAggregateOutputType> | number
          }
        }
      }
      ClientBadge: {
        payload: Prisma.$ClientBadgePayload<ExtArgs>
        fields: Prisma.ClientBadgeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientBadgeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientBadgePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientBadgeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientBadgePayload>
          }
          findFirst: {
            args: Prisma.ClientBadgeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientBadgePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientBadgeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientBadgePayload>
          }
          findMany: {
            args: Prisma.ClientBadgeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientBadgePayload>[]
          }
          create: {
            args: Prisma.ClientBadgeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientBadgePayload>
          }
          createMany: {
            args: Prisma.ClientBadgeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClientBadgeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientBadgePayload>[]
          }
          delete: {
            args: Prisma.ClientBadgeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientBadgePayload>
          }
          update: {
            args: Prisma.ClientBadgeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientBadgePayload>
          }
          deleteMany: {
            args: Prisma.ClientBadgeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientBadgeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClientBadgeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientBadgePayload>[]
          }
          upsert: {
            args: Prisma.ClientBadgeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientBadgePayload>
          }
          aggregate: {
            args: Prisma.ClientBadgeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClientBadge>
          }
          groupBy: {
            args: Prisma.ClientBadgeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientBadgeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientBadgeCountArgs<ExtArgs>
            result: $Utils.Optional<ClientBadgeCountAggregateOutputType> | number
          }
        }
      }
      WorkoutTemplate: {
        payload: Prisma.$WorkoutTemplatePayload<ExtArgs>
        fields: Prisma.WorkoutTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkoutTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkoutTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutTemplatePayload>
          }
          findFirst: {
            args: Prisma.WorkoutTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkoutTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutTemplatePayload>
          }
          findMany: {
            args: Prisma.WorkoutTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutTemplatePayload>[]
          }
          create: {
            args: Prisma.WorkoutTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutTemplatePayload>
          }
          createMany: {
            args: Prisma.WorkoutTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkoutTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutTemplatePayload>[]
          }
          delete: {
            args: Prisma.WorkoutTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutTemplatePayload>
          }
          update: {
            args: Prisma.WorkoutTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutTemplatePayload>
          }
          deleteMany: {
            args: Prisma.WorkoutTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkoutTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkoutTemplateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutTemplatePayload>[]
          }
          upsert: {
            args: Prisma.WorkoutTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutTemplatePayload>
          }
          aggregate: {
            args: Prisma.WorkoutTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkoutTemplate>
          }
          groupBy: {
            args: Prisma.WorkoutTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkoutTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkoutTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<WorkoutTemplateCountAggregateOutputType> | number
          }
        }
      }
      ScheduleTemplate: {
        payload: Prisma.$ScheduleTemplatePayload<ExtArgs>
        fields: Prisma.ScheduleTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScheduleTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScheduleTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleTemplatePayload>
          }
          findFirst: {
            args: Prisma.ScheduleTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScheduleTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleTemplatePayload>
          }
          findMany: {
            args: Prisma.ScheduleTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleTemplatePayload>[]
          }
          create: {
            args: Prisma.ScheduleTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleTemplatePayload>
          }
          createMany: {
            args: Prisma.ScheduleTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ScheduleTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleTemplatePayload>[]
          }
          delete: {
            args: Prisma.ScheduleTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleTemplatePayload>
          }
          update: {
            args: Prisma.ScheduleTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleTemplatePayload>
          }
          deleteMany: {
            args: Prisma.ScheduleTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScheduleTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ScheduleTemplateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleTemplatePayload>[]
          }
          upsert: {
            args: Prisma.ScheduleTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleTemplatePayload>
          }
          aggregate: {
            args: Prisma.ScheduleTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateScheduleTemplate>
          }
          groupBy: {
            args: Prisma.ScheduleTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScheduleTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScheduleTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<ScheduleTemplateCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://pris.ly/d/logging).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
    /**
     * SQL commenter plugins that add metadata to SQL queries as comments.
     * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   adapter,
     *   comments: [
     *     traceContext(),
     *     queryInsights(),
     *   ],
     * })
     * ```
     */
    comments?: runtime.SqlCommenterPlugin[]
  }
  export type GlobalOmitConfig = {
    tenant?: TenantOmit
    user?: UserOmit
    account?: AccountOmit
    userSession?: UserSessionOmit
    verificationToken?: VerificationTokenOmit
    passwordResetToken?: PasswordResetTokenOmit
    client?: ClientOmit
    clientMeasurement?: ClientMeasurementOmit
    progressPhoto?: ProgressPhotoOmit
    session?: SessionOmit
    class?: ClassOmit
    classBooking?: ClassBookingOmit
    package?: PackageOmit
    order?: OrderOmit
    invoice?: InvoiceOmit
    aILog?: AILogOmit
    currency?: CurrencyOmit
    exchangeRate?: ExchangeRateOmit
    bankAccount?: BankAccountOmit
    bankTransaction?: BankTransactionOmit
    invoicePayment?: InvoicePaymentOmit
    paymentGatewayConfig?: PaymentGatewayConfigOmit
    cryptoWallet?: CryptoWalletOmit
    cryptoPayment?: CryptoPaymentOmit
    expenseCategory?: ExpenseCategoryOmit
    expense?: ExpenseOmit
    recurringInvoiceTemplate?: RecurringInvoiceTemplateOmit
    pushSubscription?: PushSubscriptionOmit
    notificationPreference?: NotificationPreferenceOmit
    notificationLog?: NotificationLogOmit
    calendarIntegration?: CalendarIntegrationOmit
    calendarEventSync?: CalendarEventSyncOmit
    calendarFeedToken?: CalendarFeedTokenOmit
    badge?: BadgeOmit
    clientBadge?: ClientBadgeOmit
    workoutTemplate?: WorkoutTemplateOmit
    scheduleTemplate?: ScheduleTemplateOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type TenantCountOutputType
   */

  export type TenantCountOutputType = {
    users: number
    clients: number
    sessions: number
    classes: number
    packages: number
    orders: number
    invoices: number
    aiLogs: number
    bankAccounts: number
    bankTransactions: number
    invoicePayments: number
    paymentGatewayConfigs: number
    cryptoWallets: number
    expenseCategories: number
    expenses: number
    recurringInvoiceTemplates: number
    badges: number
    workoutTemplates: number
    scheduleTemplates: number
  }

  export type TenantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | TenantCountOutputTypeCountUsersArgs
    clients?: boolean | TenantCountOutputTypeCountClientsArgs
    sessions?: boolean | TenantCountOutputTypeCountSessionsArgs
    classes?: boolean | TenantCountOutputTypeCountClassesArgs
    packages?: boolean | TenantCountOutputTypeCountPackagesArgs
    orders?: boolean | TenantCountOutputTypeCountOrdersArgs
    invoices?: boolean | TenantCountOutputTypeCountInvoicesArgs
    aiLogs?: boolean | TenantCountOutputTypeCountAiLogsArgs
    bankAccounts?: boolean | TenantCountOutputTypeCountBankAccountsArgs
    bankTransactions?: boolean | TenantCountOutputTypeCountBankTransactionsArgs
    invoicePayments?: boolean | TenantCountOutputTypeCountInvoicePaymentsArgs
    paymentGatewayConfigs?: boolean | TenantCountOutputTypeCountPaymentGatewayConfigsArgs
    cryptoWallets?: boolean | TenantCountOutputTypeCountCryptoWalletsArgs
    expenseCategories?: boolean | TenantCountOutputTypeCountExpenseCategoriesArgs
    expenses?: boolean | TenantCountOutputTypeCountExpensesArgs
    recurringInvoiceTemplates?: boolean | TenantCountOutputTypeCountRecurringInvoiceTemplatesArgs
    badges?: boolean | TenantCountOutputTypeCountBadgesArgs
    workoutTemplates?: boolean | TenantCountOutputTypeCountWorkoutTemplatesArgs
    scheduleTemplates?: boolean | TenantCountOutputTypeCountScheduleTemplatesArgs
  }

  // Custom InputTypes
  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantCountOutputType
     */
    select?: TenantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountClientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountPackagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PackageWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountAiLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AILogWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountBankAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BankAccountWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountBankTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BankTransactionWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountInvoicePaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoicePaymentWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountPaymentGatewayConfigsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentGatewayConfigWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountCryptoWalletsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CryptoWalletWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountExpenseCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseCategoryWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountExpensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountRecurringInvoiceTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecurringInvoiceTemplateWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountBadgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BadgeWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountWorkoutTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkoutTemplateWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountScheduleTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleTemplateWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    accounts: number
    sessions: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSessionWhereInput
  }


  /**
   * Count Type ClientCountOutputType
   */

  export type ClientCountOutputType = {
    sessions: number
    orders: number
    invoices: number
    measurements: number
    progressPhotos: number
    badges: number
  }

  export type ClientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | ClientCountOutputTypeCountSessionsArgs
    orders?: boolean | ClientCountOutputTypeCountOrdersArgs
    invoices?: boolean | ClientCountOutputTypeCountInvoicesArgs
    measurements?: boolean | ClientCountOutputTypeCountMeasurementsArgs
    progressPhotos?: boolean | ClientCountOutputTypeCountProgressPhotosArgs
    badges?: boolean | ClientCountOutputTypeCountBadgesArgs
  }

  // Custom InputTypes
  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCountOutputType
     */
    select?: ClientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountMeasurementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientMeasurementWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountProgressPhotosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgressPhotoWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountBadgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientBadgeWhereInput
  }


  /**
   * Count Type ClassCountOutputType
   */

  export type ClassCountOutputType = {
    bookings: number
  }

  export type ClassCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | ClassCountOutputTypeCountBookingsArgs
  }

  // Custom InputTypes
  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassCountOutputType
     */
    select?: ClassCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassBookingWhereInput
  }


  /**
   * Count Type OrderCountOutputType
   */

  export type OrderCountOutputType = {
    invoices: number
  }

  export type OrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoices?: boolean | OrderCountOutputTypeCountInvoicesArgs
  }

  // Custom InputTypes
  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     */
    select?: OrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }


  /**
   * Count Type InvoiceCountOutputType
   */

  export type InvoiceCountOutputType = {
    payments: number
    bankTransactions: number
    cryptoPayments: number
  }

  export type InvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | InvoiceCountOutputTypeCountPaymentsArgs
    bankTransactions?: boolean | InvoiceCountOutputTypeCountBankTransactionsArgs
    cryptoPayments?: boolean | InvoiceCountOutputTypeCountCryptoPaymentsArgs
  }

  // Custom InputTypes
  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceCountOutputType
     */
    select?: InvoiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoicePaymentWhereInput
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountBankTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BankTransactionWhereInput
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountCryptoPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CryptoPaymentWhereInput
  }


  /**
   * Count Type CurrencyCountOutputType
   */

  export type CurrencyCountOutputType = {
    exchangeRatesFrom: number
    exchangeRatesTo: number
  }

  export type CurrencyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exchangeRatesFrom?: boolean | CurrencyCountOutputTypeCountExchangeRatesFromArgs
    exchangeRatesTo?: boolean | CurrencyCountOutputTypeCountExchangeRatesToArgs
  }

  // Custom InputTypes
  /**
   * CurrencyCountOutputType without action
   */
  export type CurrencyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrencyCountOutputType
     */
    select?: CurrencyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CurrencyCountOutputType without action
   */
  export type CurrencyCountOutputTypeCountExchangeRatesFromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExchangeRateWhereInput
  }

  /**
   * CurrencyCountOutputType without action
   */
  export type CurrencyCountOutputTypeCountExchangeRatesToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExchangeRateWhereInput
  }


  /**
   * Count Type BankAccountCountOutputType
   */

  export type BankAccountCountOutputType = {
    transactions: number
  }

  export type BankAccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | BankAccountCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * BankAccountCountOutputType without action
   */
  export type BankAccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccountCountOutputType
     */
    select?: BankAccountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BankAccountCountOutputType without action
   */
  export type BankAccountCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BankTransactionWhereInput
  }


  /**
   * Count Type CryptoWalletCountOutputType
   */

  export type CryptoWalletCountOutputType = {
    payments: number
  }

  export type CryptoWalletCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | CryptoWalletCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * CryptoWalletCountOutputType without action
   */
  export type CryptoWalletCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoWalletCountOutputType
     */
    select?: CryptoWalletCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CryptoWalletCountOutputType without action
   */
  export type CryptoWalletCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CryptoPaymentWhereInput
  }


  /**
   * Count Type ExpenseCategoryCountOutputType
   */

  export type ExpenseCategoryCountOutputType = {
    expenses: number
  }

  export type ExpenseCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    expenses?: boolean | ExpenseCategoryCountOutputTypeCountExpensesArgs
  }

  // Custom InputTypes
  /**
   * ExpenseCategoryCountOutputType without action
   */
  export type ExpenseCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategoryCountOutputType
     */
    select?: ExpenseCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExpenseCategoryCountOutputType without action
   */
  export type ExpenseCategoryCountOutputTypeCountExpensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseWhereInput
  }


  /**
   * Count Type CalendarIntegrationCountOutputType
   */

  export type CalendarIntegrationCountOutputType = {
    eventSyncs: number
  }

  export type CalendarIntegrationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    eventSyncs?: boolean | CalendarIntegrationCountOutputTypeCountEventSyncsArgs
  }

  // Custom InputTypes
  /**
   * CalendarIntegrationCountOutputType without action
   */
  export type CalendarIntegrationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarIntegrationCountOutputType
     */
    select?: CalendarIntegrationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CalendarIntegrationCountOutputType without action
   */
  export type CalendarIntegrationCountOutputTypeCountEventSyncsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalendarEventSyncWhereInput
  }


  /**
   * Count Type BadgeCountOutputType
   */

  export type BadgeCountOutputType = {
    clientBadges: number
  }

  export type BadgeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientBadges?: boolean | BadgeCountOutputTypeCountClientBadgesArgs
  }

  // Custom InputTypes
  /**
   * BadgeCountOutputType without action
   */
  export type BadgeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BadgeCountOutputType
     */
    select?: BadgeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BadgeCountOutputType without action
   */
  export type BadgeCountOutputTypeCountClientBadgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientBadgeWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Tenant
   */

  export type AggregateTenant = {
    _count: TenantCountAggregateOutputType | null
    _avg: TenantAvgAggregateOutputType | null
    _sum: TenantSumAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  export type TenantAvgAggregateOutputType = {
    aiCredits: number | null
  }

  export type TenantSumAggregateOutputType = {
    aiCredits: number | null
  }

  export type TenantMinAggregateOutputType = {
    id: string | null
    vertical: $Enums.Vertical | null
    name: string | null
    slug: string | null
    email: string | null
    phone: string | null
    website: string | null
    logo: string | null
    subscriptionTier: string | null
    aiCredits: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantMaxAggregateOutputType = {
    id: string | null
    vertical: $Enums.Vertical | null
    name: string | null
    slug: string | null
    email: string | null
    phone: string | null
    website: string | null
    logo: string | null
    subscriptionTier: string | null
    aiCredits: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantCountAggregateOutputType = {
    id: number
    vertical: number
    name: number
    slug: number
    email: number
    phone: number
    website: number
    logo: number
    subscriptionTier: number
    aiCredits: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TenantAvgAggregateInputType = {
    aiCredits?: true
  }

  export type TenantSumAggregateInputType = {
    aiCredits?: true
  }

  export type TenantMinAggregateInputType = {
    id?: true
    vertical?: true
    name?: true
    slug?: true
    email?: true
    phone?: true
    website?: true
    logo?: true
    subscriptionTier?: true
    aiCredits?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantMaxAggregateInputType = {
    id?: true
    vertical?: true
    name?: true
    slug?: true
    email?: true
    phone?: true
    website?: true
    logo?: true
    subscriptionTier?: true
    aiCredits?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantCountAggregateInputType = {
    id?: true
    vertical?: true
    name?: true
    slug?: true
    email?: true
    phone?: true
    website?: true
    logo?: true
    subscriptionTier?: true
    aiCredits?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TenantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenant to aggregate.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tenants
    **/
    _count?: true | TenantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TenantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TenantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantMaxAggregateInputType
  }

  export type GetTenantAggregateType<T extends TenantAggregateArgs> = {
        [P in keyof T & keyof AggregateTenant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenant[P]>
      : GetScalarType<T[P], AggregateTenant[P]>
  }




  export type TenantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantWhereInput
    orderBy?: TenantOrderByWithAggregationInput | TenantOrderByWithAggregationInput[]
    by: TenantScalarFieldEnum[] | TenantScalarFieldEnum
    having?: TenantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantCountAggregateInputType | true
    _avg?: TenantAvgAggregateInputType
    _sum?: TenantSumAggregateInputType
    _min?: TenantMinAggregateInputType
    _max?: TenantMaxAggregateInputType
  }

  export type TenantGroupByOutputType = {
    id: string
    vertical: $Enums.Vertical
    name: string
    slug: string
    email: string | null
    phone: string | null
    website: string | null
    logo: string | null
    subscriptionTier: string
    aiCredits: number
    createdAt: Date
    updatedAt: Date
    _count: TenantCountAggregateOutputType | null
    _avg: TenantAvgAggregateOutputType | null
    _sum: TenantSumAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  type GetTenantGroupByPayload<T extends TenantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantGroupByOutputType[P]>
            : GetScalarType<T[P], TenantGroupByOutputType[P]>
        }
      >
    >


  export type TenantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vertical?: boolean
    name?: boolean
    slug?: boolean
    email?: boolean
    phone?: boolean
    website?: boolean
    logo?: boolean
    subscriptionTier?: boolean
    aiCredits?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | Tenant$usersArgs<ExtArgs>
    clients?: boolean | Tenant$clientsArgs<ExtArgs>
    sessions?: boolean | Tenant$sessionsArgs<ExtArgs>
    classes?: boolean | Tenant$classesArgs<ExtArgs>
    packages?: boolean | Tenant$packagesArgs<ExtArgs>
    orders?: boolean | Tenant$ordersArgs<ExtArgs>
    invoices?: boolean | Tenant$invoicesArgs<ExtArgs>
    aiLogs?: boolean | Tenant$aiLogsArgs<ExtArgs>
    bankAccounts?: boolean | Tenant$bankAccountsArgs<ExtArgs>
    bankTransactions?: boolean | Tenant$bankTransactionsArgs<ExtArgs>
    invoicePayments?: boolean | Tenant$invoicePaymentsArgs<ExtArgs>
    paymentGatewayConfigs?: boolean | Tenant$paymentGatewayConfigsArgs<ExtArgs>
    cryptoWallets?: boolean | Tenant$cryptoWalletsArgs<ExtArgs>
    expenseCategories?: boolean | Tenant$expenseCategoriesArgs<ExtArgs>
    expenses?: boolean | Tenant$expensesArgs<ExtArgs>
    recurringInvoiceTemplates?: boolean | Tenant$recurringInvoiceTemplatesArgs<ExtArgs>
    badges?: boolean | Tenant$badgesArgs<ExtArgs>
    workoutTemplates?: boolean | Tenant$workoutTemplatesArgs<ExtArgs>
    scheduleTemplates?: boolean | Tenant$scheduleTemplatesArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vertical?: boolean
    name?: boolean
    slug?: boolean
    email?: boolean
    phone?: boolean
    website?: boolean
    logo?: boolean
    subscriptionTier?: boolean
    aiCredits?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vertical?: boolean
    name?: boolean
    slug?: boolean
    email?: boolean
    phone?: boolean
    website?: boolean
    logo?: boolean
    subscriptionTier?: boolean
    aiCredits?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectScalar = {
    id?: boolean
    vertical?: boolean
    name?: boolean
    slug?: boolean
    email?: boolean
    phone?: boolean
    website?: boolean
    logo?: boolean
    subscriptionTier?: boolean
    aiCredits?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TenantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "vertical" | "name" | "slug" | "email" | "phone" | "website" | "logo" | "subscriptionTier" | "aiCredits" | "createdAt" | "updatedAt", ExtArgs["result"]["tenant"]>
  export type TenantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Tenant$usersArgs<ExtArgs>
    clients?: boolean | Tenant$clientsArgs<ExtArgs>
    sessions?: boolean | Tenant$sessionsArgs<ExtArgs>
    classes?: boolean | Tenant$classesArgs<ExtArgs>
    packages?: boolean | Tenant$packagesArgs<ExtArgs>
    orders?: boolean | Tenant$ordersArgs<ExtArgs>
    invoices?: boolean | Tenant$invoicesArgs<ExtArgs>
    aiLogs?: boolean | Tenant$aiLogsArgs<ExtArgs>
    bankAccounts?: boolean | Tenant$bankAccountsArgs<ExtArgs>
    bankTransactions?: boolean | Tenant$bankTransactionsArgs<ExtArgs>
    invoicePayments?: boolean | Tenant$invoicePaymentsArgs<ExtArgs>
    paymentGatewayConfigs?: boolean | Tenant$paymentGatewayConfigsArgs<ExtArgs>
    cryptoWallets?: boolean | Tenant$cryptoWalletsArgs<ExtArgs>
    expenseCategories?: boolean | Tenant$expenseCategoriesArgs<ExtArgs>
    expenses?: boolean | Tenant$expensesArgs<ExtArgs>
    recurringInvoiceTemplates?: boolean | Tenant$recurringInvoiceTemplatesArgs<ExtArgs>
    badges?: boolean | Tenant$badgesArgs<ExtArgs>
    workoutTemplates?: boolean | Tenant$workoutTemplatesArgs<ExtArgs>
    scheduleTemplates?: boolean | Tenant$scheduleTemplatesArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TenantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TenantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TenantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tenant"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      clients: Prisma.$ClientPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      classes: Prisma.$ClassPayload<ExtArgs>[]
      packages: Prisma.$PackagePayload<ExtArgs>[]
      orders: Prisma.$OrderPayload<ExtArgs>[]
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      aiLogs: Prisma.$AILogPayload<ExtArgs>[]
      bankAccounts: Prisma.$BankAccountPayload<ExtArgs>[]
      bankTransactions: Prisma.$BankTransactionPayload<ExtArgs>[]
      invoicePayments: Prisma.$InvoicePaymentPayload<ExtArgs>[]
      paymentGatewayConfigs: Prisma.$PaymentGatewayConfigPayload<ExtArgs>[]
      cryptoWallets: Prisma.$CryptoWalletPayload<ExtArgs>[]
      expenseCategories: Prisma.$ExpenseCategoryPayload<ExtArgs>[]
      expenses: Prisma.$ExpensePayload<ExtArgs>[]
      recurringInvoiceTemplates: Prisma.$RecurringInvoiceTemplatePayload<ExtArgs>[]
      badges: Prisma.$BadgePayload<ExtArgs>[]
      workoutTemplates: Prisma.$WorkoutTemplatePayload<ExtArgs>[]
      scheduleTemplates: Prisma.$ScheduleTemplatePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      vertical: $Enums.Vertical
      name: string
      slug: string
      email: string | null
      phone: string | null
      website: string | null
      logo: string | null
      subscriptionTier: string
      aiCredits: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tenant"]>
    composites: {}
  }

  type TenantGetPayload<S extends boolean | null | undefined | TenantDefaultArgs> = $Result.GetResult<Prisma.$TenantPayload, S>

  type TenantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TenantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TenantCountAggregateInputType | true
    }

  export interface TenantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tenant'], meta: { name: 'Tenant' } }
    /**
     * Find zero or one Tenant that matches the filter.
     * @param {TenantFindUniqueArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenantFindUniqueArgs>(args: SelectSubset<T, TenantFindUniqueArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tenant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TenantFindUniqueOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenantFindUniqueOrThrowArgs>(args: SelectSubset<T, TenantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tenant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenantFindFirstArgs>(args?: SelectSubset<T, TenantFindFirstArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tenant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenantFindFirstOrThrowArgs>(args?: SelectSubset<T, TenantFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tenants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tenants
     * const tenants = await prisma.tenant.findMany()
     * 
     * // Get first 10 Tenants
     * const tenants = await prisma.tenant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantWithIdOnly = await prisma.tenant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TenantFindManyArgs>(args?: SelectSubset<T, TenantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tenant.
     * @param {TenantCreateArgs} args - Arguments to create a Tenant.
     * @example
     * // Create one Tenant
     * const Tenant = await prisma.tenant.create({
     *   data: {
     *     // ... data to create a Tenant
     *   }
     * })
     * 
     */
    create<T extends TenantCreateArgs>(args: SelectSubset<T, TenantCreateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tenants.
     * @param {TenantCreateManyArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenantCreateManyArgs>(args?: SelectSubset<T, TenantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tenants and returns the data saved in the database.
     * @param {TenantCreateManyAndReturnArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tenants and only return the `id`
     * const tenantWithIdOnly = await prisma.tenant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenantCreateManyAndReturnArgs>(args?: SelectSubset<T, TenantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tenant.
     * @param {TenantDeleteArgs} args - Arguments to delete one Tenant.
     * @example
     * // Delete one Tenant
     * const Tenant = await prisma.tenant.delete({
     *   where: {
     *     // ... filter to delete one Tenant
     *   }
     * })
     * 
     */
    delete<T extends TenantDeleteArgs>(args: SelectSubset<T, TenantDeleteArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tenant.
     * @param {TenantUpdateArgs} args - Arguments to update one Tenant.
     * @example
     * // Update one Tenant
     * const tenant = await prisma.tenant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenantUpdateArgs>(args: SelectSubset<T, TenantUpdateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tenants.
     * @param {TenantDeleteManyArgs} args - Arguments to filter Tenants to delete.
     * @example
     * // Delete a few Tenants
     * const { count } = await prisma.tenant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenantDeleteManyArgs>(args?: SelectSubset<T, TenantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tenants
     * const tenant = await prisma.tenant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenantUpdateManyArgs>(args: SelectSubset<T, TenantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tenants and returns the data updated in the database.
     * @param {TenantUpdateManyAndReturnArgs} args - Arguments to update many Tenants.
     * @example
     * // Update many Tenants
     * const tenant = await prisma.tenant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tenants and only return the `id`
     * const tenantWithIdOnly = await prisma.tenant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TenantUpdateManyAndReturnArgs>(args: SelectSubset<T, TenantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tenant.
     * @param {TenantUpsertArgs} args - Arguments to update or create a Tenant.
     * @example
     * // Update or create a Tenant
     * const tenant = await prisma.tenant.upsert({
     *   create: {
     *     // ... data to create a Tenant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tenant we want to update
     *   }
     * })
     */
    upsert<T extends TenantUpsertArgs>(args: SelectSubset<T, TenantUpsertArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantCountArgs} args - Arguments to filter Tenants to count.
     * @example
     * // Count the number of Tenants
     * const count = await prisma.tenant.count({
     *   where: {
     *     // ... the filter for the Tenants we want to count
     *   }
     * })
    **/
    count<T extends TenantCountArgs>(
      args?: Subset<T, TenantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantAggregateArgs>(args: Subset<T, TenantAggregateArgs>): Prisma.PrismaPromise<GetTenantAggregateType<T>>

    /**
     * Group by Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenantGroupByArgs['orderBy'] }
        : { orderBy?: TenantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tenant model
   */
  readonly fields: TenantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tenant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Tenant$usersArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    clients<T extends Tenant$clientsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$clientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends Tenant$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    classes<T extends Tenant$classesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$classesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    packages<T extends Tenant$packagesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$packagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orders<T extends Tenant$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoices<T extends Tenant$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    aiLogs<T extends Tenant$aiLogsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$aiLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AILogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bankAccounts<T extends Tenant$bankAccountsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$bankAccountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bankTransactions<T extends Tenant$bankTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$bankTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoicePayments<T extends Tenant$invoicePaymentsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$invoicePaymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    paymentGatewayConfigs<T extends Tenant$paymentGatewayConfigsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$paymentGatewayConfigsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentGatewayConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cryptoWallets<T extends Tenant$cryptoWalletsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$cryptoWalletsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CryptoWalletPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    expenseCategories<T extends Tenant$expenseCategoriesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$expenseCategoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    expenses<T extends Tenant$expensesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$expensesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    recurringInvoiceTemplates<T extends Tenant$recurringInvoiceTemplatesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$recurringInvoiceTemplatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecurringInvoiceTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    badges<T extends Tenant$badgesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$badgesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    workoutTemplates<T extends Tenant$workoutTemplatesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$workoutTemplatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkoutTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    scheduleTemplates<T extends Tenant$scheduleTemplatesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$scheduleTemplatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduleTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tenant model
   */
  interface TenantFieldRefs {
    readonly id: FieldRef<"Tenant", 'String'>
    readonly vertical: FieldRef<"Tenant", 'Vertical'>
    readonly name: FieldRef<"Tenant", 'String'>
    readonly slug: FieldRef<"Tenant", 'String'>
    readonly email: FieldRef<"Tenant", 'String'>
    readonly phone: FieldRef<"Tenant", 'String'>
    readonly website: FieldRef<"Tenant", 'String'>
    readonly logo: FieldRef<"Tenant", 'String'>
    readonly subscriptionTier: FieldRef<"Tenant", 'String'>
    readonly aiCredits: FieldRef<"Tenant", 'Int'>
    readonly createdAt: FieldRef<"Tenant", 'DateTime'>
    readonly updatedAt: FieldRef<"Tenant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tenant findUnique
   */
  export type TenantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findUniqueOrThrow
   */
  export type TenantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findFirst
   */
  export type TenantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findFirstOrThrow
   */
  export type TenantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findMany
   */
  export type TenantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenants to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant create
   */
  export type TenantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to create a Tenant.
     */
    data: XOR<TenantCreateInput, TenantUncheckedCreateInput>
  }

  /**
   * Tenant createMany
   */
  export type TenantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tenant createManyAndReturn
   */
  export type TenantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tenant update
   */
  export type TenantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to update a Tenant.
     */
    data: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
    /**
     * Choose, which Tenant to update.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant updateMany
   */
  export type TenantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tenants.
     */
    data: XOR<TenantUpdateManyMutationInput, TenantUncheckedUpdateManyInput>
    /**
     * Filter which Tenants to update
     */
    where?: TenantWhereInput
    /**
     * Limit how many Tenants to update.
     */
    limit?: number
  }

  /**
   * Tenant updateManyAndReturn
   */
  export type TenantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * The data used to update Tenants.
     */
    data: XOR<TenantUpdateManyMutationInput, TenantUncheckedUpdateManyInput>
    /**
     * Filter which Tenants to update
     */
    where?: TenantWhereInput
    /**
     * Limit how many Tenants to update.
     */
    limit?: number
  }

  /**
   * Tenant upsert
   */
  export type TenantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The filter to search for the Tenant to update in case it exists.
     */
    where: TenantWhereUniqueInput
    /**
     * In case the Tenant found by the `where` argument doesn't exist, create a new Tenant with this data.
     */
    create: XOR<TenantCreateInput, TenantUncheckedCreateInput>
    /**
     * In case the Tenant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
  }

  /**
   * Tenant delete
   */
  export type TenantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter which Tenant to delete.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant deleteMany
   */
  export type TenantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenants to delete
     */
    where?: TenantWhereInput
    /**
     * Limit how many Tenants to delete.
     */
    limit?: number
  }

  /**
   * Tenant.users
   */
  export type Tenant$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Tenant.clients
   */
  export type Tenant$clientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    cursor?: ClientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Tenant.sessions
   */
  export type Tenant$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Tenant.classes
   */
  export type Tenant$classesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    where?: ClassWhereInput
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    cursor?: ClassWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Tenant.packages
   */
  export type Tenant$packagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageInclude<ExtArgs> | null
    where?: PackageWhereInput
    orderBy?: PackageOrderByWithRelationInput | PackageOrderByWithRelationInput[]
    cursor?: PackageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PackageScalarFieldEnum | PackageScalarFieldEnum[]
  }

  /**
   * Tenant.orders
   */
  export type Tenant$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Tenant.invoices
   */
  export type Tenant$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Tenant.aiLogs
   */
  export type Tenant$aiLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AILog
     */
    select?: AILogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AILog
     */
    omit?: AILogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AILogInclude<ExtArgs> | null
    where?: AILogWhereInput
    orderBy?: AILogOrderByWithRelationInput | AILogOrderByWithRelationInput[]
    cursor?: AILogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AILogScalarFieldEnum | AILogScalarFieldEnum[]
  }

  /**
   * Tenant.bankAccounts
   */
  export type Tenant$bankAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    where?: BankAccountWhereInput
    orderBy?: BankAccountOrderByWithRelationInput | BankAccountOrderByWithRelationInput[]
    cursor?: BankAccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BankAccountScalarFieldEnum | BankAccountScalarFieldEnum[]
  }

  /**
   * Tenant.bankTransactions
   */
  export type Tenant$bankTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankTransaction
     */
    select?: BankTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankTransaction
     */
    omit?: BankTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankTransactionInclude<ExtArgs> | null
    where?: BankTransactionWhereInput
    orderBy?: BankTransactionOrderByWithRelationInput | BankTransactionOrderByWithRelationInput[]
    cursor?: BankTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BankTransactionScalarFieldEnum | BankTransactionScalarFieldEnum[]
  }

  /**
   * Tenant.invoicePayments
   */
  export type Tenant$invoicePaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoicePayment
     */
    select?: InvoicePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoicePayment
     */
    omit?: InvoicePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoicePaymentInclude<ExtArgs> | null
    where?: InvoicePaymentWhereInput
    orderBy?: InvoicePaymentOrderByWithRelationInput | InvoicePaymentOrderByWithRelationInput[]
    cursor?: InvoicePaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoicePaymentScalarFieldEnum | InvoicePaymentScalarFieldEnum[]
  }

  /**
   * Tenant.paymentGatewayConfigs
   */
  export type Tenant$paymentGatewayConfigsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentGatewayConfig
     */
    select?: PaymentGatewayConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentGatewayConfig
     */
    omit?: PaymentGatewayConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentGatewayConfigInclude<ExtArgs> | null
    where?: PaymentGatewayConfigWhereInput
    orderBy?: PaymentGatewayConfigOrderByWithRelationInput | PaymentGatewayConfigOrderByWithRelationInput[]
    cursor?: PaymentGatewayConfigWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentGatewayConfigScalarFieldEnum | PaymentGatewayConfigScalarFieldEnum[]
  }

  /**
   * Tenant.cryptoWallets
   */
  export type Tenant$cryptoWalletsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoWallet
     */
    select?: CryptoWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoWallet
     */
    omit?: CryptoWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoWalletInclude<ExtArgs> | null
    where?: CryptoWalletWhereInput
    orderBy?: CryptoWalletOrderByWithRelationInput | CryptoWalletOrderByWithRelationInput[]
    cursor?: CryptoWalletWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CryptoWalletScalarFieldEnum | CryptoWalletScalarFieldEnum[]
  }

  /**
   * Tenant.expenseCategories
   */
  export type Tenant$expenseCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseCategory
     */
    omit?: ExpenseCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
    where?: ExpenseCategoryWhereInput
    orderBy?: ExpenseCategoryOrderByWithRelationInput | ExpenseCategoryOrderByWithRelationInput[]
    cursor?: ExpenseCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpenseCategoryScalarFieldEnum | ExpenseCategoryScalarFieldEnum[]
  }

  /**
   * Tenant.expenses
   */
  export type Tenant$expensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    where?: ExpenseWhereInput
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    cursor?: ExpenseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Tenant.recurringInvoiceTemplates
   */
  export type Tenant$recurringInvoiceTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringInvoiceTemplate
     */
    select?: RecurringInvoiceTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringInvoiceTemplate
     */
    omit?: RecurringInvoiceTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringInvoiceTemplateInclude<ExtArgs> | null
    where?: RecurringInvoiceTemplateWhereInput
    orderBy?: RecurringInvoiceTemplateOrderByWithRelationInput | RecurringInvoiceTemplateOrderByWithRelationInput[]
    cursor?: RecurringInvoiceTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecurringInvoiceTemplateScalarFieldEnum | RecurringInvoiceTemplateScalarFieldEnum[]
  }

  /**
   * Tenant.badges
   */
  export type Tenant$badgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    where?: BadgeWhereInput
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    cursor?: BadgeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[]
  }

  /**
   * Tenant.workoutTemplates
   */
  export type Tenant$workoutTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutTemplate
     */
    select?: WorkoutTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutTemplate
     */
    omit?: WorkoutTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutTemplateInclude<ExtArgs> | null
    where?: WorkoutTemplateWhereInput
    orderBy?: WorkoutTemplateOrderByWithRelationInput | WorkoutTemplateOrderByWithRelationInput[]
    cursor?: WorkoutTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkoutTemplateScalarFieldEnum | WorkoutTemplateScalarFieldEnum[]
  }

  /**
   * Tenant.scheduleTemplates
   */
  export type Tenant$scheduleTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleTemplate
     */
    select?: ScheduleTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleTemplate
     */
    omit?: ScheduleTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleTemplateInclude<ExtArgs> | null
    where?: ScheduleTemplateWhereInput
    orderBy?: ScheduleTemplateOrderByWithRelationInput | ScheduleTemplateOrderByWithRelationInput[]
    cursor?: ScheduleTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduleTemplateScalarFieldEnum | ScheduleTemplateScalarFieldEnum[]
  }

  /**
   * Tenant without action
   */
  export type TenantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    email: string | null
    emailVerified: Date | null
    image: string | null
    password: string | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    email: string | null
    emailVerified: Date | null
    image: string | null
    password: string | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    tenantId: number
    name: number
    email: number
    emailVerified: number
    image: number
    password: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    password?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    password?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    password?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    tenantId: string
    name: string | null
    email: string
    emailVerified: Date | null
    image: string | null
    password: string | null
    role: string
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    password?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    password?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    password?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    tenantId?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    password?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "name" | "email" | "emailVerified" | "image" | "password" | "role" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      sessions: Prisma.$UserSessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      name: string | null
      email: string
      emailVerified: Date | null
      image: string | null
      password: string | null
      role: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly tenantId: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'DateTime'>
    readonly image: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    where?: UserSessionWhereInput
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    cursor?: UserSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountSumAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    provider: number
    providerAccountId: number
    refresh_token: number
    access_token: number
    expires_at: number
    token_type: number
    scope: number
    id_token: number
    session_state: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    expires_at?: true
  }

  export type AccountSumAggregateInputType = {
    expires_at?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "provider" | "providerAccountId" | "refresh_token" | "access_token" | "expires_at" | "token_type" | "scope" | "id_token" | "session_state", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      provider: string
      providerAccountId: string
      refresh_token: string | null
      access_token: string | null
      expires_at: number | null
      token_type: string | null
      scope: string | null
      id_token: string | null
      session_state: string | null
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly type: FieldRef<"Account", 'String'>
    readonly provider: FieldRef<"Account", 'String'>
    readonly providerAccountId: FieldRef<"Account", 'String'>
    readonly refresh_token: FieldRef<"Account", 'String'>
    readonly access_token: FieldRef<"Account", 'String'>
    readonly expires_at: FieldRef<"Account", 'Int'>
    readonly token_type: FieldRef<"Account", 'String'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly id_token: FieldRef<"Account", 'String'>
    readonly session_state: FieldRef<"Account", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model UserSession
   */

  export type AggregateUserSession = {
    _count: UserSessionCountAggregateOutputType | null
    _min: UserSessionMinAggregateOutputType | null
    _max: UserSessionMaxAggregateOutputType | null
  }

  export type UserSessionMinAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type UserSessionMaxAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type UserSessionCountAggregateOutputType = {
    id: number
    sessionToken: number
    userId: number
    expires: number
    _all: number
  }


  export type UserSessionMinAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type UserSessionMaxAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type UserSessionCountAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    _all?: true
  }

  export type UserSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSession to aggregate.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSessions
    **/
    _count?: true | UserSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSessionMaxAggregateInputType
  }

  export type GetUserSessionAggregateType<T extends UserSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSession[P]>
      : GetScalarType<T[P], AggregateUserSession[P]>
  }




  export type UserSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSessionWhereInput
    orderBy?: UserSessionOrderByWithAggregationInput | UserSessionOrderByWithAggregationInput[]
    by: UserSessionScalarFieldEnum[] | UserSessionScalarFieldEnum
    having?: UserSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSessionCountAggregateInputType | true
    _min?: UserSessionMinAggregateInputType
    _max?: UserSessionMaxAggregateInputType
  }

  export type UserSessionGroupByOutputType = {
    id: string
    sessionToken: string
    userId: string
    expires: Date
    _count: UserSessionCountAggregateOutputType | null
    _min: UserSessionMinAggregateOutputType | null
    _max: UserSessionMaxAggregateOutputType | null
  }

  type GetUserSessionGroupByPayload<T extends UserSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSessionGroupByOutputType[P]>
            : GetScalarType<T[P], UserSessionGroupByOutputType[P]>
        }
      >
    >


  export type UserSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSession"]>

  export type UserSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSession"]>

  export type UserSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSession"]>

  export type UserSessionSelectScalar = {
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
  }

  export type UserSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionToken" | "userId" | "expires", ExtArgs["result"]["userSession"]>
  export type UserSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSession"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionToken: string
      userId: string
      expires: Date
    }, ExtArgs["result"]["userSession"]>
    composites: {}
  }

  type UserSessionGetPayload<S extends boolean | null | undefined | UserSessionDefaultArgs> = $Result.GetResult<Prisma.$UserSessionPayload, S>

  type UserSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserSessionCountAggregateInputType | true
    }

  export interface UserSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSession'], meta: { name: 'UserSession' } }
    /**
     * Find zero or one UserSession that matches the filter.
     * @param {UserSessionFindUniqueArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSessionFindUniqueArgs>(args: SelectSubset<T, UserSessionFindUniqueArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserSessionFindUniqueOrThrowArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindFirstArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSessionFindFirstArgs>(args?: SelectSubset<T, UserSessionFindFirstArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindFirstOrThrowArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSessions
     * const userSessions = await prisma.userSession.findMany()
     * 
     * // Get first 10 UserSessions
     * const userSessions = await prisma.userSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userSessionWithIdOnly = await prisma.userSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserSessionFindManyArgs>(args?: SelectSubset<T, UserSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserSession.
     * @param {UserSessionCreateArgs} args - Arguments to create a UserSession.
     * @example
     * // Create one UserSession
     * const UserSession = await prisma.userSession.create({
     *   data: {
     *     // ... data to create a UserSession
     *   }
     * })
     * 
     */
    create<T extends UserSessionCreateArgs>(args: SelectSubset<T, UserSessionCreateArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserSessions.
     * @param {UserSessionCreateManyArgs} args - Arguments to create many UserSessions.
     * @example
     * // Create many UserSessions
     * const userSession = await prisma.userSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSessionCreateManyArgs>(args?: SelectSubset<T, UserSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserSessions and returns the data saved in the database.
     * @param {UserSessionCreateManyAndReturnArgs} args - Arguments to create many UserSessions.
     * @example
     * // Create many UserSessions
     * const userSession = await prisma.userSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserSessions and only return the `id`
     * const userSessionWithIdOnly = await prisma.userSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, UserSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserSession.
     * @param {UserSessionDeleteArgs} args - Arguments to delete one UserSession.
     * @example
     * // Delete one UserSession
     * const UserSession = await prisma.userSession.delete({
     *   where: {
     *     // ... filter to delete one UserSession
     *   }
     * })
     * 
     */
    delete<T extends UserSessionDeleteArgs>(args: SelectSubset<T, UserSessionDeleteArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserSession.
     * @param {UserSessionUpdateArgs} args - Arguments to update one UserSession.
     * @example
     * // Update one UserSession
     * const userSession = await prisma.userSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSessionUpdateArgs>(args: SelectSubset<T, UserSessionUpdateArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserSessions.
     * @param {UserSessionDeleteManyArgs} args - Arguments to filter UserSessions to delete.
     * @example
     * // Delete a few UserSessions
     * const { count } = await prisma.userSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSessionDeleteManyArgs>(args?: SelectSubset<T, UserSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSessions
     * const userSession = await prisma.userSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSessionUpdateManyArgs>(args: SelectSubset<T, UserSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSessions and returns the data updated in the database.
     * @param {UserSessionUpdateManyAndReturnArgs} args - Arguments to update many UserSessions.
     * @example
     * // Update many UserSessions
     * const userSession = await prisma.userSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserSessions and only return the `id`
     * const userSessionWithIdOnly = await prisma.userSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, UserSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserSession.
     * @param {UserSessionUpsertArgs} args - Arguments to update or create a UserSession.
     * @example
     * // Update or create a UserSession
     * const userSession = await prisma.userSession.upsert({
     *   create: {
     *     // ... data to create a UserSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSession we want to update
     *   }
     * })
     */
    upsert<T extends UserSessionUpsertArgs>(args: SelectSubset<T, UserSessionUpsertArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionCountArgs} args - Arguments to filter UserSessions to count.
     * @example
     * // Count the number of UserSessions
     * const count = await prisma.userSession.count({
     *   where: {
     *     // ... the filter for the UserSessions we want to count
     *   }
     * })
    **/
    count<T extends UserSessionCountArgs>(
      args?: Subset<T, UserSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSessionAggregateArgs>(args: Subset<T, UserSessionAggregateArgs>): Prisma.PrismaPromise<GetUserSessionAggregateType<T>>

    /**
     * Group by UserSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSessionGroupByArgs['orderBy'] }
        : { orderBy?: UserSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSession model
   */
  readonly fields: UserSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSession model
   */
  interface UserSessionFieldRefs {
    readonly id: FieldRef<"UserSession", 'String'>
    readonly sessionToken: FieldRef<"UserSession", 'String'>
    readonly userId: FieldRef<"UserSession", 'String'>
    readonly expires: FieldRef<"UserSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserSession findUnique
   */
  export type UserSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession findUniqueOrThrow
   */
  export type UserSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession findFirst
   */
  export type UserSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSessions.
     */
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * UserSession findFirstOrThrow
   */
  export type UserSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSessions.
     */
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * UserSession findMany
   */
  export type UserSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSessions to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * UserSession create
   */
  export type UserSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSession.
     */
    data: XOR<UserSessionCreateInput, UserSessionUncheckedCreateInput>
  }

  /**
   * UserSession createMany
   */
  export type UserSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSessions.
     */
    data: UserSessionCreateManyInput | UserSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserSession createManyAndReturn
   */
  export type UserSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * The data used to create many UserSessions.
     */
    data: UserSessionCreateManyInput | UserSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSession update
   */
  export type UserSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSession.
     */
    data: XOR<UserSessionUpdateInput, UserSessionUncheckedUpdateInput>
    /**
     * Choose, which UserSession to update.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession updateMany
   */
  export type UserSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSessions.
     */
    data: XOR<UserSessionUpdateManyMutationInput, UserSessionUncheckedUpdateManyInput>
    /**
     * Filter which UserSessions to update
     */
    where?: UserSessionWhereInput
    /**
     * Limit how many UserSessions to update.
     */
    limit?: number
  }

  /**
   * UserSession updateManyAndReturn
   */
  export type UserSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * The data used to update UserSessions.
     */
    data: XOR<UserSessionUpdateManyMutationInput, UserSessionUncheckedUpdateManyInput>
    /**
     * Filter which UserSessions to update
     */
    where?: UserSessionWhereInput
    /**
     * Limit how many UserSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSession upsert
   */
  export type UserSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSession to update in case it exists.
     */
    where: UserSessionWhereUniqueInput
    /**
     * In case the UserSession found by the `where` argument doesn't exist, create a new UserSession with this data.
     */
    create: XOR<UserSessionCreateInput, UserSessionUncheckedCreateInput>
    /**
     * In case the UserSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSessionUpdateInput, UserSessionUncheckedUpdateInput>
  }

  /**
   * UserSession delete
   */
  export type UserSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter which UserSession to delete.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession deleteMany
   */
  export type UserSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSessions to delete
     */
    where?: UserSessionWhereInput
    /**
     * Limit how many UserSessions to delete.
     */
    limit?: number
  }

  /**
   * UserSession without action
   */
  export type UserSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
  }


  /**
   * Model VerificationToken
   */

  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  export type VerificationTokenMinAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenMaxAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenCountAggregateOutputType = {
    identifier: number
    token: number
    expires: number
    _all: number
  }


  export type VerificationTokenMinAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenMaxAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenCountAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
    _all?: true
  }

  export type VerificationTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationToken to aggregate.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationTokens
    **/
    _count?: true | VerificationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type GetVerificationTokenAggregateType<T extends VerificationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>
  }




  export type VerificationTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationTokenWhereInput
    orderBy?: VerificationTokenOrderByWithAggregationInput | VerificationTokenOrderByWithAggregationInput[]
    by: VerificationTokenScalarFieldEnum[] | VerificationTokenScalarFieldEnum
    having?: VerificationTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationTokenCountAggregateInputType | true
    _min?: VerificationTokenMinAggregateInputType
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type VerificationTokenGroupByOutputType = {
    identifier: string
    token: string
    expires: Date
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  type GetVerificationTokenGroupByPayload<T extends VerificationTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
        }
      >
    >


  export type VerificationTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectScalar = {
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }

  export type VerificationTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"identifier" | "token" | "expires", ExtArgs["result"]["verificationToken"]>

  export type $VerificationTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerificationToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      identifier: string
      token: string
      expires: Date
    }, ExtArgs["result"]["verificationToken"]>
    composites: {}
  }

  type VerificationTokenGetPayload<S extends boolean | null | undefined | VerificationTokenDefaultArgs> = $Result.GetResult<Prisma.$VerificationTokenPayload, S>

  type VerificationTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationTokenCountAggregateInputType | true
    }

  export interface VerificationTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationToken'], meta: { name: 'VerificationToken' } }
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationTokenFindUniqueArgs>(args: SelectSubset<T, VerificationTokenFindUniqueArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VerificationToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationTokenFindFirstArgs>(args?: SelectSubset<T, VerificationTokenFindFirstArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     * 
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     * 
     * // Only select the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.findMany({ select: { identifier: true } })
     * 
     */
    findMany<T extends VerificationTokenFindManyArgs>(args?: SelectSubset<T, VerificationTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     * 
     */
    create<T extends VerificationTokenCreateArgs>(args: SelectSubset<T, VerificationTokenCreateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VerificationTokens.
     * @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationTokenCreateManyArgs>(args?: SelectSubset<T, VerificationTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerificationTokens and returns the data saved in the database.
     * @param {VerificationTokenCreateManyAndReturnArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.createManyAndReturn({
     *   select: { identifier: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     * 
     */
    delete<T extends VerificationTokenDeleteArgs>(args: SelectSubset<T, VerificationTokenDeleteArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationTokenUpdateArgs>(args: SelectSubset<T, VerificationTokenUpdateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationTokenDeleteManyArgs>(args?: SelectSubset<T, VerificationTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationTokenUpdateManyArgs>(args: SelectSubset<T, VerificationTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens and returns the data updated in the database.
     * @param {VerificationTokenUpdateManyAndReturnArgs} args - Arguments to update many VerificationTokens.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.updateManyAndReturn({
     *   select: { identifier: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
     */
    upsert<T extends VerificationTokenUpsertArgs>(args: SelectSubset<T, VerificationTokenUpsertArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
    **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationTokenAggregateArgs>(args: Subset<T, VerificationTokenAggregateArgs>): Prisma.PrismaPromise<GetVerificationTokenAggregateType<T>>

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: VerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerificationToken model
   */
  readonly fields: VerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerificationToken model
   */
  interface VerificationTokenFieldRefs {
    readonly identifier: FieldRef<"VerificationToken", 'String'>
    readonly token: FieldRef<"VerificationToken", 'String'>
    readonly expires: FieldRef<"VerificationToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerificationToken findUnique
   */
  export type VerificationTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findFirst
   */
  export type VerificationTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationTokens to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to create a VerificationToken.
     */
    data: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
  }

  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken createManyAndReturn
   */
  export type VerificationTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to update a VerificationToken.
     */
    data: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
    /**
     * Choose, which VerificationToken to update.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken updateManyAndReturn
   */
  export type VerificationTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     */
    where: VerificationTokenWhereUniqueInput
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     */
    create: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
  }

  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter which VerificationToken to delete.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationTokens to delete
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to delete.
     */
    limit?: number
  }

  /**
   * VerificationToken without action
   */
  export type VerificationTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
  }


  /**
   * Model PasswordResetToken
   */

  export type AggregatePasswordResetToken = {
    _count: PasswordResetTokenCountAggregateOutputType | null
    _min: PasswordResetTokenMinAggregateOutputType | null
    _max: PasswordResetTokenMaxAggregateOutputType | null
  }

  export type PasswordResetTokenMinAggregateOutputType = {
    id: string | null
    email: string | null
    token: string | null
    expires: Date | null
    createdAt: Date | null
  }

  export type PasswordResetTokenMaxAggregateOutputType = {
    id: string | null
    email: string | null
    token: string | null
    expires: Date | null
    createdAt: Date | null
  }

  export type PasswordResetTokenCountAggregateOutputType = {
    id: number
    email: number
    token: number
    expires: number
    createdAt: number
    _all: number
  }


  export type PasswordResetTokenMinAggregateInputType = {
    id?: true
    email?: true
    token?: true
    expires?: true
    createdAt?: true
  }

  export type PasswordResetTokenMaxAggregateInputType = {
    id?: true
    email?: true
    token?: true
    expires?: true
    createdAt?: true
  }

  export type PasswordResetTokenCountAggregateInputType = {
    id?: true
    email?: true
    token?: true
    expires?: true
    createdAt?: true
    _all?: true
  }

  export type PasswordResetTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResetToken to aggregate.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PasswordResetTokens
    **/
    _count?: true | PasswordResetTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PasswordResetTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PasswordResetTokenMaxAggregateInputType
  }

  export type GetPasswordResetTokenAggregateType<T extends PasswordResetTokenAggregateArgs> = {
        [P in keyof T & keyof AggregatePasswordResetToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePasswordResetToken[P]>
      : GetScalarType<T[P], AggregatePasswordResetToken[P]>
  }




  export type PasswordResetTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordResetTokenWhereInput
    orderBy?: PasswordResetTokenOrderByWithAggregationInput | PasswordResetTokenOrderByWithAggregationInput[]
    by: PasswordResetTokenScalarFieldEnum[] | PasswordResetTokenScalarFieldEnum
    having?: PasswordResetTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasswordResetTokenCountAggregateInputType | true
    _min?: PasswordResetTokenMinAggregateInputType
    _max?: PasswordResetTokenMaxAggregateInputType
  }

  export type PasswordResetTokenGroupByOutputType = {
    id: string
    email: string
    token: string
    expires: Date
    createdAt: Date
    _count: PasswordResetTokenCountAggregateOutputType | null
    _min: PasswordResetTokenMinAggregateOutputType | null
    _max: PasswordResetTokenMaxAggregateOutputType | null
  }

  type GetPasswordResetTokenGroupByPayload<T extends PasswordResetTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasswordResetTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasswordResetTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasswordResetTokenGroupByOutputType[P]>
            : GetScalarType<T[P], PasswordResetTokenGroupByOutputType[P]>
        }
      >
    >


  export type PasswordResetTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    token?: boolean
    expires?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    token?: boolean
    expires?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    token?: boolean
    expires?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectScalar = {
    id?: boolean
    email?: boolean
    token?: boolean
    expires?: boolean
    createdAt?: boolean
  }

  export type PasswordResetTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "token" | "expires" | "createdAt", ExtArgs["result"]["passwordResetToken"]>

  export type $PasswordResetTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PasswordResetToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      token: string
      expires: Date
      createdAt: Date
    }, ExtArgs["result"]["passwordResetToken"]>
    composites: {}
  }

  type PasswordResetTokenGetPayload<S extends boolean | null | undefined | PasswordResetTokenDefaultArgs> = $Result.GetResult<Prisma.$PasswordResetTokenPayload, S>

  type PasswordResetTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PasswordResetTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PasswordResetTokenCountAggregateInputType | true
    }

  export interface PasswordResetTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PasswordResetToken'], meta: { name: 'PasswordResetToken' } }
    /**
     * Find zero or one PasswordResetToken that matches the filter.
     * @param {PasswordResetTokenFindUniqueArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PasswordResetTokenFindUniqueArgs>(args: SelectSubset<T, PasswordResetTokenFindUniqueArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PasswordResetToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PasswordResetTokenFindUniqueOrThrowArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PasswordResetTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordResetToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindFirstArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PasswordResetTokenFindFirstArgs>(args?: SelectSubset<T, PasswordResetTokenFindFirstArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordResetToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindFirstOrThrowArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PasswordResetTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, PasswordResetTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PasswordResetTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PasswordResetTokens
     * const passwordResetTokens = await prisma.passwordResetToken.findMany()
     * 
     * // Get first 10 PasswordResetTokens
     * const passwordResetTokens = await prisma.passwordResetToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PasswordResetTokenFindManyArgs>(args?: SelectSubset<T, PasswordResetTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PasswordResetToken.
     * @param {PasswordResetTokenCreateArgs} args - Arguments to create a PasswordResetToken.
     * @example
     * // Create one PasswordResetToken
     * const PasswordResetToken = await prisma.passwordResetToken.create({
     *   data: {
     *     // ... data to create a PasswordResetToken
     *   }
     * })
     * 
     */
    create<T extends PasswordResetTokenCreateArgs>(args: SelectSubset<T, PasswordResetTokenCreateArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PasswordResetTokens.
     * @param {PasswordResetTokenCreateManyArgs} args - Arguments to create many PasswordResetTokens.
     * @example
     * // Create many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PasswordResetTokenCreateManyArgs>(args?: SelectSubset<T, PasswordResetTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PasswordResetTokens and returns the data saved in the database.
     * @param {PasswordResetTokenCreateManyAndReturnArgs} args - Arguments to create many PasswordResetTokens.
     * @example
     * // Create many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PasswordResetTokens and only return the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PasswordResetTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, PasswordResetTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PasswordResetToken.
     * @param {PasswordResetTokenDeleteArgs} args - Arguments to delete one PasswordResetToken.
     * @example
     * // Delete one PasswordResetToken
     * const PasswordResetToken = await prisma.passwordResetToken.delete({
     *   where: {
     *     // ... filter to delete one PasswordResetToken
     *   }
     * })
     * 
     */
    delete<T extends PasswordResetTokenDeleteArgs>(args: SelectSubset<T, PasswordResetTokenDeleteArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PasswordResetToken.
     * @param {PasswordResetTokenUpdateArgs} args - Arguments to update one PasswordResetToken.
     * @example
     * // Update one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PasswordResetTokenUpdateArgs>(args: SelectSubset<T, PasswordResetTokenUpdateArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PasswordResetTokens.
     * @param {PasswordResetTokenDeleteManyArgs} args - Arguments to filter PasswordResetTokens to delete.
     * @example
     * // Delete a few PasswordResetTokens
     * const { count } = await prisma.passwordResetToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PasswordResetTokenDeleteManyArgs>(args?: SelectSubset<T, PasswordResetTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResetTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PasswordResetTokenUpdateManyArgs>(args: SelectSubset<T, PasswordResetTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResetTokens and returns the data updated in the database.
     * @param {PasswordResetTokenUpdateManyAndReturnArgs} args - Arguments to update many PasswordResetTokens.
     * @example
     * // Update many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PasswordResetTokens and only return the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PasswordResetTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, PasswordResetTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PasswordResetToken.
     * @param {PasswordResetTokenUpsertArgs} args - Arguments to update or create a PasswordResetToken.
     * @example
     * // Update or create a PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.upsert({
     *   create: {
     *     // ... data to create a PasswordResetToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PasswordResetToken we want to update
     *   }
     * })
     */
    upsert<T extends PasswordResetTokenUpsertArgs>(args: SelectSubset<T, PasswordResetTokenUpsertArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PasswordResetTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenCountArgs} args - Arguments to filter PasswordResetTokens to count.
     * @example
     * // Count the number of PasswordResetTokens
     * const count = await prisma.passwordResetToken.count({
     *   where: {
     *     // ... the filter for the PasswordResetTokens we want to count
     *   }
     * })
    **/
    count<T extends PasswordResetTokenCountArgs>(
      args?: Subset<T, PasswordResetTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasswordResetTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PasswordResetToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasswordResetTokenAggregateArgs>(args: Subset<T, PasswordResetTokenAggregateArgs>): Prisma.PrismaPromise<GetPasswordResetTokenAggregateType<T>>

    /**
     * Group by PasswordResetToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PasswordResetTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PasswordResetTokenGroupByArgs['orderBy'] }
        : { orderBy?: PasswordResetTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PasswordResetTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasswordResetTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PasswordResetToken model
   */
  readonly fields: PasswordResetTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PasswordResetToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PasswordResetTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PasswordResetToken model
   */
  interface PasswordResetTokenFieldRefs {
    readonly id: FieldRef<"PasswordResetToken", 'String'>
    readonly email: FieldRef<"PasswordResetToken", 'String'>
    readonly token: FieldRef<"PasswordResetToken", 'String'>
    readonly expires: FieldRef<"PasswordResetToken", 'DateTime'>
    readonly createdAt: FieldRef<"PasswordResetToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PasswordResetToken findUnique
   */
  export type PasswordResetTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken findUniqueOrThrow
   */
  export type PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken findFirst
   */
  export type PasswordResetTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResetTokens.
     */
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken findFirstOrThrow
   */
  export type PasswordResetTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResetTokens.
     */
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken findMany
   */
  export type PasswordResetTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Filter, which PasswordResetTokens to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken create
   */
  export type PasswordResetTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * The data needed to create a PasswordResetToken.
     */
    data: XOR<PasswordResetTokenCreateInput, PasswordResetTokenUncheckedCreateInput>
  }

  /**
   * PasswordResetToken createMany
   */
  export type PasswordResetTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PasswordResetTokens.
     */
    data: PasswordResetTokenCreateManyInput | PasswordResetTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PasswordResetToken createManyAndReturn
   */
  export type PasswordResetTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * The data used to create many PasswordResetTokens.
     */
    data: PasswordResetTokenCreateManyInput | PasswordResetTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PasswordResetToken update
   */
  export type PasswordResetTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * The data needed to update a PasswordResetToken.
     */
    data: XOR<PasswordResetTokenUpdateInput, PasswordResetTokenUncheckedUpdateInput>
    /**
     * Choose, which PasswordResetToken to update.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken updateMany
   */
  export type PasswordResetTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PasswordResetTokens.
     */
    data: XOR<PasswordResetTokenUpdateManyMutationInput, PasswordResetTokenUncheckedUpdateManyInput>
    /**
     * Filter which PasswordResetTokens to update
     */
    where?: PasswordResetTokenWhereInput
    /**
     * Limit how many PasswordResetTokens to update.
     */
    limit?: number
  }

  /**
   * PasswordResetToken updateManyAndReturn
   */
  export type PasswordResetTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * The data used to update PasswordResetTokens.
     */
    data: XOR<PasswordResetTokenUpdateManyMutationInput, PasswordResetTokenUncheckedUpdateManyInput>
    /**
     * Filter which PasswordResetTokens to update
     */
    where?: PasswordResetTokenWhereInput
    /**
     * Limit how many PasswordResetTokens to update.
     */
    limit?: number
  }

  /**
   * PasswordResetToken upsert
   */
  export type PasswordResetTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * The filter to search for the PasswordResetToken to update in case it exists.
     */
    where: PasswordResetTokenWhereUniqueInput
    /**
     * In case the PasswordResetToken found by the `where` argument doesn't exist, create a new PasswordResetToken with this data.
     */
    create: XOR<PasswordResetTokenCreateInput, PasswordResetTokenUncheckedCreateInput>
    /**
     * In case the PasswordResetToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PasswordResetTokenUpdateInput, PasswordResetTokenUncheckedUpdateInput>
  }

  /**
   * PasswordResetToken delete
   */
  export type PasswordResetTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Filter which PasswordResetToken to delete.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken deleteMany
   */
  export type PasswordResetTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResetTokens to delete
     */
    where?: PasswordResetTokenWhereInput
    /**
     * Limit how many PasswordResetTokens to delete.
     */
    limit?: number
  }

  /**
   * PasswordResetToken without action
   */
  export type PasswordResetTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
  }


  /**
   * Model Client
   */

  export type AggregateClient = {
    _count: ClientCountAggregateOutputType | null
    _avg: ClientAvgAggregateOutputType | null
    _sum: ClientSumAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  export type ClientAvgAggregateOutputType = {
    currentWeight: number | null
    targetWeight: number | null
    height: number | null
    bodyFatPercent: number | null
    creditsRemaining: number | null
  }

  export type ClientSumAggregateOutputType = {
    currentWeight: number | null
    targetWeight: number | null
    height: number | null
    bodyFatPercent: number | null
    creditsRemaining: number | null
  }

  export type ClientMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    email: string | null
    phone: string | null
    avatar: string | null
    dateOfBirth: Date | null
    gender: string | null
    currentWeight: number | null
    targetWeight: number | null
    height: number | null
    bodyFatPercent: number | null
    fitnessLevel: string | null
    injuryHistory: string | null
    dietaryNotes: string | null
    medicalNotes: string | null
    creditsRemaining: number | null
    membershipType: string | null
    membershipExpiry: Date | null
    status: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    email: string | null
    phone: string | null
    avatar: string | null
    dateOfBirth: Date | null
    gender: string | null
    currentWeight: number | null
    targetWeight: number | null
    height: number | null
    bodyFatPercent: number | null
    fitnessLevel: string | null
    injuryHistory: string | null
    dietaryNotes: string | null
    medicalNotes: string | null
    creditsRemaining: number | null
    membershipType: string | null
    membershipExpiry: Date | null
    status: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientCountAggregateOutputType = {
    id: number
    tenantId: number
    name: number
    email: number
    phone: number
    avatar: number
    dateOfBirth: number
    gender: number
    goals: number
    currentWeight: number
    targetWeight: number
    height: number
    bodyMeasurements: number
    bodyFatPercent: number
    fitnessLevel: number
    injuryHistory: number
    dietaryNotes: number
    medicalNotes: number
    creditsRemaining: number
    membershipType: number
    membershipExpiry: number
    status: number
    tags: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClientAvgAggregateInputType = {
    currentWeight?: true
    targetWeight?: true
    height?: true
    bodyFatPercent?: true
    creditsRemaining?: true
  }

  export type ClientSumAggregateInputType = {
    currentWeight?: true
    targetWeight?: true
    height?: true
    bodyFatPercent?: true
    creditsRemaining?: true
  }

  export type ClientMinAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    email?: true
    phone?: true
    avatar?: true
    dateOfBirth?: true
    gender?: true
    currentWeight?: true
    targetWeight?: true
    height?: true
    bodyFatPercent?: true
    fitnessLevel?: true
    injuryHistory?: true
    dietaryNotes?: true
    medicalNotes?: true
    creditsRemaining?: true
    membershipType?: true
    membershipExpiry?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientMaxAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    email?: true
    phone?: true
    avatar?: true
    dateOfBirth?: true
    gender?: true
    currentWeight?: true
    targetWeight?: true
    height?: true
    bodyFatPercent?: true
    fitnessLevel?: true
    injuryHistory?: true
    dietaryNotes?: true
    medicalNotes?: true
    creditsRemaining?: true
    membershipType?: true
    membershipExpiry?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientCountAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    email?: true
    phone?: true
    avatar?: true
    dateOfBirth?: true
    gender?: true
    goals?: true
    currentWeight?: true
    targetWeight?: true
    height?: true
    bodyMeasurements?: true
    bodyFatPercent?: true
    fitnessLevel?: true
    injuryHistory?: true
    dietaryNotes?: true
    medicalNotes?: true
    creditsRemaining?: true
    membershipType?: true
    membershipExpiry?: true
    status?: true
    tags?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Client to aggregate.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clients
    **/
    _count?: true | ClientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientMaxAggregateInputType
  }

  export type GetClientAggregateType<T extends ClientAggregateArgs> = {
        [P in keyof T & keyof AggregateClient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClient[P]>
      : GetScalarType<T[P], AggregateClient[P]>
  }




  export type ClientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientWhereInput
    orderBy?: ClientOrderByWithAggregationInput | ClientOrderByWithAggregationInput[]
    by: ClientScalarFieldEnum[] | ClientScalarFieldEnum
    having?: ClientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientCountAggregateInputType | true
    _avg?: ClientAvgAggregateInputType
    _sum?: ClientSumAggregateInputType
    _min?: ClientMinAggregateInputType
    _max?: ClientMaxAggregateInputType
  }

  export type ClientGroupByOutputType = {
    id: string
    tenantId: string
    name: string
    email: string
    phone: string | null
    avatar: string | null
    dateOfBirth: Date | null
    gender: string | null
    goals: string[]
    currentWeight: number | null
    targetWeight: number | null
    height: number | null
    bodyMeasurements: JsonValue | null
    bodyFatPercent: number | null
    fitnessLevel: string | null
    injuryHistory: string | null
    dietaryNotes: string | null
    medicalNotes: string | null
    creditsRemaining: number
    membershipType: string | null
    membershipExpiry: Date | null
    status: string
    tags: string[]
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: ClientCountAggregateOutputType | null
    _avg: ClientAvgAggregateOutputType | null
    _sum: ClientSumAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  type GetClientGroupByPayload<T extends ClientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientGroupByOutputType[P]>
            : GetScalarType<T[P], ClientGroupByOutputType[P]>
        }
      >
    >


  export type ClientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    avatar?: boolean
    dateOfBirth?: boolean
    gender?: boolean
    goals?: boolean
    currentWeight?: boolean
    targetWeight?: boolean
    height?: boolean
    bodyMeasurements?: boolean
    bodyFatPercent?: boolean
    fitnessLevel?: boolean
    injuryHistory?: boolean
    dietaryNotes?: boolean
    medicalNotes?: boolean
    creditsRemaining?: boolean
    membershipType?: boolean
    membershipExpiry?: boolean
    status?: boolean
    tags?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    sessions?: boolean | Client$sessionsArgs<ExtArgs>
    orders?: boolean | Client$ordersArgs<ExtArgs>
    invoices?: boolean | Client$invoicesArgs<ExtArgs>
    measurements?: boolean | Client$measurementsArgs<ExtArgs>
    progressPhotos?: boolean | Client$progressPhotosArgs<ExtArgs>
    badges?: boolean | Client$badgesArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>

  export type ClientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    avatar?: boolean
    dateOfBirth?: boolean
    gender?: boolean
    goals?: boolean
    currentWeight?: boolean
    targetWeight?: boolean
    height?: boolean
    bodyMeasurements?: boolean
    bodyFatPercent?: boolean
    fitnessLevel?: boolean
    injuryHistory?: boolean
    dietaryNotes?: boolean
    medicalNotes?: boolean
    creditsRemaining?: boolean
    membershipType?: boolean
    membershipExpiry?: boolean
    status?: boolean
    tags?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>

  export type ClientSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    avatar?: boolean
    dateOfBirth?: boolean
    gender?: boolean
    goals?: boolean
    currentWeight?: boolean
    targetWeight?: boolean
    height?: boolean
    bodyMeasurements?: boolean
    bodyFatPercent?: boolean
    fitnessLevel?: boolean
    injuryHistory?: boolean
    dietaryNotes?: boolean
    medicalNotes?: boolean
    creditsRemaining?: boolean
    membershipType?: boolean
    membershipExpiry?: boolean
    status?: boolean
    tags?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>

  export type ClientSelectScalar = {
    id?: boolean
    tenantId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    avatar?: boolean
    dateOfBirth?: boolean
    gender?: boolean
    goals?: boolean
    currentWeight?: boolean
    targetWeight?: boolean
    height?: boolean
    bodyMeasurements?: boolean
    bodyFatPercent?: boolean
    fitnessLevel?: boolean
    injuryHistory?: boolean
    dietaryNotes?: boolean
    medicalNotes?: boolean
    creditsRemaining?: boolean
    membershipType?: boolean
    membershipExpiry?: boolean
    status?: boolean
    tags?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "name" | "email" | "phone" | "avatar" | "dateOfBirth" | "gender" | "goals" | "currentWeight" | "targetWeight" | "height" | "bodyMeasurements" | "bodyFatPercent" | "fitnessLevel" | "injuryHistory" | "dietaryNotes" | "medicalNotes" | "creditsRemaining" | "membershipType" | "membershipExpiry" | "status" | "tags" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["client"]>
  export type ClientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    sessions?: boolean | Client$sessionsArgs<ExtArgs>
    orders?: boolean | Client$ordersArgs<ExtArgs>
    invoices?: boolean | Client$invoicesArgs<ExtArgs>
    measurements?: boolean | Client$measurementsArgs<ExtArgs>
    progressPhotos?: boolean | Client$progressPhotosArgs<ExtArgs>
    badges?: boolean | Client$badgesArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type ClientIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $ClientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Client"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      orders: Prisma.$OrderPayload<ExtArgs>[]
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      measurements: Prisma.$ClientMeasurementPayload<ExtArgs>[]
      progressPhotos: Prisma.$ProgressPhotoPayload<ExtArgs>[]
      badges: Prisma.$ClientBadgePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      name: string
      email: string
      phone: string | null
      avatar: string | null
      dateOfBirth: Date | null
      gender: string | null
      goals: string[]
      currentWeight: number | null
      targetWeight: number | null
      height: number | null
      bodyMeasurements: Prisma.JsonValue | null
      bodyFatPercent: number | null
      fitnessLevel: string | null
      injuryHistory: string | null
      dietaryNotes: string | null
      medicalNotes: string | null
      creditsRemaining: number
      membershipType: string | null
      membershipExpiry: Date | null
      status: string
      tags: string[]
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["client"]>
    composites: {}
  }

  type ClientGetPayload<S extends boolean | null | undefined | ClientDefaultArgs> = $Result.GetResult<Prisma.$ClientPayload, S>

  type ClientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClientCountAggregateInputType | true
    }

  export interface ClientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Client'], meta: { name: 'Client' } }
    /**
     * Find zero or one Client that matches the filter.
     * @param {ClientFindUniqueArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientFindUniqueArgs>(args: SelectSubset<T, ClientFindUniqueArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Client that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClientFindUniqueOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Client that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientFindFirstArgs>(args?: SelectSubset<T, ClientFindFirstArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Client that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clients
     * const clients = await prisma.client.findMany()
     * 
     * // Get first 10 Clients
     * const clients = await prisma.client.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientWithIdOnly = await prisma.client.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientFindManyArgs>(args?: SelectSubset<T, ClientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Client.
     * @param {ClientCreateArgs} args - Arguments to create a Client.
     * @example
     * // Create one Client
     * const Client = await prisma.client.create({
     *   data: {
     *     // ... data to create a Client
     *   }
     * })
     * 
     */
    create<T extends ClientCreateArgs>(args: SelectSubset<T, ClientCreateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Clients.
     * @param {ClientCreateManyArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientCreateManyArgs>(args?: SelectSubset<T, ClientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Clients and returns the data saved in the database.
     * @param {ClientCreateManyAndReturnArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Clients and only return the `id`
     * const clientWithIdOnly = await prisma.client.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClientCreateManyAndReturnArgs>(args?: SelectSubset<T, ClientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Client.
     * @param {ClientDeleteArgs} args - Arguments to delete one Client.
     * @example
     * // Delete one Client
     * const Client = await prisma.client.delete({
     *   where: {
     *     // ... filter to delete one Client
     *   }
     * })
     * 
     */
    delete<T extends ClientDeleteArgs>(args: SelectSubset<T, ClientDeleteArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Client.
     * @param {ClientUpdateArgs} args - Arguments to update one Client.
     * @example
     * // Update one Client
     * const client = await prisma.client.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientUpdateArgs>(args: SelectSubset<T, ClientUpdateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Clients.
     * @param {ClientDeleteManyArgs} args - Arguments to filter Clients to delete.
     * @example
     * // Delete a few Clients
     * const { count } = await prisma.client.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientDeleteManyArgs>(args?: SelectSubset<T, ClientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientUpdateManyArgs>(args: SelectSubset<T, ClientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients and returns the data updated in the database.
     * @param {ClientUpdateManyAndReturnArgs} args - Arguments to update many Clients.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Clients and only return the `id`
     * const clientWithIdOnly = await prisma.client.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClientUpdateManyAndReturnArgs>(args: SelectSubset<T, ClientUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Client.
     * @param {ClientUpsertArgs} args - Arguments to update or create a Client.
     * @example
     * // Update or create a Client
     * const client = await prisma.client.upsert({
     *   create: {
     *     // ... data to create a Client
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Client we want to update
     *   }
     * })
     */
    upsert<T extends ClientUpsertArgs>(args: SelectSubset<T, ClientUpsertArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCountArgs} args - Arguments to filter Clients to count.
     * @example
     * // Count the number of Clients
     * const count = await prisma.client.count({
     *   where: {
     *     // ... the filter for the Clients we want to count
     *   }
     * })
    **/
    count<T extends ClientCountArgs>(
      args?: Subset<T, ClientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientAggregateArgs>(args: Subset<T, ClientAggregateArgs>): Prisma.PrismaPromise<GetClientAggregateType<T>>

    /**
     * Group by Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientGroupByArgs['orderBy'] }
        : { orderBy?: ClientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Client model
   */
  readonly fields: ClientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Client.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sessions<T extends Client$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, Client$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orders<T extends Client$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Client$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoices<T extends Client$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Client$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    measurements<T extends Client$measurementsArgs<ExtArgs> = {}>(args?: Subset<T, Client$measurementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientMeasurementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    progressPhotos<T extends Client$progressPhotosArgs<ExtArgs> = {}>(args?: Subset<T, Client$progressPhotosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgressPhotoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    badges<T extends Client$badgesArgs<ExtArgs> = {}>(args?: Subset<T, Client$badgesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientBadgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Client model
   */
  interface ClientFieldRefs {
    readonly id: FieldRef<"Client", 'String'>
    readonly tenantId: FieldRef<"Client", 'String'>
    readonly name: FieldRef<"Client", 'String'>
    readonly email: FieldRef<"Client", 'String'>
    readonly phone: FieldRef<"Client", 'String'>
    readonly avatar: FieldRef<"Client", 'String'>
    readonly dateOfBirth: FieldRef<"Client", 'DateTime'>
    readonly gender: FieldRef<"Client", 'String'>
    readonly goals: FieldRef<"Client", 'String[]'>
    readonly currentWeight: FieldRef<"Client", 'Float'>
    readonly targetWeight: FieldRef<"Client", 'Float'>
    readonly height: FieldRef<"Client", 'Float'>
    readonly bodyMeasurements: FieldRef<"Client", 'Json'>
    readonly bodyFatPercent: FieldRef<"Client", 'Float'>
    readonly fitnessLevel: FieldRef<"Client", 'String'>
    readonly injuryHistory: FieldRef<"Client", 'String'>
    readonly dietaryNotes: FieldRef<"Client", 'String'>
    readonly medicalNotes: FieldRef<"Client", 'String'>
    readonly creditsRemaining: FieldRef<"Client", 'Int'>
    readonly membershipType: FieldRef<"Client", 'String'>
    readonly membershipExpiry: FieldRef<"Client", 'DateTime'>
    readonly status: FieldRef<"Client", 'String'>
    readonly tags: FieldRef<"Client", 'String[]'>
    readonly notes: FieldRef<"Client", 'String'>
    readonly createdAt: FieldRef<"Client", 'DateTime'>
    readonly updatedAt: FieldRef<"Client", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Client findUnique
   */
  export type ClientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findUniqueOrThrow
   */
  export type ClientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findFirst
   */
  export type ClientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findFirstOrThrow
   */
  export type ClientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findMany
   */
  export type ClientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Clients to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client create
   */
  export type ClientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to create a Client.
     */
    data: XOR<ClientCreateInput, ClientUncheckedCreateInput>
  }

  /**
   * Client createMany
   */
  export type ClientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Client createManyAndReturn
   */
  export type ClientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Client update
   */
  export type ClientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to update a Client.
     */
    data: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
    /**
     * Choose, which Client to update.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client updateMany
   */
  export type ClientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>
    /**
     * Filter which Clients to update
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to update.
     */
    limit?: number
  }

  /**
   * Client updateManyAndReturn
   */
  export type ClientUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>
    /**
     * Filter which Clients to update
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Client upsert
   */
  export type ClientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The filter to search for the Client to update in case it exists.
     */
    where: ClientWhereUniqueInput
    /**
     * In case the Client found by the `where` argument doesn't exist, create a new Client with this data.
     */
    create: XOR<ClientCreateInput, ClientUncheckedCreateInput>
    /**
     * In case the Client was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
  }

  /**
   * Client delete
   */
  export type ClientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter which Client to delete.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client deleteMany
   */
  export type ClientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clients to delete
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to delete.
     */
    limit?: number
  }

  /**
   * Client.sessions
   */
  export type Client$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Client.orders
   */
  export type Client$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Client.invoices
   */
  export type Client$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Client.measurements
   */
  export type Client$measurementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientMeasurement
     */
    select?: ClientMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientMeasurement
     */
    omit?: ClientMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientMeasurementInclude<ExtArgs> | null
    where?: ClientMeasurementWhereInput
    orderBy?: ClientMeasurementOrderByWithRelationInput | ClientMeasurementOrderByWithRelationInput[]
    cursor?: ClientMeasurementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientMeasurementScalarFieldEnum | ClientMeasurementScalarFieldEnum[]
  }

  /**
   * Client.progressPhotos
   */
  export type Client$progressPhotosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressPhoto
     */
    select?: ProgressPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgressPhoto
     */
    omit?: ProgressPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressPhotoInclude<ExtArgs> | null
    where?: ProgressPhotoWhereInput
    orderBy?: ProgressPhotoOrderByWithRelationInput | ProgressPhotoOrderByWithRelationInput[]
    cursor?: ProgressPhotoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProgressPhotoScalarFieldEnum | ProgressPhotoScalarFieldEnum[]
  }

  /**
   * Client.badges
   */
  export type Client$badgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientBadge
     */
    select?: ClientBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientBadge
     */
    omit?: ClientBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientBadgeInclude<ExtArgs> | null
    where?: ClientBadgeWhereInput
    orderBy?: ClientBadgeOrderByWithRelationInput | ClientBadgeOrderByWithRelationInput[]
    cursor?: ClientBadgeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientBadgeScalarFieldEnum | ClientBadgeScalarFieldEnum[]
  }

  /**
   * Client without action
   */
  export type ClientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
  }


  /**
   * Model ClientMeasurement
   */

  export type AggregateClientMeasurement = {
    _count: ClientMeasurementCountAggregateOutputType | null
    _avg: ClientMeasurementAvgAggregateOutputType | null
    _sum: ClientMeasurementSumAggregateOutputType | null
    _min: ClientMeasurementMinAggregateOutputType | null
    _max: ClientMeasurementMaxAggregateOutputType | null
  }

  export type ClientMeasurementAvgAggregateOutputType = {
    weight: number | null
    bodyFat: number | null
  }

  export type ClientMeasurementSumAggregateOutputType = {
    weight: number | null
    bodyFat: number | null
  }

  export type ClientMeasurementMinAggregateOutputType = {
    id: string | null
    clientId: string | null
    date: Date | null
    weight: number | null
    bodyFat: number | null
    notes: string | null
    createdAt: Date | null
  }

  export type ClientMeasurementMaxAggregateOutputType = {
    id: string | null
    clientId: string | null
    date: Date | null
    weight: number | null
    bodyFat: number | null
    notes: string | null
    createdAt: Date | null
  }

  export type ClientMeasurementCountAggregateOutputType = {
    id: number
    clientId: number
    date: number
    weight: number
    bodyFat: number
    measurements: number
    notes: number
    createdAt: number
    _all: number
  }


  export type ClientMeasurementAvgAggregateInputType = {
    weight?: true
    bodyFat?: true
  }

  export type ClientMeasurementSumAggregateInputType = {
    weight?: true
    bodyFat?: true
  }

  export type ClientMeasurementMinAggregateInputType = {
    id?: true
    clientId?: true
    date?: true
    weight?: true
    bodyFat?: true
    notes?: true
    createdAt?: true
  }

  export type ClientMeasurementMaxAggregateInputType = {
    id?: true
    clientId?: true
    date?: true
    weight?: true
    bodyFat?: true
    notes?: true
    createdAt?: true
  }

  export type ClientMeasurementCountAggregateInputType = {
    id?: true
    clientId?: true
    date?: true
    weight?: true
    bodyFat?: true
    measurements?: true
    notes?: true
    createdAt?: true
    _all?: true
  }

  export type ClientMeasurementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientMeasurement to aggregate.
     */
    where?: ClientMeasurementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientMeasurements to fetch.
     */
    orderBy?: ClientMeasurementOrderByWithRelationInput | ClientMeasurementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientMeasurementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientMeasurements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientMeasurements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClientMeasurements
    **/
    _count?: true | ClientMeasurementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientMeasurementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientMeasurementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientMeasurementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientMeasurementMaxAggregateInputType
  }

  export type GetClientMeasurementAggregateType<T extends ClientMeasurementAggregateArgs> = {
        [P in keyof T & keyof AggregateClientMeasurement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientMeasurement[P]>
      : GetScalarType<T[P], AggregateClientMeasurement[P]>
  }




  export type ClientMeasurementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientMeasurementWhereInput
    orderBy?: ClientMeasurementOrderByWithAggregationInput | ClientMeasurementOrderByWithAggregationInput[]
    by: ClientMeasurementScalarFieldEnum[] | ClientMeasurementScalarFieldEnum
    having?: ClientMeasurementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientMeasurementCountAggregateInputType | true
    _avg?: ClientMeasurementAvgAggregateInputType
    _sum?: ClientMeasurementSumAggregateInputType
    _min?: ClientMeasurementMinAggregateInputType
    _max?: ClientMeasurementMaxAggregateInputType
  }

  export type ClientMeasurementGroupByOutputType = {
    id: string
    clientId: string
    date: Date
    weight: number | null
    bodyFat: number | null
    measurements: JsonValue | null
    notes: string | null
    createdAt: Date
    _count: ClientMeasurementCountAggregateOutputType | null
    _avg: ClientMeasurementAvgAggregateOutputType | null
    _sum: ClientMeasurementSumAggregateOutputType | null
    _min: ClientMeasurementMinAggregateOutputType | null
    _max: ClientMeasurementMaxAggregateOutputType | null
  }

  type GetClientMeasurementGroupByPayload<T extends ClientMeasurementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientMeasurementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientMeasurementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientMeasurementGroupByOutputType[P]>
            : GetScalarType<T[P], ClientMeasurementGroupByOutputType[P]>
        }
      >
    >


  export type ClientMeasurementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    date?: boolean
    weight?: boolean
    bodyFat?: boolean
    measurements?: boolean
    notes?: boolean
    createdAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientMeasurement"]>

  export type ClientMeasurementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    date?: boolean
    weight?: boolean
    bodyFat?: boolean
    measurements?: boolean
    notes?: boolean
    createdAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientMeasurement"]>

  export type ClientMeasurementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    date?: boolean
    weight?: boolean
    bodyFat?: boolean
    measurements?: boolean
    notes?: boolean
    createdAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientMeasurement"]>

  export type ClientMeasurementSelectScalar = {
    id?: boolean
    clientId?: boolean
    date?: boolean
    weight?: boolean
    bodyFat?: boolean
    measurements?: boolean
    notes?: boolean
    createdAt?: boolean
  }

  export type ClientMeasurementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clientId" | "date" | "weight" | "bodyFat" | "measurements" | "notes" | "createdAt", ExtArgs["result"]["clientMeasurement"]>
  export type ClientMeasurementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }
  export type ClientMeasurementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }
  export type ClientMeasurementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }

  export type $ClientMeasurementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClientMeasurement"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clientId: string
      date: Date
      weight: number | null
      bodyFat: number | null
      measurements: Prisma.JsonValue | null
      notes: string | null
      createdAt: Date
    }, ExtArgs["result"]["clientMeasurement"]>
    composites: {}
  }

  type ClientMeasurementGetPayload<S extends boolean | null | undefined | ClientMeasurementDefaultArgs> = $Result.GetResult<Prisma.$ClientMeasurementPayload, S>

  type ClientMeasurementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClientMeasurementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClientMeasurementCountAggregateInputType | true
    }

  export interface ClientMeasurementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClientMeasurement'], meta: { name: 'ClientMeasurement' } }
    /**
     * Find zero or one ClientMeasurement that matches the filter.
     * @param {ClientMeasurementFindUniqueArgs} args - Arguments to find a ClientMeasurement
     * @example
     * // Get one ClientMeasurement
     * const clientMeasurement = await prisma.clientMeasurement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientMeasurementFindUniqueArgs>(args: SelectSubset<T, ClientMeasurementFindUniqueArgs<ExtArgs>>): Prisma__ClientMeasurementClient<$Result.GetResult<Prisma.$ClientMeasurementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClientMeasurement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClientMeasurementFindUniqueOrThrowArgs} args - Arguments to find a ClientMeasurement
     * @example
     * // Get one ClientMeasurement
     * const clientMeasurement = await prisma.clientMeasurement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientMeasurementFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientMeasurementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientMeasurementClient<$Result.GetResult<Prisma.$ClientMeasurementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientMeasurement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientMeasurementFindFirstArgs} args - Arguments to find a ClientMeasurement
     * @example
     * // Get one ClientMeasurement
     * const clientMeasurement = await prisma.clientMeasurement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientMeasurementFindFirstArgs>(args?: SelectSubset<T, ClientMeasurementFindFirstArgs<ExtArgs>>): Prisma__ClientMeasurementClient<$Result.GetResult<Prisma.$ClientMeasurementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientMeasurement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientMeasurementFindFirstOrThrowArgs} args - Arguments to find a ClientMeasurement
     * @example
     * // Get one ClientMeasurement
     * const clientMeasurement = await prisma.clientMeasurement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientMeasurementFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientMeasurementFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientMeasurementClient<$Result.GetResult<Prisma.$ClientMeasurementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClientMeasurements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientMeasurementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClientMeasurements
     * const clientMeasurements = await prisma.clientMeasurement.findMany()
     * 
     * // Get first 10 ClientMeasurements
     * const clientMeasurements = await prisma.clientMeasurement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientMeasurementWithIdOnly = await prisma.clientMeasurement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientMeasurementFindManyArgs>(args?: SelectSubset<T, ClientMeasurementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientMeasurementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClientMeasurement.
     * @param {ClientMeasurementCreateArgs} args - Arguments to create a ClientMeasurement.
     * @example
     * // Create one ClientMeasurement
     * const ClientMeasurement = await prisma.clientMeasurement.create({
     *   data: {
     *     // ... data to create a ClientMeasurement
     *   }
     * })
     * 
     */
    create<T extends ClientMeasurementCreateArgs>(args: SelectSubset<T, ClientMeasurementCreateArgs<ExtArgs>>): Prisma__ClientMeasurementClient<$Result.GetResult<Prisma.$ClientMeasurementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClientMeasurements.
     * @param {ClientMeasurementCreateManyArgs} args - Arguments to create many ClientMeasurements.
     * @example
     * // Create many ClientMeasurements
     * const clientMeasurement = await prisma.clientMeasurement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientMeasurementCreateManyArgs>(args?: SelectSubset<T, ClientMeasurementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClientMeasurements and returns the data saved in the database.
     * @param {ClientMeasurementCreateManyAndReturnArgs} args - Arguments to create many ClientMeasurements.
     * @example
     * // Create many ClientMeasurements
     * const clientMeasurement = await prisma.clientMeasurement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClientMeasurements and only return the `id`
     * const clientMeasurementWithIdOnly = await prisma.clientMeasurement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClientMeasurementCreateManyAndReturnArgs>(args?: SelectSubset<T, ClientMeasurementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientMeasurementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ClientMeasurement.
     * @param {ClientMeasurementDeleteArgs} args - Arguments to delete one ClientMeasurement.
     * @example
     * // Delete one ClientMeasurement
     * const ClientMeasurement = await prisma.clientMeasurement.delete({
     *   where: {
     *     // ... filter to delete one ClientMeasurement
     *   }
     * })
     * 
     */
    delete<T extends ClientMeasurementDeleteArgs>(args: SelectSubset<T, ClientMeasurementDeleteArgs<ExtArgs>>): Prisma__ClientMeasurementClient<$Result.GetResult<Prisma.$ClientMeasurementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClientMeasurement.
     * @param {ClientMeasurementUpdateArgs} args - Arguments to update one ClientMeasurement.
     * @example
     * // Update one ClientMeasurement
     * const clientMeasurement = await prisma.clientMeasurement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientMeasurementUpdateArgs>(args: SelectSubset<T, ClientMeasurementUpdateArgs<ExtArgs>>): Prisma__ClientMeasurementClient<$Result.GetResult<Prisma.$ClientMeasurementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClientMeasurements.
     * @param {ClientMeasurementDeleteManyArgs} args - Arguments to filter ClientMeasurements to delete.
     * @example
     * // Delete a few ClientMeasurements
     * const { count } = await prisma.clientMeasurement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientMeasurementDeleteManyArgs>(args?: SelectSubset<T, ClientMeasurementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientMeasurements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientMeasurementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClientMeasurements
     * const clientMeasurement = await prisma.clientMeasurement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientMeasurementUpdateManyArgs>(args: SelectSubset<T, ClientMeasurementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientMeasurements and returns the data updated in the database.
     * @param {ClientMeasurementUpdateManyAndReturnArgs} args - Arguments to update many ClientMeasurements.
     * @example
     * // Update many ClientMeasurements
     * const clientMeasurement = await prisma.clientMeasurement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ClientMeasurements and only return the `id`
     * const clientMeasurementWithIdOnly = await prisma.clientMeasurement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClientMeasurementUpdateManyAndReturnArgs>(args: SelectSubset<T, ClientMeasurementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientMeasurementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ClientMeasurement.
     * @param {ClientMeasurementUpsertArgs} args - Arguments to update or create a ClientMeasurement.
     * @example
     * // Update or create a ClientMeasurement
     * const clientMeasurement = await prisma.clientMeasurement.upsert({
     *   create: {
     *     // ... data to create a ClientMeasurement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClientMeasurement we want to update
     *   }
     * })
     */
    upsert<T extends ClientMeasurementUpsertArgs>(args: SelectSubset<T, ClientMeasurementUpsertArgs<ExtArgs>>): Prisma__ClientMeasurementClient<$Result.GetResult<Prisma.$ClientMeasurementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClientMeasurements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientMeasurementCountArgs} args - Arguments to filter ClientMeasurements to count.
     * @example
     * // Count the number of ClientMeasurements
     * const count = await prisma.clientMeasurement.count({
     *   where: {
     *     // ... the filter for the ClientMeasurements we want to count
     *   }
     * })
    **/
    count<T extends ClientMeasurementCountArgs>(
      args?: Subset<T, ClientMeasurementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientMeasurementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClientMeasurement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientMeasurementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientMeasurementAggregateArgs>(args: Subset<T, ClientMeasurementAggregateArgs>): Prisma.PrismaPromise<GetClientMeasurementAggregateType<T>>

    /**
     * Group by ClientMeasurement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientMeasurementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientMeasurementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientMeasurementGroupByArgs['orderBy'] }
        : { orderBy?: ClientMeasurementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientMeasurementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientMeasurementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClientMeasurement model
   */
  readonly fields: ClientMeasurementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClientMeasurement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientMeasurementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClientMeasurement model
   */
  interface ClientMeasurementFieldRefs {
    readonly id: FieldRef<"ClientMeasurement", 'String'>
    readonly clientId: FieldRef<"ClientMeasurement", 'String'>
    readonly date: FieldRef<"ClientMeasurement", 'DateTime'>
    readonly weight: FieldRef<"ClientMeasurement", 'Float'>
    readonly bodyFat: FieldRef<"ClientMeasurement", 'Float'>
    readonly measurements: FieldRef<"ClientMeasurement", 'Json'>
    readonly notes: FieldRef<"ClientMeasurement", 'String'>
    readonly createdAt: FieldRef<"ClientMeasurement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClientMeasurement findUnique
   */
  export type ClientMeasurementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientMeasurement
     */
    select?: ClientMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientMeasurement
     */
    omit?: ClientMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientMeasurementInclude<ExtArgs> | null
    /**
     * Filter, which ClientMeasurement to fetch.
     */
    where: ClientMeasurementWhereUniqueInput
  }

  /**
   * ClientMeasurement findUniqueOrThrow
   */
  export type ClientMeasurementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientMeasurement
     */
    select?: ClientMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientMeasurement
     */
    omit?: ClientMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientMeasurementInclude<ExtArgs> | null
    /**
     * Filter, which ClientMeasurement to fetch.
     */
    where: ClientMeasurementWhereUniqueInput
  }

  /**
   * ClientMeasurement findFirst
   */
  export type ClientMeasurementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientMeasurement
     */
    select?: ClientMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientMeasurement
     */
    omit?: ClientMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientMeasurementInclude<ExtArgs> | null
    /**
     * Filter, which ClientMeasurement to fetch.
     */
    where?: ClientMeasurementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientMeasurements to fetch.
     */
    orderBy?: ClientMeasurementOrderByWithRelationInput | ClientMeasurementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientMeasurements.
     */
    cursor?: ClientMeasurementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientMeasurements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientMeasurements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientMeasurements.
     */
    distinct?: ClientMeasurementScalarFieldEnum | ClientMeasurementScalarFieldEnum[]
  }

  /**
   * ClientMeasurement findFirstOrThrow
   */
  export type ClientMeasurementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientMeasurement
     */
    select?: ClientMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientMeasurement
     */
    omit?: ClientMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientMeasurementInclude<ExtArgs> | null
    /**
     * Filter, which ClientMeasurement to fetch.
     */
    where?: ClientMeasurementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientMeasurements to fetch.
     */
    orderBy?: ClientMeasurementOrderByWithRelationInput | ClientMeasurementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientMeasurements.
     */
    cursor?: ClientMeasurementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientMeasurements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientMeasurements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientMeasurements.
     */
    distinct?: ClientMeasurementScalarFieldEnum | ClientMeasurementScalarFieldEnum[]
  }

  /**
   * ClientMeasurement findMany
   */
  export type ClientMeasurementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientMeasurement
     */
    select?: ClientMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientMeasurement
     */
    omit?: ClientMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientMeasurementInclude<ExtArgs> | null
    /**
     * Filter, which ClientMeasurements to fetch.
     */
    where?: ClientMeasurementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientMeasurements to fetch.
     */
    orderBy?: ClientMeasurementOrderByWithRelationInput | ClientMeasurementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClientMeasurements.
     */
    cursor?: ClientMeasurementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientMeasurements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientMeasurements.
     */
    skip?: number
    distinct?: ClientMeasurementScalarFieldEnum | ClientMeasurementScalarFieldEnum[]
  }

  /**
   * ClientMeasurement create
   */
  export type ClientMeasurementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientMeasurement
     */
    select?: ClientMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientMeasurement
     */
    omit?: ClientMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientMeasurementInclude<ExtArgs> | null
    /**
     * The data needed to create a ClientMeasurement.
     */
    data: XOR<ClientMeasurementCreateInput, ClientMeasurementUncheckedCreateInput>
  }

  /**
   * ClientMeasurement createMany
   */
  export type ClientMeasurementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClientMeasurements.
     */
    data: ClientMeasurementCreateManyInput | ClientMeasurementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClientMeasurement createManyAndReturn
   */
  export type ClientMeasurementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientMeasurement
     */
    select?: ClientMeasurementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClientMeasurement
     */
    omit?: ClientMeasurementOmit<ExtArgs> | null
    /**
     * The data used to create many ClientMeasurements.
     */
    data: ClientMeasurementCreateManyInput | ClientMeasurementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientMeasurementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClientMeasurement update
   */
  export type ClientMeasurementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientMeasurement
     */
    select?: ClientMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientMeasurement
     */
    omit?: ClientMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientMeasurementInclude<ExtArgs> | null
    /**
     * The data needed to update a ClientMeasurement.
     */
    data: XOR<ClientMeasurementUpdateInput, ClientMeasurementUncheckedUpdateInput>
    /**
     * Choose, which ClientMeasurement to update.
     */
    where: ClientMeasurementWhereUniqueInput
  }

  /**
   * ClientMeasurement updateMany
   */
  export type ClientMeasurementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClientMeasurements.
     */
    data: XOR<ClientMeasurementUpdateManyMutationInput, ClientMeasurementUncheckedUpdateManyInput>
    /**
     * Filter which ClientMeasurements to update
     */
    where?: ClientMeasurementWhereInput
    /**
     * Limit how many ClientMeasurements to update.
     */
    limit?: number
  }

  /**
   * ClientMeasurement updateManyAndReturn
   */
  export type ClientMeasurementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientMeasurement
     */
    select?: ClientMeasurementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClientMeasurement
     */
    omit?: ClientMeasurementOmit<ExtArgs> | null
    /**
     * The data used to update ClientMeasurements.
     */
    data: XOR<ClientMeasurementUpdateManyMutationInput, ClientMeasurementUncheckedUpdateManyInput>
    /**
     * Filter which ClientMeasurements to update
     */
    where?: ClientMeasurementWhereInput
    /**
     * Limit how many ClientMeasurements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientMeasurementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClientMeasurement upsert
   */
  export type ClientMeasurementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientMeasurement
     */
    select?: ClientMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientMeasurement
     */
    omit?: ClientMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientMeasurementInclude<ExtArgs> | null
    /**
     * The filter to search for the ClientMeasurement to update in case it exists.
     */
    where: ClientMeasurementWhereUniqueInput
    /**
     * In case the ClientMeasurement found by the `where` argument doesn't exist, create a new ClientMeasurement with this data.
     */
    create: XOR<ClientMeasurementCreateInput, ClientMeasurementUncheckedCreateInput>
    /**
     * In case the ClientMeasurement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientMeasurementUpdateInput, ClientMeasurementUncheckedUpdateInput>
  }

  /**
   * ClientMeasurement delete
   */
  export type ClientMeasurementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientMeasurement
     */
    select?: ClientMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientMeasurement
     */
    omit?: ClientMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientMeasurementInclude<ExtArgs> | null
    /**
     * Filter which ClientMeasurement to delete.
     */
    where: ClientMeasurementWhereUniqueInput
  }

  /**
   * ClientMeasurement deleteMany
   */
  export type ClientMeasurementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientMeasurements to delete
     */
    where?: ClientMeasurementWhereInput
    /**
     * Limit how many ClientMeasurements to delete.
     */
    limit?: number
  }

  /**
   * ClientMeasurement without action
   */
  export type ClientMeasurementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientMeasurement
     */
    select?: ClientMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientMeasurement
     */
    omit?: ClientMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientMeasurementInclude<ExtArgs> | null
  }


  /**
   * Model ProgressPhoto
   */

  export type AggregateProgressPhoto = {
    _count: ProgressPhotoCountAggregateOutputType | null
    _min: ProgressPhotoMinAggregateOutputType | null
    _max: ProgressPhotoMaxAggregateOutputType | null
  }

  export type ProgressPhotoMinAggregateOutputType = {
    id: string | null
    clientId: string | null
    url: string | null
    date: Date | null
    view: string | null
    notes: string | null
    createdAt: Date | null
  }

  export type ProgressPhotoMaxAggregateOutputType = {
    id: string | null
    clientId: string | null
    url: string | null
    date: Date | null
    view: string | null
    notes: string | null
    createdAt: Date | null
  }

  export type ProgressPhotoCountAggregateOutputType = {
    id: number
    clientId: number
    url: number
    date: number
    view: number
    notes: number
    createdAt: number
    _all: number
  }


  export type ProgressPhotoMinAggregateInputType = {
    id?: true
    clientId?: true
    url?: true
    date?: true
    view?: true
    notes?: true
    createdAt?: true
  }

  export type ProgressPhotoMaxAggregateInputType = {
    id?: true
    clientId?: true
    url?: true
    date?: true
    view?: true
    notes?: true
    createdAt?: true
  }

  export type ProgressPhotoCountAggregateInputType = {
    id?: true
    clientId?: true
    url?: true
    date?: true
    view?: true
    notes?: true
    createdAt?: true
    _all?: true
  }

  export type ProgressPhotoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProgressPhoto to aggregate.
     */
    where?: ProgressPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgressPhotos to fetch.
     */
    orderBy?: ProgressPhotoOrderByWithRelationInput | ProgressPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProgressPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgressPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgressPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProgressPhotos
    **/
    _count?: true | ProgressPhotoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProgressPhotoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProgressPhotoMaxAggregateInputType
  }

  export type GetProgressPhotoAggregateType<T extends ProgressPhotoAggregateArgs> = {
        [P in keyof T & keyof AggregateProgressPhoto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProgressPhoto[P]>
      : GetScalarType<T[P], AggregateProgressPhoto[P]>
  }




  export type ProgressPhotoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgressPhotoWhereInput
    orderBy?: ProgressPhotoOrderByWithAggregationInput | ProgressPhotoOrderByWithAggregationInput[]
    by: ProgressPhotoScalarFieldEnum[] | ProgressPhotoScalarFieldEnum
    having?: ProgressPhotoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProgressPhotoCountAggregateInputType | true
    _min?: ProgressPhotoMinAggregateInputType
    _max?: ProgressPhotoMaxAggregateInputType
  }

  export type ProgressPhotoGroupByOutputType = {
    id: string
    clientId: string
    url: string
    date: Date
    view: string
    notes: string | null
    createdAt: Date
    _count: ProgressPhotoCountAggregateOutputType | null
    _min: ProgressPhotoMinAggregateOutputType | null
    _max: ProgressPhotoMaxAggregateOutputType | null
  }

  type GetProgressPhotoGroupByPayload<T extends ProgressPhotoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProgressPhotoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProgressPhotoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProgressPhotoGroupByOutputType[P]>
            : GetScalarType<T[P], ProgressPhotoGroupByOutputType[P]>
        }
      >
    >


  export type ProgressPhotoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    url?: boolean
    date?: boolean
    view?: boolean
    notes?: boolean
    createdAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["progressPhoto"]>

  export type ProgressPhotoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    url?: boolean
    date?: boolean
    view?: boolean
    notes?: boolean
    createdAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["progressPhoto"]>

  export type ProgressPhotoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    url?: boolean
    date?: boolean
    view?: boolean
    notes?: boolean
    createdAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["progressPhoto"]>

  export type ProgressPhotoSelectScalar = {
    id?: boolean
    clientId?: boolean
    url?: boolean
    date?: boolean
    view?: boolean
    notes?: boolean
    createdAt?: boolean
  }

  export type ProgressPhotoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clientId" | "url" | "date" | "view" | "notes" | "createdAt", ExtArgs["result"]["progressPhoto"]>
  export type ProgressPhotoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }
  export type ProgressPhotoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }
  export type ProgressPhotoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }

  export type $ProgressPhotoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProgressPhoto"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clientId: string
      url: string
      date: Date
      view: string
      notes: string | null
      createdAt: Date
    }, ExtArgs["result"]["progressPhoto"]>
    composites: {}
  }

  type ProgressPhotoGetPayload<S extends boolean | null | undefined | ProgressPhotoDefaultArgs> = $Result.GetResult<Prisma.$ProgressPhotoPayload, S>

  type ProgressPhotoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProgressPhotoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProgressPhotoCountAggregateInputType | true
    }

  export interface ProgressPhotoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProgressPhoto'], meta: { name: 'ProgressPhoto' } }
    /**
     * Find zero or one ProgressPhoto that matches the filter.
     * @param {ProgressPhotoFindUniqueArgs} args - Arguments to find a ProgressPhoto
     * @example
     * // Get one ProgressPhoto
     * const progressPhoto = await prisma.progressPhoto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProgressPhotoFindUniqueArgs>(args: SelectSubset<T, ProgressPhotoFindUniqueArgs<ExtArgs>>): Prisma__ProgressPhotoClient<$Result.GetResult<Prisma.$ProgressPhotoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProgressPhoto that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProgressPhotoFindUniqueOrThrowArgs} args - Arguments to find a ProgressPhoto
     * @example
     * // Get one ProgressPhoto
     * const progressPhoto = await prisma.progressPhoto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProgressPhotoFindUniqueOrThrowArgs>(args: SelectSubset<T, ProgressPhotoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProgressPhotoClient<$Result.GetResult<Prisma.$ProgressPhotoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProgressPhoto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgressPhotoFindFirstArgs} args - Arguments to find a ProgressPhoto
     * @example
     * // Get one ProgressPhoto
     * const progressPhoto = await prisma.progressPhoto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProgressPhotoFindFirstArgs>(args?: SelectSubset<T, ProgressPhotoFindFirstArgs<ExtArgs>>): Prisma__ProgressPhotoClient<$Result.GetResult<Prisma.$ProgressPhotoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProgressPhoto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgressPhotoFindFirstOrThrowArgs} args - Arguments to find a ProgressPhoto
     * @example
     * // Get one ProgressPhoto
     * const progressPhoto = await prisma.progressPhoto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProgressPhotoFindFirstOrThrowArgs>(args?: SelectSubset<T, ProgressPhotoFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProgressPhotoClient<$Result.GetResult<Prisma.$ProgressPhotoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProgressPhotos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgressPhotoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProgressPhotos
     * const progressPhotos = await prisma.progressPhoto.findMany()
     * 
     * // Get first 10 ProgressPhotos
     * const progressPhotos = await prisma.progressPhoto.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const progressPhotoWithIdOnly = await prisma.progressPhoto.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProgressPhotoFindManyArgs>(args?: SelectSubset<T, ProgressPhotoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgressPhotoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProgressPhoto.
     * @param {ProgressPhotoCreateArgs} args - Arguments to create a ProgressPhoto.
     * @example
     * // Create one ProgressPhoto
     * const ProgressPhoto = await prisma.progressPhoto.create({
     *   data: {
     *     // ... data to create a ProgressPhoto
     *   }
     * })
     * 
     */
    create<T extends ProgressPhotoCreateArgs>(args: SelectSubset<T, ProgressPhotoCreateArgs<ExtArgs>>): Prisma__ProgressPhotoClient<$Result.GetResult<Prisma.$ProgressPhotoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProgressPhotos.
     * @param {ProgressPhotoCreateManyArgs} args - Arguments to create many ProgressPhotos.
     * @example
     * // Create many ProgressPhotos
     * const progressPhoto = await prisma.progressPhoto.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProgressPhotoCreateManyArgs>(args?: SelectSubset<T, ProgressPhotoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProgressPhotos and returns the data saved in the database.
     * @param {ProgressPhotoCreateManyAndReturnArgs} args - Arguments to create many ProgressPhotos.
     * @example
     * // Create many ProgressPhotos
     * const progressPhoto = await prisma.progressPhoto.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProgressPhotos and only return the `id`
     * const progressPhotoWithIdOnly = await prisma.progressPhoto.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProgressPhotoCreateManyAndReturnArgs>(args?: SelectSubset<T, ProgressPhotoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgressPhotoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProgressPhoto.
     * @param {ProgressPhotoDeleteArgs} args - Arguments to delete one ProgressPhoto.
     * @example
     * // Delete one ProgressPhoto
     * const ProgressPhoto = await prisma.progressPhoto.delete({
     *   where: {
     *     // ... filter to delete one ProgressPhoto
     *   }
     * })
     * 
     */
    delete<T extends ProgressPhotoDeleteArgs>(args: SelectSubset<T, ProgressPhotoDeleteArgs<ExtArgs>>): Prisma__ProgressPhotoClient<$Result.GetResult<Prisma.$ProgressPhotoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProgressPhoto.
     * @param {ProgressPhotoUpdateArgs} args - Arguments to update one ProgressPhoto.
     * @example
     * // Update one ProgressPhoto
     * const progressPhoto = await prisma.progressPhoto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProgressPhotoUpdateArgs>(args: SelectSubset<T, ProgressPhotoUpdateArgs<ExtArgs>>): Prisma__ProgressPhotoClient<$Result.GetResult<Prisma.$ProgressPhotoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProgressPhotos.
     * @param {ProgressPhotoDeleteManyArgs} args - Arguments to filter ProgressPhotos to delete.
     * @example
     * // Delete a few ProgressPhotos
     * const { count } = await prisma.progressPhoto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProgressPhotoDeleteManyArgs>(args?: SelectSubset<T, ProgressPhotoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProgressPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgressPhotoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProgressPhotos
     * const progressPhoto = await prisma.progressPhoto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProgressPhotoUpdateManyArgs>(args: SelectSubset<T, ProgressPhotoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProgressPhotos and returns the data updated in the database.
     * @param {ProgressPhotoUpdateManyAndReturnArgs} args - Arguments to update many ProgressPhotos.
     * @example
     * // Update many ProgressPhotos
     * const progressPhoto = await prisma.progressPhoto.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProgressPhotos and only return the `id`
     * const progressPhotoWithIdOnly = await prisma.progressPhoto.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProgressPhotoUpdateManyAndReturnArgs>(args: SelectSubset<T, ProgressPhotoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgressPhotoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProgressPhoto.
     * @param {ProgressPhotoUpsertArgs} args - Arguments to update or create a ProgressPhoto.
     * @example
     * // Update or create a ProgressPhoto
     * const progressPhoto = await prisma.progressPhoto.upsert({
     *   create: {
     *     // ... data to create a ProgressPhoto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProgressPhoto we want to update
     *   }
     * })
     */
    upsert<T extends ProgressPhotoUpsertArgs>(args: SelectSubset<T, ProgressPhotoUpsertArgs<ExtArgs>>): Prisma__ProgressPhotoClient<$Result.GetResult<Prisma.$ProgressPhotoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProgressPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgressPhotoCountArgs} args - Arguments to filter ProgressPhotos to count.
     * @example
     * // Count the number of ProgressPhotos
     * const count = await prisma.progressPhoto.count({
     *   where: {
     *     // ... the filter for the ProgressPhotos we want to count
     *   }
     * })
    **/
    count<T extends ProgressPhotoCountArgs>(
      args?: Subset<T, ProgressPhotoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProgressPhotoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProgressPhoto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgressPhotoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProgressPhotoAggregateArgs>(args: Subset<T, ProgressPhotoAggregateArgs>): Prisma.PrismaPromise<GetProgressPhotoAggregateType<T>>

    /**
     * Group by ProgressPhoto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgressPhotoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProgressPhotoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProgressPhotoGroupByArgs['orderBy'] }
        : { orderBy?: ProgressPhotoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProgressPhotoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProgressPhotoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProgressPhoto model
   */
  readonly fields: ProgressPhotoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProgressPhoto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProgressPhotoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProgressPhoto model
   */
  interface ProgressPhotoFieldRefs {
    readonly id: FieldRef<"ProgressPhoto", 'String'>
    readonly clientId: FieldRef<"ProgressPhoto", 'String'>
    readonly url: FieldRef<"ProgressPhoto", 'String'>
    readonly date: FieldRef<"ProgressPhoto", 'DateTime'>
    readonly view: FieldRef<"ProgressPhoto", 'String'>
    readonly notes: FieldRef<"ProgressPhoto", 'String'>
    readonly createdAt: FieldRef<"ProgressPhoto", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProgressPhoto findUnique
   */
  export type ProgressPhotoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressPhoto
     */
    select?: ProgressPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgressPhoto
     */
    omit?: ProgressPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressPhotoInclude<ExtArgs> | null
    /**
     * Filter, which ProgressPhoto to fetch.
     */
    where: ProgressPhotoWhereUniqueInput
  }

  /**
   * ProgressPhoto findUniqueOrThrow
   */
  export type ProgressPhotoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressPhoto
     */
    select?: ProgressPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgressPhoto
     */
    omit?: ProgressPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressPhotoInclude<ExtArgs> | null
    /**
     * Filter, which ProgressPhoto to fetch.
     */
    where: ProgressPhotoWhereUniqueInput
  }

  /**
   * ProgressPhoto findFirst
   */
  export type ProgressPhotoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressPhoto
     */
    select?: ProgressPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgressPhoto
     */
    omit?: ProgressPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressPhotoInclude<ExtArgs> | null
    /**
     * Filter, which ProgressPhoto to fetch.
     */
    where?: ProgressPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgressPhotos to fetch.
     */
    orderBy?: ProgressPhotoOrderByWithRelationInput | ProgressPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProgressPhotos.
     */
    cursor?: ProgressPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgressPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgressPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProgressPhotos.
     */
    distinct?: ProgressPhotoScalarFieldEnum | ProgressPhotoScalarFieldEnum[]
  }

  /**
   * ProgressPhoto findFirstOrThrow
   */
  export type ProgressPhotoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressPhoto
     */
    select?: ProgressPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgressPhoto
     */
    omit?: ProgressPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressPhotoInclude<ExtArgs> | null
    /**
     * Filter, which ProgressPhoto to fetch.
     */
    where?: ProgressPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgressPhotos to fetch.
     */
    orderBy?: ProgressPhotoOrderByWithRelationInput | ProgressPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProgressPhotos.
     */
    cursor?: ProgressPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgressPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgressPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProgressPhotos.
     */
    distinct?: ProgressPhotoScalarFieldEnum | ProgressPhotoScalarFieldEnum[]
  }

  /**
   * ProgressPhoto findMany
   */
  export type ProgressPhotoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressPhoto
     */
    select?: ProgressPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgressPhoto
     */
    omit?: ProgressPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressPhotoInclude<ExtArgs> | null
    /**
     * Filter, which ProgressPhotos to fetch.
     */
    where?: ProgressPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgressPhotos to fetch.
     */
    orderBy?: ProgressPhotoOrderByWithRelationInput | ProgressPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProgressPhotos.
     */
    cursor?: ProgressPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgressPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgressPhotos.
     */
    skip?: number
    distinct?: ProgressPhotoScalarFieldEnum | ProgressPhotoScalarFieldEnum[]
  }

  /**
   * ProgressPhoto create
   */
  export type ProgressPhotoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressPhoto
     */
    select?: ProgressPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgressPhoto
     */
    omit?: ProgressPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressPhotoInclude<ExtArgs> | null
    /**
     * The data needed to create a ProgressPhoto.
     */
    data: XOR<ProgressPhotoCreateInput, ProgressPhotoUncheckedCreateInput>
  }

  /**
   * ProgressPhoto createMany
   */
  export type ProgressPhotoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProgressPhotos.
     */
    data: ProgressPhotoCreateManyInput | ProgressPhotoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProgressPhoto createManyAndReturn
   */
  export type ProgressPhotoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressPhoto
     */
    select?: ProgressPhotoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProgressPhoto
     */
    omit?: ProgressPhotoOmit<ExtArgs> | null
    /**
     * The data used to create many ProgressPhotos.
     */
    data: ProgressPhotoCreateManyInput | ProgressPhotoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressPhotoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProgressPhoto update
   */
  export type ProgressPhotoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressPhoto
     */
    select?: ProgressPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgressPhoto
     */
    omit?: ProgressPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressPhotoInclude<ExtArgs> | null
    /**
     * The data needed to update a ProgressPhoto.
     */
    data: XOR<ProgressPhotoUpdateInput, ProgressPhotoUncheckedUpdateInput>
    /**
     * Choose, which ProgressPhoto to update.
     */
    where: ProgressPhotoWhereUniqueInput
  }

  /**
   * ProgressPhoto updateMany
   */
  export type ProgressPhotoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProgressPhotos.
     */
    data: XOR<ProgressPhotoUpdateManyMutationInput, ProgressPhotoUncheckedUpdateManyInput>
    /**
     * Filter which ProgressPhotos to update
     */
    where?: ProgressPhotoWhereInput
    /**
     * Limit how many ProgressPhotos to update.
     */
    limit?: number
  }

  /**
   * ProgressPhoto updateManyAndReturn
   */
  export type ProgressPhotoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressPhoto
     */
    select?: ProgressPhotoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProgressPhoto
     */
    omit?: ProgressPhotoOmit<ExtArgs> | null
    /**
     * The data used to update ProgressPhotos.
     */
    data: XOR<ProgressPhotoUpdateManyMutationInput, ProgressPhotoUncheckedUpdateManyInput>
    /**
     * Filter which ProgressPhotos to update
     */
    where?: ProgressPhotoWhereInput
    /**
     * Limit how many ProgressPhotos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressPhotoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProgressPhoto upsert
   */
  export type ProgressPhotoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressPhoto
     */
    select?: ProgressPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgressPhoto
     */
    omit?: ProgressPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressPhotoInclude<ExtArgs> | null
    /**
     * The filter to search for the ProgressPhoto to update in case it exists.
     */
    where: ProgressPhotoWhereUniqueInput
    /**
     * In case the ProgressPhoto found by the `where` argument doesn't exist, create a new ProgressPhoto with this data.
     */
    create: XOR<ProgressPhotoCreateInput, ProgressPhotoUncheckedCreateInput>
    /**
     * In case the ProgressPhoto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProgressPhotoUpdateInput, ProgressPhotoUncheckedUpdateInput>
  }

  /**
   * ProgressPhoto delete
   */
  export type ProgressPhotoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressPhoto
     */
    select?: ProgressPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgressPhoto
     */
    omit?: ProgressPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressPhotoInclude<ExtArgs> | null
    /**
     * Filter which ProgressPhoto to delete.
     */
    where: ProgressPhotoWhereUniqueInput
  }

  /**
   * ProgressPhoto deleteMany
   */
  export type ProgressPhotoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProgressPhotos to delete
     */
    where?: ProgressPhotoWhereInput
    /**
     * Limit how many ProgressPhotos to delete.
     */
    limit?: number
  }

  /**
   * ProgressPhoto without action
   */
  export type ProgressPhotoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressPhoto
     */
    select?: ProgressPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgressPhoto
     */
    omit?: ProgressPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressPhotoInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _avg: SessionAvgAggregateOutputType | null
    _sum: SessionSumAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionAvgAggregateOutputType = {
    duration: number | null
    caloriesBurned: number | null
    heartRateAvg: number | null
    clientRating: number | null
    price: number | null
  }

  export type SessionSumAggregateOutputType = {
    duration: number | null
    caloriesBurned: number | null
    heartRateAvg: number | null
    clientRating: number | null
    price: number | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    clientId: string | null
    scheduledAt: Date | null
    duration: number | null
    status: string | null
    caloriesBurned: number | null
    heartRateAvg: number | null
    clientFeedback: string | null
    trainerNotes: string | null
    intensity: string | null
    clientRating: number | null
    price: number | null
    paid: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    clientId: string | null
    scheduledAt: Date | null
    duration: number | null
    status: string | null
    caloriesBurned: number | null
    heartRateAvg: number | null
    clientFeedback: string | null
    trainerNotes: string | null
    intensity: string | null
    clientRating: number | null
    price: number | null
    paid: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    tenantId: number
    clientId: number
    scheduledAt: number
    duration: number
    status: number
    workoutPlan: number
    exercisesLogged: number
    caloriesBurned: number
    heartRateAvg: number
    muscleGroups: number
    clientFeedback: number
    trainerNotes: number
    intensity: number
    clientRating: number
    price: number
    paid: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SessionAvgAggregateInputType = {
    duration?: true
    caloriesBurned?: true
    heartRateAvg?: true
    clientRating?: true
    price?: true
  }

  export type SessionSumAggregateInputType = {
    duration?: true
    caloriesBurned?: true
    heartRateAvg?: true
    clientRating?: true
    price?: true
  }

  export type SessionMinAggregateInputType = {
    id?: true
    tenantId?: true
    clientId?: true
    scheduledAt?: true
    duration?: true
    status?: true
    caloriesBurned?: true
    heartRateAvg?: true
    clientFeedback?: true
    trainerNotes?: true
    intensity?: true
    clientRating?: true
    price?: true
    paid?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    tenantId?: true
    clientId?: true
    scheduledAt?: true
    duration?: true
    status?: true
    caloriesBurned?: true
    heartRateAvg?: true
    clientFeedback?: true
    trainerNotes?: true
    intensity?: true
    clientRating?: true
    price?: true
    paid?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    tenantId?: true
    clientId?: true
    scheduledAt?: true
    duration?: true
    status?: true
    workoutPlan?: true
    exercisesLogged?: true
    caloriesBurned?: true
    heartRateAvg?: true
    muscleGroups?: true
    clientFeedback?: true
    trainerNotes?: true
    intensity?: true
    clientRating?: true
    price?: true
    paid?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _avg?: SessionAvgAggregateInputType
    _sum?: SessionSumAggregateInputType
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    tenantId: string
    clientId: string
    scheduledAt: Date
    duration: number
    status: string
    workoutPlan: JsonValue | null
    exercisesLogged: JsonValue[]
    caloriesBurned: number | null
    heartRateAvg: number | null
    muscleGroups: string[]
    clientFeedback: string | null
    trainerNotes: string | null
    intensity: string | null
    clientRating: number | null
    price: number | null
    paid: boolean
    createdAt: Date
    updatedAt: Date
    _count: SessionCountAggregateOutputType | null
    _avg: SessionAvgAggregateOutputType | null
    _sum: SessionSumAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    clientId?: boolean
    scheduledAt?: boolean
    duration?: boolean
    status?: boolean
    workoutPlan?: boolean
    exercisesLogged?: boolean
    caloriesBurned?: boolean
    heartRateAvg?: boolean
    muscleGroups?: boolean
    clientFeedback?: boolean
    trainerNotes?: boolean
    intensity?: boolean
    clientRating?: boolean
    price?: boolean
    paid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    clientId?: boolean
    scheduledAt?: boolean
    duration?: boolean
    status?: boolean
    workoutPlan?: boolean
    exercisesLogged?: boolean
    caloriesBurned?: boolean
    heartRateAvg?: boolean
    muscleGroups?: boolean
    clientFeedback?: boolean
    trainerNotes?: boolean
    intensity?: boolean
    clientRating?: boolean
    price?: boolean
    paid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    clientId?: boolean
    scheduledAt?: boolean
    duration?: boolean
    status?: boolean
    workoutPlan?: boolean
    exercisesLogged?: boolean
    caloriesBurned?: boolean
    heartRateAvg?: boolean
    muscleGroups?: boolean
    clientFeedback?: boolean
    trainerNotes?: boolean
    intensity?: boolean
    clientRating?: boolean
    price?: boolean
    paid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    tenantId?: boolean
    clientId?: boolean
    scheduledAt?: boolean
    duration?: boolean
    status?: boolean
    workoutPlan?: boolean
    exercisesLogged?: boolean
    caloriesBurned?: boolean
    heartRateAvg?: boolean
    muscleGroups?: boolean
    clientFeedback?: boolean
    trainerNotes?: boolean
    intensity?: boolean
    clientRating?: boolean
    price?: boolean
    paid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "clientId" | "scheduledAt" | "duration" | "status" | "workoutPlan" | "exercisesLogged" | "caloriesBurned" | "heartRateAvg" | "muscleGroups" | "clientFeedback" | "trainerNotes" | "intensity" | "clientRating" | "price" | "paid" | "createdAt" | "updatedAt", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      client: Prisma.$ClientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      clientId: string
      scheduledAt: Date
      duration: number
      status: string
      workoutPlan: Prisma.JsonValue | null
      exercisesLogged: Prisma.JsonValue[]
      caloriesBurned: number | null
      heartRateAvg: number | null
      muscleGroups: string[]
      clientFeedback: string | null
      trainerNotes: string | null
      intensity: string | null
      clientRating: number | null
      price: number | null
      paid: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly tenantId: FieldRef<"Session", 'String'>
    readonly clientId: FieldRef<"Session", 'String'>
    readonly scheduledAt: FieldRef<"Session", 'DateTime'>
    readonly duration: FieldRef<"Session", 'Int'>
    readonly status: FieldRef<"Session", 'String'>
    readonly workoutPlan: FieldRef<"Session", 'Json'>
    readonly exercisesLogged: FieldRef<"Session", 'Json[]'>
    readonly caloriesBurned: FieldRef<"Session", 'Int'>
    readonly heartRateAvg: FieldRef<"Session", 'Int'>
    readonly muscleGroups: FieldRef<"Session", 'String[]'>
    readonly clientFeedback: FieldRef<"Session", 'String'>
    readonly trainerNotes: FieldRef<"Session", 'String'>
    readonly intensity: FieldRef<"Session", 'String'>
    readonly clientRating: FieldRef<"Session", 'Int'>
    readonly price: FieldRef<"Session", 'Float'>
    readonly paid: FieldRef<"Session", 'Boolean'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly updatedAt: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model Class
   */

  export type AggregateClass = {
    _count: ClassCountAggregateOutputType | null
    _avg: ClassAvgAggregateOutputType | null
    _sum: ClassSumAggregateOutputType | null
    _min: ClassMinAggregateOutputType | null
    _max: ClassMaxAggregateOutputType | null
  }

  export type ClassAvgAggregateOutputType = {
    duration: number | null
    capacity: number | null
    price: number | null
  }

  export type ClassSumAggregateOutputType = {
    duration: number | null
    capacity: number | null
    price: number | null
  }

  export type ClassMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    description: string | null
    type: string | null
    scheduledAt: Date | null
    duration: number | null
    capacity: number | null
    instructor: string | null
    location: string | null
    price: number | null
    isRecurring: boolean | null
    recurrence: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClassMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    description: string | null
    type: string | null
    scheduledAt: Date | null
    duration: number | null
    capacity: number | null
    instructor: string | null
    location: string | null
    price: number | null
    isRecurring: boolean | null
    recurrence: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClassCountAggregateOutputType = {
    id: number
    tenantId: number
    name: number
    description: number
    type: number
    scheduledAt: number
    duration: number
    capacity: number
    instructor: number
    location: number
    price: number
    isRecurring: number
    recurrence: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClassAvgAggregateInputType = {
    duration?: true
    capacity?: true
    price?: true
  }

  export type ClassSumAggregateInputType = {
    duration?: true
    capacity?: true
    price?: true
  }

  export type ClassMinAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    description?: true
    type?: true
    scheduledAt?: true
    duration?: true
    capacity?: true
    instructor?: true
    location?: true
    price?: true
    isRecurring?: true
    recurrence?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClassMaxAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    description?: true
    type?: true
    scheduledAt?: true
    duration?: true
    capacity?: true
    instructor?: true
    location?: true
    price?: true
    isRecurring?: true
    recurrence?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClassCountAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    description?: true
    type?: true
    scheduledAt?: true
    duration?: true
    capacity?: true
    instructor?: true
    location?: true
    price?: true
    isRecurring?: true
    recurrence?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClassAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Class to aggregate.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Classes
    **/
    _count?: true | ClassCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClassAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClassSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassMaxAggregateInputType
  }

  export type GetClassAggregateType<T extends ClassAggregateArgs> = {
        [P in keyof T & keyof AggregateClass]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClass[P]>
      : GetScalarType<T[P], AggregateClass[P]>
  }




  export type ClassGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassWhereInput
    orderBy?: ClassOrderByWithAggregationInput | ClassOrderByWithAggregationInput[]
    by: ClassScalarFieldEnum[] | ClassScalarFieldEnum
    having?: ClassScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassCountAggregateInputType | true
    _avg?: ClassAvgAggregateInputType
    _sum?: ClassSumAggregateInputType
    _min?: ClassMinAggregateInputType
    _max?: ClassMaxAggregateInputType
  }

  export type ClassGroupByOutputType = {
    id: string
    tenantId: string
    name: string
    description: string | null
    type: string
    scheduledAt: Date
    duration: number
    capacity: number
    instructor: string | null
    location: string | null
    price: number
    isRecurring: boolean
    recurrence: string | null
    status: string
    createdAt: Date
    updatedAt: Date
    _count: ClassCountAggregateOutputType | null
    _avg: ClassAvgAggregateOutputType | null
    _sum: ClassSumAggregateOutputType | null
    _min: ClassMinAggregateOutputType | null
    _max: ClassMaxAggregateOutputType | null
  }

  type GetClassGroupByPayload<T extends ClassGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClassGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassGroupByOutputType[P]>
            : GetScalarType<T[P], ClassGroupByOutputType[P]>
        }
      >
    >


  export type ClassSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    scheduledAt?: boolean
    duration?: boolean
    capacity?: boolean
    instructor?: boolean
    location?: boolean
    price?: boolean
    isRecurring?: boolean
    recurrence?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    bookings?: boolean | Class$bookingsArgs<ExtArgs>
    _count?: boolean | ClassCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["class"]>

  export type ClassSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    scheduledAt?: boolean
    duration?: boolean
    capacity?: boolean
    instructor?: boolean
    location?: boolean
    price?: boolean
    isRecurring?: boolean
    recurrence?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["class"]>

  export type ClassSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    scheduledAt?: boolean
    duration?: boolean
    capacity?: boolean
    instructor?: boolean
    location?: boolean
    price?: boolean
    isRecurring?: boolean
    recurrence?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["class"]>

  export type ClassSelectScalar = {
    id?: boolean
    tenantId?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    scheduledAt?: boolean
    duration?: boolean
    capacity?: boolean
    instructor?: boolean
    location?: boolean
    price?: boolean
    isRecurring?: boolean
    recurrence?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClassOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "name" | "description" | "type" | "scheduledAt" | "duration" | "capacity" | "instructor" | "location" | "price" | "isRecurring" | "recurrence" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["class"]>
  export type ClassInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    bookings?: boolean | Class$bookingsArgs<ExtArgs>
    _count?: boolean | ClassCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClassIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type ClassIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $ClassPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Class"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      bookings: Prisma.$ClassBookingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      name: string
      description: string | null
      type: string
      scheduledAt: Date
      duration: number
      capacity: number
      instructor: string | null
      location: string | null
      price: number
      isRecurring: boolean
      recurrence: string | null
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["class"]>
    composites: {}
  }

  type ClassGetPayload<S extends boolean | null | undefined | ClassDefaultArgs> = $Result.GetResult<Prisma.$ClassPayload, S>

  type ClassCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClassFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClassCountAggregateInputType | true
    }

  export interface ClassDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Class'], meta: { name: 'Class' } }
    /**
     * Find zero or one Class that matches the filter.
     * @param {ClassFindUniqueArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClassFindUniqueArgs>(args: SelectSubset<T, ClassFindUniqueArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Class that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClassFindUniqueOrThrowArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClassFindUniqueOrThrowArgs>(args: SelectSubset<T, ClassFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Class that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindFirstArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClassFindFirstArgs>(args?: SelectSubset<T, ClassFindFirstArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Class that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindFirstOrThrowArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClassFindFirstOrThrowArgs>(args?: SelectSubset<T, ClassFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Classes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Classes
     * const classes = await prisma.class.findMany()
     * 
     * // Get first 10 Classes
     * const classes = await prisma.class.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const classWithIdOnly = await prisma.class.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClassFindManyArgs>(args?: SelectSubset<T, ClassFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Class.
     * @param {ClassCreateArgs} args - Arguments to create a Class.
     * @example
     * // Create one Class
     * const Class = await prisma.class.create({
     *   data: {
     *     // ... data to create a Class
     *   }
     * })
     * 
     */
    create<T extends ClassCreateArgs>(args: SelectSubset<T, ClassCreateArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Classes.
     * @param {ClassCreateManyArgs} args - Arguments to create many Classes.
     * @example
     * // Create many Classes
     * const class = await prisma.class.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClassCreateManyArgs>(args?: SelectSubset<T, ClassCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Classes and returns the data saved in the database.
     * @param {ClassCreateManyAndReturnArgs} args - Arguments to create many Classes.
     * @example
     * // Create many Classes
     * const class = await prisma.class.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Classes and only return the `id`
     * const classWithIdOnly = await prisma.class.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClassCreateManyAndReturnArgs>(args?: SelectSubset<T, ClassCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Class.
     * @param {ClassDeleteArgs} args - Arguments to delete one Class.
     * @example
     * // Delete one Class
     * const Class = await prisma.class.delete({
     *   where: {
     *     // ... filter to delete one Class
     *   }
     * })
     * 
     */
    delete<T extends ClassDeleteArgs>(args: SelectSubset<T, ClassDeleteArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Class.
     * @param {ClassUpdateArgs} args - Arguments to update one Class.
     * @example
     * // Update one Class
     * const class = await prisma.class.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClassUpdateArgs>(args: SelectSubset<T, ClassUpdateArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Classes.
     * @param {ClassDeleteManyArgs} args - Arguments to filter Classes to delete.
     * @example
     * // Delete a few Classes
     * const { count } = await prisma.class.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClassDeleteManyArgs>(args?: SelectSubset<T, ClassDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Classes
     * const class = await prisma.class.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClassUpdateManyArgs>(args: SelectSubset<T, ClassUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Classes and returns the data updated in the database.
     * @param {ClassUpdateManyAndReturnArgs} args - Arguments to update many Classes.
     * @example
     * // Update many Classes
     * const class = await prisma.class.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Classes and only return the `id`
     * const classWithIdOnly = await prisma.class.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClassUpdateManyAndReturnArgs>(args: SelectSubset<T, ClassUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Class.
     * @param {ClassUpsertArgs} args - Arguments to update or create a Class.
     * @example
     * // Update or create a Class
     * const class = await prisma.class.upsert({
     *   create: {
     *     // ... data to create a Class
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Class we want to update
     *   }
     * })
     */
    upsert<T extends ClassUpsertArgs>(args: SelectSubset<T, ClassUpsertArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassCountArgs} args - Arguments to filter Classes to count.
     * @example
     * // Count the number of Classes
     * const count = await prisma.class.count({
     *   where: {
     *     // ... the filter for the Classes we want to count
     *   }
     * })
    **/
    count<T extends ClassCountArgs>(
      args?: Subset<T, ClassCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Class.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassAggregateArgs>(args: Subset<T, ClassAggregateArgs>): Prisma.PrismaPromise<GetClassAggregateType<T>>

    /**
     * Group by Class.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassGroupByArgs['orderBy'] }
        : { orderBy?: ClassGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Class model
   */
  readonly fields: ClassFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Class.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClassClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    bookings<T extends Class$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, Class$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassBookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Class model
   */
  interface ClassFieldRefs {
    readonly id: FieldRef<"Class", 'String'>
    readonly tenantId: FieldRef<"Class", 'String'>
    readonly name: FieldRef<"Class", 'String'>
    readonly description: FieldRef<"Class", 'String'>
    readonly type: FieldRef<"Class", 'String'>
    readonly scheduledAt: FieldRef<"Class", 'DateTime'>
    readonly duration: FieldRef<"Class", 'Int'>
    readonly capacity: FieldRef<"Class", 'Int'>
    readonly instructor: FieldRef<"Class", 'String'>
    readonly location: FieldRef<"Class", 'String'>
    readonly price: FieldRef<"Class", 'Float'>
    readonly isRecurring: FieldRef<"Class", 'Boolean'>
    readonly recurrence: FieldRef<"Class", 'String'>
    readonly status: FieldRef<"Class", 'String'>
    readonly createdAt: FieldRef<"Class", 'DateTime'>
    readonly updatedAt: FieldRef<"Class", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Class findUnique
   */
  export type ClassFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class findUniqueOrThrow
   */
  export type ClassFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class findFirst
   */
  export type ClassFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Classes.
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Classes.
     */
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Class findFirstOrThrow
   */
  export type ClassFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Classes.
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Classes.
     */
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Class findMany
   */
  export type ClassFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Classes to fetch.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Classes.
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Class create
   */
  export type ClassCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * The data needed to create a Class.
     */
    data: XOR<ClassCreateInput, ClassUncheckedCreateInput>
  }

  /**
   * Class createMany
   */
  export type ClassCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Classes.
     */
    data: ClassCreateManyInput | ClassCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Class createManyAndReturn
   */
  export type ClassCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * The data used to create many Classes.
     */
    data: ClassCreateManyInput | ClassCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Class update
   */
  export type ClassUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * The data needed to update a Class.
     */
    data: XOR<ClassUpdateInput, ClassUncheckedUpdateInput>
    /**
     * Choose, which Class to update.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class updateMany
   */
  export type ClassUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Classes.
     */
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyInput>
    /**
     * Filter which Classes to update
     */
    where?: ClassWhereInput
    /**
     * Limit how many Classes to update.
     */
    limit?: number
  }

  /**
   * Class updateManyAndReturn
   */
  export type ClassUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * The data used to update Classes.
     */
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyInput>
    /**
     * Filter which Classes to update
     */
    where?: ClassWhereInput
    /**
     * Limit how many Classes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Class upsert
   */
  export type ClassUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * The filter to search for the Class to update in case it exists.
     */
    where: ClassWhereUniqueInput
    /**
     * In case the Class found by the `where` argument doesn't exist, create a new Class with this data.
     */
    create: XOR<ClassCreateInput, ClassUncheckedCreateInput>
    /**
     * In case the Class was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassUpdateInput, ClassUncheckedUpdateInput>
  }

  /**
   * Class delete
   */
  export type ClassDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter which Class to delete.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class deleteMany
   */
  export type ClassDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Classes to delete
     */
    where?: ClassWhereInput
    /**
     * Limit how many Classes to delete.
     */
    limit?: number
  }

  /**
   * Class.bookings
   */
  export type Class$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassBooking
     */
    select?: ClassBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassBooking
     */
    omit?: ClassBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassBookingInclude<ExtArgs> | null
    where?: ClassBookingWhereInput
    orderBy?: ClassBookingOrderByWithRelationInput | ClassBookingOrderByWithRelationInput[]
    cursor?: ClassBookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassBookingScalarFieldEnum | ClassBookingScalarFieldEnum[]
  }

  /**
   * Class without action
   */
  export type ClassDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
  }


  /**
   * Model ClassBooking
   */

  export type AggregateClassBooking = {
    _count: ClassBookingCountAggregateOutputType | null
    _min: ClassBookingMinAggregateOutputType | null
    _max: ClassBookingMaxAggregateOutputType | null
  }

  export type ClassBookingMinAggregateOutputType = {
    id: string | null
    classId: string | null
    clientId: string | null
    status: string | null
    checkedIn: boolean | null
    paid: boolean | null
    createdAt: Date | null
  }

  export type ClassBookingMaxAggregateOutputType = {
    id: string | null
    classId: string | null
    clientId: string | null
    status: string | null
    checkedIn: boolean | null
    paid: boolean | null
    createdAt: Date | null
  }

  export type ClassBookingCountAggregateOutputType = {
    id: number
    classId: number
    clientId: number
    status: number
    checkedIn: number
    paid: number
    createdAt: number
    _all: number
  }


  export type ClassBookingMinAggregateInputType = {
    id?: true
    classId?: true
    clientId?: true
    status?: true
    checkedIn?: true
    paid?: true
    createdAt?: true
  }

  export type ClassBookingMaxAggregateInputType = {
    id?: true
    classId?: true
    clientId?: true
    status?: true
    checkedIn?: true
    paid?: true
    createdAt?: true
  }

  export type ClassBookingCountAggregateInputType = {
    id?: true
    classId?: true
    clientId?: true
    status?: true
    checkedIn?: true
    paid?: true
    createdAt?: true
    _all?: true
  }

  export type ClassBookingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClassBooking to aggregate.
     */
    where?: ClassBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassBookings to fetch.
     */
    orderBy?: ClassBookingOrderByWithRelationInput | ClassBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClassBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassBookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClassBookings
    **/
    _count?: true | ClassBookingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassBookingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassBookingMaxAggregateInputType
  }

  export type GetClassBookingAggregateType<T extends ClassBookingAggregateArgs> = {
        [P in keyof T & keyof AggregateClassBooking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClassBooking[P]>
      : GetScalarType<T[P], AggregateClassBooking[P]>
  }




  export type ClassBookingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassBookingWhereInput
    orderBy?: ClassBookingOrderByWithAggregationInput | ClassBookingOrderByWithAggregationInput[]
    by: ClassBookingScalarFieldEnum[] | ClassBookingScalarFieldEnum
    having?: ClassBookingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassBookingCountAggregateInputType | true
    _min?: ClassBookingMinAggregateInputType
    _max?: ClassBookingMaxAggregateInputType
  }

  export type ClassBookingGroupByOutputType = {
    id: string
    classId: string
    clientId: string
    status: string
    checkedIn: boolean
    paid: boolean
    createdAt: Date
    _count: ClassBookingCountAggregateOutputType | null
    _min: ClassBookingMinAggregateOutputType | null
    _max: ClassBookingMaxAggregateOutputType | null
  }

  type GetClassBookingGroupByPayload<T extends ClassBookingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClassBookingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassBookingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassBookingGroupByOutputType[P]>
            : GetScalarType<T[P], ClassBookingGroupByOutputType[P]>
        }
      >
    >


  export type ClassBookingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    classId?: boolean
    clientId?: boolean
    status?: boolean
    checkedIn?: boolean
    paid?: boolean
    createdAt?: boolean
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classBooking"]>

  export type ClassBookingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    classId?: boolean
    clientId?: boolean
    status?: boolean
    checkedIn?: boolean
    paid?: boolean
    createdAt?: boolean
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classBooking"]>

  export type ClassBookingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    classId?: boolean
    clientId?: boolean
    status?: boolean
    checkedIn?: boolean
    paid?: boolean
    createdAt?: boolean
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classBooking"]>

  export type ClassBookingSelectScalar = {
    id?: boolean
    classId?: boolean
    clientId?: boolean
    status?: boolean
    checkedIn?: boolean
    paid?: boolean
    createdAt?: boolean
  }

  export type ClassBookingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "classId" | "clientId" | "status" | "checkedIn" | "paid" | "createdAt", ExtArgs["result"]["classBooking"]>
  export type ClassBookingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }
  export type ClassBookingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }
  export type ClassBookingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }

  export type $ClassBookingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClassBooking"
    objects: {
      class: Prisma.$ClassPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      classId: string
      clientId: string
      status: string
      checkedIn: boolean
      paid: boolean
      createdAt: Date
    }, ExtArgs["result"]["classBooking"]>
    composites: {}
  }

  type ClassBookingGetPayload<S extends boolean | null | undefined | ClassBookingDefaultArgs> = $Result.GetResult<Prisma.$ClassBookingPayload, S>

  type ClassBookingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClassBookingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClassBookingCountAggregateInputType | true
    }

  export interface ClassBookingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClassBooking'], meta: { name: 'ClassBooking' } }
    /**
     * Find zero or one ClassBooking that matches the filter.
     * @param {ClassBookingFindUniqueArgs} args - Arguments to find a ClassBooking
     * @example
     * // Get one ClassBooking
     * const classBooking = await prisma.classBooking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClassBookingFindUniqueArgs>(args: SelectSubset<T, ClassBookingFindUniqueArgs<ExtArgs>>): Prisma__ClassBookingClient<$Result.GetResult<Prisma.$ClassBookingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClassBooking that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClassBookingFindUniqueOrThrowArgs} args - Arguments to find a ClassBooking
     * @example
     * // Get one ClassBooking
     * const classBooking = await prisma.classBooking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClassBookingFindUniqueOrThrowArgs>(args: SelectSubset<T, ClassBookingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClassBookingClient<$Result.GetResult<Prisma.$ClassBookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClassBooking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassBookingFindFirstArgs} args - Arguments to find a ClassBooking
     * @example
     * // Get one ClassBooking
     * const classBooking = await prisma.classBooking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClassBookingFindFirstArgs>(args?: SelectSubset<T, ClassBookingFindFirstArgs<ExtArgs>>): Prisma__ClassBookingClient<$Result.GetResult<Prisma.$ClassBookingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClassBooking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassBookingFindFirstOrThrowArgs} args - Arguments to find a ClassBooking
     * @example
     * // Get one ClassBooking
     * const classBooking = await prisma.classBooking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClassBookingFindFirstOrThrowArgs>(args?: SelectSubset<T, ClassBookingFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClassBookingClient<$Result.GetResult<Prisma.$ClassBookingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClassBookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassBookingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClassBookings
     * const classBookings = await prisma.classBooking.findMany()
     * 
     * // Get first 10 ClassBookings
     * const classBookings = await prisma.classBooking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const classBookingWithIdOnly = await prisma.classBooking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClassBookingFindManyArgs>(args?: SelectSubset<T, ClassBookingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassBookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClassBooking.
     * @param {ClassBookingCreateArgs} args - Arguments to create a ClassBooking.
     * @example
     * // Create one ClassBooking
     * const ClassBooking = await prisma.classBooking.create({
     *   data: {
     *     // ... data to create a ClassBooking
     *   }
     * })
     * 
     */
    create<T extends ClassBookingCreateArgs>(args: SelectSubset<T, ClassBookingCreateArgs<ExtArgs>>): Prisma__ClassBookingClient<$Result.GetResult<Prisma.$ClassBookingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClassBookings.
     * @param {ClassBookingCreateManyArgs} args - Arguments to create many ClassBookings.
     * @example
     * // Create many ClassBookings
     * const classBooking = await prisma.classBooking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClassBookingCreateManyArgs>(args?: SelectSubset<T, ClassBookingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClassBookings and returns the data saved in the database.
     * @param {ClassBookingCreateManyAndReturnArgs} args - Arguments to create many ClassBookings.
     * @example
     * // Create many ClassBookings
     * const classBooking = await prisma.classBooking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClassBookings and only return the `id`
     * const classBookingWithIdOnly = await prisma.classBooking.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClassBookingCreateManyAndReturnArgs>(args?: SelectSubset<T, ClassBookingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassBookingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ClassBooking.
     * @param {ClassBookingDeleteArgs} args - Arguments to delete one ClassBooking.
     * @example
     * // Delete one ClassBooking
     * const ClassBooking = await prisma.classBooking.delete({
     *   where: {
     *     // ... filter to delete one ClassBooking
     *   }
     * })
     * 
     */
    delete<T extends ClassBookingDeleteArgs>(args: SelectSubset<T, ClassBookingDeleteArgs<ExtArgs>>): Prisma__ClassBookingClient<$Result.GetResult<Prisma.$ClassBookingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClassBooking.
     * @param {ClassBookingUpdateArgs} args - Arguments to update one ClassBooking.
     * @example
     * // Update one ClassBooking
     * const classBooking = await prisma.classBooking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClassBookingUpdateArgs>(args: SelectSubset<T, ClassBookingUpdateArgs<ExtArgs>>): Prisma__ClassBookingClient<$Result.GetResult<Prisma.$ClassBookingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClassBookings.
     * @param {ClassBookingDeleteManyArgs} args - Arguments to filter ClassBookings to delete.
     * @example
     * // Delete a few ClassBookings
     * const { count } = await prisma.classBooking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClassBookingDeleteManyArgs>(args?: SelectSubset<T, ClassBookingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClassBookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassBookingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClassBookings
     * const classBooking = await prisma.classBooking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClassBookingUpdateManyArgs>(args: SelectSubset<T, ClassBookingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClassBookings and returns the data updated in the database.
     * @param {ClassBookingUpdateManyAndReturnArgs} args - Arguments to update many ClassBookings.
     * @example
     * // Update many ClassBookings
     * const classBooking = await prisma.classBooking.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ClassBookings and only return the `id`
     * const classBookingWithIdOnly = await prisma.classBooking.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClassBookingUpdateManyAndReturnArgs>(args: SelectSubset<T, ClassBookingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassBookingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ClassBooking.
     * @param {ClassBookingUpsertArgs} args - Arguments to update or create a ClassBooking.
     * @example
     * // Update or create a ClassBooking
     * const classBooking = await prisma.classBooking.upsert({
     *   create: {
     *     // ... data to create a ClassBooking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClassBooking we want to update
     *   }
     * })
     */
    upsert<T extends ClassBookingUpsertArgs>(args: SelectSubset<T, ClassBookingUpsertArgs<ExtArgs>>): Prisma__ClassBookingClient<$Result.GetResult<Prisma.$ClassBookingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClassBookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassBookingCountArgs} args - Arguments to filter ClassBookings to count.
     * @example
     * // Count the number of ClassBookings
     * const count = await prisma.classBooking.count({
     *   where: {
     *     // ... the filter for the ClassBookings we want to count
     *   }
     * })
    **/
    count<T extends ClassBookingCountArgs>(
      args?: Subset<T, ClassBookingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassBookingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClassBooking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassBookingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassBookingAggregateArgs>(args: Subset<T, ClassBookingAggregateArgs>): Prisma.PrismaPromise<GetClassBookingAggregateType<T>>

    /**
     * Group by ClassBooking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassBookingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassBookingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassBookingGroupByArgs['orderBy'] }
        : { orderBy?: ClassBookingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassBookingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassBookingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClassBooking model
   */
  readonly fields: ClassBookingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClassBooking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClassBookingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    class<T extends ClassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassDefaultArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClassBooking model
   */
  interface ClassBookingFieldRefs {
    readonly id: FieldRef<"ClassBooking", 'String'>
    readonly classId: FieldRef<"ClassBooking", 'String'>
    readonly clientId: FieldRef<"ClassBooking", 'String'>
    readonly status: FieldRef<"ClassBooking", 'String'>
    readonly checkedIn: FieldRef<"ClassBooking", 'Boolean'>
    readonly paid: FieldRef<"ClassBooking", 'Boolean'>
    readonly createdAt: FieldRef<"ClassBooking", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClassBooking findUnique
   */
  export type ClassBookingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassBooking
     */
    select?: ClassBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassBooking
     */
    omit?: ClassBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassBookingInclude<ExtArgs> | null
    /**
     * Filter, which ClassBooking to fetch.
     */
    where: ClassBookingWhereUniqueInput
  }

  /**
   * ClassBooking findUniqueOrThrow
   */
  export type ClassBookingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassBooking
     */
    select?: ClassBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassBooking
     */
    omit?: ClassBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassBookingInclude<ExtArgs> | null
    /**
     * Filter, which ClassBooking to fetch.
     */
    where: ClassBookingWhereUniqueInput
  }

  /**
   * ClassBooking findFirst
   */
  export type ClassBookingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassBooking
     */
    select?: ClassBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassBooking
     */
    omit?: ClassBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassBookingInclude<ExtArgs> | null
    /**
     * Filter, which ClassBooking to fetch.
     */
    where?: ClassBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassBookings to fetch.
     */
    orderBy?: ClassBookingOrderByWithRelationInput | ClassBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassBookings.
     */
    cursor?: ClassBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassBookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassBookings.
     */
    distinct?: ClassBookingScalarFieldEnum | ClassBookingScalarFieldEnum[]
  }

  /**
   * ClassBooking findFirstOrThrow
   */
  export type ClassBookingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassBooking
     */
    select?: ClassBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassBooking
     */
    omit?: ClassBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassBookingInclude<ExtArgs> | null
    /**
     * Filter, which ClassBooking to fetch.
     */
    where?: ClassBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassBookings to fetch.
     */
    orderBy?: ClassBookingOrderByWithRelationInput | ClassBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassBookings.
     */
    cursor?: ClassBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassBookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassBookings.
     */
    distinct?: ClassBookingScalarFieldEnum | ClassBookingScalarFieldEnum[]
  }

  /**
   * ClassBooking findMany
   */
  export type ClassBookingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassBooking
     */
    select?: ClassBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassBooking
     */
    omit?: ClassBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassBookingInclude<ExtArgs> | null
    /**
     * Filter, which ClassBookings to fetch.
     */
    where?: ClassBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassBookings to fetch.
     */
    orderBy?: ClassBookingOrderByWithRelationInput | ClassBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClassBookings.
     */
    cursor?: ClassBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassBookings.
     */
    skip?: number
    distinct?: ClassBookingScalarFieldEnum | ClassBookingScalarFieldEnum[]
  }

  /**
   * ClassBooking create
   */
  export type ClassBookingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassBooking
     */
    select?: ClassBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassBooking
     */
    omit?: ClassBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassBookingInclude<ExtArgs> | null
    /**
     * The data needed to create a ClassBooking.
     */
    data: XOR<ClassBookingCreateInput, ClassBookingUncheckedCreateInput>
  }

  /**
   * ClassBooking createMany
   */
  export type ClassBookingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClassBookings.
     */
    data: ClassBookingCreateManyInput | ClassBookingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClassBooking createManyAndReturn
   */
  export type ClassBookingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassBooking
     */
    select?: ClassBookingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClassBooking
     */
    omit?: ClassBookingOmit<ExtArgs> | null
    /**
     * The data used to create many ClassBookings.
     */
    data: ClassBookingCreateManyInput | ClassBookingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassBookingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClassBooking update
   */
  export type ClassBookingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassBooking
     */
    select?: ClassBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassBooking
     */
    omit?: ClassBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassBookingInclude<ExtArgs> | null
    /**
     * The data needed to update a ClassBooking.
     */
    data: XOR<ClassBookingUpdateInput, ClassBookingUncheckedUpdateInput>
    /**
     * Choose, which ClassBooking to update.
     */
    where: ClassBookingWhereUniqueInput
  }

  /**
   * ClassBooking updateMany
   */
  export type ClassBookingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClassBookings.
     */
    data: XOR<ClassBookingUpdateManyMutationInput, ClassBookingUncheckedUpdateManyInput>
    /**
     * Filter which ClassBookings to update
     */
    where?: ClassBookingWhereInput
    /**
     * Limit how many ClassBookings to update.
     */
    limit?: number
  }

  /**
   * ClassBooking updateManyAndReturn
   */
  export type ClassBookingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassBooking
     */
    select?: ClassBookingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClassBooking
     */
    omit?: ClassBookingOmit<ExtArgs> | null
    /**
     * The data used to update ClassBookings.
     */
    data: XOR<ClassBookingUpdateManyMutationInput, ClassBookingUncheckedUpdateManyInput>
    /**
     * Filter which ClassBookings to update
     */
    where?: ClassBookingWhereInput
    /**
     * Limit how many ClassBookings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassBookingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClassBooking upsert
   */
  export type ClassBookingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassBooking
     */
    select?: ClassBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassBooking
     */
    omit?: ClassBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassBookingInclude<ExtArgs> | null
    /**
     * The filter to search for the ClassBooking to update in case it exists.
     */
    where: ClassBookingWhereUniqueInput
    /**
     * In case the ClassBooking found by the `where` argument doesn't exist, create a new ClassBooking with this data.
     */
    create: XOR<ClassBookingCreateInput, ClassBookingUncheckedCreateInput>
    /**
     * In case the ClassBooking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassBookingUpdateInput, ClassBookingUncheckedUpdateInput>
  }

  /**
   * ClassBooking delete
   */
  export type ClassBookingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassBooking
     */
    select?: ClassBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassBooking
     */
    omit?: ClassBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassBookingInclude<ExtArgs> | null
    /**
     * Filter which ClassBooking to delete.
     */
    where: ClassBookingWhereUniqueInput
  }

  /**
   * ClassBooking deleteMany
   */
  export type ClassBookingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClassBookings to delete
     */
    where?: ClassBookingWhereInput
    /**
     * Limit how many ClassBookings to delete.
     */
    limit?: number
  }

  /**
   * ClassBooking without action
   */
  export type ClassBookingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassBooking
     */
    select?: ClassBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassBooking
     */
    omit?: ClassBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassBookingInclude<ExtArgs> | null
  }


  /**
   * Model Package
   */

  export type AggregatePackage = {
    _count: PackageCountAggregateOutputType | null
    _avg: PackageAvgAggregateOutputType | null
    _sum: PackageSumAggregateOutputType | null
    _min: PackageMinAggregateOutputType | null
    _max: PackageMaxAggregateOutputType | null
  }

  export type PackageAvgAggregateOutputType = {
    price: number | null
    credits: number | null
    validityDays: number | null
  }

  export type PackageSumAggregateOutputType = {
    price: number | null
    credits: number | null
    validityDays: number | null
  }

  export type PackageMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    description: string | null
    type: string | null
    price: number | null
    credits: number | null
    validityDays: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PackageMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    description: string | null
    type: string | null
    price: number | null
    credits: number | null
    validityDays: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PackageCountAggregateOutputType = {
    id: number
    tenantId: number
    name: number
    description: number
    type: number
    price: number
    credits: number
    validityDays: number
    features: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PackageAvgAggregateInputType = {
    price?: true
    credits?: true
    validityDays?: true
  }

  export type PackageSumAggregateInputType = {
    price?: true
    credits?: true
    validityDays?: true
  }

  export type PackageMinAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    description?: true
    type?: true
    price?: true
    credits?: true
    validityDays?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PackageMaxAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    description?: true
    type?: true
    price?: true
    credits?: true
    validityDays?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PackageCountAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    description?: true
    type?: true
    price?: true
    credits?: true
    validityDays?: true
    features?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PackageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Package to aggregate.
     */
    where?: PackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Packages to fetch.
     */
    orderBy?: PackageOrderByWithRelationInput | PackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Packages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Packages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Packages
    **/
    _count?: true | PackageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PackageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PackageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PackageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PackageMaxAggregateInputType
  }

  export type GetPackageAggregateType<T extends PackageAggregateArgs> = {
        [P in keyof T & keyof AggregatePackage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePackage[P]>
      : GetScalarType<T[P], AggregatePackage[P]>
  }




  export type PackageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PackageWhereInput
    orderBy?: PackageOrderByWithAggregationInput | PackageOrderByWithAggregationInput[]
    by: PackageScalarFieldEnum[] | PackageScalarFieldEnum
    having?: PackageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PackageCountAggregateInputType | true
    _avg?: PackageAvgAggregateInputType
    _sum?: PackageSumAggregateInputType
    _min?: PackageMinAggregateInputType
    _max?: PackageMaxAggregateInputType
  }

  export type PackageGroupByOutputType = {
    id: string
    tenantId: string
    name: string
    description: string | null
    type: string
    price: number
    credits: number
    validityDays: number
    features: string[]
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: PackageCountAggregateOutputType | null
    _avg: PackageAvgAggregateOutputType | null
    _sum: PackageSumAggregateOutputType | null
    _min: PackageMinAggregateOutputType | null
    _max: PackageMaxAggregateOutputType | null
  }

  type GetPackageGroupByPayload<T extends PackageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PackageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PackageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PackageGroupByOutputType[P]>
            : GetScalarType<T[P], PackageGroupByOutputType[P]>
        }
      >
    >


  export type PackageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    price?: boolean
    credits?: boolean
    validityDays?: boolean
    features?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["package"]>

  export type PackageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    price?: boolean
    credits?: boolean
    validityDays?: boolean
    features?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["package"]>

  export type PackageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    price?: boolean
    credits?: boolean
    validityDays?: boolean
    features?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["package"]>

  export type PackageSelectScalar = {
    id?: boolean
    tenantId?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    price?: boolean
    credits?: boolean
    validityDays?: boolean
    features?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PackageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "name" | "description" | "type" | "price" | "credits" | "validityDays" | "features" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["package"]>
  export type PackageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type PackageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type PackageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $PackagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Package"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      name: string
      description: string | null
      type: string
      price: number
      credits: number
      validityDays: number
      features: string[]
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["package"]>
    composites: {}
  }

  type PackageGetPayload<S extends boolean | null | undefined | PackageDefaultArgs> = $Result.GetResult<Prisma.$PackagePayload, S>

  type PackageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PackageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PackageCountAggregateInputType | true
    }

  export interface PackageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Package'], meta: { name: 'Package' } }
    /**
     * Find zero or one Package that matches the filter.
     * @param {PackageFindUniqueArgs} args - Arguments to find a Package
     * @example
     * // Get one Package
     * const package = await prisma.package.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PackageFindUniqueArgs>(args: SelectSubset<T, PackageFindUniqueArgs<ExtArgs>>): Prisma__PackageClient<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Package that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PackageFindUniqueOrThrowArgs} args - Arguments to find a Package
     * @example
     * // Get one Package
     * const package = await prisma.package.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PackageFindUniqueOrThrowArgs>(args: SelectSubset<T, PackageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PackageClient<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Package that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageFindFirstArgs} args - Arguments to find a Package
     * @example
     * // Get one Package
     * const package = await prisma.package.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PackageFindFirstArgs>(args?: SelectSubset<T, PackageFindFirstArgs<ExtArgs>>): Prisma__PackageClient<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Package that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageFindFirstOrThrowArgs} args - Arguments to find a Package
     * @example
     * // Get one Package
     * const package = await prisma.package.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PackageFindFirstOrThrowArgs>(args?: SelectSubset<T, PackageFindFirstOrThrowArgs<ExtArgs>>): Prisma__PackageClient<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Packages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Packages
     * const packages = await prisma.package.findMany()
     * 
     * // Get first 10 Packages
     * const packages = await prisma.package.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const packageWithIdOnly = await prisma.package.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PackageFindManyArgs>(args?: SelectSubset<T, PackageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Package.
     * @param {PackageCreateArgs} args - Arguments to create a Package.
     * @example
     * // Create one Package
     * const Package = await prisma.package.create({
     *   data: {
     *     // ... data to create a Package
     *   }
     * })
     * 
     */
    create<T extends PackageCreateArgs>(args: SelectSubset<T, PackageCreateArgs<ExtArgs>>): Prisma__PackageClient<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Packages.
     * @param {PackageCreateManyArgs} args - Arguments to create many Packages.
     * @example
     * // Create many Packages
     * const package = await prisma.package.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PackageCreateManyArgs>(args?: SelectSubset<T, PackageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Packages and returns the data saved in the database.
     * @param {PackageCreateManyAndReturnArgs} args - Arguments to create many Packages.
     * @example
     * // Create many Packages
     * const package = await prisma.package.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Packages and only return the `id`
     * const packageWithIdOnly = await prisma.package.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PackageCreateManyAndReturnArgs>(args?: SelectSubset<T, PackageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Package.
     * @param {PackageDeleteArgs} args - Arguments to delete one Package.
     * @example
     * // Delete one Package
     * const Package = await prisma.package.delete({
     *   where: {
     *     // ... filter to delete one Package
     *   }
     * })
     * 
     */
    delete<T extends PackageDeleteArgs>(args: SelectSubset<T, PackageDeleteArgs<ExtArgs>>): Prisma__PackageClient<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Package.
     * @param {PackageUpdateArgs} args - Arguments to update one Package.
     * @example
     * // Update one Package
     * const package = await prisma.package.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PackageUpdateArgs>(args: SelectSubset<T, PackageUpdateArgs<ExtArgs>>): Prisma__PackageClient<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Packages.
     * @param {PackageDeleteManyArgs} args - Arguments to filter Packages to delete.
     * @example
     * // Delete a few Packages
     * const { count } = await prisma.package.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PackageDeleteManyArgs>(args?: SelectSubset<T, PackageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Packages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Packages
     * const package = await prisma.package.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PackageUpdateManyArgs>(args: SelectSubset<T, PackageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Packages and returns the data updated in the database.
     * @param {PackageUpdateManyAndReturnArgs} args - Arguments to update many Packages.
     * @example
     * // Update many Packages
     * const package = await prisma.package.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Packages and only return the `id`
     * const packageWithIdOnly = await prisma.package.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PackageUpdateManyAndReturnArgs>(args: SelectSubset<T, PackageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Package.
     * @param {PackageUpsertArgs} args - Arguments to update or create a Package.
     * @example
     * // Update or create a Package
     * const package = await prisma.package.upsert({
     *   create: {
     *     // ... data to create a Package
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Package we want to update
     *   }
     * })
     */
    upsert<T extends PackageUpsertArgs>(args: SelectSubset<T, PackageUpsertArgs<ExtArgs>>): Prisma__PackageClient<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Packages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageCountArgs} args - Arguments to filter Packages to count.
     * @example
     * // Count the number of Packages
     * const count = await prisma.package.count({
     *   where: {
     *     // ... the filter for the Packages we want to count
     *   }
     * })
    **/
    count<T extends PackageCountArgs>(
      args?: Subset<T, PackageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PackageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Package.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PackageAggregateArgs>(args: Subset<T, PackageAggregateArgs>): Prisma.PrismaPromise<GetPackageAggregateType<T>>

    /**
     * Group by Package.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PackageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PackageGroupByArgs['orderBy'] }
        : { orderBy?: PackageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PackageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPackageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Package model
   */
  readonly fields: PackageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Package.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PackageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Package model
   */
  interface PackageFieldRefs {
    readonly id: FieldRef<"Package", 'String'>
    readonly tenantId: FieldRef<"Package", 'String'>
    readonly name: FieldRef<"Package", 'String'>
    readonly description: FieldRef<"Package", 'String'>
    readonly type: FieldRef<"Package", 'String'>
    readonly price: FieldRef<"Package", 'Float'>
    readonly credits: FieldRef<"Package", 'Int'>
    readonly validityDays: FieldRef<"Package", 'Int'>
    readonly features: FieldRef<"Package", 'String[]'>
    readonly isActive: FieldRef<"Package", 'Boolean'>
    readonly createdAt: FieldRef<"Package", 'DateTime'>
    readonly updatedAt: FieldRef<"Package", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Package findUnique
   */
  export type PackageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageInclude<ExtArgs> | null
    /**
     * Filter, which Package to fetch.
     */
    where: PackageWhereUniqueInput
  }

  /**
   * Package findUniqueOrThrow
   */
  export type PackageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageInclude<ExtArgs> | null
    /**
     * Filter, which Package to fetch.
     */
    where: PackageWhereUniqueInput
  }

  /**
   * Package findFirst
   */
  export type PackageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageInclude<ExtArgs> | null
    /**
     * Filter, which Package to fetch.
     */
    where?: PackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Packages to fetch.
     */
    orderBy?: PackageOrderByWithRelationInput | PackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Packages.
     */
    cursor?: PackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Packages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Packages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Packages.
     */
    distinct?: PackageScalarFieldEnum | PackageScalarFieldEnum[]
  }

  /**
   * Package findFirstOrThrow
   */
  export type PackageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageInclude<ExtArgs> | null
    /**
     * Filter, which Package to fetch.
     */
    where?: PackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Packages to fetch.
     */
    orderBy?: PackageOrderByWithRelationInput | PackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Packages.
     */
    cursor?: PackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Packages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Packages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Packages.
     */
    distinct?: PackageScalarFieldEnum | PackageScalarFieldEnum[]
  }

  /**
   * Package findMany
   */
  export type PackageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageInclude<ExtArgs> | null
    /**
     * Filter, which Packages to fetch.
     */
    where?: PackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Packages to fetch.
     */
    orderBy?: PackageOrderByWithRelationInput | PackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Packages.
     */
    cursor?: PackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Packages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Packages.
     */
    skip?: number
    distinct?: PackageScalarFieldEnum | PackageScalarFieldEnum[]
  }

  /**
   * Package create
   */
  export type PackageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageInclude<ExtArgs> | null
    /**
     * The data needed to create a Package.
     */
    data: XOR<PackageCreateInput, PackageUncheckedCreateInput>
  }

  /**
   * Package createMany
   */
  export type PackageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Packages.
     */
    data: PackageCreateManyInput | PackageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Package createManyAndReturn
   */
  export type PackageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * The data used to create many Packages.
     */
    data: PackageCreateManyInput | PackageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Package update
   */
  export type PackageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageInclude<ExtArgs> | null
    /**
     * The data needed to update a Package.
     */
    data: XOR<PackageUpdateInput, PackageUncheckedUpdateInput>
    /**
     * Choose, which Package to update.
     */
    where: PackageWhereUniqueInput
  }

  /**
   * Package updateMany
   */
  export type PackageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Packages.
     */
    data: XOR<PackageUpdateManyMutationInput, PackageUncheckedUpdateManyInput>
    /**
     * Filter which Packages to update
     */
    where?: PackageWhereInput
    /**
     * Limit how many Packages to update.
     */
    limit?: number
  }

  /**
   * Package updateManyAndReturn
   */
  export type PackageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * The data used to update Packages.
     */
    data: XOR<PackageUpdateManyMutationInput, PackageUncheckedUpdateManyInput>
    /**
     * Filter which Packages to update
     */
    where?: PackageWhereInput
    /**
     * Limit how many Packages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Package upsert
   */
  export type PackageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageInclude<ExtArgs> | null
    /**
     * The filter to search for the Package to update in case it exists.
     */
    where: PackageWhereUniqueInput
    /**
     * In case the Package found by the `where` argument doesn't exist, create a new Package with this data.
     */
    create: XOR<PackageCreateInput, PackageUncheckedCreateInput>
    /**
     * In case the Package was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PackageUpdateInput, PackageUncheckedUpdateInput>
  }

  /**
   * Package delete
   */
  export type PackageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageInclude<ExtArgs> | null
    /**
     * Filter which Package to delete.
     */
    where: PackageWhereUniqueInput
  }

  /**
   * Package deleteMany
   */
  export type PackageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Packages to delete
     */
    where?: PackageWhereInput
    /**
     * Limit how many Packages to delete.
     */
    limit?: number
  }

  /**
   * Package without action
   */
  export type PackageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageInclude<ExtArgs> | null
  }


  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    subtotal: number | null
    tax: number | null
    discount: number | null
    total: number | null
    paidAmount: number | null
  }

  export type OrderSumAggregateOutputType = {
    subtotal: number | null
    tax: number | null
    discount: number | null
    total: number | null
    paidAmount: number | null
  }

  export type OrderMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    clientId: string | null
    orderNumber: string | null
    status: string | null
    subtotal: number | null
    tax: number | null
    discount: number | null
    total: number | null
    paymentMethod: string | null
    paymentStatus: string | null
    paidAmount: number | null
    orderDate: Date | null
    dueDate: Date | null
    paidDate: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    clientId: string | null
    orderNumber: string | null
    status: string | null
    subtotal: number | null
    tax: number | null
    discount: number | null
    total: number | null
    paymentMethod: string | null
    paymentStatus: string | null
    paidAmount: number | null
    orderDate: Date | null
    dueDate: Date | null
    paidDate: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    tenantId: number
    clientId: number
    orderNumber: number
    status: number
    items: number
    subtotal: number
    tax: number
    discount: number
    total: number
    paymentMethod: number
    paymentStatus: number
    paidAmount: number
    orderDate: number
    dueDate: number
    paidDate: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    subtotal?: true
    tax?: true
    discount?: true
    total?: true
    paidAmount?: true
  }

  export type OrderSumAggregateInputType = {
    subtotal?: true
    tax?: true
    discount?: true
    total?: true
    paidAmount?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    tenantId?: true
    clientId?: true
    orderNumber?: true
    status?: true
    subtotal?: true
    tax?: true
    discount?: true
    total?: true
    paymentMethod?: true
    paymentStatus?: true
    paidAmount?: true
    orderDate?: true
    dueDate?: true
    paidDate?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    tenantId?: true
    clientId?: true
    orderNumber?: true
    status?: true
    subtotal?: true
    tax?: true
    discount?: true
    total?: true
    paymentMethod?: true
    paymentStatus?: true
    paidAmount?: true
    orderDate?: true
    dueDate?: true
    paidDate?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    tenantId?: true
    clientId?: true
    orderNumber?: true
    status?: true
    items?: true
    subtotal?: true
    tax?: true
    discount?: true
    total?: true
    paymentMethod?: true
    paymentStatus?: true
    paidAmount?: true
    orderDate?: true
    dueDate?: true
    paidDate?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    id: string
    tenantId: string
    clientId: string
    orderNumber: string
    status: string
    items: JsonValue[]
    subtotal: number
    tax: number
    discount: number
    total: number
    paymentMethod: string | null
    paymentStatus: string
    paidAmount: number
    orderDate: Date
    dueDate: Date | null
    paidDate: Date | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    clientId?: boolean
    orderNumber?: boolean
    status?: boolean
    items?: boolean
    subtotal?: boolean
    tax?: boolean
    discount?: boolean
    total?: boolean
    paymentMethod?: boolean
    paymentStatus?: boolean
    paidAmount?: boolean
    orderDate?: boolean
    dueDate?: boolean
    paidDate?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
    invoices?: boolean | Order$invoicesArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    clientId?: boolean
    orderNumber?: boolean
    status?: boolean
    items?: boolean
    subtotal?: boolean
    tax?: boolean
    discount?: boolean
    total?: boolean
    paymentMethod?: boolean
    paymentStatus?: boolean
    paidAmount?: boolean
    orderDate?: boolean
    dueDate?: boolean
    paidDate?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    clientId?: boolean
    orderNumber?: boolean
    status?: boolean
    items?: boolean
    subtotal?: boolean
    tax?: boolean
    discount?: boolean
    total?: boolean
    paymentMethod?: boolean
    paymentStatus?: boolean
    paidAmount?: boolean
    orderDate?: boolean
    dueDate?: boolean
    paidDate?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectScalar = {
    id?: boolean
    tenantId?: boolean
    clientId?: boolean
    orderNumber?: boolean
    status?: boolean
    items?: boolean
    subtotal?: boolean
    tax?: boolean
    discount?: boolean
    total?: boolean
    paymentMethod?: boolean
    paymentStatus?: boolean
    paidAmount?: boolean
    orderDate?: boolean
    dueDate?: boolean
    paidDate?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "clientId" | "orderNumber" | "status" | "items" | "subtotal" | "tax" | "discount" | "total" | "paymentMethod" | "paymentStatus" | "paidAmount" | "orderDate" | "dueDate" | "paidDate" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["order"]>
  export type OrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
    invoices?: boolean | Order$invoicesArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }
  export type OrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }

  export type $OrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Order"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      client: Prisma.$ClientPayload<ExtArgs>
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      clientId: string
      orderNumber: string
      status: string
      items: Prisma.JsonValue[]
      subtotal: number
      tax: number
      discount: number
      total: number
      paymentMethod: string | null
      paymentStatus: string
      paidAmount: number
      orderDate: Date
      dueDate: Date | null
      paidDate: Date | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["order"]>
    composites: {}
  }

  type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<Prisma.$OrderPayload, S>

  type OrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order'], meta: { name: 'Order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderFindUniqueArgs>(args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderFindFirstArgs>(args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderFindManyArgs>(args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
     */
    create<T extends OrderCreateArgs>(args: SelectSubset<T, OrderCreateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Orders.
     * @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderCreateManyArgs>(args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Orders and returns the data saved in the database.
     * @param {OrderCreateManyAndReturnArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
     */
    delete<T extends OrderDeleteArgs>(args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderUpdateArgs>(args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderDeleteManyArgs>(args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderUpdateManyArgs>(args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders and returns the data updated in the database.
     * @param {OrderUpdateManyAndReturnArgs} args - Arguments to update many Orders.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
     */
    upsert<T extends OrderUpsertArgs>(args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Order model
   */
  readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    invoices<T extends Order$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Order$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Order model
   */
  interface OrderFieldRefs {
    readonly id: FieldRef<"Order", 'String'>
    readonly tenantId: FieldRef<"Order", 'String'>
    readonly clientId: FieldRef<"Order", 'String'>
    readonly orderNumber: FieldRef<"Order", 'String'>
    readonly status: FieldRef<"Order", 'String'>
    readonly items: FieldRef<"Order", 'Json[]'>
    readonly subtotal: FieldRef<"Order", 'Float'>
    readonly tax: FieldRef<"Order", 'Float'>
    readonly discount: FieldRef<"Order", 'Float'>
    readonly total: FieldRef<"Order", 'Float'>
    readonly paymentMethod: FieldRef<"Order", 'String'>
    readonly paymentStatus: FieldRef<"Order", 'String'>
    readonly paidAmount: FieldRef<"Order", 'Float'>
    readonly orderDate: FieldRef<"Order", 'DateTime'>
    readonly dueDate: FieldRef<"Order", 'DateTime'>
    readonly paidDate: FieldRef<"Order", 'DateTime'>
    readonly notes: FieldRef<"Order", 'String'>
    readonly createdAt: FieldRef<"Order", 'DateTime'>
    readonly updatedAt: FieldRef<"Order", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }

  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Order createManyAndReturn
   */
  export type OrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
  }

  /**
   * Order updateManyAndReturn
   */
  export type OrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }

  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to delete.
     */
    limit?: number
  }

  /**
   * Order.invoices
   */
  export type Order$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Order without action
   */
  export type OrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
  }


  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    subtotal: number | null
    tax: number | null
    total: number | null
  }

  export type InvoiceSumAggregateOutputType = {
    subtotal: number | null
    tax: number | null
    total: number | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    orderId: string | null
    clientId: string | null
    invoiceNumber: string | null
    status: string | null
    issueDate: Date | null
    dueDate: Date | null
    paidDate: Date | null
    subtotal: number | null
    tax: number | null
    total: number | null
    paymentMethod: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    orderId: string | null
    clientId: string | null
    invoiceNumber: string | null
    status: string | null
    issueDate: Date | null
    dueDate: Date | null
    paidDate: Date | null
    subtotal: number | null
    tax: number | null
    total: number | null
    paymentMethod: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    tenantId: number
    orderId: number
    clientId: number
    invoiceNumber: number
    status: number
    issueDate: number
    dueDate: number
    paidDate: number
    subtotal: number
    tax: number
    total: number
    paymentMethod: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    subtotal?: true
    tax?: true
    total?: true
  }

  export type InvoiceSumAggregateInputType = {
    subtotal?: true
    tax?: true
    total?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    tenantId?: true
    orderId?: true
    clientId?: true
    invoiceNumber?: true
    status?: true
    issueDate?: true
    dueDate?: true
    paidDate?: true
    subtotal?: true
    tax?: true
    total?: true
    paymentMethod?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    tenantId?: true
    orderId?: true
    clientId?: true
    invoiceNumber?: true
    status?: true
    issueDate?: true
    dueDate?: true
    paidDate?: true
    subtotal?: true
    tax?: true
    total?: true
    paymentMethod?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    tenantId?: true
    orderId?: true
    clientId?: true
    invoiceNumber?: true
    status?: true
    issueDate?: true
    dueDate?: true
    paidDate?: true
    subtotal?: true
    tax?: true
    total?: true
    paymentMethod?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    id: string
    tenantId: string
    orderId: string | null
    clientId: string
    invoiceNumber: string
    status: string
    issueDate: Date
    dueDate: Date
    paidDate: Date | null
    subtotal: number
    tax: number
    total: number
    paymentMethod: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    orderId?: boolean
    clientId?: boolean
    invoiceNumber?: boolean
    status?: boolean
    issueDate?: boolean
    dueDate?: boolean
    paidDate?: boolean
    subtotal?: boolean
    tax?: boolean
    total?: boolean
    paymentMethod?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    order?: boolean | Invoice$orderArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
    payments?: boolean | Invoice$paymentsArgs<ExtArgs>
    bankTransactions?: boolean | Invoice$bankTransactionsArgs<ExtArgs>
    cryptoPayments?: boolean | Invoice$cryptoPaymentsArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    orderId?: boolean
    clientId?: boolean
    invoiceNumber?: boolean
    status?: boolean
    issueDate?: boolean
    dueDate?: boolean
    paidDate?: boolean
    subtotal?: boolean
    tax?: boolean
    total?: boolean
    paymentMethod?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    order?: boolean | Invoice$orderArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    orderId?: boolean
    clientId?: boolean
    invoiceNumber?: boolean
    status?: boolean
    issueDate?: boolean
    dueDate?: boolean
    paidDate?: boolean
    subtotal?: boolean
    tax?: boolean
    total?: boolean
    paymentMethod?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    order?: boolean | Invoice$orderArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectScalar = {
    id?: boolean
    tenantId?: boolean
    orderId?: boolean
    clientId?: boolean
    invoiceNumber?: boolean
    status?: boolean
    issueDate?: boolean
    dueDate?: boolean
    paidDate?: boolean
    subtotal?: boolean
    tax?: boolean
    total?: boolean
    paymentMethod?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InvoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "orderId" | "clientId" | "invoiceNumber" | "status" | "issueDate" | "dueDate" | "paidDate" | "subtotal" | "tax" | "total" | "paymentMethod" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["invoice"]>
  export type InvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    order?: boolean | Invoice$orderArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
    payments?: boolean | Invoice$paymentsArgs<ExtArgs>
    bankTransactions?: boolean | Invoice$bankTransactionsArgs<ExtArgs>
    cryptoPayments?: boolean | Invoice$cryptoPaymentsArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    order?: boolean | Invoice$orderArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    order?: boolean | Invoice$orderArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }

  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoice"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      order: Prisma.$OrderPayload<ExtArgs> | null
      client: Prisma.$ClientPayload<ExtArgs>
      payments: Prisma.$InvoicePaymentPayload<ExtArgs>[]
      bankTransactions: Prisma.$BankTransactionPayload<ExtArgs>[]
      cryptoPayments: Prisma.$CryptoPaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      orderId: string | null
      clientId: string
      invoiceNumber: string
      status: string
      issueDate: Date
      dueDate: Date
      paidDate: Date | null
      subtotal: number
      tax: number
      total: number
      paymentMethod: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> = $Result.GetResult<Prisma.$InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceFindUniqueArgs>(args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceFindFirstArgs>(args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceFindManyArgs>(args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends InvoiceCreateArgs>(args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invoices.
     * @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceCreateManyArgs>(args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invoices and returns the data saved in the database.
     * @param {InvoiceCreateManyAndReturnArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends InvoiceDeleteArgs>(args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceUpdateArgs>(args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceDeleteManyArgs>(args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceUpdateManyArgs>(args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices and returns the data updated in the database.
     * @param {InvoiceUpdateManyAndReturnArgs} args - Arguments to update many Invoices.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvoiceUpdateManyAndReturnArgs>(args: SelectSubset<T, InvoiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceUpsertArgs>(args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice model
   */
  readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    order<T extends Invoice$orderArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$orderArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    payments<T extends Invoice$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bankTransactions<T extends Invoice$bankTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$bankTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cryptoPayments<T extends Invoice$cryptoPaymentsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$cryptoPaymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CryptoPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoice model
   */
  interface InvoiceFieldRefs {
    readonly id: FieldRef<"Invoice", 'String'>
    readonly tenantId: FieldRef<"Invoice", 'String'>
    readonly orderId: FieldRef<"Invoice", 'String'>
    readonly clientId: FieldRef<"Invoice", 'String'>
    readonly invoiceNumber: FieldRef<"Invoice", 'String'>
    readonly status: FieldRef<"Invoice", 'String'>
    readonly issueDate: FieldRef<"Invoice", 'DateTime'>
    readonly dueDate: FieldRef<"Invoice", 'DateTime'>
    readonly paidDate: FieldRef<"Invoice", 'DateTime'>
    readonly subtotal: FieldRef<"Invoice", 'Float'>
    readonly tax: FieldRef<"Invoice", 'Float'>
    readonly total: FieldRef<"Invoice", 'Float'>
    readonly paymentMethod: FieldRef<"Invoice", 'String'>
    readonly notes: FieldRef<"Invoice", 'String'>
    readonly createdAt: FieldRef<"Invoice", 'DateTime'>
    readonly updatedAt: FieldRef<"Invoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }

  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invoice createManyAndReturn
   */
  export type InvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
  }

  /**
   * Invoice updateManyAndReturn
   */
  export type InvoiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }

  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to delete.
     */
    limit?: number
  }

  /**
   * Invoice.order
   */
  export type Invoice$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
  }

  /**
   * Invoice.payments
   */
  export type Invoice$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoicePayment
     */
    select?: InvoicePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoicePayment
     */
    omit?: InvoicePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoicePaymentInclude<ExtArgs> | null
    where?: InvoicePaymentWhereInput
    orderBy?: InvoicePaymentOrderByWithRelationInput | InvoicePaymentOrderByWithRelationInput[]
    cursor?: InvoicePaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoicePaymentScalarFieldEnum | InvoicePaymentScalarFieldEnum[]
  }

  /**
   * Invoice.bankTransactions
   */
  export type Invoice$bankTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankTransaction
     */
    select?: BankTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankTransaction
     */
    omit?: BankTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankTransactionInclude<ExtArgs> | null
    where?: BankTransactionWhereInput
    orderBy?: BankTransactionOrderByWithRelationInput | BankTransactionOrderByWithRelationInput[]
    cursor?: BankTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BankTransactionScalarFieldEnum | BankTransactionScalarFieldEnum[]
  }

  /**
   * Invoice.cryptoPayments
   */
  export type Invoice$cryptoPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoPayment
     */
    select?: CryptoPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoPayment
     */
    omit?: CryptoPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoPaymentInclude<ExtArgs> | null
    where?: CryptoPaymentWhereInput
    orderBy?: CryptoPaymentOrderByWithRelationInput | CryptoPaymentOrderByWithRelationInput[]
    cursor?: CryptoPaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CryptoPaymentScalarFieldEnum | CryptoPaymentScalarFieldEnum[]
  }

  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
  }


  /**
   * Model AILog
   */

  export type AggregateAILog = {
    _count: AILogCountAggregateOutputType | null
    _avg: AILogAvgAggregateOutputType | null
    _sum: AILogSumAggregateOutputType | null
    _min: AILogMinAggregateOutputType | null
    _max: AILogMaxAggregateOutputType | null
  }

  export type AILogAvgAggregateOutputType = {
    promptTokens: number | null
    completionTokens: number | null
    totalTokens: number | null
    estimatedCost: number | null
    latencyMs: number | null
  }

  export type AILogSumAggregateOutputType = {
    promptTokens: number | null
    completionTokens: number | null
    totalTokens: number | null
    estimatedCost: number | null
    latencyMs: number | null
  }

  export type AILogMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    feature: string | null
    model: string | null
    promptTokens: number | null
    completionTokens: number | null
    totalTokens: number | null
    estimatedCost: number | null
    latencyMs: number | null
    success: boolean | null
    error: string | null
    createdAt: Date | null
  }

  export type AILogMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    feature: string | null
    model: string | null
    promptTokens: number | null
    completionTokens: number | null
    totalTokens: number | null
    estimatedCost: number | null
    latencyMs: number | null
    success: boolean | null
    error: string | null
    createdAt: Date | null
  }

  export type AILogCountAggregateOutputType = {
    id: number
    tenantId: number
    feature: number
    model: number
    promptTokens: number
    completionTokens: number
    totalTokens: number
    estimatedCost: number
    input: number
    output: number
    latencyMs: number
    success: number
    error: number
    createdAt: number
    _all: number
  }


  export type AILogAvgAggregateInputType = {
    promptTokens?: true
    completionTokens?: true
    totalTokens?: true
    estimatedCost?: true
    latencyMs?: true
  }

  export type AILogSumAggregateInputType = {
    promptTokens?: true
    completionTokens?: true
    totalTokens?: true
    estimatedCost?: true
    latencyMs?: true
  }

  export type AILogMinAggregateInputType = {
    id?: true
    tenantId?: true
    feature?: true
    model?: true
    promptTokens?: true
    completionTokens?: true
    totalTokens?: true
    estimatedCost?: true
    latencyMs?: true
    success?: true
    error?: true
    createdAt?: true
  }

  export type AILogMaxAggregateInputType = {
    id?: true
    tenantId?: true
    feature?: true
    model?: true
    promptTokens?: true
    completionTokens?: true
    totalTokens?: true
    estimatedCost?: true
    latencyMs?: true
    success?: true
    error?: true
    createdAt?: true
  }

  export type AILogCountAggregateInputType = {
    id?: true
    tenantId?: true
    feature?: true
    model?: true
    promptTokens?: true
    completionTokens?: true
    totalTokens?: true
    estimatedCost?: true
    input?: true
    output?: true
    latencyMs?: true
    success?: true
    error?: true
    createdAt?: true
    _all?: true
  }

  export type AILogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AILog to aggregate.
     */
    where?: AILogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AILogs to fetch.
     */
    orderBy?: AILogOrderByWithRelationInput | AILogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AILogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AILogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AILogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AILogs
    **/
    _count?: true | AILogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AILogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AILogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AILogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AILogMaxAggregateInputType
  }

  export type GetAILogAggregateType<T extends AILogAggregateArgs> = {
        [P in keyof T & keyof AggregateAILog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAILog[P]>
      : GetScalarType<T[P], AggregateAILog[P]>
  }




  export type AILogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AILogWhereInput
    orderBy?: AILogOrderByWithAggregationInput | AILogOrderByWithAggregationInput[]
    by: AILogScalarFieldEnum[] | AILogScalarFieldEnum
    having?: AILogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AILogCountAggregateInputType | true
    _avg?: AILogAvgAggregateInputType
    _sum?: AILogSumAggregateInputType
    _min?: AILogMinAggregateInputType
    _max?: AILogMaxAggregateInputType
  }

  export type AILogGroupByOutputType = {
    id: string
    tenantId: string
    feature: string
    model: string
    promptTokens: number
    completionTokens: number
    totalTokens: number
    estimatedCost: number
    input: JsonValue
    output: JsonValue | null
    latencyMs: number | null
    success: boolean
    error: string | null
    createdAt: Date
    _count: AILogCountAggregateOutputType | null
    _avg: AILogAvgAggregateOutputType | null
    _sum: AILogSumAggregateOutputType | null
    _min: AILogMinAggregateOutputType | null
    _max: AILogMaxAggregateOutputType | null
  }

  type GetAILogGroupByPayload<T extends AILogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AILogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AILogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AILogGroupByOutputType[P]>
            : GetScalarType<T[P], AILogGroupByOutputType[P]>
        }
      >
    >


  export type AILogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    feature?: boolean
    model?: boolean
    promptTokens?: boolean
    completionTokens?: boolean
    totalTokens?: boolean
    estimatedCost?: boolean
    input?: boolean
    output?: boolean
    latencyMs?: boolean
    success?: boolean
    error?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aILog"]>

  export type AILogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    feature?: boolean
    model?: boolean
    promptTokens?: boolean
    completionTokens?: boolean
    totalTokens?: boolean
    estimatedCost?: boolean
    input?: boolean
    output?: boolean
    latencyMs?: boolean
    success?: boolean
    error?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aILog"]>

  export type AILogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    feature?: boolean
    model?: boolean
    promptTokens?: boolean
    completionTokens?: boolean
    totalTokens?: boolean
    estimatedCost?: boolean
    input?: boolean
    output?: boolean
    latencyMs?: boolean
    success?: boolean
    error?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aILog"]>

  export type AILogSelectScalar = {
    id?: boolean
    tenantId?: boolean
    feature?: boolean
    model?: boolean
    promptTokens?: boolean
    completionTokens?: boolean
    totalTokens?: boolean
    estimatedCost?: boolean
    input?: boolean
    output?: boolean
    latencyMs?: boolean
    success?: boolean
    error?: boolean
    createdAt?: boolean
  }

  export type AILogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "feature" | "model" | "promptTokens" | "completionTokens" | "totalTokens" | "estimatedCost" | "input" | "output" | "latencyMs" | "success" | "error" | "createdAt", ExtArgs["result"]["aILog"]>
  export type AILogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type AILogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type AILogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $AILogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AILog"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      feature: string
      model: string
      promptTokens: number
      completionTokens: number
      totalTokens: number
      estimatedCost: number
      input: Prisma.JsonValue
      output: Prisma.JsonValue | null
      latencyMs: number | null
      success: boolean
      error: string | null
      createdAt: Date
    }, ExtArgs["result"]["aILog"]>
    composites: {}
  }

  type AILogGetPayload<S extends boolean | null | undefined | AILogDefaultArgs> = $Result.GetResult<Prisma.$AILogPayload, S>

  type AILogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AILogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AILogCountAggregateInputType | true
    }

  export interface AILogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AILog'], meta: { name: 'AILog' } }
    /**
     * Find zero or one AILog that matches the filter.
     * @param {AILogFindUniqueArgs} args - Arguments to find a AILog
     * @example
     * // Get one AILog
     * const aILog = await prisma.aILog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AILogFindUniqueArgs>(args: SelectSubset<T, AILogFindUniqueArgs<ExtArgs>>): Prisma__AILogClient<$Result.GetResult<Prisma.$AILogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AILog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AILogFindUniqueOrThrowArgs} args - Arguments to find a AILog
     * @example
     * // Get one AILog
     * const aILog = await prisma.aILog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AILogFindUniqueOrThrowArgs>(args: SelectSubset<T, AILogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AILogClient<$Result.GetResult<Prisma.$AILogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AILog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AILogFindFirstArgs} args - Arguments to find a AILog
     * @example
     * // Get one AILog
     * const aILog = await prisma.aILog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AILogFindFirstArgs>(args?: SelectSubset<T, AILogFindFirstArgs<ExtArgs>>): Prisma__AILogClient<$Result.GetResult<Prisma.$AILogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AILog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AILogFindFirstOrThrowArgs} args - Arguments to find a AILog
     * @example
     * // Get one AILog
     * const aILog = await prisma.aILog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AILogFindFirstOrThrowArgs>(args?: SelectSubset<T, AILogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AILogClient<$Result.GetResult<Prisma.$AILogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AILogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AILogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AILogs
     * const aILogs = await prisma.aILog.findMany()
     * 
     * // Get first 10 AILogs
     * const aILogs = await prisma.aILog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aILogWithIdOnly = await prisma.aILog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AILogFindManyArgs>(args?: SelectSubset<T, AILogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AILogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AILog.
     * @param {AILogCreateArgs} args - Arguments to create a AILog.
     * @example
     * // Create one AILog
     * const AILog = await prisma.aILog.create({
     *   data: {
     *     // ... data to create a AILog
     *   }
     * })
     * 
     */
    create<T extends AILogCreateArgs>(args: SelectSubset<T, AILogCreateArgs<ExtArgs>>): Prisma__AILogClient<$Result.GetResult<Prisma.$AILogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AILogs.
     * @param {AILogCreateManyArgs} args - Arguments to create many AILogs.
     * @example
     * // Create many AILogs
     * const aILog = await prisma.aILog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AILogCreateManyArgs>(args?: SelectSubset<T, AILogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AILogs and returns the data saved in the database.
     * @param {AILogCreateManyAndReturnArgs} args - Arguments to create many AILogs.
     * @example
     * // Create many AILogs
     * const aILog = await prisma.aILog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AILogs and only return the `id`
     * const aILogWithIdOnly = await prisma.aILog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AILogCreateManyAndReturnArgs>(args?: SelectSubset<T, AILogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AILogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AILog.
     * @param {AILogDeleteArgs} args - Arguments to delete one AILog.
     * @example
     * // Delete one AILog
     * const AILog = await prisma.aILog.delete({
     *   where: {
     *     // ... filter to delete one AILog
     *   }
     * })
     * 
     */
    delete<T extends AILogDeleteArgs>(args: SelectSubset<T, AILogDeleteArgs<ExtArgs>>): Prisma__AILogClient<$Result.GetResult<Prisma.$AILogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AILog.
     * @param {AILogUpdateArgs} args - Arguments to update one AILog.
     * @example
     * // Update one AILog
     * const aILog = await prisma.aILog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AILogUpdateArgs>(args: SelectSubset<T, AILogUpdateArgs<ExtArgs>>): Prisma__AILogClient<$Result.GetResult<Prisma.$AILogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AILogs.
     * @param {AILogDeleteManyArgs} args - Arguments to filter AILogs to delete.
     * @example
     * // Delete a few AILogs
     * const { count } = await prisma.aILog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AILogDeleteManyArgs>(args?: SelectSubset<T, AILogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AILogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AILogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AILogs
     * const aILog = await prisma.aILog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AILogUpdateManyArgs>(args: SelectSubset<T, AILogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AILogs and returns the data updated in the database.
     * @param {AILogUpdateManyAndReturnArgs} args - Arguments to update many AILogs.
     * @example
     * // Update many AILogs
     * const aILog = await prisma.aILog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AILogs and only return the `id`
     * const aILogWithIdOnly = await prisma.aILog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AILogUpdateManyAndReturnArgs>(args: SelectSubset<T, AILogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AILogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AILog.
     * @param {AILogUpsertArgs} args - Arguments to update or create a AILog.
     * @example
     * // Update or create a AILog
     * const aILog = await prisma.aILog.upsert({
     *   create: {
     *     // ... data to create a AILog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AILog we want to update
     *   }
     * })
     */
    upsert<T extends AILogUpsertArgs>(args: SelectSubset<T, AILogUpsertArgs<ExtArgs>>): Prisma__AILogClient<$Result.GetResult<Prisma.$AILogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AILogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AILogCountArgs} args - Arguments to filter AILogs to count.
     * @example
     * // Count the number of AILogs
     * const count = await prisma.aILog.count({
     *   where: {
     *     // ... the filter for the AILogs we want to count
     *   }
     * })
    **/
    count<T extends AILogCountArgs>(
      args?: Subset<T, AILogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AILogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AILog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AILogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AILogAggregateArgs>(args: Subset<T, AILogAggregateArgs>): Prisma.PrismaPromise<GetAILogAggregateType<T>>

    /**
     * Group by AILog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AILogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AILogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AILogGroupByArgs['orderBy'] }
        : { orderBy?: AILogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AILogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAILogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AILog model
   */
  readonly fields: AILogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AILog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AILogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AILog model
   */
  interface AILogFieldRefs {
    readonly id: FieldRef<"AILog", 'String'>
    readonly tenantId: FieldRef<"AILog", 'String'>
    readonly feature: FieldRef<"AILog", 'String'>
    readonly model: FieldRef<"AILog", 'String'>
    readonly promptTokens: FieldRef<"AILog", 'Int'>
    readonly completionTokens: FieldRef<"AILog", 'Int'>
    readonly totalTokens: FieldRef<"AILog", 'Int'>
    readonly estimatedCost: FieldRef<"AILog", 'Float'>
    readonly input: FieldRef<"AILog", 'Json'>
    readonly output: FieldRef<"AILog", 'Json'>
    readonly latencyMs: FieldRef<"AILog", 'Int'>
    readonly success: FieldRef<"AILog", 'Boolean'>
    readonly error: FieldRef<"AILog", 'String'>
    readonly createdAt: FieldRef<"AILog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AILog findUnique
   */
  export type AILogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AILog
     */
    select?: AILogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AILog
     */
    omit?: AILogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AILogInclude<ExtArgs> | null
    /**
     * Filter, which AILog to fetch.
     */
    where: AILogWhereUniqueInput
  }

  /**
   * AILog findUniqueOrThrow
   */
  export type AILogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AILog
     */
    select?: AILogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AILog
     */
    omit?: AILogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AILogInclude<ExtArgs> | null
    /**
     * Filter, which AILog to fetch.
     */
    where: AILogWhereUniqueInput
  }

  /**
   * AILog findFirst
   */
  export type AILogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AILog
     */
    select?: AILogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AILog
     */
    omit?: AILogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AILogInclude<ExtArgs> | null
    /**
     * Filter, which AILog to fetch.
     */
    where?: AILogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AILogs to fetch.
     */
    orderBy?: AILogOrderByWithRelationInput | AILogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AILogs.
     */
    cursor?: AILogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AILogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AILogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AILogs.
     */
    distinct?: AILogScalarFieldEnum | AILogScalarFieldEnum[]
  }

  /**
   * AILog findFirstOrThrow
   */
  export type AILogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AILog
     */
    select?: AILogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AILog
     */
    omit?: AILogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AILogInclude<ExtArgs> | null
    /**
     * Filter, which AILog to fetch.
     */
    where?: AILogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AILogs to fetch.
     */
    orderBy?: AILogOrderByWithRelationInput | AILogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AILogs.
     */
    cursor?: AILogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AILogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AILogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AILogs.
     */
    distinct?: AILogScalarFieldEnum | AILogScalarFieldEnum[]
  }

  /**
   * AILog findMany
   */
  export type AILogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AILog
     */
    select?: AILogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AILog
     */
    omit?: AILogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AILogInclude<ExtArgs> | null
    /**
     * Filter, which AILogs to fetch.
     */
    where?: AILogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AILogs to fetch.
     */
    orderBy?: AILogOrderByWithRelationInput | AILogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AILogs.
     */
    cursor?: AILogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AILogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AILogs.
     */
    skip?: number
    distinct?: AILogScalarFieldEnum | AILogScalarFieldEnum[]
  }

  /**
   * AILog create
   */
  export type AILogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AILog
     */
    select?: AILogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AILog
     */
    omit?: AILogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AILogInclude<ExtArgs> | null
    /**
     * The data needed to create a AILog.
     */
    data: XOR<AILogCreateInput, AILogUncheckedCreateInput>
  }

  /**
   * AILog createMany
   */
  export type AILogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AILogs.
     */
    data: AILogCreateManyInput | AILogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AILog createManyAndReturn
   */
  export type AILogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AILog
     */
    select?: AILogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AILog
     */
    omit?: AILogOmit<ExtArgs> | null
    /**
     * The data used to create many AILogs.
     */
    data: AILogCreateManyInput | AILogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AILogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AILog update
   */
  export type AILogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AILog
     */
    select?: AILogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AILog
     */
    omit?: AILogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AILogInclude<ExtArgs> | null
    /**
     * The data needed to update a AILog.
     */
    data: XOR<AILogUpdateInput, AILogUncheckedUpdateInput>
    /**
     * Choose, which AILog to update.
     */
    where: AILogWhereUniqueInput
  }

  /**
   * AILog updateMany
   */
  export type AILogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AILogs.
     */
    data: XOR<AILogUpdateManyMutationInput, AILogUncheckedUpdateManyInput>
    /**
     * Filter which AILogs to update
     */
    where?: AILogWhereInput
    /**
     * Limit how many AILogs to update.
     */
    limit?: number
  }

  /**
   * AILog updateManyAndReturn
   */
  export type AILogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AILog
     */
    select?: AILogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AILog
     */
    omit?: AILogOmit<ExtArgs> | null
    /**
     * The data used to update AILogs.
     */
    data: XOR<AILogUpdateManyMutationInput, AILogUncheckedUpdateManyInput>
    /**
     * Filter which AILogs to update
     */
    where?: AILogWhereInput
    /**
     * Limit how many AILogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AILogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AILog upsert
   */
  export type AILogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AILog
     */
    select?: AILogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AILog
     */
    omit?: AILogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AILogInclude<ExtArgs> | null
    /**
     * The filter to search for the AILog to update in case it exists.
     */
    where: AILogWhereUniqueInput
    /**
     * In case the AILog found by the `where` argument doesn't exist, create a new AILog with this data.
     */
    create: XOR<AILogCreateInput, AILogUncheckedCreateInput>
    /**
     * In case the AILog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AILogUpdateInput, AILogUncheckedUpdateInput>
  }

  /**
   * AILog delete
   */
  export type AILogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AILog
     */
    select?: AILogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AILog
     */
    omit?: AILogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AILogInclude<ExtArgs> | null
    /**
     * Filter which AILog to delete.
     */
    where: AILogWhereUniqueInput
  }

  /**
   * AILog deleteMany
   */
  export type AILogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AILogs to delete
     */
    where?: AILogWhereInput
    /**
     * Limit how many AILogs to delete.
     */
    limit?: number
  }

  /**
   * AILog without action
   */
  export type AILogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AILog
     */
    select?: AILogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AILog
     */
    omit?: AILogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AILogInclude<ExtArgs> | null
  }


  /**
   * Model Currency
   */

  export type AggregateCurrency = {
    _count: CurrencyCountAggregateOutputType | null
    _avg: CurrencyAvgAggregateOutputType | null
    _sum: CurrencySumAggregateOutputType | null
    _min: CurrencyMinAggregateOutputType | null
    _max: CurrencyMaxAggregateOutputType | null
  }

  export type CurrencyAvgAggregateOutputType = {
    decimals: number | null
  }

  export type CurrencySumAggregateOutputType = {
    decimals: number | null
  }

  export type CurrencyMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    symbol: string | null
    decimals: number | null
    isCrypto: boolean | null
    isStablecoin: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CurrencyMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    symbol: string | null
    decimals: number | null
    isCrypto: boolean | null
    isStablecoin: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CurrencyCountAggregateOutputType = {
    id: number
    code: number
    name: number
    symbol: number
    decimals: number
    isCrypto: number
    isStablecoin: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CurrencyAvgAggregateInputType = {
    decimals?: true
  }

  export type CurrencySumAggregateInputType = {
    decimals?: true
  }

  export type CurrencyMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    symbol?: true
    decimals?: true
    isCrypto?: true
    isStablecoin?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CurrencyMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    symbol?: true
    decimals?: true
    isCrypto?: true
    isStablecoin?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CurrencyCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    symbol?: true
    decimals?: true
    isCrypto?: true
    isStablecoin?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CurrencyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Currency to aggregate.
     */
    where?: CurrencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Currencies to fetch.
     */
    orderBy?: CurrencyOrderByWithRelationInput | CurrencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CurrencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Currencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Currencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Currencies
    **/
    _count?: true | CurrencyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CurrencyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CurrencySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CurrencyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CurrencyMaxAggregateInputType
  }

  export type GetCurrencyAggregateType<T extends CurrencyAggregateArgs> = {
        [P in keyof T & keyof AggregateCurrency]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCurrency[P]>
      : GetScalarType<T[P], AggregateCurrency[P]>
  }




  export type CurrencyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CurrencyWhereInput
    orderBy?: CurrencyOrderByWithAggregationInput | CurrencyOrderByWithAggregationInput[]
    by: CurrencyScalarFieldEnum[] | CurrencyScalarFieldEnum
    having?: CurrencyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CurrencyCountAggregateInputType | true
    _avg?: CurrencyAvgAggregateInputType
    _sum?: CurrencySumAggregateInputType
    _min?: CurrencyMinAggregateInputType
    _max?: CurrencyMaxAggregateInputType
  }

  export type CurrencyGroupByOutputType = {
    id: string
    code: string
    name: string
    symbol: string
    decimals: number
    isCrypto: boolean
    isStablecoin: boolean
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: CurrencyCountAggregateOutputType | null
    _avg: CurrencyAvgAggregateOutputType | null
    _sum: CurrencySumAggregateOutputType | null
    _min: CurrencyMinAggregateOutputType | null
    _max: CurrencyMaxAggregateOutputType | null
  }

  type GetCurrencyGroupByPayload<T extends CurrencyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CurrencyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CurrencyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CurrencyGroupByOutputType[P]>
            : GetScalarType<T[P], CurrencyGroupByOutputType[P]>
        }
      >
    >


  export type CurrencySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    symbol?: boolean
    decimals?: boolean
    isCrypto?: boolean
    isStablecoin?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    exchangeRatesFrom?: boolean | Currency$exchangeRatesFromArgs<ExtArgs>
    exchangeRatesTo?: boolean | Currency$exchangeRatesToArgs<ExtArgs>
    _count?: boolean | CurrencyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["currency"]>

  export type CurrencySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    symbol?: boolean
    decimals?: boolean
    isCrypto?: boolean
    isStablecoin?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["currency"]>

  export type CurrencySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    symbol?: boolean
    decimals?: boolean
    isCrypto?: boolean
    isStablecoin?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["currency"]>

  export type CurrencySelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    symbol?: boolean
    decimals?: boolean
    isCrypto?: boolean
    isStablecoin?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CurrencyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "symbol" | "decimals" | "isCrypto" | "isStablecoin" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["currency"]>
  export type CurrencyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exchangeRatesFrom?: boolean | Currency$exchangeRatesFromArgs<ExtArgs>
    exchangeRatesTo?: boolean | Currency$exchangeRatesToArgs<ExtArgs>
    _count?: boolean | CurrencyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CurrencyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CurrencyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CurrencyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Currency"
    objects: {
      exchangeRatesFrom: Prisma.$ExchangeRatePayload<ExtArgs>[]
      exchangeRatesTo: Prisma.$ExchangeRatePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      symbol: string
      decimals: number
      isCrypto: boolean
      isStablecoin: boolean
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["currency"]>
    composites: {}
  }

  type CurrencyGetPayload<S extends boolean | null | undefined | CurrencyDefaultArgs> = $Result.GetResult<Prisma.$CurrencyPayload, S>

  type CurrencyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CurrencyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CurrencyCountAggregateInputType | true
    }

  export interface CurrencyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Currency'], meta: { name: 'Currency' } }
    /**
     * Find zero or one Currency that matches the filter.
     * @param {CurrencyFindUniqueArgs} args - Arguments to find a Currency
     * @example
     * // Get one Currency
     * const currency = await prisma.currency.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CurrencyFindUniqueArgs>(args: SelectSubset<T, CurrencyFindUniqueArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Currency that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CurrencyFindUniqueOrThrowArgs} args - Arguments to find a Currency
     * @example
     * // Get one Currency
     * const currency = await prisma.currency.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CurrencyFindUniqueOrThrowArgs>(args: SelectSubset<T, CurrencyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Currency that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyFindFirstArgs} args - Arguments to find a Currency
     * @example
     * // Get one Currency
     * const currency = await prisma.currency.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CurrencyFindFirstArgs>(args?: SelectSubset<T, CurrencyFindFirstArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Currency that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyFindFirstOrThrowArgs} args - Arguments to find a Currency
     * @example
     * // Get one Currency
     * const currency = await prisma.currency.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CurrencyFindFirstOrThrowArgs>(args?: SelectSubset<T, CurrencyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Currencies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Currencies
     * const currencies = await prisma.currency.findMany()
     * 
     * // Get first 10 Currencies
     * const currencies = await prisma.currency.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const currencyWithIdOnly = await prisma.currency.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CurrencyFindManyArgs>(args?: SelectSubset<T, CurrencyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Currency.
     * @param {CurrencyCreateArgs} args - Arguments to create a Currency.
     * @example
     * // Create one Currency
     * const Currency = await prisma.currency.create({
     *   data: {
     *     // ... data to create a Currency
     *   }
     * })
     * 
     */
    create<T extends CurrencyCreateArgs>(args: SelectSubset<T, CurrencyCreateArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Currencies.
     * @param {CurrencyCreateManyArgs} args - Arguments to create many Currencies.
     * @example
     * // Create many Currencies
     * const currency = await prisma.currency.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CurrencyCreateManyArgs>(args?: SelectSubset<T, CurrencyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Currencies and returns the data saved in the database.
     * @param {CurrencyCreateManyAndReturnArgs} args - Arguments to create many Currencies.
     * @example
     * // Create many Currencies
     * const currency = await prisma.currency.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Currencies and only return the `id`
     * const currencyWithIdOnly = await prisma.currency.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CurrencyCreateManyAndReturnArgs>(args?: SelectSubset<T, CurrencyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Currency.
     * @param {CurrencyDeleteArgs} args - Arguments to delete one Currency.
     * @example
     * // Delete one Currency
     * const Currency = await prisma.currency.delete({
     *   where: {
     *     // ... filter to delete one Currency
     *   }
     * })
     * 
     */
    delete<T extends CurrencyDeleteArgs>(args: SelectSubset<T, CurrencyDeleteArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Currency.
     * @param {CurrencyUpdateArgs} args - Arguments to update one Currency.
     * @example
     * // Update one Currency
     * const currency = await prisma.currency.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CurrencyUpdateArgs>(args: SelectSubset<T, CurrencyUpdateArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Currencies.
     * @param {CurrencyDeleteManyArgs} args - Arguments to filter Currencies to delete.
     * @example
     * // Delete a few Currencies
     * const { count } = await prisma.currency.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CurrencyDeleteManyArgs>(args?: SelectSubset<T, CurrencyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Currencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Currencies
     * const currency = await prisma.currency.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CurrencyUpdateManyArgs>(args: SelectSubset<T, CurrencyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Currencies and returns the data updated in the database.
     * @param {CurrencyUpdateManyAndReturnArgs} args - Arguments to update many Currencies.
     * @example
     * // Update many Currencies
     * const currency = await prisma.currency.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Currencies and only return the `id`
     * const currencyWithIdOnly = await prisma.currency.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CurrencyUpdateManyAndReturnArgs>(args: SelectSubset<T, CurrencyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Currency.
     * @param {CurrencyUpsertArgs} args - Arguments to update or create a Currency.
     * @example
     * // Update or create a Currency
     * const currency = await prisma.currency.upsert({
     *   create: {
     *     // ... data to create a Currency
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Currency we want to update
     *   }
     * })
     */
    upsert<T extends CurrencyUpsertArgs>(args: SelectSubset<T, CurrencyUpsertArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Currencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyCountArgs} args - Arguments to filter Currencies to count.
     * @example
     * // Count the number of Currencies
     * const count = await prisma.currency.count({
     *   where: {
     *     // ... the filter for the Currencies we want to count
     *   }
     * })
    **/
    count<T extends CurrencyCountArgs>(
      args?: Subset<T, CurrencyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CurrencyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Currency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CurrencyAggregateArgs>(args: Subset<T, CurrencyAggregateArgs>): Prisma.PrismaPromise<GetCurrencyAggregateType<T>>

    /**
     * Group by Currency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CurrencyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CurrencyGroupByArgs['orderBy'] }
        : { orderBy?: CurrencyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CurrencyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCurrencyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Currency model
   */
  readonly fields: CurrencyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Currency.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CurrencyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    exchangeRatesFrom<T extends Currency$exchangeRatesFromArgs<ExtArgs> = {}>(args?: Subset<T, Currency$exchangeRatesFromArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExchangeRatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    exchangeRatesTo<T extends Currency$exchangeRatesToArgs<ExtArgs> = {}>(args?: Subset<T, Currency$exchangeRatesToArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExchangeRatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Currency model
   */
  interface CurrencyFieldRefs {
    readonly id: FieldRef<"Currency", 'String'>
    readonly code: FieldRef<"Currency", 'String'>
    readonly name: FieldRef<"Currency", 'String'>
    readonly symbol: FieldRef<"Currency", 'String'>
    readonly decimals: FieldRef<"Currency", 'Int'>
    readonly isCrypto: FieldRef<"Currency", 'Boolean'>
    readonly isStablecoin: FieldRef<"Currency", 'Boolean'>
    readonly isActive: FieldRef<"Currency", 'Boolean'>
    readonly createdAt: FieldRef<"Currency", 'DateTime'>
    readonly updatedAt: FieldRef<"Currency", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Currency findUnique
   */
  export type CurrencyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * Filter, which Currency to fetch.
     */
    where: CurrencyWhereUniqueInput
  }

  /**
   * Currency findUniqueOrThrow
   */
  export type CurrencyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * Filter, which Currency to fetch.
     */
    where: CurrencyWhereUniqueInput
  }

  /**
   * Currency findFirst
   */
  export type CurrencyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * Filter, which Currency to fetch.
     */
    where?: CurrencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Currencies to fetch.
     */
    orderBy?: CurrencyOrderByWithRelationInput | CurrencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Currencies.
     */
    cursor?: CurrencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Currencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Currencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Currencies.
     */
    distinct?: CurrencyScalarFieldEnum | CurrencyScalarFieldEnum[]
  }

  /**
   * Currency findFirstOrThrow
   */
  export type CurrencyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * Filter, which Currency to fetch.
     */
    where?: CurrencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Currencies to fetch.
     */
    orderBy?: CurrencyOrderByWithRelationInput | CurrencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Currencies.
     */
    cursor?: CurrencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Currencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Currencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Currencies.
     */
    distinct?: CurrencyScalarFieldEnum | CurrencyScalarFieldEnum[]
  }

  /**
   * Currency findMany
   */
  export type CurrencyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * Filter, which Currencies to fetch.
     */
    where?: CurrencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Currencies to fetch.
     */
    orderBy?: CurrencyOrderByWithRelationInput | CurrencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Currencies.
     */
    cursor?: CurrencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Currencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Currencies.
     */
    skip?: number
    distinct?: CurrencyScalarFieldEnum | CurrencyScalarFieldEnum[]
  }

  /**
   * Currency create
   */
  export type CurrencyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * The data needed to create a Currency.
     */
    data: XOR<CurrencyCreateInput, CurrencyUncheckedCreateInput>
  }

  /**
   * Currency createMany
   */
  export type CurrencyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Currencies.
     */
    data: CurrencyCreateManyInput | CurrencyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Currency createManyAndReturn
   */
  export type CurrencyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * The data used to create many Currencies.
     */
    data: CurrencyCreateManyInput | CurrencyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Currency update
   */
  export type CurrencyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * The data needed to update a Currency.
     */
    data: XOR<CurrencyUpdateInput, CurrencyUncheckedUpdateInput>
    /**
     * Choose, which Currency to update.
     */
    where: CurrencyWhereUniqueInput
  }

  /**
   * Currency updateMany
   */
  export type CurrencyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Currencies.
     */
    data: XOR<CurrencyUpdateManyMutationInput, CurrencyUncheckedUpdateManyInput>
    /**
     * Filter which Currencies to update
     */
    where?: CurrencyWhereInput
    /**
     * Limit how many Currencies to update.
     */
    limit?: number
  }

  /**
   * Currency updateManyAndReturn
   */
  export type CurrencyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * The data used to update Currencies.
     */
    data: XOR<CurrencyUpdateManyMutationInput, CurrencyUncheckedUpdateManyInput>
    /**
     * Filter which Currencies to update
     */
    where?: CurrencyWhereInput
    /**
     * Limit how many Currencies to update.
     */
    limit?: number
  }

  /**
   * Currency upsert
   */
  export type CurrencyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * The filter to search for the Currency to update in case it exists.
     */
    where: CurrencyWhereUniqueInput
    /**
     * In case the Currency found by the `where` argument doesn't exist, create a new Currency with this data.
     */
    create: XOR<CurrencyCreateInput, CurrencyUncheckedCreateInput>
    /**
     * In case the Currency was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CurrencyUpdateInput, CurrencyUncheckedUpdateInput>
  }

  /**
   * Currency delete
   */
  export type CurrencyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * Filter which Currency to delete.
     */
    where: CurrencyWhereUniqueInput
  }

  /**
   * Currency deleteMany
   */
  export type CurrencyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Currencies to delete
     */
    where?: CurrencyWhereInput
    /**
     * Limit how many Currencies to delete.
     */
    limit?: number
  }

  /**
   * Currency.exchangeRatesFrom
   */
  export type Currency$exchangeRatesFromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeRate
     */
    select?: ExchangeRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExchangeRate
     */
    omit?: ExchangeRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangeRateInclude<ExtArgs> | null
    where?: ExchangeRateWhereInput
    orderBy?: ExchangeRateOrderByWithRelationInput | ExchangeRateOrderByWithRelationInput[]
    cursor?: ExchangeRateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExchangeRateScalarFieldEnum | ExchangeRateScalarFieldEnum[]
  }

  /**
   * Currency.exchangeRatesTo
   */
  export type Currency$exchangeRatesToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeRate
     */
    select?: ExchangeRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExchangeRate
     */
    omit?: ExchangeRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangeRateInclude<ExtArgs> | null
    where?: ExchangeRateWhereInput
    orderBy?: ExchangeRateOrderByWithRelationInput | ExchangeRateOrderByWithRelationInput[]
    cursor?: ExchangeRateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExchangeRateScalarFieldEnum | ExchangeRateScalarFieldEnum[]
  }

  /**
   * Currency without action
   */
  export type CurrencyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
  }


  /**
   * Model ExchangeRate
   */

  export type AggregateExchangeRate = {
    _count: ExchangeRateCountAggregateOutputType | null
    _avg: ExchangeRateAvgAggregateOutputType | null
    _sum: ExchangeRateSumAggregateOutputType | null
    _min: ExchangeRateMinAggregateOutputType | null
    _max: ExchangeRateMaxAggregateOutputType | null
  }

  export type ExchangeRateAvgAggregateOutputType = {
    rate: Decimal | null
  }

  export type ExchangeRateSumAggregateOutputType = {
    rate: Decimal | null
  }

  export type ExchangeRateMinAggregateOutputType = {
    id: string | null
    fromCurrencyId: string | null
    toCurrencyId: string | null
    rate: Decimal | null
    source: string | null
    timestamp: Date | null
  }

  export type ExchangeRateMaxAggregateOutputType = {
    id: string | null
    fromCurrencyId: string | null
    toCurrencyId: string | null
    rate: Decimal | null
    source: string | null
    timestamp: Date | null
  }

  export type ExchangeRateCountAggregateOutputType = {
    id: number
    fromCurrencyId: number
    toCurrencyId: number
    rate: number
    source: number
    timestamp: number
    _all: number
  }


  export type ExchangeRateAvgAggregateInputType = {
    rate?: true
  }

  export type ExchangeRateSumAggregateInputType = {
    rate?: true
  }

  export type ExchangeRateMinAggregateInputType = {
    id?: true
    fromCurrencyId?: true
    toCurrencyId?: true
    rate?: true
    source?: true
    timestamp?: true
  }

  export type ExchangeRateMaxAggregateInputType = {
    id?: true
    fromCurrencyId?: true
    toCurrencyId?: true
    rate?: true
    source?: true
    timestamp?: true
  }

  export type ExchangeRateCountAggregateInputType = {
    id?: true
    fromCurrencyId?: true
    toCurrencyId?: true
    rate?: true
    source?: true
    timestamp?: true
    _all?: true
  }

  export type ExchangeRateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExchangeRate to aggregate.
     */
    where?: ExchangeRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExchangeRates to fetch.
     */
    orderBy?: ExchangeRateOrderByWithRelationInput | ExchangeRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExchangeRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExchangeRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExchangeRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExchangeRates
    **/
    _count?: true | ExchangeRateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExchangeRateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExchangeRateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExchangeRateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExchangeRateMaxAggregateInputType
  }

  export type GetExchangeRateAggregateType<T extends ExchangeRateAggregateArgs> = {
        [P in keyof T & keyof AggregateExchangeRate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExchangeRate[P]>
      : GetScalarType<T[P], AggregateExchangeRate[P]>
  }




  export type ExchangeRateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExchangeRateWhereInput
    orderBy?: ExchangeRateOrderByWithAggregationInput | ExchangeRateOrderByWithAggregationInput[]
    by: ExchangeRateScalarFieldEnum[] | ExchangeRateScalarFieldEnum
    having?: ExchangeRateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExchangeRateCountAggregateInputType | true
    _avg?: ExchangeRateAvgAggregateInputType
    _sum?: ExchangeRateSumAggregateInputType
    _min?: ExchangeRateMinAggregateInputType
    _max?: ExchangeRateMaxAggregateInputType
  }

  export type ExchangeRateGroupByOutputType = {
    id: string
    fromCurrencyId: string
    toCurrencyId: string
    rate: Decimal
    source: string
    timestamp: Date
    _count: ExchangeRateCountAggregateOutputType | null
    _avg: ExchangeRateAvgAggregateOutputType | null
    _sum: ExchangeRateSumAggregateOutputType | null
    _min: ExchangeRateMinAggregateOutputType | null
    _max: ExchangeRateMaxAggregateOutputType | null
  }

  type GetExchangeRateGroupByPayload<T extends ExchangeRateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExchangeRateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExchangeRateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExchangeRateGroupByOutputType[P]>
            : GetScalarType<T[P], ExchangeRateGroupByOutputType[P]>
        }
      >
    >


  export type ExchangeRateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fromCurrencyId?: boolean
    toCurrencyId?: boolean
    rate?: boolean
    source?: boolean
    timestamp?: boolean
    fromCurrency?: boolean | CurrencyDefaultArgs<ExtArgs>
    toCurrency?: boolean | CurrencyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exchangeRate"]>

  export type ExchangeRateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fromCurrencyId?: boolean
    toCurrencyId?: boolean
    rate?: boolean
    source?: boolean
    timestamp?: boolean
    fromCurrency?: boolean | CurrencyDefaultArgs<ExtArgs>
    toCurrency?: boolean | CurrencyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exchangeRate"]>

  export type ExchangeRateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fromCurrencyId?: boolean
    toCurrencyId?: boolean
    rate?: boolean
    source?: boolean
    timestamp?: boolean
    fromCurrency?: boolean | CurrencyDefaultArgs<ExtArgs>
    toCurrency?: boolean | CurrencyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exchangeRate"]>

  export type ExchangeRateSelectScalar = {
    id?: boolean
    fromCurrencyId?: boolean
    toCurrencyId?: boolean
    rate?: boolean
    source?: boolean
    timestamp?: boolean
  }

  export type ExchangeRateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "fromCurrencyId" | "toCurrencyId" | "rate" | "source" | "timestamp", ExtArgs["result"]["exchangeRate"]>
  export type ExchangeRateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fromCurrency?: boolean | CurrencyDefaultArgs<ExtArgs>
    toCurrency?: boolean | CurrencyDefaultArgs<ExtArgs>
  }
  export type ExchangeRateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fromCurrency?: boolean | CurrencyDefaultArgs<ExtArgs>
    toCurrency?: boolean | CurrencyDefaultArgs<ExtArgs>
  }
  export type ExchangeRateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fromCurrency?: boolean | CurrencyDefaultArgs<ExtArgs>
    toCurrency?: boolean | CurrencyDefaultArgs<ExtArgs>
  }

  export type $ExchangeRatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExchangeRate"
    objects: {
      fromCurrency: Prisma.$CurrencyPayload<ExtArgs>
      toCurrency: Prisma.$CurrencyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      fromCurrencyId: string
      toCurrencyId: string
      rate: Prisma.Decimal
      source: string
      timestamp: Date
    }, ExtArgs["result"]["exchangeRate"]>
    composites: {}
  }

  type ExchangeRateGetPayload<S extends boolean | null | undefined | ExchangeRateDefaultArgs> = $Result.GetResult<Prisma.$ExchangeRatePayload, S>

  type ExchangeRateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExchangeRateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExchangeRateCountAggregateInputType | true
    }

  export interface ExchangeRateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExchangeRate'], meta: { name: 'ExchangeRate' } }
    /**
     * Find zero or one ExchangeRate that matches the filter.
     * @param {ExchangeRateFindUniqueArgs} args - Arguments to find a ExchangeRate
     * @example
     * // Get one ExchangeRate
     * const exchangeRate = await prisma.exchangeRate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExchangeRateFindUniqueArgs>(args: SelectSubset<T, ExchangeRateFindUniqueArgs<ExtArgs>>): Prisma__ExchangeRateClient<$Result.GetResult<Prisma.$ExchangeRatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ExchangeRate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExchangeRateFindUniqueOrThrowArgs} args - Arguments to find a ExchangeRate
     * @example
     * // Get one ExchangeRate
     * const exchangeRate = await prisma.exchangeRate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExchangeRateFindUniqueOrThrowArgs>(args: SelectSubset<T, ExchangeRateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExchangeRateClient<$Result.GetResult<Prisma.$ExchangeRatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExchangeRate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExchangeRateFindFirstArgs} args - Arguments to find a ExchangeRate
     * @example
     * // Get one ExchangeRate
     * const exchangeRate = await prisma.exchangeRate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExchangeRateFindFirstArgs>(args?: SelectSubset<T, ExchangeRateFindFirstArgs<ExtArgs>>): Prisma__ExchangeRateClient<$Result.GetResult<Prisma.$ExchangeRatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExchangeRate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExchangeRateFindFirstOrThrowArgs} args - Arguments to find a ExchangeRate
     * @example
     * // Get one ExchangeRate
     * const exchangeRate = await prisma.exchangeRate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExchangeRateFindFirstOrThrowArgs>(args?: SelectSubset<T, ExchangeRateFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExchangeRateClient<$Result.GetResult<Prisma.$ExchangeRatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExchangeRates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExchangeRateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExchangeRates
     * const exchangeRates = await prisma.exchangeRate.findMany()
     * 
     * // Get first 10 ExchangeRates
     * const exchangeRates = await prisma.exchangeRate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const exchangeRateWithIdOnly = await prisma.exchangeRate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExchangeRateFindManyArgs>(args?: SelectSubset<T, ExchangeRateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExchangeRatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ExchangeRate.
     * @param {ExchangeRateCreateArgs} args - Arguments to create a ExchangeRate.
     * @example
     * // Create one ExchangeRate
     * const ExchangeRate = await prisma.exchangeRate.create({
     *   data: {
     *     // ... data to create a ExchangeRate
     *   }
     * })
     * 
     */
    create<T extends ExchangeRateCreateArgs>(args: SelectSubset<T, ExchangeRateCreateArgs<ExtArgs>>): Prisma__ExchangeRateClient<$Result.GetResult<Prisma.$ExchangeRatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ExchangeRates.
     * @param {ExchangeRateCreateManyArgs} args - Arguments to create many ExchangeRates.
     * @example
     * // Create many ExchangeRates
     * const exchangeRate = await prisma.exchangeRate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExchangeRateCreateManyArgs>(args?: SelectSubset<T, ExchangeRateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExchangeRates and returns the data saved in the database.
     * @param {ExchangeRateCreateManyAndReturnArgs} args - Arguments to create many ExchangeRates.
     * @example
     * // Create many ExchangeRates
     * const exchangeRate = await prisma.exchangeRate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExchangeRates and only return the `id`
     * const exchangeRateWithIdOnly = await prisma.exchangeRate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExchangeRateCreateManyAndReturnArgs>(args?: SelectSubset<T, ExchangeRateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExchangeRatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ExchangeRate.
     * @param {ExchangeRateDeleteArgs} args - Arguments to delete one ExchangeRate.
     * @example
     * // Delete one ExchangeRate
     * const ExchangeRate = await prisma.exchangeRate.delete({
     *   where: {
     *     // ... filter to delete one ExchangeRate
     *   }
     * })
     * 
     */
    delete<T extends ExchangeRateDeleteArgs>(args: SelectSubset<T, ExchangeRateDeleteArgs<ExtArgs>>): Prisma__ExchangeRateClient<$Result.GetResult<Prisma.$ExchangeRatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ExchangeRate.
     * @param {ExchangeRateUpdateArgs} args - Arguments to update one ExchangeRate.
     * @example
     * // Update one ExchangeRate
     * const exchangeRate = await prisma.exchangeRate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExchangeRateUpdateArgs>(args: SelectSubset<T, ExchangeRateUpdateArgs<ExtArgs>>): Prisma__ExchangeRateClient<$Result.GetResult<Prisma.$ExchangeRatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ExchangeRates.
     * @param {ExchangeRateDeleteManyArgs} args - Arguments to filter ExchangeRates to delete.
     * @example
     * // Delete a few ExchangeRates
     * const { count } = await prisma.exchangeRate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExchangeRateDeleteManyArgs>(args?: SelectSubset<T, ExchangeRateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExchangeRates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExchangeRateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExchangeRates
     * const exchangeRate = await prisma.exchangeRate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExchangeRateUpdateManyArgs>(args: SelectSubset<T, ExchangeRateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExchangeRates and returns the data updated in the database.
     * @param {ExchangeRateUpdateManyAndReturnArgs} args - Arguments to update many ExchangeRates.
     * @example
     * // Update many ExchangeRates
     * const exchangeRate = await prisma.exchangeRate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ExchangeRates and only return the `id`
     * const exchangeRateWithIdOnly = await prisma.exchangeRate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExchangeRateUpdateManyAndReturnArgs>(args: SelectSubset<T, ExchangeRateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExchangeRatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ExchangeRate.
     * @param {ExchangeRateUpsertArgs} args - Arguments to update or create a ExchangeRate.
     * @example
     * // Update or create a ExchangeRate
     * const exchangeRate = await prisma.exchangeRate.upsert({
     *   create: {
     *     // ... data to create a ExchangeRate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExchangeRate we want to update
     *   }
     * })
     */
    upsert<T extends ExchangeRateUpsertArgs>(args: SelectSubset<T, ExchangeRateUpsertArgs<ExtArgs>>): Prisma__ExchangeRateClient<$Result.GetResult<Prisma.$ExchangeRatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ExchangeRates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExchangeRateCountArgs} args - Arguments to filter ExchangeRates to count.
     * @example
     * // Count the number of ExchangeRates
     * const count = await prisma.exchangeRate.count({
     *   where: {
     *     // ... the filter for the ExchangeRates we want to count
     *   }
     * })
    **/
    count<T extends ExchangeRateCountArgs>(
      args?: Subset<T, ExchangeRateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExchangeRateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExchangeRate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExchangeRateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExchangeRateAggregateArgs>(args: Subset<T, ExchangeRateAggregateArgs>): Prisma.PrismaPromise<GetExchangeRateAggregateType<T>>

    /**
     * Group by ExchangeRate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExchangeRateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExchangeRateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExchangeRateGroupByArgs['orderBy'] }
        : { orderBy?: ExchangeRateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExchangeRateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExchangeRateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExchangeRate model
   */
  readonly fields: ExchangeRateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExchangeRate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExchangeRateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    fromCurrency<T extends CurrencyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CurrencyDefaultArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    toCurrency<T extends CurrencyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CurrencyDefaultArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExchangeRate model
   */
  interface ExchangeRateFieldRefs {
    readonly id: FieldRef<"ExchangeRate", 'String'>
    readonly fromCurrencyId: FieldRef<"ExchangeRate", 'String'>
    readonly toCurrencyId: FieldRef<"ExchangeRate", 'String'>
    readonly rate: FieldRef<"ExchangeRate", 'Decimal'>
    readonly source: FieldRef<"ExchangeRate", 'String'>
    readonly timestamp: FieldRef<"ExchangeRate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExchangeRate findUnique
   */
  export type ExchangeRateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeRate
     */
    select?: ExchangeRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExchangeRate
     */
    omit?: ExchangeRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangeRateInclude<ExtArgs> | null
    /**
     * Filter, which ExchangeRate to fetch.
     */
    where: ExchangeRateWhereUniqueInput
  }

  /**
   * ExchangeRate findUniqueOrThrow
   */
  export type ExchangeRateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeRate
     */
    select?: ExchangeRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExchangeRate
     */
    omit?: ExchangeRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangeRateInclude<ExtArgs> | null
    /**
     * Filter, which ExchangeRate to fetch.
     */
    where: ExchangeRateWhereUniqueInput
  }

  /**
   * ExchangeRate findFirst
   */
  export type ExchangeRateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeRate
     */
    select?: ExchangeRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExchangeRate
     */
    omit?: ExchangeRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangeRateInclude<ExtArgs> | null
    /**
     * Filter, which ExchangeRate to fetch.
     */
    where?: ExchangeRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExchangeRates to fetch.
     */
    orderBy?: ExchangeRateOrderByWithRelationInput | ExchangeRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExchangeRates.
     */
    cursor?: ExchangeRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExchangeRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExchangeRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExchangeRates.
     */
    distinct?: ExchangeRateScalarFieldEnum | ExchangeRateScalarFieldEnum[]
  }

  /**
   * ExchangeRate findFirstOrThrow
   */
  export type ExchangeRateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeRate
     */
    select?: ExchangeRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExchangeRate
     */
    omit?: ExchangeRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangeRateInclude<ExtArgs> | null
    /**
     * Filter, which ExchangeRate to fetch.
     */
    where?: ExchangeRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExchangeRates to fetch.
     */
    orderBy?: ExchangeRateOrderByWithRelationInput | ExchangeRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExchangeRates.
     */
    cursor?: ExchangeRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExchangeRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExchangeRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExchangeRates.
     */
    distinct?: ExchangeRateScalarFieldEnum | ExchangeRateScalarFieldEnum[]
  }

  /**
   * ExchangeRate findMany
   */
  export type ExchangeRateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeRate
     */
    select?: ExchangeRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExchangeRate
     */
    omit?: ExchangeRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangeRateInclude<ExtArgs> | null
    /**
     * Filter, which ExchangeRates to fetch.
     */
    where?: ExchangeRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExchangeRates to fetch.
     */
    orderBy?: ExchangeRateOrderByWithRelationInput | ExchangeRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExchangeRates.
     */
    cursor?: ExchangeRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExchangeRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExchangeRates.
     */
    skip?: number
    distinct?: ExchangeRateScalarFieldEnum | ExchangeRateScalarFieldEnum[]
  }

  /**
   * ExchangeRate create
   */
  export type ExchangeRateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeRate
     */
    select?: ExchangeRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExchangeRate
     */
    omit?: ExchangeRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangeRateInclude<ExtArgs> | null
    /**
     * The data needed to create a ExchangeRate.
     */
    data: XOR<ExchangeRateCreateInput, ExchangeRateUncheckedCreateInput>
  }

  /**
   * ExchangeRate createMany
   */
  export type ExchangeRateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExchangeRates.
     */
    data: ExchangeRateCreateManyInput | ExchangeRateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExchangeRate createManyAndReturn
   */
  export type ExchangeRateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeRate
     */
    select?: ExchangeRateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExchangeRate
     */
    omit?: ExchangeRateOmit<ExtArgs> | null
    /**
     * The data used to create many ExchangeRates.
     */
    data: ExchangeRateCreateManyInput | ExchangeRateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangeRateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExchangeRate update
   */
  export type ExchangeRateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeRate
     */
    select?: ExchangeRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExchangeRate
     */
    omit?: ExchangeRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangeRateInclude<ExtArgs> | null
    /**
     * The data needed to update a ExchangeRate.
     */
    data: XOR<ExchangeRateUpdateInput, ExchangeRateUncheckedUpdateInput>
    /**
     * Choose, which ExchangeRate to update.
     */
    where: ExchangeRateWhereUniqueInput
  }

  /**
   * ExchangeRate updateMany
   */
  export type ExchangeRateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExchangeRates.
     */
    data: XOR<ExchangeRateUpdateManyMutationInput, ExchangeRateUncheckedUpdateManyInput>
    /**
     * Filter which ExchangeRates to update
     */
    where?: ExchangeRateWhereInput
    /**
     * Limit how many ExchangeRates to update.
     */
    limit?: number
  }

  /**
   * ExchangeRate updateManyAndReturn
   */
  export type ExchangeRateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeRate
     */
    select?: ExchangeRateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExchangeRate
     */
    omit?: ExchangeRateOmit<ExtArgs> | null
    /**
     * The data used to update ExchangeRates.
     */
    data: XOR<ExchangeRateUpdateManyMutationInput, ExchangeRateUncheckedUpdateManyInput>
    /**
     * Filter which ExchangeRates to update
     */
    where?: ExchangeRateWhereInput
    /**
     * Limit how many ExchangeRates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangeRateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExchangeRate upsert
   */
  export type ExchangeRateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeRate
     */
    select?: ExchangeRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExchangeRate
     */
    omit?: ExchangeRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangeRateInclude<ExtArgs> | null
    /**
     * The filter to search for the ExchangeRate to update in case it exists.
     */
    where: ExchangeRateWhereUniqueInput
    /**
     * In case the ExchangeRate found by the `where` argument doesn't exist, create a new ExchangeRate with this data.
     */
    create: XOR<ExchangeRateCreateInput, ExchangeRateUncheckedCreateInput>
    /**
     * In case the ExchangeRate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExchangeRateUpdateInput, ExchangeRateUncheckedUpdateInput>
  }

  /**
   * ExchangeRate delete
   */
  export type ExchangeRateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeRate
     */
    select?: ExchangeRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExchangeRate
     */
    omit?: ExchangeRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangeRateInclude<ExtArgs> | null
    /**
     * Filter which ExchangeRate to delete.
     */
    where: ExchangeRateWhereUniqueInput
  }

  /**
   * ExchangeRate deleteMany
   */
  export type ExchangeRateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExchangeRates to delete
     */
    where?: ExchangeRateWhereInput
    /**
     * Limit how many ExchangeRates to delete.
     */
    limit?: number
  }

  /**
   * ExchangeRate without action
   */
  export type ExchangeRateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeRate
     */
    select?: ExchangeRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExchangeRate
     */
    omit?: ExchangeRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangeRateInclude<ExtArgs> | null
  }


  /**
   * Model BankAccount
   */

  export type AggregateBankAccount = {
    _count: BankAccountCountAggregateOutputType | null
    _avg: BankAccountAvgAggregateOutputType | null
    _sum: BankAccountSumAggregateOutputType | null
    _min: BankAccountMinAggregateOutputType | null
    _max: BankAccountMaxAggregateOutputType | null
  }

  export type BankAccountAvgAggregateOutputType = {
    balance: Decimal | null
  }

  export type BankAccountSumAggregateOutputType = {
    balance: Decimal | null
  }

  export type BankAccountMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    accountName: string | null
    accountNumber: string | null
    bankCode: string | null
    iban: string | null
    swift: string | null
    provider: $Enums.BankProvider | null
    providerAccountId: string | null
    currency: string | null
    balance: Decimal | null
    balanceUpdatedAt: Date | null
    autoSync: boolean | null
    lastSyncAt: Date | null
    syncFrequency: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BankAccountMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    accountName: string | null
    accountNumber: string | null
    bankCode: string | null
    iban: string | null
    swift: string | null
    provider: $Enums.BankProvider | null
    providerAccountId: string | null
    currency: string | null
    balance: Decimal | null
    balanceUpdatedAt: Date | null
    autoSync: boolean | null
    lastSyncAt: Date | null
    syncFrequency: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BankAccountCountAggregateOutputType = {
    id: number
    tenantId: number
    accountName: number
    accountNumber: number
    bankCode: number
    iban: number
    swift: number
    provider: number
    providerAccountId: number
    currency: number
    balance: number
    balanceUpdatedAt: number
    autoSync: number
    lastSyncAt: number
    syncFrequency: number
    credentials: number
    isActive: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BankAccountAvgAggregateInputType = {
    balance?: true
  }

  export type BankAccountSumAggregateInputType = {
    balance?: true
  }

  export type BankAccountMinAggregateInputType = {
    id?: true
    tenantId?: true
    accountName?: true
    accountNumber?: true
    bankCode?: true
    iban?: true
    swift?: true
    provider?: true
    providerAccountId?: true
    currency?: true
    balance?: true
    balanceUpdatedAt?: true
    autoSync?: true
    lastSyncAt?: true
    syncFrequency?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BankAccountMaxAggregateInputType = {
    id?: true
    tenantId?: true
    accountName?: true
    accountNumber?: true
    bankCode?: true
    iban?: true
    swift?: true
    provider?: true
    providerAccountId?: true
    currency?: true
    balance?: true
    balanceUpdatedAt?: true
    autoSync?: true
    lastSyncAt?: true
    syncFrequency?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BankAccountCountAggregateInputType = {
    id?: true
    tenantId?: true
    accountName?: true
    accountNumber?: true
    bankCode?: true
    iban?: true
    swift?: true
    provider?: true
    providerAccountId?: true
    currency?: true
    balance?: true
    balanceUpdatedAt?: true
    autoSync?: true
    lastSyncAt?: true
    syncFrequency?: true
    credentials?: true
    isActive?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BankAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BankAccount to aggregate.
     */
    where?: BankAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankAccounts to fetch.
     */
    orderBy?: BankAccountOrderByWithRelationInput | BankAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BankAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BankAccounts
    **/
    _count?: true | BankAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BankAccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BankAccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BankAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BankAccountMaxAggregateInputType
  }

  export type GetBankAccountAggregateType<T extends BankAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateBankAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBankAccount[P]>
      : GetScalarType<T[P], AggregateBankAccount[P]>
  }




  export type BankAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BankAccountWhereInput
    orderBy?: BankAccountOrderByWithAggregationInput | BankAccountOrderByWithAggregationInput[]
    by: BankAccountScalarFieldEnum[] | BankAccountScalarFieldEnum
    having?: BankAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BankAccountCountAggregateInputType | true
    _avg?: BankAccountAvgAggregateInputType
    _sum?: BankAccountSumAggregateInputType
    _min?: BankAccountMinAggregateInputType
    _max?: BankAccountMaxAggregateInputType
  }

  export type BankAccountGroupByOutputType = {
    id: string
    tenantId: string
    accountName: string
    accountNumber: string
    bankCode: string | null
    iban: string | null
    swift: string | null
    provider: $Enums.BankProvider
    providerAccountId: string | null
    currency: string
    balance: Decimal | null
    balanceUpdatedAt: Date | null
    autoSync: boolean
    lastSyncAt: Date | null
    syncFrequency: string
    credentials: JsonValue | null
    isActive: boolean
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: BankAccountCountAggregateOutputType | null
    _avg: BankAccountAvgAggregateOutputType | null
    _sum: BankAccountSumAggregateOutputType | null
    _min: BankAccountMinAggregateOutputType | null
    _max: BankAccountMaxAggregateOutputType | null
  }

  type GetBankAccountGroupByPayload<T extends BankAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BankAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BankAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BankAccountGroupByOutputType[P]>
            : GetScalarType<T[P], BankAccountGroupByOutputType[P]>
        }
      >
    >


  export type BankAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    accountName?: boolean
    accountNumber?: boolean
    bankCode?: boolean
    iban?: boolean
    swift?: boolean
    provider?: boolean
    providerAccountId?: boolean
    currency?: boolean
    balance?: boolean
    balanceUpdatedAt?: boolean
    autoSync?: boolean
    lastSyncAt?: boolean
    syncFrequency?: boolean
    credentials?: boolean
    isActive?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    transactions?: boolean | BankAccount$transactionsArgs<ExtArgs>
    _count?: boolean | BankAccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bankAccount"]>

  export type BankAccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    accountName?: boolean
    accountNumber?: boolean
    bankCode?: boolean
    iban?: boolean
    swift?: boolean
    provider?: boolean
    providerAccountId?: boolean
    currency?: boolean
    balance?: boolean
    balanceUpdatedAt?: boolean
    autoSync?: boolean
    lastSyncAt?: boolean
    syncFrequency?: boolean
    credentials?: boolean
    isActive?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bankAccount"]>

  export type BankAccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    accountName?: boolean
    accountNumber?: boolean
    bankCode?: boolean
    iban?: boolean
    swift?: boolean
    provider?: boolean
    providerAccountId?: boolean
    currency?: boolean
    balance?: boolean
    balanceUpdatedAt?: boolean
    autoSync?: boolean
    lastSyncAt?: boolean
    syncFrequency?: boolean
    credentials?: boolean
    isActive?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bankAccount"]>

  export type BankAccountSelectScalar = {
    id?: boolean
    tenantId?: boolean
    accountName?: boolean
    accountNumber?: boolean
    bankCode?: boolean
    iban?: boolean
    swift?: boolean
    provider?: boolean
    providerAccountId?: boolean
    currency?: boolean
    balance?: boolean
    balanceUpdatedAt?: boolean
    autoSync?: boolean
    lastSyncAt?: boolean
    syncFrequency?: boolean
    credentials?: boolean
    isActive?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BankAccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "accountName" | "accountNumber" | "bankCode" | "iban" | "swift" | "provider" | "providerAccountId" | "currency" | "balance" | "balanceUpdatedAt" | "autoSync" | "lastSyncAt" | "syncFrequency" | "credentials" | "isActive" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["bankAccount"]>
  export type BankAccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    transactions?: boolean | BankAccount$transactionsArgs<ExtArgs>
    _count?: boolean | BankAccountCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BankAccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type BankAccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $BankAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BankAccount"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      transactions: Prisma.$BankTransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      accountName: string
      accountNumber: string
      bankCode: string | null
      iban: string | null
      swift: string | null
      provider: $Enums.BankProvider
      providerAccountId: string | null
      currency: string
      balance: Prisma.Decimal | null
      balanceUpdatedAt: Date | null
      autoSync: boolean
      lastSyncAt: Date | null
      syncFrequency: string
      credentials: Prisma.JsonValue | null
      isActive: boolean
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["bankAccount"]>
    composites: {}
  }

  type BankAccountGetPayload<S extends boolean | null | undefined | BankAccountDefaultArgs> = $Result.GetResult<Prisma.$BankAccountPayload, S>

  type BankAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BankAccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BankAccountCountAggregateInputType | true
    }

  export interface BankAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BankAccount'], meta: { name: 'BankAccount' } }
    /**
     * Find zero or one BankAccount that matches the filter.
     * @param {BankAccountFindUniqueArgs} args - Arguments to find a BankAccount
     * @example
     * // Get one BankAccount
     * const bankAccount = await prisma.bankAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BankAccountFindUniqueArgs>(args: SelectSubset<T, BankAccountFindUniqueArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BankAccount that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BankAccountFindUniqueOrThrowArgs} args - Arguments to find a BankAccount
     * @example
     * // Get one BankAccount
     * const bankAccount = await prisma.bankAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BankAccountFindUniqueOrThrowArgs>(args: SelectSubset<T, BankAccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BankAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountFindFirstArgs} args - Arguments to find a BankAccount
     * @example
     * // Get one BankAccount
     * const bankAccount = await prisma.bankAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BankAccountFindFirstArgs>(args?: SelectSubset<T, BankAccountFindFirstArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BankAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountFindFirstOrThrowArgs} args - Arguments to find a BankAccount
     * @example
     * // Get one BankAccount
     * const bankAccount = await prisma.bankAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BankAccountFindFirstOrThrowArgs>(args?: SelectSubset<T, BankAccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BankAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BankAccounts
     * const bankAccounts = await prisma.bankAccount.findMany()
     * 
     * // Get first 10 BankAccounts
     * const bankAccounts = await prisma.bankAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bankAccountWithIdOnly = await prisma.bankAccount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BankAccountFindManyArgs>(args?: SelectSubset<T, BankAccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BankAccount.
     * @param {BankAccountCreateArgs} args - Arguments to create a BankAccount.
     * @example
     * // Create one BankAccount
     * const BankAccount = await prisma.bankAccount.create({
     *   data: {
     *     // ... data to create a BankAccount
     *   }
     * })
     * 
     */
    create<T extends BankAccountCreateArgs>(args: SelectSubset<T, BankAccountCreateArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BankAccounts.
     * @param {BankAccountCreateManyArgs} args - Arguments to create many BankAccounts.
     * @example
     * // Create many BankAccounts
     * const bankAccount = await prisma.bankAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BankAccountCreateManyArgs>(args?: SelectSubset<T, BankAccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BankAccounts and returns the data saved in the database.
     * @param {BankAccountCreateManyAndReturnArgs} args - Arguments to create many BankAccounts.
     * @example
     * // Create many BankAccounts
     * const bankAccount = await prisma.bankAccount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BankAccounts and only return the `id`
     * const bankAccountWithIdOnly = await prisma.bankAccount.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BankAccountCreateManyAndReturnArgs>(args?: SelectSubset<T, BankAccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BankAccount.
     * @param {BankAccountDeleteArgs} args - Arguments to delete one BankAccount.
     * @example
     * // Delete one BankAccount
     * const BankAccount = await prisma.bankAccount.delete({
     *   where: {
     *     // ... filter to delete one BankAccount
     *   }
     * })
     * 
     */
    delete<T extends BankAccountDeleteArgs>(args: SelectSubset<T, BankAccountDeleteArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BankAccount.
     * @param {BankAccountUpdateArgs} args - Arguments to update one BankAccount.
     * @example
     * // Update one BankAccount
     * const bankAccount = await prisma.bankAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BankAccountUpdateArgs>(args: SelectSubset<T, BankAccountUpdateArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BankAccounts.
     * @param {BankAccountDeleteManyArgs} args - Arguments to filter BankAccounts to delete.
     * @example
     * // Delete a few BankAccounts
     * const { count } = await prisma.bankAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BankAccountDeleteManyArgs>(args?: SelectSubset<T, BankAccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BankAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BankAccounts
     * const bankAccount = await prisma.bankAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BankAccountUpdateManyArgs>(args: SelectSubset<T, BankAccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BankAccounts and returns the data updated in the database.
     * @param {BankAccountUpdateManyAndReturnArgs} args - Arguments to update many BankAccounts.
     * @example
     * // Update many BankAccounts
     * const bankAccount = await prisma.bankAccount.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BankAccounts and only return the `id`
     * const bankAccountWithIdOnly = await prisma.bankAccount.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BankAccountUpdateManyAndReturnArgs>(args: SelectSubset<T, BankAccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BankAccount.
     * @param {BankAccountUpsertArgs} args - Arguments to update or create a BankAccount.
     * @example
     * // Update or create a BankAccount
     * const bankAccount = await prisma.bankAccount.upsert({
     *   create: {
     *     // ... data to create a BankAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BankAccount we want to update
     *   }
     * })
     */
    upsert<T extends BankAccountUpsertArgs>(args: SelectSubset<T, BankAccountUpsertArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BankAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountCountArgs} args - Arguments to filter BankAccounts to count.
     * @example
     * // Count the number of BankAccounts
     * const count = await prisma.bankAccount.count({
     *   where: {
     *     // ... the filter for the BankAccounts we want to count
     *   }
     * })
    **/
    count<T extends BankAccountCountArgs>(
      args?: Subset<T, BankAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BankAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BankAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BankAccountAggregateArgs>(args: Subset<T, BankAccountAggregateArgs>): Prisma.PrismaPromise<GetBankAccountAggregateType<T>>

    /**
     * Group by BankAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BankAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BankAccountGroupByArgs['orderBy'] }
        : { orderBy?: BankAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BankAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBankAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BankAccount model
   */
  readonly fields: BankAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BankAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BankAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    transactions<T extends BankAccount$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, BankAccount$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BankAccount model
   */
  interface BankAccountFieldRefs {
    readonly id: FieldRef<"BankAccount", 'String'>
    readonly tenantId: FieldRef<"BankAccount", 'String'>
    readonly accountName: FieldRef<"BankAccount", 'String'>
    readonly accountNumber: FieldRef<"BankAccount", 'String'>
    readonly bankCode: FieldRef<"BankAccount", 'String'>
    readonly iban: FieldRef<"BankAccount", 'String'>
    readonly swift: FieldRef<"BankAccount", 'String'>
    readonly provider: FieldRef<"BankAccount", 'BankProvider'>
    readonly providerAccountId: FieldRef<"BankAccount", 'String'>
    readonly currency: FieldRef<"BankAccount", 'String'>
    readonly balance: FieldRef<"BankAccount", 'Decimal'>
    readonly balanceUpdatedAt: FieldRef<"BankAccount", 'DateTime'>
    readonly autoSync: FieldRef<"BankAccount", 'Boolean'>
    readonly lastSyncAt: FieldRef<"BankAccount", 'DateTime'>
    readonly syncFrequency: FieldRef<"BankAccount", 'String'>
    readonly credentials: FieldRef<"BankAccount", 'Json'>
    readonly isActive: FieldRef<"BankAccount", 'Boolean'>
    readonly metadata: FieldRef<"BankAccount", 'Json'>
    readonly createdAt: FieldRef<"BankAccount", 'DateTime'>
    readonly updatedAt: FieldRef<"BankAccount", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BankAccount findUnique
   */
  export type BankAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * Filter, which BankAccount to fetch.
     */
    where: BankAccountWhereUniqueInput
  }

  /**
   * BankAccount findUniqueOrThrow
   */
  export type BankAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * Filter, which BankAccount to fetch.
     */
    where: BankAccountWhereUniqueInput
  }

  /**
   * BankAccount findFirst
   */
  export type BankAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * Filter, which BankAccount to fetch.
     */
    where?: BankAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankAccounts to fetch.
     */
    orderBy?: BankAccountOrderByWithRelationInput | BankAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BankAccounts.
     */
    cursor?: BankAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BankAccounts.
     */
    distinct?: BankAccountScalarFieldEnum | BankAccountScalarFieldEnum[]
  }

  /**
   * BankAccount findFirstOrThrow
   */
  export type BankAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * Filter, which BankAccount to fetch.
     */
    where?: BankAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankAccounts to fetch.
     */
    orderBy?: BankAccountOrderByWithRelationInput | BankAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BankAccounts.
     */
    cursor?: BankAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BankAccounts.
     */
    distinct?: BankAccountScalarFieldEnum | BankAccountScalarFieldEnum[]
  }

  /**
   * BankAccount findMany
   */
  export type BankAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * Filter, which BankAccounts to fetch.
     */
    where?: BankAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankAccounts to fetch.
     */
    orderBy?: BankAccountOrderByWithRelationInput | BankAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BankAccounts.
     */
    cursor?: BankAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankAccounts.
     */
    skip?: number
    distinct?: BankAccountScalarFieldEnum | BankAccountScalarFieldEnum[]
  }

  /**
   * BankAccount create
   */
  export type BankAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * The data needed to create a BankAccount.
     */
    data: XOR<BankAccountCreateInput, BankAccountUncheckedCreateInput>
  }

  /**
   * BankAccount createMany
   */
  export type BankAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BankAccounts.
     */
    data: BankAccountCreateManyInput | BankAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BankAccount createManyAndReturn
   */
  export type BankAccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * The data used to create many BankAccounts.
     */
    data: BankAccountCreateManyInput | BankAccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BankAccount update
   */
  export type BankAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * The data needed to update a BankAccount.
     */
    data: XOR<BankAccountUpdateInput, BankAccountUncheckedUpdateInput>
    /**
     * Choose, which BankAccount to update.
     */
    where: BankAccountWhereUniqueInput
  }

  /**
   * BankAccount updateMany
   */
  export type BankAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BankAccounts.
     */
    data: XOR<BankAccountUpdateManyMutationInput, BankAccountUncheckedUpdateManyInput>
    /**
     * Filter which BankAccounts to update
     */
    where?: BankAccountWhereInput
    /**
     * Limit how many BankAccounts to update.
     */
    limit?: number
  }

  /**
   * BankAccount updateManyAndReturn
   */
  export type BankAccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * The data used to update BankAccounts.
     */
    data: XOR<BankAccountUpdateManyMutationInput, BankAccountUncheckedUpdateManyInput>
    /**
     * Filter which BankAccounts to update
     */
    where?: BankAccountWhereInput
    /**
     * Limit how many BankAccounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BankAccount upsert
   */
  export type BankAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * The filter to search for the BankAccount to update in case it exists.
     */
    where: BankAccountWhereUniqueInput
    /**
     * In case the BankAccount found by the `where` argument doesn't exist, create a new BankAccount with this data.
     */
    create: XOR<BankAccountCreateInput, BankAccountUncheckedCreateInput>
    /**
     * In case the BankAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BankAccountUpdateInput, BankAccountUncheckedUpdateInput>
  }

  /**
   * BankAccount delete
   */
  export type BankAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * Filter which BankAccount to delete.
     */
    where: BankAccountWhereUniqueInput
  }

  /**
   * BankAccount deleteMany
   */
  export type BankAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BankAccounts to delete
     */
    where?: BankAccountWhereInput
    /**
     * Limit how many BankAccounts to delete.
     */
    limit?: number
  }

  /**
   * BankAccount.transactions
   */
  export type BankAccount$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankTransaction
     */
    select?: BankTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankTransaction
     */
    omit?: BankTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankTransactionInclude<ExtArgs> | null
    where?: BankTransactionWhereInput
    orderBy?: BankTransactionOrderByWithRelationInput | BankTransactionOrderByWithRelationInput[]
    cursor?: BankTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BankTransactionScalarFieldEnum | BankTransactionScalarFieldEnum[]
  }

  /**
   * BankAccount without action
   */
  export type BankAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
  }


  /**
   * Model BankTransaction
   */

  export type AggregateBankTransaction = {
    _count: BankTransactionCountAggregateOutputType | null
    _avg: BankTransactionAvgAggregateOutputType | null
    _sum: BankTransactionSumAggregateOutputType | null
    _min: BankTransactionMinAggregateOutputType | null
    _max: BankTransactionMaxAggregateOutputType | null
  }

  export type BankTransactionAvgAggregateOutputType = {
    amount: Decimal | null
    matchConfidence: Decimal | null
  }

  export type BankTransactionSumAggregateOutputType = {
    amount: Decimal | null
    matchConfidence: Decimal | null
  }

  export type BankTransactionMinAggregateOutputType = {
    id: string | null
    bankAccountId: string | null
    tenantId: string | null
    transactionId: string | null
    date: Date | null
    amount: Decimal | null
    currency: string | null
    type: $Enums.TransactionType | null
    counterpartyName: string | null
    counterpartyAccount: string | null
    counterpartyBankCode: string | null
    description: string | null
    note: string | null
    variableSymbol: string | null
    constantSymbol: string | null
    specificSymbol: string | null
    reference: string | null
    isMatched: boolean | null
    matchedInvoiceId: string | null
    matchedPaymentId: string | null
    matchConfidence: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BankTransactionMaxAggregateOutputType = {
    id: string | null
    bankAccountId: string | null
    tenantId: string | null
    transactionId: string | null
    date: Date | null
    amount: Decimal | null
    currency: string | null
    type: $Enums.TransactionType | null
    counterpartyName: string | null
    counterpartyAccount: string | null
    counterpartyBankCode: string | null
    description: string | null
    note: string | null
    variableSymbol: string | null
    constantSymbol: string | null
    specificSymbol: string | null
    reference: string | null
    isMatched: boolean | null
    matchedInvoiceId: string | null
    matchedPaymentId: string | null
    matchConfidence: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BankTransactionCountAggregateOutputType = {
    id: number
    bankAccountId: number
    tenantId: number
    transactionId: number
    date: number
    amount: number
    currency: number
    type: number
    counterpartyName: number
    counterpartyAccount: number
    counterpartyBankCode: number
    description: number
    note: number
    variableSymbol: number
    constantSymbol: number
    specificSymbol: number
    reference: number
    isMatched: number
    matchedInvoiceId: number
    matchedPaymentId: number
    matchConfidence: number
    aiSuggestions: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BankTransactionAvgAggregateInputType = {
    amount?: true
    matchConfidence?: true
  }

  export type BankTransactionSumAggregateInputType = {
    amount?: true
    matchConfidence?: true
  }

  export type BankTransactionMinAggregateInputType = {
    id?: true
    bankAccountId?: true
    tenantId?: true
    transactionId?: true
    date?: true
    amount?: true
    currency?: true
    type?: true
    counterpartyName?: true
    counterpartyAccount?: true
    counterpartyBankCode?: true
    description?: true
    note?: true
    variableSymbol?: true
    constantSymbol?: true
    specificSymbol?: true
    reference?: true
    isMatched?: true
    matchedInvoiceId?: true
    matchedPaymentId?: true
    matchConfidence?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BankTransactionMaxAggregateInputType = {
    id?: true
    bankAccountId?: true
    tenantId?: true
    transactionId?: true
    date?: true
    amount?: true
    currency?: true
    type?: true
    counterpartyName?: true
    counterpartyAccount?: true
    counterpartyBankCode?: true
    description?: true
    note?: true
    variableSymbol?: true
    constantSymbol?: true
    specificSymbol?: true
    reference?: true
    isMatched?: true
    matchedInvoiceId?: true
    matchedPaymentId?: true
    matchConfidence?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BankTransactionCountAggregateInputType = {
    id?: true
    bankAccountId?: true
    tenantId?: true
    transactionId?: true
    date?: true
    amount?: true
    currency?: true
    type?: true
    counterpartyName?: true
    counterpartyAccount?: true
    counterpartyBankCode?: true
    description?: true
    note?: true
    variableSymbol?: true
    constantSymbol?: true
    specificSymbol?: true
    reference?: true
    isMatched?: true
    matchedInvoiceId?: true
    matchedPaymentId?: true
    matchConfidence?: true
    aiSuggestions?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BankTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BankTransaction to aggregate.
     */
    where?: BankTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankTransactions to fetch.
     */
    orderBy?: BankTransactionOrderByWithRelationInput | BankTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BankTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BankTransactions
    **/
    _count?: true | BankTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BankTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BankTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BankTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BankTransactionMaxAggregateInputType
  }

  export type GetBankTransactionAggregateType<T extends BankTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateBankTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBankTransaction[P]>
      : GetScalarType<T[P], AggregateBankTransaction[P]>
  }




  export type BankTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BankTransactionWhereInput
    orderBy?: BankTransactionOrderByWithAggregationInput | BankTransactionOrderByWithAggregationInput[]
    by: BankTransactionScalarFieldEnum[] | BankTransactionScalarFieldEnum
    having?: BankTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BankTransactionCountAggregateInputType | true
    _avg?: BankTransactionAvgAggregateInputType
    _sum?: BankTransactionSumAggregateInputType
    _min?: BankTransactionMinAggregateInputType
    _max?: BankTransactionMaxAggregateInputType
  }

  export type BankTransactionGroupByOutputType = {
    id: string
    bankAccountId: string
    tenantId: string
    transactionId: string
    date: Date
    amount: Decimal
    currency: string
    type: $Enums.TransactionType
    counterpartyName: string | null
    counterpartyAccount: string | null
    counterpartyBankCode: string | null
    description: string | null
    note: string | null
    variableSymbol: string | null
    constantSymbol: string | null
    specificSymbol: string | null
    reference: string | null
    isMatched: boolean
    matchedInvoiceId: string | null
    matchedPaymentId: string | null
    matchConfidence: Decimal | null
    aiSuggestions: JsonValue | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: BankTransactionCountAggregateOutputType | null
    _avg: BankTransactionAvgAggregateOutputType | null
    _sum: BankTransactionSumAggregateOutputType | null
    _min: BankTransactionMinAggregateOutputType | null
    _max: BankTransactionMaxAggregateOutputType | null
  }

  type GetBankTransactionGroupByPayload<T extends BankTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BankTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BankTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BankTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], BankTransactionGroupByOutputType[P]>
        }
      >
    >


  export type BankTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bankAccountId?: boolean
    tenantId?: boolean
    transactionId?: boolean
    date?: boolean
    amount?: boolean
    currency?: boolean
    type?: boolean
    counterpartyName?: boolean
    counterpartyAccount?: boolean
    counterpartyBankCode?: boolean
    description?: boolean
    note?: boolean
    variableSymbol?: boolean
    constantSymbol?: boolean
    specificSymbol?: boolean
    reference?: boolean
    isMatched?: boolean
    matchedInvoiceId?: boolean
    matchedPaymentId?: boolean
    matchConfidence?: boolean
    aiSuggestions?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bankAccount?: boolean | BankAccountDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    matchedInvoice?: boolean | BankTransaction$matchedInvoiceArgs<ExtArgs>
  }, ExtArgs["result"]["bankTransaction"]>

  export type BankTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bankAccountId?: boolean
    tenantId?: boolean
    transactionId?: boolean
    date?: boolean
    amount?: boolean
    currency?: boolean
    type?: boolean
    counterpartyName?: boolean
    counterpartyAccount?: boolean
    counterpartyBankCode?: boolean
    description?: boolean
    note?: boolean
    variableSymbol?: boolean
    constantSymbol?: boolean
    specificSymbol?: boolean
    reference?: boolean
    isMatched?: boolean
    matchedInvoiceId?: boolean
    matchedPaymentId?: boolean
    matchConfidence?: boolean
    aiSuggestions?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bankAccount?: boolean | BankAccountDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    matchedInvoice?: boolean | BankTransaction$matchedInvoiceArgs<ExtArgs>
  }, ExtArgs["result"]["bankTransaction"]>

  export type BankTransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bankAccountId?: boolean
    tenantId?: boolean
    transactionId?: boolean
    date?: boolean
    amount?: boolean
    currency?: boolean
    type?: boolean
    counterpartyName?: boolean
    counterpartyAccount?: boolean
    counterpartyBankCode?: boolean
    description?: boolean
    note?: boolean
    variableSymbol?: boolean
    constantSymbol?: boolean
    specificSymbol?: boolean
    reference?: boolean
    isMatched?: boolean
    matchedInvoiceId?: boolean
    matchedPaymentId?: boolean
    matchConfidence?: boolean
    aiSuggestions?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bankAccount?: boolean | BankAccountDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    matchedInvoice?: boolean | BankTransaction$matchedInvoiceArgs<ExtArgs>
  }, ExtArgs["result"]["bankTransaction"]>

  export type BankTransactionSelectScalar = {
    id?: boolean
    bankAccountId?: boolean
    tenantId?: boolean
    transactionId?: boolean
    date?: boolean
    amount?: boolean
    currency?: boolean
    type?: boolean
    counterpartyName?: boolean
    counterpartyAccount?: boolean
    counterpartyBankCode?: boolean
    description?: boolean
    note?: boolean
    variableSymbol?: boolean
    constantSymbol?: boolean
    specificSymbol?: boolean
    reference?: boolean
    isMatched?: boolean
    matchedInvoiceId?: boolean
    matchedPaymentId?: boolean
    matchConfidence?: boolean
    aiSuggestions?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BankTransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bankAccountId" | "tenantId" | "transactionId" | "date" | "amount" | "currency" | "type" | "counterpartyName" | "counterpartyAccount" | "counterpartyBankCode" | "description" | "note" | "variableSymbol" | "constantSymbol" | "specificSymbol" | "reference" | "isMatched" | "matchedInvoiceId" | "matchedPaymentId" | "matchConfidence" | "aiSuggestions" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["bankTransaction"]>
  export type BankTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bankAccount?: boolean | BankAccountDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    matchedInvoice?: boolean | BankTransaction$matchedInvoiceArgs<ExtArgs>
  }
  export type BankTransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bankAccount?: boolean | BankAccountDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    matchedInvoice?: boolean | BankTransaction$matchedInvoiceArgs<ExtArgs>
  }
  export type BankTransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bankAccount?: boolean | BankAccountDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    matchedInvoice?: boolean | BankTransaction$matchedInvoiceArgs<ExtArgs>
  }

  export type $BankTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BankTransaction"
    objects: {
      bankAccount: Prisma.$BankAccountPayload<ExtArgs>
      tenant: Prisma.$TenantPayload<ExtArgs>
      matchedInvoice: Prisma.$InvoicePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bankAccountId: string
      tenantId: string
      transactionId: string
      date: Date
      amount: Prisma.Decimal
      currency: string
      type: $Enums.TransactionType
      counterpartyName: string | null
      counterpartyAccount: string | null
      counterpartyBankCode: string | null
      description: string | null
      note: string | null
      variableSymbol: string | null
      constantSymbol: string | null
      specificSymbol: string | null
      reference: string | null
      isMatched: boolean
      matchedInvoiceId: string | null
      matchedPaymentId: string | null
      matchConfidence: Prisma.Decimal | null
      aiSuggestions: Prisma.JsonValue | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["bankTransaction"]>
    composites: {}
  }

  type BankTransactionGetPayload<S extends boolean | null | undefined | BankTransactionDefaultArgs> = $Result.GetResult<Prisma.$BankTransactionPayload, S>

  type BankTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BankTransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BankTransactionCountAggregateInputType | true
    }

  export interface BankTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BankTransaction'], meta: { name: 'BankTransaction' } }
    /**
     * Find zero or one BankTransaction that matches the filter.
     * @param {BankTransactionFindUniqueArgs} args - Arguments to find a BankTransaction
     * @example
     * // Get one BankTransaction
     * const bankTransaction = await prisma.bankTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BankTransactionFindUniqueArgs>(args: SelectSubset<T, BankTransactionFindUniqueArgs<ExtArgs>>): Prisma__BankTransactionClient<$Result.GetResult<Prisma.$BankTransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BankTransaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BankTransactionFindUniqueOrThrowArgs} args - Arguments to find a BankTransaction
     * @example
     * // Get one BankTransaction
     * const bankTransaction = await prisma.bankTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BankTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, BankTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BankTransactionClient<$Result.GetResult<Prisma.$BankTransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BankTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankTransactionFindFirstArgs} args - Arguments to find a BankTransaction
     * @example
     * // Get one BankTransaction
     * const bankTransaction = await prisma.bankTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BankTransactionFindFirstArgs>(args?: SelectSubset<T, BankTransactionFindFirstArgs<ExtArgs>>): Prisma__BankTransactionClient<$Result.GetResult<Prisma.$BankTransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BankTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankTransactionFindFirstOrThrowArgs} args - Arguments to find a BankTransaction
     * @example
     * // Get one BankTransaction
     * const bankTransaction = await prisma.bankTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BankTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, BankTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__BankTransactionClient<$Result.GetResult<Prisma.$BankTransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BankTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BankTransactions
     * const bankTransactions = await prisma.bankTransaction.findMany()
     * 
     * // Get first 10 BankTransactions
     * const bankTransactions = await prisma.bankTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bankTransactionWithIdOnly = await prisma.bankTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BankTransactionFindManyArgs>(args?: SelectSubset<T, BankTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BankTransaction.
     * @param {BankTransactionCreateArgs} args - Arguments to create a BankTransaction.
     * @example
     * // Create one BankTransaction
     * const BankTransaction = await prisma.bankTransaction.create({
     *   data: {
     *     // ... data to create a BankTransaction
     *   }
     * })
     * 
     */
    create<T extends BankTransactionCreateArgs>(args: SelectSubset<T, BankTransactionCreateArgs<ExtArgs>>): Prisma__BankTransactionClient<$Result.GetResult<Prisma.$BankTransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BankTransactions.
     * @param {BankTransactionCreateManyArgs} args - Arguments to create many BankTransactions.
     * @example
     * // Create many BankTransactions
     * const bankTransaction = await prisma.bankTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BankTransactionCreateManyArgs>(args?: SelectSubset<T, BankTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BankTransactions and returns the data saved in the database.
     * @param {BankTransactionCreateManyAndReturnArgs} args - Arguments to create many BankTransactions.
     * @example
     * // Create many BankTransactions
     * const bankTransaction = await prisma.bankTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BankTransactions and only return the `id`
     * const bankTransactionWithIdOnly = await prisma.bankTransaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BankTransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, BankTransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankTransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BankTransaction.
     * @param {BankTransactionDeleteArgs} args - Arguments to delete one BankTransaction.
     * @example
     * // Delete one BankTransaction
     * const BankTransaction = await prisma.bankTransaction.delete({
     *   where: {
     *     // ... filter to delete one BankTransaction
     *   }
     * })
     * 
     */
    delete<T extends BankTransactionDeleteArgs>(args: SelectSubset<T, BankTransactionDeleteArgs<ExtArgs>>): Prisma__BankTransactionClient<$Result.GetResult<Prisma.$BankTransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BankTransaction.
     * @param {BankTransactionUpdateArgs} args - Arguments to update one BankTransaction.
     * @example
     * // Update one BankTransaction
     * const bankTransaction = await prisma.bankTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BankTransactionUpdateArgs>(args: SelectSubset<T, BankTransactionUpdateArgs<ExtArgs>>): Prisma__BankTransactionClient<$Result.GetResult<Prisma.$BankTransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BankTransactions.
     * @param {BankTransactionDeleteManyArgs} args - Arguments to filter BankTransactions to delete.
     * @example
     * // Delete a few BankTransactions
     * const { count } = await prisma.bankTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BankTransactionDeleteManyArgs>(args?: SelectSubset<T, BankTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BankTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BankTransactions
     * const bankTransaction = await prisma.bankTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BankTransactionUpdateManyArgs>(args: SelectSubset<T, BankTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BankTransactions and returns the data updated in the database.
     * @param {BankTransactionUpdateManyAndReturnArgs} args - Arguments to update many BankTransactions.
     * @example
     * // Update many BankTransactions
     * const bankTransaction = await prisma.bankTransaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BankTransactions and only return the `id`
     * const bankTransactionWithIdOnly = await prisma.bankTransaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BankTransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, BankTransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankTransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BankTransaction.
     * @param {BankTransactionUpsertArgs} args - Arguments to update or create a BankTransaction.
     * @example
     * // Update or create a BankTransaction
     * const bankTransaction = await prisma.bankTransaction.upsert({
     *   create: {
     *     // ... data to create a BankTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BankTransaction we want to update
     *   }
     * })
     */
    upsert<T extends BankTransactionUpsertArgs>(args: SelectSubset<T, BankTransactionUpsertArgs<ExtArgs>>): Prisma__BankTransactionClient<$Result.GetResult<Prisma.$BankTransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BankTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankTransactionCountArgs} args - Arguments to filter BankTransactions to count.
     * @example
     * // Count the number of BankTransactions
     * const count = await prisma.bankTransaction.count({
     *   where: {
     *     // ... the filter for the BankTransactions we want to count
     *   }
     * })
    **/
    count<T extends BankTransactionCountArgs>(
      args?: Subset<T, BankTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BankTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BankTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BankTransactionAggregateArgs>(args: Subset<T, BankTransactionAggregateArgs>): Prisma.PrismaPromise<GetBankTransactionAggregateType<T>>

    /**
     * Group by BankTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BankTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BankTransactionGroupByArgs['orderBy'] }
        : { orderBy?: BankTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BankTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBankTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BankTransaction model
   */
  readonly fields: BankTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BankTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BankTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bankAccount<T extends BankAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BankAccountDefaultArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    matchedInvoice<T extends BankTransaction$matchedInvoiceArgs<ExtArgs> = {}>(args?: Subset<T, BankTransaction$matchedInvoiceArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BankTransaction model
   */
  interface BankTransactionFieldRefs {
    readonly id: FieldRef<"BankTransaction", 'String'>
    readonly bankAccountId: FieldRef<"BankTransaction", 'String'>
    readonly tenantId: FieldRef<"BankTransaction", 'String'>
    readonly transactionId: FieldRef<"BankTransaction", 'String'>
    readonly date: FieldRef<"BankTransaction", 'DateTime'>
    readonly amount: FieldRef<"BankTransaction", 'Decimal'>
    readonly currency: FieldRef<"BankTransaction", 'String'>
    readonly type: FieldRef<"BankTransaction", 'TransactionType'>
    readonly counterpartyName: FieldRef<"BankTransaction", 'String'>
    readonly counterpartyAccount: FieldRef<"BankTransaction", 'String'>
    readonly counterpartyBankCode: FieldRef<"BankTransaction", 'String'>
    readonly description: FieldRef<"BankTransaction", 'String'>
    readonly note: FieldRef<"BankTransaction", 'String'>
    readonly variableSymbol: FieldRef<"BankTransaction", 'String'>
    readonly constantSymbol: FieldRef<"BankTransaction", 'String'>
    readonly specificSymbol: FieldRef<"BankTransaction", 'String'>
    readonly reference: FieldRef<"BankTransaction", 'String'>
    readonly isMatched: FieldRef<"BankTransaction", 'Boolean'>
    readonly matchedInvoiceId: FieldRef<"BankTransaction", 'String'>
    readonly matchedPaymentId: FieldRef<"BankTransaction", 'String'>
    readonly matchConfidence: FieldRef<"BankTransaction", 'Decimal'>
    readonly aiSuggestions: FieldRef<"BankTransaction", 'Json'>
    readonly metadata: FieldRef<"BankTransaction", 'Json'>
    readonly createdAt: FieldRef<"BankTransaction", 'DateTime'>
    readonly updatedAt: FieldRef<"BankTransaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BankTransaction findUnique
   */
  export type BankTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankTransaction
     */
    select?: BankTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankTransaction
     */
    omit?: BankTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankTransactionInclude<ExtArgs> | null
    /**
     * Filter, which BankTransaction to fetch.
     */
    where: BankTransactionWhereUniqueInput
  }

  /**
   * BankTransaction findUniqueOrThrow
   */
  export type BankTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankTransaction
     */
    select?: BankTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankTransaction
     */
    omit?: BankTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankTransactionInclude<ExtArgs> | null
    /**
     * Filter, which BankTransaction to fetch.
     */
    where: BankTransactionWhereUniqueInput
  }

  /**
   * BankTransaction findFirst
   */
  export type BankTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankTransaction
     */
    select?: BankTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankTransaction
     */
    omit?: BankTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankTransactionInclude<ExtArgs> | null
    /**
     * Filter, which BankTransaction to fetch.
     */
    where?: BankTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankTransactions to fetch.
     */
    orderBy?: BankTransactionOrderByWithRelationInput | BankTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BankTransactions.
     */
    cursor?: BankTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BankTransactions.
     */
    distinct?: BankTransactionScalarFieldEnum | BankTransactionScalarFieldEnum[]
  }

  /**
   * BankTransaction findFirstOrThrow
   */
  export type BankTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankTransaction
     */
    select?: BankTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankTransaction
     */
    omit?: BankTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankTransactionInclude<ExtArgs> | null
    /**
     * Filter, which BankTransaction to fetch.
     */
    where?: BankTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankTransactions to fetch.
     */
    orderBy?: BankTransactionOrderByWithRelationInput | BankTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BankTransactions.
     */
    cursor?: BankTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BankTransactions.
     */
    distinct?: BankTransactionScalarFieldEnum | BankTransactionScalarFieldEnum[]
  }

  /**
   * BankTransaction findMany
   */
  export type BankTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankTransaction
     */
    select?: BankTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankTransaction
     */
    omit?: BankTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankTransactionInclude<ExtArgs> | null
    /**
     * Filter, which BankTransactions to fetch.
     */
    where?: BankTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankTransactions to fetch.
     */
    orderBy?: BankTransactionOrderByWithRelationInput | BankTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BankTransactions.
     */
    cursor?: BankTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankTransactions.
     */
    skip?: number
    distinct?: BankTransactionScalarFieldEnum | BankTransactionScalarFieldEnum[]
  }

  /**
   * BankTransaction create
   */
  export type BankTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankTransaction
     */
    select?: BankTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankTransaction
     */
    omit?: BankTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a BankTransaction.
     */
    data: XOR<BankTransactionCreateInput, BankTransactionUncheckedCreateInput>
  }

  /**
   * BankTransaction createMany
   */
  export type BankTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BankTransactions.
     */
    data: BankTransactionCreateManyInput | BankTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BankTransaction createManyAndReturn
   */
  export type BankTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankTransaction
     */
    select?: BankTransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BankTransaction
     */
    omit?: BankTransactionOmit<ExtArgs> | null
    /**
     * The data used to create many BankTransactions.
     */
    data: BankTransactionCreateManyInput | BankTransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankTransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BankTransaction update
   */
  export type BankTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankTransaction
     */
    select?: BankTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankTransaction
     */
    omit?: BankTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a BankTransaction.
     */
    data: XOR<BankTransactionUpdateInput, BankTransactionUncheckedUpdateInput>
    /**
     * Choose, which BankTransaction to update.
     */
    where: BankTransactionWhereUniqueInput
  }

  /**
   * BankTransaction updateMany
   */
  export type BankTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BankTransactions.
     */
    data: XOR<BankTransactionUpdateManyMutationInput, BankTransactionUncheckedUpdateManyInput>
    /**
     * Filter which BankTransactions to update
     */
    where?: BankTransactionWhereInput
    /**
     * Limit how many BankTransactions to update.
     */
    limit?: number
  }

  /**
   * BankTransaction updateManyAndReturn
   */
  export type BankTransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankTransaction
     */
    select?: BankTransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BankTransaction
     */
    omit?: BankTransactionOmit<ExtArgs> | null
    /**
     * The data used to update BankTransactions.
     */
    data: XOR<BankTransactionUpdateManyMutationInput, BankTransactionUncheckedUpdateManyInput>
    /**
     * Filter which BankTransactions to update
     */
    where?: BankTransactionWhereInput
    /**
     * Limit how many BankTransactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankTransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BankTransaction upsert
   */
  export type BankTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankTransaction
     */
    select?: BankTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankTransaction
     */
    omit?: BankTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the BankTransaction to update in case it exists.
     */
    where: BankTransactionWhereUniqueInput
    /**
     * In case the BankTransaction found by the `where` argument doesn't exist, create a new BankTransaction with this data.
     */
    create: XOR<BankTransactionCreateInput, BankTransactionUncheckedCreateInput>
    /**
     * In case the BankTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BankTransactionUpdateInput, BankTransactionUncheckedUpdateInput>
  }

  /**
   * BankTransaction delete
   */
  export type BankTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankTransaction
     */
    select?: BankTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankTransaction
     */
    omit?: BankTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankTransactionInclude<ExtArgs> | null
    /**
     * Filter which BankTransaction to delete.
     */
    where: BankTransactionWhereUniqueInput
  }

  /**
   * BankTransaction deleteMany
   */
  export type BankTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BankTransactions to delete
     */
    where?: BankTransactionWhereInput
    /**
     * Limit how many BankTransactions to delete.
     */
    limit?: number
  }

  /**
   * BankTransaction.matchedInvoice
   */
  export type BankTransaction$matchedInvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
  }

  /**
   * BankTransaction without action
   */
  export type BankTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankTransaction
     */
    select?: BankTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankTransaction
     */
    omit?: BankTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankTransactionInclude<ExtArgs> | null
  }


  /**
   * Model InvoicePayment
   */

  export type AggregateInvoicePayment = {
    _count: InvoicePaymentCountAggregateOutputType | null
    _avg: InvoicePaymentAvgAggregateOutputType | null
    _sum: InvoicePaymentSumAggregateOutputType | null
    _min: InvoicePaymentMinAggregateOutputType | null
    _max: InvoicePaymentMaxAggregateOutputType | null
  }

  export type InvoicePaymentAvgAggregateOutputType = {
    amount: Decimal | null
    gatewayFee: Decimal | null
  }

  export type InvoicePaymentSumAggregateOutputType = {
    amount: Decimal | null
    gatewayFee: Decimal | null
  }

  export type InvoicePaymentMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    invoiceId: string | null
    amount: Decimal | null
    currency: string | null
    method: $Enums.PaymentMethod | null
    status: string | null
    gatewayProvider: string | null
    gatewayPaymentId: string | null
    gatewayFee: Decimal | null
    transactionId: string | null
    reference: string | null
    processedAt: Date | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoicePaymentMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    invoiceId: string | null
    amount: Decimal | null
    currency: string | null
    method: $Enums.PaymentMethod | null
    status: string | null
    gatewayProvider: string | null
    gatewayPaymentId: string | null
    gatewayFee: Decimal | null
    transactionId: string | null
    reference: string | null
    processedAt: Date | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoicePaymentCountAggregateOutputType = {
    id: number
    tenantId: number
    invoiceId: number
    amount: number
    currency: number
    method: number
    status: number
    gatewayProvider: number
    gatewayPaymentId: number
    gatewayFee: number
    transactionId: number
    reference: number
    processedAt: number
    completedAt: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InvoicePaymentAvgAggregateInputType = {
    amount?: true
    gatewayFee?: true
  }

  export type InvoicePaymentSumAggregateInputType = {
    amount?: true
    gatewayFee?: true
  }

  export type InvoicePaymentMinAggregateInputType = {
    id?: true
    tenantId?: true
    invoiceId?: true
    amount?: true
    currency?: true
    method?: true
    status?: true
    gatewayProvider?: true
    gatewayPaymentId?: true
    gatewayFee?: true
    transactionId?: true
    reference?: true
    processedAt?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoicePaymentMaxAggregateInputType = {
    id?: true
    tenantId?: true
    invoiceId?: true
    amount?: true
    currency?: true
    method?: true
    status?: true
    gatewayProvider?: true
    gatewayPaymentId?: true
    gatewayFee?: true
    transactionId?: true
    reference?: true
    processedAt?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoicePaymentCountAggregateInputType = {
    id?: true
    tenantId?: true
    invoiceId?: true
    amount?: true
    currency?: true
    method?: true
    status?: true
    gatewayProvider?: true
    gatewayPaymentId?: true
    gatewayFee?: true
    transactionId?: true
    reference?: true
    processedAt?: true
    completedAt?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InvoicePaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoicePayment to aggregate.
     */
    where?: InvoicePaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoicePayments to fetch.
     */
    orderBy?: InvoicePaymentOrderByWithRelationInput | InvoicePaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoicePaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoicePayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoicePayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InvoicePayments
    **/
    _count?: true | InvoicePaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoicePaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoicePaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoicePaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoicePaymentMaxAggregateInputType
  }

  export type GetInvoicePaymentAggregateType<T extends InvoicePaymentAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoicePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoicePayment[P]>
      : GetScalarType<T[P], AggregateInvoicePayment[P]>
  }




  export type InvoicePaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoicePaymentWhereInput
    orderBy?: InvoicePaymentOrderByWithAggregationInput | InvoicePaymentOrderByWithAggregationInput[]
    by: InvoicePaymentScalarFieldEnum[] | InvoicePaymentScalarFieldEnum
    having?: InvoicePaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoicePaymentCountAggregateInputType | true
    _avg?: InvoicePaymentAvgAggregateInputType
    _sum?: InvoicePaymentSumAggregateInputType
    _min?: InvoicePaymentMinAggregateInputType
    _max?: InvoicePaymentMaxAggregateInputType
  }

  export type InvoicePaymentGroupByOutputType = {
    id: string
    tenantId: string
    invoiceId: string
    amount: Decimal
    currency: string
    method: $Enums.PaymentMethod
    status: string
    gatewayProvider: string | null
    gatewayPaymentId: string | null
    gatewayFee: Decimal | null
    transactionId: string | null
    reference: string | null
    processedAt: Date | null
    completedAt: Date | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: InvoicePaymentCountAggregateOutputType | null
    _avg: InvoicePaymentAvgAggregateOutputType | null
    _sum: InvoicePaymentSumAggregateOutputType | null
    _min: InvoicePaymentMinAggregateOutputType | null
    _max: InvoicePaymentMaxAggregateOutputType | null
  }

  type GetInvoicePaymentGroupByPayload<T extends InvoicePaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoicePaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoicePaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoicePaymentGroupByOutputType[P]>
            : GetScalarType<T[P], InvoicePaymentGroupByOutputType[P]>
        }
      >
    >


  export type InvoicePaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    invoiceId?: boolean
    amount?: boolean
    currency?: boolean
    method?: boolean
    status?: boolean
    gatewayProvider?: boolean
    gatewayPaymentId?: boolean
    gatewayFee?: boolean
    transactionId?: boolean
    reference?: boolean
    processedAt?: boolean
    completedAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoicePayment"]>

  export type InvoicePaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    invoiceId?: boolean
    amount?: boolean
    currency?: boolean
    method?: boolean
    status?: boolean
    gatewayProvider?: boolean
    gatewayPaymentId?: boolean
    gatewayFee?: boolean
    transactionId?: boolean
    reference?: boolean
    processedAt?: boolean
    completedAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoicePayment"]>

  export type InvoicePaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    invoiceId?: boolean
    amount?: boolean
    currency?: boolean
    method?: boolean
    status?: boolean
    gatewayProvider?: boolean
    gatewayPaymentId?: boolean
    gatewayFee?: boolean
    transactionId?: boolean
    reference?: boolean
    processedAt?: boolean
    completedAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoicePayment"]>

  export type InvoicePaymentSelectScalar = {
    id?: boolean
    tenantId?: boolean
    invoiceId?: boolean
    amount?: boolean
    currency?: boolean
    method?: boolean
    status?: boolean
    gatewayProvider?: boolean
    gatewayPaymentId?: boolean
    gatewayFee?: boolean
    transactionId?: boolean
    reference?: boolean
    processedAt?: boolean
    completedAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InvoicePaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "invoiceId" | "amount" | "currency" | "method" | "status" | "gatewayProvider" | "gatewayPaymentId" | "gatewayFee" | "transactionId" | "reference" | "processedAt" | "completedAt" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["invoicePayment"]>
  export type InvoicePaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }
  export type InvoicePaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }
  export type InvoicePaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }

  export type $InvoicePaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InvoicePayment"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      invoice: Prisma.$InvoicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      invoiceId: string
      amount: Prisma.Decimal
      currency: string
      method: $Enums.PaymentMethod
      status: string
      gatewayProvider: string | null
      gatewayPaymentId: string | null
      gatewayFee: Prisma.Decimal | null
      transactionId: string | null
      reference: string | null
      processedAt: Date | null
      completedAt: Date | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["invoicePayment"]>
    composites: {}
  }

  type InvoicePaymentGetPayload<S extends boolean | null | undefined | InvoicePaymentDefaultArgs> = $Result.GetResult<Prisma.$InvoicePaymentPayload, S>

  type InvoicePaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvoicePaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoicePaymentCountAggregateInputType | true
    }

  export interface InvoicePaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InvoicePayment'], meta: { name: 'InvoicePayment' } }
    /**
     * Find zero or one InvoicePayment that matches the filter.
     * @param {InvoicePaymentFindUniqueArgs} args - Arguments to find a InvoicePayment
     * @example
     * // Get one InvoicePayment
     * const invoicePayment = await prisma.invoicePayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoicePaymentFindUniqueArgs>(args: SelectSubset<T, InvoicePaymentFindUniqueArgs<ExtArgs>>): Prisma__InvoicePaymentClient<$Result.GetResult<Prisma.$InvoicePaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InvoicePayment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoicePaymentFindUniqueOrThrowArgs} args - Arguments to find a InvoicePayment
     * @example
     * // Get one InvoicePayment
     * const invoicePayment = await prisma.invoicePayment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoicePaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoicePaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoicePaymentClient<$Result.GetResult<Prisma.$InvoicePaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InvoicePayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoicePaymentFindFirstArgs} args - Arguments to find a InvoicePayment
     * @example
     * // Get one InvoicePayment
     * const invoicePayment = await prisma.invoicePayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoicePaymentFindFirstArgs>(args?: SelectSubset<T, InvoicePaymentFindFirstArgs<ExtArgs>>): Prisma__InvoicePaymentClient<$Result.GetResult<Prisma.$InvoicePaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InvoicePayment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoicePaymentFindFirstOrThrowArgs} args - Arguments to find a InvoicePayment
     * @example
     * // Get one InvoicePayment
     * const invoicePayment = await prisma.invoicePayment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoicePaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoicePaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoicePaymentClient<$Result.GetResult<Prisma.$InvoicePaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InvoicePayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoicePaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvoicePayments
     * const invoicePayments = await prisma.invoicePayment.findMany()
     * 
     * // Get first 10 InvoicePayments
     * const invoicePayments = await prisma.invoicePayment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoicePaymentWithIdOnly = await prisma.invoicePayment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoicePaymentFindManyArgs>(args?: SelectSubset<T, InvoicePaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InvoicePayment.
     * @param {InvoicePaymentCreateArgs} args - Arguments to create a InvoicePayment.
     * @example
     * // Create one InvoicePayment
     * const InvoicePayment = await prisma.invoicePayment.create({
     *   data: {
     *     // ... data to create a InvoicePayment
     *   }
     * })
     * 
     */
    create<T extends InvoicePaymentCreateArgs>(args: SelectSubset<T, InvoicePaymentCreateArgs<ExtArgs>>): Prisma__InvoicePaymentClient<$Result.GetResult<Prisma.$InvoicePaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InvoicePayments.
     * @param {InvoicePaymentCreateManyArgs} args - Arguments to create many InvoicePayments.
     * @example
     * // Create many InvoicePayments
     * const invoicePayment = await prisma.invoicePayment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoicePaymentCreateManyArgs>(args?: SelectSubset<T, InvoicePaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InvoicePayments and returns the data saved in the database.
     * @param {InvoicePaymentCreateManyAndReturnArgs} args - Arguments to create many InvoicePayments.
     * @example
     * // Create many InvoicePayments
     * const invoicePayment = await prisma.invoicePayment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InvoicePayments and only return the `id`
     * const invoicePaymentWithIdOnly = await prisma.invoicePayment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoicePaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoicePaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InvoicePayment.
     * @param {InvoicePaymentDeleteArgs} args - Arguments to delete one InvoicePayment.
     * @example
     * // Delete one InvoicePayment
     * const InvoicePayment = await prisma.invoicePayment.delete({
     *   where: {
     *     // ... filter to delete one InvoicePayment
     *   }
     * })
     * 
     */
    delete<T extends InvoicePaymentDeleteArgs>(args: SelectSubset<T, InvoicePaymentDeleteArgs<ExtArgs>>): Prisma__InvoicePaymentClient<$Result.GetResult<Prisma.$InvoicePaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InvoicePayment.
     * @param {InvoicePaymentUpdateArgs} args - Arguments to update one InvoicePayment.
     * @example
     * // Update one InvoicePayment
     * const invoicePayment = await prisma.invoicePayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoicePaymentUpdateArgs>(args: SelectSubset<T, InvoicePaymentUpdateArgs<ExtArgs>>): Prisma__InvoicePaymentClient<$Result.GetResult<Prisma.$InvoicePaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InvoicePayments.
     * @param {InvoicePaymentDeleteManyArgs} args - Arguments to filter InvoicePayments to delete.
     * @example
     * // Delete a few InvoicePayments
     * const { count } = await prisma.invoicePayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoicePaymentDeleteManyArgs>(args?: SelectSubset<T, InvoicePaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvoicePayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoicePaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvoicePayments
     * const invoicePayment = await prisma.invoicePayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoicePaymentUpdateManyArgs>(args: SelectSubset<T, InvoicePaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvoicePayments and returns the data updated in the database.
     * @param {InvoicePaymentUpdateManyAndReturnArgs} args - Arguments to update many InvoicePayments.
     * @example
     * // Update many InvoicePayments
     * const invoicePayment = await prisma.invoicePayment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InvoicePayments and only return the `id`
     * const invoicePaymentWithIdOnly = await prisma.invoicePayment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvoicePaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, InvoicePaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InvoicePayment.
     * @param {InvoicePaymentUpsertArgs} args - Arguments to update or create a InvoicePayment.
     * @example
     * // Update or create a InvoicePayment
     * const invoicePayment = await prisma.invoicePayment.upsert({
     *   create: {
     *     // ... data to create a InvoicePayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvoicePayment we want to update
     *   }
     * })
     */
    upsert<T extends InvoicePaymentUpsertArgs>(args: SelectSubset<T, InvoicePaymentUpsertArgs<ExtArgs>>): Prisma__InvoicePaymentClient<$Result.GetResult<Prisma.$InvoicePaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InvoicePayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoicePaymentCountArgs} args - Arguments to filter InvoicePayments to count.
     * @example
     * // Count the number of InvoicePayments
     * const count = await prisma.invoicePayment.count({
     *   where: {
     *     // ... the filter for the InvoicePayments we want to count
     *   }
     * })
    **/
    count<T extends InvoicePaymentCountArgs>(
      args?: Subset<T, InvoicePaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoicePaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvoicePayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoicePaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoicePaymentAggregateArgs>(args: Subset<T, InvoicePaymentAggregateArgs>): Prisma.PrismaPromise<GetInvoicePaymentAggregateType<T>>

    /**
     * Group by InvoicePayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoicePaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoicePaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoicePaymentGroupByArgs['orderBy'] }
        : { orderBy?: InvoicePaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoicePaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoicePaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InvoicePayment model
   */
  readonly fields: InvoicePaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InvoicePayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoicePaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    invoice<T extends InvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceDefaultArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InvoicePayment model
   */
  interface InvoicePaymentFieldRefs {
    readonly id: FieldRef<"InvoicePayment", 'String'>
    readonly tenantId: FieldRef<"InvoicePayment", 'String'>
    readonly invoiceId: FieldRef<"InvoicePayment", 'String'>
    readonly amount: FieldRef<"InvoicePayment", 'Decimal'>
    readonly currency: FieldRef<"InvoicePayment", 'String'>
    readonly method: FieldRef<"InvoicePayment", 'PaymentMethod'>
    readonly status: FieldRef<"InvoicePayment", 'String'>
    readonly gatewayProvider: FieldRef<"InvoicePayment", 'String'>
    readonly gatewayPaymentId: FieldRef<"InvoicePayment", 'String'>
    readonly gatewayFee: FieldRef<"InvoicePayment", 'Decimal'>
    readonly transactionId: FieldRef<"InvoicePayment", 'String'>
    readonly reference: FieldRef<"InvoicePayment", 'String'>
    readonly processedAt: FieldRef<"InvoicePayment", 'DateTime'>
    readonly completedAt: FieldRef<"InvoicePayment", 'DateTime'>
    readonly metadata: FieldRef<"InvoicePayment", 'Json'>
    readonly createdAt: FieldRef<"InvoicePayment", 'DateTime'>
    readonly updatedAt: FieldRef<"InvoicePayment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InvoicePayment findUnique
   */
  export type InvoicePaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoicePayment
     */
    select?: InvoicePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoicePayment
     */
    omit?: InvoicePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoicePaymentInclude<ExtArgs> | null
    /**
     * Filter, which InvoicePayment to fetch.
     */
    where: InvoicePaymentWhereUniqueInput
  }

  /**
   * InvoicePayment findUniqueOrThrow
   */
  export type InvoicePaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoicePayment
     */
    select?: InvoicePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoicePayment
     */
    omit?: InvoicePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoicePaymentInclude<ExtArgs> | null
    /**
     * Filter, which InvoicePayment to fetch.
     */
    where: InvoicePaymentWhereUniqueInput
  }

  /**
   * InvoicePayment findFirst
   */
  export type InvoicePaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoicePayment
     */
    select?: InvoicePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoicePayment
     */
    omit?: InvoicePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoicePaymentInclude<ExtArgs> | null
    /**
     * Filter, which InvoicePayment to fetch.
     */
    where?: InvoicePaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoicePayments to fetch.
     */
    orderBy?: InvoicePaymentOrderByWithRelationInput | InvoicePaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoicePayments.
     */
    cursor?: InvoicePaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoicePayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoicePayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoicePayments.
     */
    distinct?: InvoicePaymentScalarFieldEnum | InvoicePaymentScalarFieldEnum[]
  }

  /**
   * InvoicePayment findFirstOrThrow
   */
  export type InvoicePaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoicePayment
     */
    select?: InvoicePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoicePayment
     */
    omit?: InvoicePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoicePaymentInclude<ExtArgs> | null
    /**
     * Filter, which InvoicePayment to fetch.
     */
    where?: InvoicePaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoicePayments to fetch.
     */
    orderBy?: InvoicePaymentOrderByWithRelationInput | InvoicePaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoicePayments.
     */
    cursor?: InvoicePaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoicePayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoicePayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoicePayments.
     */
    distinct?: InvoicePaymentScalarFieldEnum | InvoicePaymentScalarFieldEnum[]
  }

  /**
   * InvoicePayment findMany
   */
  export type InvoicePaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoicePayment
     */
    select?: InvoicePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoicePayment
     */
    omit?: InvoicePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoicePaymentInclude<ExtArgs> | null
    /**
     * Filter, which InvoicePayments to fetch.
     */
    where?: InvoicePaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoicePayments to fetch.
     */
    orderBy?: InvoicePaymentOrderByWithRelationInput | InvoicePaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InvoicePayments.
     */
    cursor?: InvoicePaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoicePayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoicePayments.
     */
    skip?: number
    distinct?: InvoicePaymentScalarFieldEnum | InvoicePaymentScalarFieldEnum[]
  }

  /**
   * InvoicePayment create
   */
  export type InvoicePaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoicePayment
     */
    select?: InvoicePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoicePayment
     */
    omit?: InvoicePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoicePaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a InvoicePayment.
     */
    data: XOR<InvoicePaymentCreateInput, InvoicePaymentUncheckedCreateInput>
  }

  /**
   * InvoicePayment createMany
   */
  export type InvoicePaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InvoicePayments.
     */
    data: InvoicePaymentCreateManyInput | InvoicePaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InvoicePayment createManyAndReturn
   */
  export type InvoicePaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoicePayment
     */
    select?: InvoicePaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InvoicePayment
     */
    omit?: InvoicePaymentOmit<ExtArgs> | null
    /**
     * The data used to create many InvoicePayments.
     */
    data: InvoicePaymentCreateManyInput | InvoicePaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoicePaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvoicePayment update
   */
  export type InvoicePaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoicePayment
     */
    select?: InvoicePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoicePayment
     */
    omit?: InvoicePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoicePaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a InvoicePayment.
     */
    data: XOR<InvoicePaymentUpdateInput, InvoicePaymentUncheckedUpdateInput>
    /**
     * Choose, which InvoicePayment to update.
     */
    where: InvoicePaymentWhereUniqueInput
  }

  /**
   * InvoicePayment updateMany
   */
  export type InvoicePaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InvoicePayments.
     */
    data: XOR<InvoicePaymentUpdateManyMutationInput, InvoicePaymentUncheckedUpdateManyInput>
    /**
     * Filter which InvoicePayments to update
     */
    where?: InvoicePaymentWhereInput
    /**
     * Limit how many InvoicePayments to update.
     */
    limit?: number
  }

  /**
   * InvoicePayment updateManyAndReturn
   */
  export type InvoicePaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoicePayment
     */
    select?: InvoicePaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InvoicePayment
     */
    omit?: InvoicePaymentOmit<ExtArgs> | null
    /**
     * The data used to update InvoicePayments.
     */
    data: XOR<InvoicePaymentUpdateManyMutationInput, InvoicePaymentUncheckedUpdateManyInput>
    /**
     * Filter which InvoicePayments to update
     */
    where?: InvoicePaymentWhereInput
    /**
     * Limit how many InvoicePayments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoicePaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvoicePayment upsert
   */
  export type InvoicePaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoicePayment
     */
    select?: InvoicePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoicePayment
     */
    omit?: InvoicePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoicePaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the InvoicePayment to update in case it exists.
     */
    where: InvoicePaymentWhereUniqueInput
    /**
     * In case the InvoicePayment found by the `where` argument doesn't exist, create a new InvoicePayment with this data.
     */
    create: XOR<InvoicePaymentCreateInput, InvoicePaymentUncheckedCreateInput>
    /**
     * In case the InvoicePayment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoicePaymentUpdateInput, InvoicePaymentUncheckedUpdateInput>
  }

  /**
   * InvoicePayment delete
   */
  export type InvoicePaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoicePayment
     */
    select?: InvoicePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoicePayment
     */
    omit?: InvoicePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoicePaymentInclude<ExtArgs> | null
    /**
     * Filter which InvoicePayment to delete.
     */
    where: InvoicePaymentWhereUniqueInput
  }

  /**
   * InvoicePayment deleteMany
   */
  export type InvoicePaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoicePayments to delete
     */
    where?: InvoicePaymentWhereInput
    /**
     * Limit how many InvoicePayments to delete.
     */
    limit?: number
  }

  /**
   * InvoicePayment without action
   */
  export type InvoicePaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoicePayment
     */
    select?: InvoicePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoicePayment
     */
    omit?: InvoicePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoicePaymentInclude<ExtArgs> | null
  }


  /**
   * Model PaymentGatewayConfig
   */

  export type AggregatePaymentGatewayConfig = {
    _count: PaymentGatewayConfigCountAggregateOutputType | null
    _min: PaymentGatewayConfigMinAggregateOutputType | null
    _max: PaymentGatewayConfigMaxAggregateOutputType | null
  }

  export type PaymentGatewayConfigMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    provider: string | null
    isActive: boolean | null
    isTest: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentGatewayConfigMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    provider: string | null
    isActive: boolean | null
    isTest: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentGatewayConfigCountAggregateOutputType = {
    id: number
    tenantId: number
    provider: number
    config: number
    isActive: number
    isTest: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentGatewayConfigMinAggregateInputType = {
    id?: true
    tenantId?: true
    provider?: true
    isActive?: true
    isTest?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentGatewayConfigMaxAggregateInputType = {
    id?: true
    tenantId?: true
    provider?: true
    isActive?: true
    isTest?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentGatewayConfigCountAggregateInputType = {
    id?: true
    tenantId?: true
    provider?: true
    config?: true
    isActive?: true
    isTest?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentGatewayConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentGatewayConfig to aggregate.
     */
    where?: PaymentGatewayConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentGatewayConfigs to fetch.
     */
    orderBy?: PaymentGatewayConfigOrderByWithRelationInput | PaymentGatewayConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentGatewayConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentGatewayConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentGatewayConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentGatewayConfigs
    **/
    _count?: true | PaymentGatewayConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentGatewayConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentGatewayConfigMaxAggregateInputType
  }

  export type GetPaymentGatewayConfigAggregateType<T extends PaymentGatewayConfigAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentGatewayConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentGatewayConfig[P]>
      : GetScalarType<T[P], AggregatePaymentGatewayConfig[P]>
  }




  export type PaymentGatewayConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentGatewayConfigWhereInput
    orderBy?: PaymentGatewayConfigOrderByWithAggregationInput | PaymentGatewayConfigOrderByWithAggregationInput[]
    by: PaymentGatewayConfigScalarFieldEnum[] | PaymentGatewayConfigScalarFieldEnum
    having?: PaymentGatewayConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentGatewayConfigCountAggregateInputType | true
    _min?: PaymentGatewayConfigMinAggregateInputType
    _max?: PaymentGatewayConfigMaxAggregateInputType
  }

  export type PaymentGatewayConfigGroupByOutputType = {
    id: string
    tenantId: string
    provider: string
    config: JsonValue
    isActive: boolean
    isTest: boolean
    createdAt: Date
    updatedAt: Date
    _count: PaymentGatewayConfigCountAggregateOutputType | null
    _min: PaymentGatewayConfigMinAggregateOutputType | null
    _max: PaymentGatewayConfigMaxAggregateOutputType | null
  }

  type GetPaymentGatewayConfigGroupByPayload<T extends PaymentGatewayConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGatewayConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGatewayConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGatewayConfigGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGatewayConfigGroupByOutputType[P]>
        }
      >
    >


  export type PaymentGatewayConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    provider?: boolean
    config?: boolean
    isActive?: boolean
    isTest?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentGatewayConfig"]>

  export type PaymentGatewayConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    provider?: boolean
    config?: boolean
    isActive?: boolean
    isTest?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentGatewayConfig"]>

  export type PaymentGatewayConfigSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    provider?: boolean
    config?: boolean
    isActive?: boolean
    isTest?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentGatewayConfig"]>

  export type PaymentGatewayConfigSelectScalar = {
    id?: boolean
    tenantId?: boolean
    provider?: boolean
    config?: boolean
    isActive?: boolean
    isTest?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentGatewayConfigOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "provider" | "config" | "isActive" | "isTest" | "createdAt" | "updatedAt", ExtArgs["result"]["paymentGatewayConfig"]>
  export type PaymentGatewayConfigInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type PaymentGatewayConfigIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type PaymentGatewayConfigIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $PaymentGatewayConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentGatewayConfig"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      provider: string
      config: Prisma.JsonValue
      isActive: boolean
      isTest: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["paymentGatewayConfig"]>
    composites: {}
  }

  type PaymentGatewayConfigGetPayload<S extends boolean | null | undefined | PaymentGatewayConfigDefaultArgs> = $Result.GetResult<Prisma.$PaymentGatewayConfigPayload, S>

  type PaymentGatewayConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentGatewayConfigFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentGatewayConfigCountAggregateInputType | true
    }

  export interface PaymentGatewayConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentGatewayConfig'], meta: { name: 'PaymentGatewayConfig' } }
    /**
     * Find zero or one PaymentGatewayConfig that matches the filter.
     * @param {PaymentGatewayConfigFindUniqueArgs} args - Arguments to find a PaymentGatewayConfig
     * @example
     * // Get one PaymentGatewayConfig
     * const paymentGatewayConfig = await prisma.paymentGatewayConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentGatewayConfigFindUniqueArgs>(args: SelectSubset<T, PaymentGatewayConfigFindUniqueArgs<ExtArgs>>): Prisma__PaymentGatewayConfigClient<$Result.GetResult<Prisma.$PaymentGatewayConfigPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PaymentGatewayConfig that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentGatewayConfigFindUniqueOrThrowArgs} args - Arguments to find a PaymentGatewayConfig
     * @example
     * // Get one PaymentGatewayConfig
     * const paymentGatewayConfig = await prisma.paymentGatewayConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentGatewayConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentGatewayConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentGatewayConfigClient<$Result.GetResult<Prisma.$PaymentGatewayConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentGatewayConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGatewayConfigFindFirstArgs} args - Arguments to find a PaymentGatewayConfig
     * @example
     * // Get one PaymentGatewayConfig
     * const paymentGatewayConfig = await prisma.paymentGatewayConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentGatewayConfigFindFirstArgs>(args?: SelectSubset<T, PaymentGatewayConfigFindFirstArgs<ExtArgs>>): Prisma__PaymentGatewayConfigClient<$Result.GetResult<Prisma.$PaymentGatewayConfigPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentGatewayConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGatewayConfigFindFirstOrThrowArgs} args - Arguments to find a PaymentGatewayConfig
     * @example
     * // Get one PaymentGatewayConfig
     * const paymentGatewayConfig = await prisma.paymentGatewayConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentGatewayConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentGatewayConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentGatewayConfigClient<$Result.GetResult<Prisma.$PaymentGatewayConfigPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PaymentGatewayConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGatewayConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentGatewayConfigs
     * const paymentGatewayConfigs = await prisma.paymentGatewayConfig.findMany()
     * 
     * // Get first 10 PaymentGatewayConfigs
     * const paymentGatewayConfigs = await prisma.paymentGatewayConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentGatewayConfigWithIdOnly = await prisma.paymentGatewayConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentGatewayConfigFindManyArgs>(args?: SelectSubset<T, PaymentGatewayConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentGatewayConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PaymentGatewayConfig.
     * @param {PaymentGatewayConfigCreateArgs} args - Arguments to create a PaymentGatewayConfig.
     * @example
     * // Create one PaymentGatewayConfig
     * const PaymentGatewayConfig = await prisma.paymentGatewayConfig.create({
     *   data: {
     *     // ... data to create a PaymentGatewayConfig
     *   }
     * })
     * 
     */
    create<T extends PaymentGatewayConfigCreateArgs>(args: SelectSubset<T, PaymentGatewayConfigCreateArgs<ExtArgs>>): Prisma__PaymentGatewayConfigClient<$Result.GetResult<Prisma.$PaymentGatewayConfigPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PaymentGatewayConfigs.
     * @param {PaymentGatewayConfigCreateManyArgs} args - Arguments to create many PaymentGatewayConfigs.
     * @example
     * // Create many PaymentGatewayConfigs
     * const paymentGatewayConfig = await prisma.paymentGatewayConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentGatewayConfigCreateManyArgs>(args?: SelectSubset<T, PaymentGatewayConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaymentGatewayConfigs and returns the data saved in the database.
     * @param {PaymentGatewayConfigCreateManyAndReturnArgs} args - Arguments to create many PaymentGatewayConfigs.
     * @example
     * // Create many PaymentGatewayConfigs
     * const paymentGatewayConfig = await prisma.paymentGatewayConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaymentGatewayConfigs and only return the `id`
     * const paymentGatewayConfigWithIdOnly = await prisma.paymentGatewayConfig.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentGatewayConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentGatewayConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentGatewayConfigPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PaymentGatewayConfig.
     * @param {PaymentGatewayConfigDeleteArgs} args - Arguments to delete one PaymentGatewayConfig.
     * @example
     * // Delete one PaymentGatewayConfig
     * const PaymentGatewayConfig = await prisma.paymentGatewayConfig.delete({
     *   where: {
     *     // ... filter to delete one PaymentGatewayConfig
     *   }
     * })
     * 
     */
    delete<T extends PaymentGatewayConfigDeleteArgs>(args: SelectSubset<T, PaymentGatewayConfigDeleteArgs<ExtArgs>>): Prisma__PaymentGatewayConfigClient<$Result.GetResult<Prisma.$PaymentGatewayConfigPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PaymentGatewayConfig.
     * @param {PaymentGatewayConfigUpdateArgs} args - Arguments to update one PaymentGatewayConfig.
     * @example
     * // Update one PaymentGatewayConfig
     * const paymentGatewayConfig = await prisma.paymentGatewayConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentGatewayConfigUpdateArgs>(args: SelectSubset<T, PaymentGatewayConfigUpdateArgs<ExtArgs>>): Prisma__PaymentGatewayConfigClient<$Result.GetResult<Prisma.$PaymentGatewayConfigPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PaymentGatewayConfigs.
     * @param {PaymentGatewayConfigDeleteManyArgs} args - Arguments to filter PaymentGatewayConfigs to delete.
     * @example
     * // Delete a few PaymentGatewayConfigs
     * const { count } = await prisma.paymentGatewayConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentGatewayConfigDeleteManyArgs>(args?: SelectSubset<T, PaymentGatewayConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentGatewayConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGatewayConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentGatewayConfigs
     * const paymentGatewayConfig = await prisma.paymentGatewayConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentGatewayConfigUpdateManyArgs>(args: SelectSubset<T, PaymentGatewayConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentGatewayConfigs and returns the data updated in the database.
     * @param {PaymentGatewayConfigUpdateManyAndReturnArgs} args - Arguments to update many PaymentGatewayConfigs.
     * @example
     * // Update many PaymentGatewayConfigs
     * const paymentGatewayConfig = await prisma.paymentGatewayConfig.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PaymentGatewayConfigs and only return the `id`
     * const paymentGatewayConfigWithIdOnly = await prisma.paymentGatewayConfig.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentGatewayConfigUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentGatewayConfigUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentGatewayConfigPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PaymentGatewayConfig.
     * @param {PaymentGatewayConfigUpsertArgs} args - Arguments to update or create a PaymentGatewayConfig.
     * @example
     * // Update or create a PaymentGatewayConfig
     * const paymentGatewayConfig = await prisma.paymentGatewayConfig.upsert({
     *   create: {
     *     // ... data to create a PaymentGatewayConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentGatewayConfig we want to update
     *   }
     * })
     */
    upsert<T extends PaymentGatewayConfigUpsertArgs>(args: SelectSubset<T, PaymentGatewayConfigUpsertArgs<ExtArgs>>): Prisma__PaymentGatewayConfigClient<$Result.GetResult<Prisma.$PaymentGatewayConfigPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PaymentGatewayConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGatewayConfigCountArgs} args - Arguments to filter PaymentGatewayConfigs to count.
     * @example
     * // Count the number of PaymentGatewayConfigs
     * const count = await prisma.paymentGatewayConfig.count({
     *   where: {
     *     // ... the filter for the PaymentGatewayConfigs we want to count
     *   }
     * })
    **/
    count<T extends PaymentGatewayConfigCountArgs>(
      args?: Subset<T, PaymentGatewayConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentGatewayConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentGatewayConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGatewayConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentGatewayConfigAggregateArgs>(args: Subset<T, PaymentGatewayConfigAggregateArgs>): Prisma.PrismaPromise<GetPaymentGatewayConfigAggregateType<T>>

    /**
     * Group by PaymentGatewayConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGatewayConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGatewayConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGatewayConfigGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGatewayConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGatewayConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGatewayConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentGatewayConfig model
   */
  readonly fields: PaymentGatewayConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentGatewayConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentGatewayConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentGatewayConfig model
   */
  interface PaymentGatewayConfigFieldRefs {
    readonly id: FieldRef<"PaymentGatewayConfig", 'String'>
    readonly tenantId: FieldRef<"PaymentGatewayConfig", 'String'>
    readonly provider: FieldRef<"PaymentGatewayConfig", 'String'>
    readonly config: FieldRef<"PaymentGatewayConfig", 'Json'>
    readonly isActive: FieldRef<"PaymentGatewayConfig", 'Boolean'>
    readonly isTest: FieldRef<"PaymentGatewayConfig", 'Boolean'>
    readonly createdAt: FieldRef<"PaymentGatewayConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"PaymentGatewayConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PaymentGatewayConfig findUnique
   */
  export type PaymentGatewayConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentGatewayConfig
     */
    select?: PaymentGatewayConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentGatewayConfig
     */
    omit?: PaymentGatewayConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentGatewayConfigInclude<ExtArgs> | null
    /**
     * Filter, which PaymentGatewayConfig to fetch.
     */
    where: PaymentGatewayConfigWhereUniqueInput
  }

  /**
   * PaymentGatewayConfig findUniqueOrThrow
   */
  export type PaymentGatewayConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentGatewayConfig
     */
    select?: PaymentGatewayConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentGatewayConfig
     */
    omit?: PaymentGatewayConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentGatewayConfigInclude<ExtArgs> | null
    /**
     * Filter, which PaymentGatewayConfig to fetch.
     */
    where: PaymentGatewayConfigWhereUniqueInput
  }

  /**
   * PaymentGatewayConfig findFirst
   */
  export type PaymentGatewayConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentGatewayConfig
     */
    select?: PaymentGatewayConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentGatewayConfig
     */
    omit?: PaymentGatewayConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentGatewayConfigInclude<ExtArgs> | null
    /**
     * Filter, which PaymentGatewayConfig to fetch.
     */
    where?: PaymentGatewayConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentGatewayConfigs to fetch.
     */
    orderBy?: PaymentGatewayConfigOrderByWithRelationInput | PaymentGatewayConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentGatewayConfigs.
     */
    cursor?: PaymentGatewayConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentGatewayConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentGatewayConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentGatewayConfigs.
     */
    distinct?: PaymentGatewayConfigScalarFieldEnum | PaymentGatewayConfigScalarFieldEnum[]
  }

  /**
   * PaymentGatewayConfig findFirstOrThrow
   */
  export type PaymentGatewayConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentGatewayConfig
     */
    select?: PaymentGatewayConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentGatewayConfig
     */
    omit?: PaymentGatewayConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentGatewayConfigInclude<ExtArgs> | null
    /**
     * Filter, which PaymentGatewayConfig to fetch.
     */
    where?: PaymentGatewayConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentGatewayConfigs to fetch.
     */
    orderBy?: PaymentGatewayConfigOrderByWithRelationInput | PaymentGatewayConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentGatewayConfigs.
     */
    cursor?: PaymentGatewayConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentGatewayConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentGatewayConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentGatewayConfigs.
     */
    distinct?: PaymentGatewayConfigScalarFieldEnum | PaymentGatewayConfigScalarFieldEnum[]
  }

  /**
   * PaymentGatewayConfig findMany
   */
  export type PaymentGatewayConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentGatewayConfig
     */
    select?: PaymentGatewayConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentGatewayConfig
     */
    omit?: PaymentGatewayConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentGatewayConfigInclude<ExtArgs> | null
    /**
     * Filter, which PaymentGatewayConfigs to fetch.
     */
    where?: PaymentGatewayConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentGatewayConfigs to fetch.
     */
    orderBy?: PaymentGatewayConfigOrderByWithRelationInput | PaymentGatewayConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentGatewayConfigs.
     */
    cursor?: PaymentGatewayConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentGatewayConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentGatewayConfigs.
     */
    skip?: number
    distinct?: PaymentGatewayConfigScalarFieldEnum | PaymentGatewayConfigScalarFieldEnum[]
  }

  /**
   * PaymentGatewayConfig create
   */
  export type PaymentGatewayConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentGatewayConfig
     */
    select?: PaymentGatewayConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentGatewayConfig
     */
    omit?: PaymentGatewayConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentGatewayConfigInclude<ExtArgs> | null
    /**
     * The data needed to create a PaymentGatewayConfig.
     */
    data: XOR<PaymentGatewayConfigCreateInput, PaymentGatewayConfigUncheckedCreateInput>
  }

  /**
   * PaymentGatewayConfig createMany
   */
  export type PaymentGatewayConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentGatewayConfigs.
     */
    data: PaymentGatewayConfigCreateManyInput | PaymentGatewayConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentGatewayConfig createManyAndReturn
   */
  export type PaymentGatewayConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentGatewayConfig
     */
    select?: PaymentGatewayConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentGatewayConfig
     */
    omit?: PaymentGatewayConfigOmit<ExtArgs> | null
    /**
     * The data used to create many PaymentGatewayConfigs.
     */
    data: PaymentGatewayConfigCreateManyInput | PaymentGatewayConfigCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentGatewayConfigIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaymentGatewayConfig update
   */
  export type PaymentGatewayConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentGatewayConfig
     */
    select?: PaymentGatewayConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentGatewayConfig
     */
    omit?: PaymentGatewayConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentGatewayConfigInclude<ExtArgs> | null
    /**
     * The data needed to update a PaymentGatewayConfig.
     */
    data: XOR<PaymentGatewayConfigUpdateInput, PaymentGatewayConfigUncheckedUpdateInput>
    /**
     * Choose, which PaymentGatewayConfig to update.
     */
    where: PaymentGatewayConfigWhereUniqueInput
  }

  /**
   * PaymentGatewayConfig updateMany
   */
  export type PaymentGatewayConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentGatewayConfigs.
     */
    data: XOR<PaymentGatewayConfigUpdateManyMutationInput, PaymentGatewayConfigUncheckedUpdateManyInput>
    /**
     * Filter which PaymentGatewayConfigs to update
     */
    where?: PaymentGatewayConfigWhereInput
    /**
     * Limit how many PaymentGatewayConfigs to update.
     */
    limit?: number
  }

  /**
   * PaymentGatewayConfig updateManyAndReturn
   */
  export type PaymentGatewayConfigUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentGatewayConfig
     */
    select?: PaymentGatewayConfigSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentGatewayConfig
     */
    omit?: PaymentGatewayConfigOmit<ExtArgs> | null
    /**
     * The data used to update PaymentGatewayConfigs.
     */
    data: XOR<PaymentGatewayConfigUpdateManyMutationInput, PaymentGatewayConfigUncheckedUpdateManyInput>
    /**
     * Filter which PaymentGatewayConfigs to update
     */
    where?: PaymentGatewayConfigWhereInput
    /**
     * Limit how many PaymentGatewayConfigs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentGatewayConfigIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaymentGatewayConfig upsert
   */
  export type PaymentGatewayConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentGatewayConfig
     */
    select?: PaymentGatewayConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentGatewayConfig
     */
    omit?: PaymentGatewayConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentGatewayConfigInclude<ExtArgs> | null
    /**
     * The filter to search for the PaymentGatewayConfig to update in case it exists.
     */
    where: PaymentGatewayConfigWhereUniqueInput
    /**
     * In case the PaymentGatewayConfig found by the `where` argument doesn't exist, create a new PaymentGatewayConfig with this data.
     */
    create: XOR<PaymentGatewayConfigCreateInput, PaymentGatewayConfigUncheckedCreateInput>
    /**
     * In case the PaymentGatewayConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentGatewayConfigUpdateInput, PaymentGatewayConfigUncheckedUpdateInput>
  }

  /**
   * PaymentGatewayConfig delete
   */
  export type PaymentGatewayConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentGatewayConfig
     */
    select?: PaymentGatewayConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentGatewayConfig
     */
    omit?: PaymentGatewayConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentGatewayConfigInclude<ExtArgs> | null
    /**
     * Filter which PaymentGatewayConfig to delete.
     */
    where: PaymentGatewayConfigWhereUniqueInput
  }

  /**
   * PaymentGatewayConfig deleteMany
   */
  export type PaymentGatewayConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentGatewayConfigs to delete
     */
    where?: PaymentGatewayConfigWhereInput
    /**
     * Limit how many PaymentGatewayConfigs to delete.
     */
    limit?: number
  }

  /**
   * PaymentGatewayConfig without action
   */
  export type PaymentGatewayConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentGatewayConfig
     */
    select?: PaymentGatewayConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentGatewayConfig
     */
    omit?: PaymentGatewayConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentGatewayConfigInclude<ExtArgs> | null
  }


  /**
   * Model CryptoWallet
   */

  export type AggregateCryptoWallet = {
    _count: CryptoWalletCountAggregateOutputType | null
    _min: CryptoWalletMinAggregateOutputType | null
    _max: CryptoWalletMaxAggregateOutputType | null
  }

  export type CryptoWalletMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    currency: string | null
    address: string | null
    network: string | null
    provider: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CryptoWalletMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    currency: string | null
    address: string | null
    network: string | null
    provider: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CryptoWalletCountAggregateOutputType = {
    id: number
    tenantId: number
    currency: number
    address: number
    network: number
    provider: number
    isActive: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CryptoWalletMinAggregateInputType = {
    id?: true
    tenantId?: true
    currency?: true
    address?: true
    network?: true
    provider?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CryptoWalletMaxAggregateInputType = {
    id?: true
    tenantId?: true
    currency?: true
    address?: true
    network?: true
    provider?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CryptoWalletCountAggregateInputType = {
    id?: true
    tenantId?: true
    currency?: true
    address?: true
    network?: true
    provider?: true
    isActive?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CryptoWalletAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CryptoWallet to aggregate.
     */
    where?: CryptoWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CryptoWallets to fetch.
     */
    orderBy?: CryptoWalletOrderByWithRelationInput | CryptoWalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CryptoWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CryptoWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CryptoWallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CryptoWallets
    **/
    _count?: true | CryptoWalletCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CryptoWalletMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CryptoWalletMaxAggregateInputType
  }

  export type GetCryptoWalletAggregateType<T extends CryptoWalletAggregateArgs> = {
        [P in keyof T & keyof AggregateCryptoWallet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCryptoWallet[P]>
      : GetScalarType<T[P], AggregateCryptoWallet[P]>
  }




  export type CryptoWalletGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CryptoWalletWhereInput
    orderBy?: CryptoWalletOrderByWithAggregationInput | CryptoWalletOrderByWithAggregationInput[]
    by: CryptoWalletScalarFieldEnum[] | CryptoWalletScalarFieldEnum
    having?: CryptoWalletScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CryptoWalletCountAggregateInputType | true
    _min?: CryptoWalletMinAggregateInputType
    _max?: CryptoWalletMaxAggregateInputType
  }

  export type CryptoWalletGroupByOutputType = {
    id: string
    tenantId: string
    currency: string
    address: string
    network: string | null
    provider: string
    isActive: boolean
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: CryptoWalletCountAggregateOutputType | null
    _min: CryptoWalletMinAggregateOutputType | null
    _max: CryptoWalletMaxAggregateOutputType | null
  }

  type GetCryptoWalletGroupByPayload<T extends CryptoWalletGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CryptoWalletGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CryptoWalletGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CryptoWalletGroupByOutputType[P]>
            : GetScalarType<T[P], CryptoWalletGroupByOutputType[P]>
        }
      >
    >


  export type CryptoWalletSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    currency?: boolean
    address?: boolean
    network?: boolean
    provider?: boolean
    isActive?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    payments?: boolean | CryptoWallet$paymentsArgs<ExtArgs>
    _count?: boolean | CryptoWalletCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cryptoWallet"]>

  export type CryptoWalletSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    currency?: boolean
    address?: boolean
    network?: boolean
    provider?: boolean
    isActive?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cryptoWallet"]>

  export type CryptoWalletSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    currency?: boolean
    address?: boolean
    network?: boolean
    provider?: boolean
    isActive?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cryptoWallet"]>

  export type CryptoWalletSelectScalar = {
    id?: boolean
    tenantId?: boolean
    currency?: boolean
    address?: boolean
    network?: boolean
    provider?: boolean
    isActive?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CryptoWalletOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "currency" | "address" | "network" | "provider" | "isActive" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["cryptoWallet"]>
  export type CryptoWalletInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    payments?: boolean | CryptoWallet$paymentsArgs<ExtArgs>
    _count?: boolean | CryptoWalletCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CryptoWalletIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type CryptoWalletIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $CryptoWalletPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CryptoWallet"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      payments: Prisma.$CryptoPaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      currency: string
      address: string
      network: string | null
      provider: string
      isActive: boolean
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cryptoWallet"]>
    composites: {}
  }

  type CryptoWalletGetPayload<S extends boolean | null | undefined | CryptoWalletDefaultArgs> = $Result.GetResult<Prisma.$CryptoWalletPayload, S>

  type CryptoWalletCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CryptoWalletFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CryptoWalletCountAggregateInputType | true
    }

  export interface CryptoWalletDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CryptoWallet'], meta: { name: 'CryptoWallet' } }
    /**
     * Find zero or one CryptoWallet that matches the filter.
     * @param {CryptoWalletFindUniqueArgs} args - Arguments to find a CryptoWallet
     * @example
     * // Get one CryptoWallet
     * const cryptoWallet = await prisma.cryptoWallet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CryptoWalletFindUniqueArgs>(args: SelectSubset<T, CryptoWalletFindUniqueArgs<ExtArgs>>): Prisma__CryptoWalletClient<$Result.GetResult<Prisma.$CryptoWalletPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CryptoWallet that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CryptoWalletFindUniqueOrThrowArgs} args - Arguments to find a CryptoWallet
     * @example
     * // Get one CryptoWallet
     * const cryptoWallet = await prisma.cryptoWallet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CryptoWalletFindUniqueOrThrowArgs>(args: SelectSubset<T, CryptoWalletFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CryptoWalletClient<$Result.GetResult<Prisma.$CryptoWalletPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CryptoWallet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoWalletFindFirstArgs} args - Arguments to find a CryptoWallet
     * @example
     * // Get one CryptoWallet
     * const cryptoWallet = await prisma.cryptoWallet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CryptoWalletFindFirstArgs>(args?: SelectSubset<T, CryptoWalletFindFirstArgs<ExtArgs>>): Prisma__CryptoWalletClient<$Result.GetResult<Prisma.$CryptoWalletPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CryptoWallet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoWalletFindFirstOrThrowArgs} args - Arguments to find a CryptoWallet
     * @example
     * // Get one CryptoWallet
     * const cryptoWallet = await prisma.cryptoWallet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CryptoWalletFindFirstOrThrowArgs>(args?: SelectSubset<T, CryptoWalletFindFirstOrThrowArgs<ExtArgs>>): Prisma__CryptoWalletClient<$Result.GetResult<Prisma.$CryptoWalletPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CryptoWallets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoWalletFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CryptoWallets
     * const cryptoWallets = await prisma.cryptoWallet.findMany()
     * 
     * // Get first 10 CryptoWallets
     * const cryptoWallets = await prisma.cryptoWallet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cryptoWalletWithIdOnly = await prisma.cryptoWallet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CryptoWalletFindManyArgs>(args?: SelectSubset<T, CryptoWalletFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CryptoWalletPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CryptoWallet.
     * @param {CryptoWalletCreateArgs} args - Arguments to create a CryptoWallet.
     * @example
     * // Create one CryptoWallet
     * const CryptoWallet = await prisma.cryptoWallet.create({
     *   data: {
     *     // ... data to create a CryptoWallet
     *   }
     * })
     * 
     */
    create<T extends CryptoWalletCreateArgs>(args: SelectSubset<T, CryptoWalletCreateArgs<ExtArgs>>): Prisma__CryptoWalletClient<$Result.GetResult<Prisma.$CryptoWalletPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CryptoWallets.
     * @param {CryptoWalletCreateManyArgs} args - Arguments to create many CryptoWallets.
     * @example
     * // Create many CryptoWallets
     * const cryptoWallet = await prisma.cryptoWallet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CryptoWalletCreateManyArgs>(args?: SelectSubset<T, CryptoWalletCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CryptoWallets and returns the data saved in the database.
     * @param {CryptoWalletCreateManyAndReturnArgs} args - Arguments to create many CryptoWallets.
     * @example
     * // Create many CryptoWallets
     * const cryptoWallet = await prisma.cryptoWallet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CryptoWallets and only return the `id`
     * const cryptoWalletWithIdOnly = await prisma.cryptoWallet.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CryptoWalletCreateManyAndReturnArgs>(args?: SelectSubset<T, CryptoWalletCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CryptoWalletPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CryptoWallet.
     * @param {CryptoWalletDeleteArgs} args - Arguments to delete one CryptoWallet.
     * @example
     * // Delete one CryptoWallet
     * const CryptoWallet = await prisma.cryptoWallet.delete({
     *   where: {
     *     // ... filter to delete one CryptoWallet
     *   }
     * })
     * 
     */
    delete<T extends CryptoWalletDeleteArgs>(args: SelectSubset<T, CryptoWalletDeleteArgs<ExtArgs>>): Prisma__CryptoWalletClient<$Result.GetResult<Prisma.$CryptoWalletPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CryptoWallet.
     * @param {CryptoWalletUpdateArgs} args - Arguments to update one CryptoWallet.
     * @example
     * // Update one CryptoWallet
     * const cryptoWallet = await prisma.cryptoWallet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CryptoWalletUpdateArgs>(args: SelectSubset<T, CryptoWalletUpdateArgs<ExtArgs>>): Prisma__CryptoWalletClient<$Result.GetResult<Prisma.$CryptoWalletPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CryptoWallets.
     * @param {CryptoWalletDeleteManyArgs} args - Arguments to filter CryptoWallets to delete.
     * @example
     * // Delete a few CryptoWallets
     * const { count } = await prisma.cryptoWallet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CryptoWalletDeleteManyArgs>(args?: SelectSubset<T, CryptoWalletDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CryptoWallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoWalletUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CryptoWallets
     * const cryptoWallet = await prisma.cryptoWallet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CryptoWalletUpdateManyArgs>(args: SelectSubset<T, CryptoWalletUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CryptoWallets and returns the data updated in the database.
     * @param {CryptoWalletUpdateManyAndReturnArgs} args - Arguments to update many CryptoWallets.
     * @example
     * // Update many CryptoWallets
     * const cryptoWallet = await prisma.cryptoWallet.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CryptoWallets and only return the `id`
     * const cryptoWalletWithIdOnly = await prisma.cryptoWallet.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CryptoWalletUpdateManyAndReturnArgs>(args: SelectSubset<T, CryptoWalletUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CryptoWalletPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CryptoWallet.
     * @param {CryptoWalletUpsertArgs} args - Arguments to update or create a CryptoWallet.
     * @example
     * // Update or create a CryptoWallet
     * const cryptoWallet = await prisma.cryptoWallet.upsert({
     *   create: {
     *     // ... data to create a CryptoWallet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CryptoWallet we want to update
     *   }
     * })
     */
    upsert<T extends CryptoWalletUpsertArgs>(args: SelectSubset<T, CryptoWalletUpsertArgs<ExtArgs>>): Prisma__CryptoWalletClient<$Result.GetResult<Prisma.$CryptoWalletPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CryptoWallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoWalletCountArgs} args - Arguments to filter CryptoWallets to count.
     * @example
     * // Count the number of CryptoWallets
     * const count = await prisma.cryptoWallet.count({
     *   where: {
     *     // ... the filter for the CryptoWallets we want to count
     *   }
     * })
    **/
    count<T extends CryptoWalletCountArgs>(
      args?: Subset<T, CryptoWalletCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CryptoWalletCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CryptoWallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoWalletAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CryptoWalletAggregateArgs>(args: Subset<T, CryptoWalletAggregateArgs>): Prisma.PrismaPromise<GetCryptoWalletAggregateType<T>>

    /**
     * Group by CryptoWallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoWalletGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CryptoWalletGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CryptoWalletGroupByArgs['orderBy'] }
        : { orderBy?: CryptoWalletGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CryptoWalletGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCryptoWalletGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CryptoWallet model
   */
  readonly fields: CryptoWalletFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CryptoWallet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CryptoWalletClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    payments<T extends CryptoWallet$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, CryptoWallet$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CryptoPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CryptoWallet model
   */
  interface CryptoWalletFieldRefs {
    readonly id: FieldRef<"CryptoWallet", 'String'>
    readonly tenantId: FieldRef<"CryptoWallet", 'String'>
    readonly currency: FieldRef<"CryptoWallet", 'String'>
    readonly address: FieldRef<"CryptoWallet", 'String'>
    readonly network: FieldRef<"CryptoWallet", 'String'>
    readonly provider: FieldRef<"CryptoWallet", 'String'>
    readonly isActive: FieldRef<"CryptoWallet", 'Boolean'>
    readonly metadata: FieldRef<"CryptoWallet", 'Json'>
    readonly createdAt: FieldRef<"CryptoWallet", 'DateTime'>
    readonly updatedAt: FieldRef<"CryptoWallet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CryptoWallet findUnique
   */
  export type CryptoWalletFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoWallet
     */
    select?: CryptoWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoWallet
     */
    omit?: CryptoWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoWalletInclude<ExtArgs> | null
    /**
     * Filter, which CryptoWallet to fetch.
     */
    where: CryptoWalletWhereUniqueInput
  }

  /**
   * CryptoWallet findUniqueOrThrow
   */
  export type CryptoWalletFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoWallet
     */
    select?: CryptoWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoWallet
     */
    omit?: CryptoWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoWalletInclude<ExtArgs> | null
    /**
     * Filter, which CryptoWallet to fetch.
     */
    where: CryptoWalletWhereUniqueInput
  }

  /**
   * CryptoWallet findFirst
   */
  export type CryptoWalletFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoWallet
     */
    select?: CryptoWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoWallet
     */
    omit?: CryptoWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoWalletInclude<ExtArgs> | null
    /**
     * Filter, which CryptoWallet to fetch.
     */
    where?: CryptoWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CryptoWallets to fetch.
     */
    orderBy?: CryptoWalletOrderByWithRelationInput | CryptoWalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CryptoWallets.
     */
    cursor?: CryptoWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CryptoWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CryptoWallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CryptoWallets.
     */
    distinct?: CryptoWalletScalarFieldEnum | CryptoWalletScalarFieldEnum[]
  }

  /**
   * CryptoWallet findFirstOrThrow
   */
  export type CryptoWalletFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoWallet
     */
    select?: CryptoWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoWallet
     */
    omit?: CryptoWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoWalletInclude<ExtArgs> | null
    /**
     * Filter, which CryptoWallet to fetch.
     */
    where?: CryptoWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CryptoWallets to fetch.
     */
    orderBy?: CryptoWalletOrderByWithRelationInput | CryptoWalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CryptoWallets.
     */
    cursor?: CryptoWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CryptoWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CryptoWallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CryptoWallets.
     */
    distinct?: CryptoWalletScalarFieldEnum | CryptoWalletScalarFieldEnum[]
  }

  /**
   * CryptoWallet findMany
   */
  export type CryptoWalletFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoWallet
     */
    select?: CryptoWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoWallet
     */
    omit?: CryptoWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoWalletInclude<ExtArgs> | null
    /**
     * Filter, which CryptoWallets to fetch.
     */
    where?: CryptoWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CryptoWallets to fetch.
     */
    orderBy?: CryptoWalletOrderByWithRelationInput | CryptoWalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CryptoWallets.
     */
    cursor?: CryptoWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CryptoWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CryptoWallets.
     */
    skip?: number
    distinct?: CryptoWalletScalarFieldEnum | CryptoWalletScalarFieldEnum[]
  }

  /**
   * CryptoWallet create
   */
  export type CryptoWalletCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoWallet
     */
    select?: CryptoWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoWallet
     */
    omit?: CryptoWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoWalletInclude<ExtArgs> | null
    /**
     * The data needed to create a CryptoWallet.
     */
    data: XOR<CryptoWalletCreateInput, CryptoWalletUncheckedCreateInput>
  }

  /**
   * CryptoWallet createMany
   */
  export type CryptoWalletCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CryptoWallets.
     */
    data: CryptoWalletCreateManyInput | CryptoWalletCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CryptoWallet createManyAndReturn
   */
  export type CryptoWalletCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoWallet
     */
    select?: CryptoWalletSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoWallet
     */
    omit?: CryptoWalletOmit<ExtArgs> | null
    /**
     * The data used to create many CryptoWallets.
     */
    data: CryptoWalletCreateManyInput | CryptoWalletCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoWalletIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CryptoWallet update
   */
  export type CryptoWalletUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoWallet
     */
    select?: CryptoWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoWallet
     */
    omit?: CryptoWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoWalletInclude<ExtArgs> | null
    /**
     * The data needed to update a CryptoWallet.
     */
    data: XOR<CryptoWalletUpdateInput, CryptoWalletUncheckedUpdateInput>
    /**
     * Choose, which CryptoWallet to update.
     */
    where: CryptoWalletWhereUniqueInput
  }

  /**
   * CryptoWallet updateMany
   */
  export type CryptoWalletUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CryptoWallets.
     */
    data: XOR<CryptoWalletUpdateManyMutationInput, CryptoWalletUncheckedUpdateManyInput>
    /**
     * Filter which CryptoWallets to update
     */
    where?: CryptoWalletWhereInput
    /**
     * Limit how many CryptoWallets to update.
     */
    limit?: number
  }

  /**
   * CryptoWallet updateManyAndReturn
   */
  export type CryptoWalletUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoWallet
     */
    select?: CryptoWalletSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoWallet
     */
    omit?: CryptoWalletOmit<ExtArgs> | null
    /**
     * The data used to update CryptoWallets.
     */
    data: XOR<CryptoWalletUpdateManyMutationInput, CryptoWalletUncheckedUpdateManyInput>
    /**
     * Filter which CryptoWallets to update
     */
    where?: CryptoWalletWhereInput
    /**
     * Limit how many CryptoWallets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoWalletIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CryptoWallet upsert
   */
  export type CryptoWalletUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoWallet
     */
    select?: CryptoWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoWallet
     */
    omit?: CryptoWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoWalletInclude<ExtArgs> | null
    /**
     * The filter to search for the CryptoWallet to update in case it exists.
     */
    where: CryptoWalletWhereUniqueInput
    /**
     * In case the CryptoWallet found by the `where` argument doesn't exist, create a new CryptoWallet with this data.
     */
    create: XOR<CryptoWalletCreateInput, CryptoWalletUncheckedCreateInput>
    /**
     * In case the CryptoWallet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CryptoWalletUpdateInput, CryptoWalletUncheckedUpdateInput>
  }

  /**
   * CryptoWallet delete
   */
  export type CryptoWalletDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoWallet
     */
    select?: CryptoWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoWallet
     */
    omit?: CryptoWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoWalletInclude<ExtArgs> | null
    /**
     * Filter which CryptoWallet to delete.
     */
    where: CryptoWalletWhereUniqueInput
  }

  /**
   * CryptoWallet deleteMany
   */
  export type CryptoWalletDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CryptoWallets to delete
     */
    where?: CryptoWalletWhereInput
    /**
     * Limit how many CryptoWallets to delete.
     */
    limit?: number
  }

  /**
   * CryptoWallet.payments
   */
  export type CryptoWallet$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoPayment
     */
    select?: CryptoPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoPayment
     */
    omit?: CryptoPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoPaymentInclude<ExtArgs> | null
    where?: CryptoPaymentWhereInput
    orderBy?: CryptoPaymentOrderByWithRelationInput | CryptoPaymentOrderByWithRelationInput[]
    cursor?: CryptoPaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CryptoPaymentScalarFieldEnum | CryptoPaymentScalarFieldEnum[]
  }

  /**
   * CryptoWallet without action
   */
  export type CryptoWalletDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoWallet
     */
    select?: CryptoWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoWallet
     */
    omit?: CryptoWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoWalletInclude<ExtArgs> | null
  }


  /**
   * Model CryptoPayment
   */

  export type AggregateCryptoPayment = {
    _count: CryptoPaymentCountAggregateOutputType | null
    _avg: CryptoPaymentAvgAggregateOutputType | null
    _sum: CryptoPaymentSumAggregateOutputType | null
    _min: CryptoPaymentMinAggregateOutputType | null
    _max: CryptoPaymentMaxAggregateOutputType | null
  }

  export type CryptoPaymentAvgAggregateOutputType = {
    confirmations: number | null
  }

  export type CryptoPaymentSumAggregateOutputType = {
    confirmations: number | null
  }

  export type CryptoPaymentMinAggregateOutputType = {
    id: string | null
    walletId: string | null
    invoiceId: string | null
    amount: string | null
    currency: string | null
    txHash: string | null
    confirmations: number | null
    status: string | null
    detectedAt: Date | null
    confirmedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CryptoPaymentMaxAggregateOutputType = {
    id: string | null
    walletId: string | null
    invoiceId: string | null
    amount: string | null
    currency: string | null
    txHash: string | null
    confirmations: number | null
    status: string | null
    detectedAt: Date | null
    confirmedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CryptoPaymentCountAggregateOutputType = {
    id: number
    walletId: number
    invoiceId: number
    amount: number
    currency: number
    txHash: number
    confirmations: number
    status: number
    detectedAt: number
    confirmedAt: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CryptoPaymentAvgAggregateInputType = {
    confirmations?: true
  }

  export type CryptoPaymentSumAggregateInputType = {
    confirmations?: true
  }

  export type CryptoPaymentMinAggregateInputType = {
    id?: true
    walletId?: true
    invoiceId?: true
    amount?: true
    currency?: true
    txHash?: true
    confirmations?: true
    status?: true
    detectedAt?: true
    confirmedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CryptoPaymentMaxAggregateInputType = {
    id?: true
    walletId?: true
    invoiceId?: true
    amount?: true
    currency?: true
    txHash?: true
    confirmations?: true
    status?: true
    detectedAt?: true
    confirmedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CryptoPaymentCountAggregateInputType = {
    id?: true
    walletId?: true
    invoiceId?: true
    amount?: true
    currency?: true
    txHash?: true
    confirmations?: true
    status?: true
    detectedAt?: true
    confirmedAt?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CryptoPaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CryptoPayment to aggregate.
     */
    where?: CryptoPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CryptoPayments to fetch.
     */
    orderBy?: CryptoPaymentOrderByWithRelationInput | CryptoPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CryptoPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CryptoPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CryptoPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CryptoPayments
    **/
    _count?: true | CryptoPaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CryptoPaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CryptoPaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CryptoPaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CryptoPaymentMaxAggregateInputType
  }

  export type GetCryptoPaymentAggregateType<T extends CryptoPaymentAggregateArgs> = {
        [P in keyof T & keyof AggregateCryptoPayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCryptoPayment[P]>
      : GetScalarType<T[P], AggregateCryptoPayment[P]>
  }




  export type CryptoPaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CryptoPaymentWhereInput
    orderBy?: CryptoPaymentOrderByWithAggregationInput | CryptoPaymentOrderByWithAggregationInput[]
    by: CryptoPaymentScalarFieldEnum[] | CryptoPaymentScalarFieldEnum
    having?: CryptoPaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CryptoPaymentCountAggregateInputType | true
    _avg?: CryptoPaymentAvgAggregateInputType
    _sum?: CryptoPaymentSumAggregateInputType
    _min?: CryptoPaymentMinAggregateInputType
    _max?: CryptoPaymentMaxAggregateInputType
  }

  export type CryptoPaymentGroupByOutputType = {
    id: string
    walletId: string
    invoiceId: string | null
    amount: string
    currency: string
    txHash: string | null
    confirmations: number
    status: string
    detectedAt: Date | null
    confirmedAt: Date | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: CryptoPaymentCountAggregateOutputType | null
    _avg: CryptoPaymentAvgAggregateOutputType | null
    _sum: CryptoPaymentSumAggregateOutputType | null
    _min: CryptoPaymentMinAggregateOutputType | null
    _max: CryptoPaymentMaxAggregateOutputType | null
  }

  type GetCryptoPaymentGroupByPayload<T extends CryptoPaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CryptoPaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CryptoPaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CryptoPaymentGroupByOutputType[P]>
            : GetScalarType<T[P], CryptoPaymentGroupByOutputType[P]>
        }
      >
    >


  export type CryptoPaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    walletId?: boolean
    invoiceId?: boolean
    amount?: boolean
    currency?: boolean
    txHash?: boolean
    confirmations?: boolean
    status?: boolean
    detectedAt?: boolean
    confirmedAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    wallet?: boolean | CryptoWalletDefaultArgs<ExtArgs>
    invoice?: boolean | CryptoPayment$invoiceArgs<ExtArgs>
  }, ExtArgs["result"]["cryptoPayment"]>

  export type CryptoPaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    walletId?: boolean
    invoiceId?: boolean
    amount?: boolean
    currency?: boolean
    txHash?: boolean
    confirmations?: boolean
    status?: boolean
    detectedAt?: boolean
    confirmedAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    wallet?: boolean | CryptoWalletDefaultArgs<ExtArgs>
    invoice?: boolean | CryptoPayment$invoiceArgs<ExtArgs>
  }, ExtArgs["result"]["cryptoPayment"]>

  export type CryptoPaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    walletId?: boolean
    invoiceId?: boolean
    amount?: boolean
    currency?: boolean
    txHash?: boolean
    confirmations?: boolean
    status?: boolean
    detectedAt?: boolean
    confirmedAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    wallet?: boolean | CryptoWalletDefaultArgs<ExtArgs>
    invoice?: boolean | CryptoPayment$invoiceArgs<ExtArgs>
  }, ExtArgs["result"]["cryptoPayment"]>

  export type CryptoPaymentSelectScalar = {
    id?: boolean
    walletId?: boolean
    invoiceId?: boolean
    amount?: boolean
    currency?: boolean
    txHash?: boolean
    confirmations?: boolean
    status?: boolean
    detectedAt?: boolean
    confirmedAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CryptoPaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "walletId" | "invoiceId" | "amount" | "currency" | "txHash" | "confirmations" | "status" | "detectedAt" | "confirmedAt" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["cryptoPayment"]>
  export type CryptoPaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    wallet?: boolean | CryptoWalletDefaultArgs<ExtArgs>
    invoice?: boolean | CryptoPayment$invoiceArgs<ExtArgs>
  }
  export type CryptoPaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    wallet?: boolean | CryptoWalletDefaultArgs<ExtArgs>
    invoice?: boolean | CryptoPayment$invoiceArgs<ExtArgs>
  }
  export type CryptoPaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    wallet?: boolean | CryptoWalletDefaultArgs<ExtArgs>
    invoice?: boolean | CryptoPayment$invoiceArgs<ExtArgs>
  }

  export type $CryptoPaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CryptoPayment"
    objects: {
      wallet: Prisma.$CryptoWalletPayload<ExtArgs>
      invoice: Prisma.$InvoicePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      walletId: string
      invoiceId: string | null
      amount: string
      currency: string
      txHash: string | null
      confirmations: number
      status: string
      detectedAt: Date | null
      confirmedAt: Date | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cryptoPayment"]>
    composites: {}
  }

  type CryptoPaymentGetPayload<S extends boolean | null | undefined | CryptoPaymentDefaultArgs> = $Result.GetResult<Prisma.$CryptoPaymentPayload, S>

  type CryptoPaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CryptoPaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CryptoPaymentCountAggregateInputType | true
    }

  export interface CryptoPaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CryptoPayment'], meta: { name: 'CryptoPayment' } }
    /**
     * Find zero or one CryptoPayment that matches the filter.
     * @param {CryptoPaymentFindUniqueArgs} args - Arguments to find a CryptoPayment
     * @example
     * // Get one CryptoPayment
     * const cryptoPayment = await prisma.cryptoPayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CryptoPaymentFindUniqueArgs>(args: SelectSubset<T, CryptoPaymentFindUniqueArgs<ExtArgs>>): Prisma__CryptoPaymentClient<$Result.GetResult<Prisma.$CryptoPaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CryptoPayment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CryptoPaymentFindUniqueOrThrowArgs} args - Arguments to find a CryptoPayment
     * @example
     * // Get one CryptoPayment
     * const cryptoPayment = await prisma.cryptoPayment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CryptoPaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, CryptoPaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CryptoPaymentClient<$Result.GetResult<Prisma.$CryptoPaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CryptoPayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoPaymentFindFirstArgs} args - Arguments to find a CryptoPayment
     * @example
     * // Get one CryptoPayment
     * const cryptoPayment = await prisma.cryptoPayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CryptoPaymentFindFirstArgs>(args?: SelectSubset<T, CryptoPaymentFindFirstArgs<ExtArgs>>): Prisma__CryptoPaymentClient<$Result.GetResult<Prisma.$CryptoPaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CryptoPayment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoPaymentFindFirstOrThrowArgs} args - Arguments to find a CryptoPayment
     * @example
     * // Get one CryptoPayment
     * const cryptoPayment = await prisma.cryptoPayment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CryptoPaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, CryptoPaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CryptoPaymentClient<$Result.GetResult<Prisma.$CryptoPaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CryptoPayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoPaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CryptoPayments
     * const cryptoPayments = await prisma.cryptoPayment.findMany()
     * 
     * // Get first 10 CryptoPayments
     * const cryptoPayments = await prisma.cryptoPayment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cryptoPaymentWithIdOnly = await prisma.cryptoPayment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CryptoPaymentFindManyArgs>(args?: SelectSubset<T, CryptoPaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CryptoPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CryptoPayment.
     * @param {CryptoPaymentCreateArgs} args - Arguments to create a CryptoPayment.
     * @example
     * // Create one CryptoPayment
     * const CryptoPayment = await prisma.cryptoPayment.create({
     *   data: {
     *     // ... data to create a CryptoPayment
     *   }
     * })
     * 
     */
    create<T extends CryptoPaymentCreateArgs>(args: SelectSubset<T, CryptoPaymentCreateArgs<ExtArgs>>): Prisma__CryptoPaymentClient<$Result.GetResult<Prisma.$CryptoPaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CryptoPayments.
     * @param {CryptoPaymentCreateManyArgs} args - Arguments to create many CryptoPayments.
     * @example
     * // Create many CryptoPayments
     * const cryptoPayment = await prisma.cryptoPayment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CryptoPaymentCreateManyArgs>(args?: SelectSubset<T, CryptoPaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CryptoPayments and returns the data saved in the database.
     * @param {CryptoPaymentCreateManyAndReturnArgs} args - Arguments to create many CryptoPayments.
     * @example
     * // Create many CryptoPayments
     * const cryptoPayment = await prisma.cryptoPayment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CryptoPayments and only return the `id`
     * const cryptoPaymentWithIdOnly = await prisma.cryptoPayment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CryptoPaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, CryptoPaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CryptoPaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CryptoPayment.
     * @param {CryptoPaymentDeleteArgs} args - Arguments to delete one CryptoPayment.
     * @example
     * // Delete one CryptoPayment
     * const CryptoPayment = await prisma.cryptoPayment.delete({
     *   where: {
     *     // ... filter to delete one CryptoPayment
     *   }
     * })
     * 
     */
    delete<T extends CryptoPaymentDeleteArgs>(args: SelectSubset<T, CryptoPaymentDeleteArgs<ExtArgs>>): Prisma__CryptoPaymentClient<$Result.GetResult<Prisma.$CryptoPaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CryptoPayment.
     * @param {CryptoPaymentUpdateArgs} args - Arguments to update one CryptoPayment.
     * @example
     * // Update one CryptoPayment
     * const cryptoPayment = await prisma.cryptoPayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CryptoPaymentUpdateArgs>(args: SelectSubset<T, CryptoPaymentUpdateArgs<ExtArgs>>): Prisma__CryptoPaymentClient<$Result.GetResult<Prisma.$CryptoPaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CryptoPayments.
     * @param {CryptoPaymentDeleteManyArgs} args - Arguments to filter CryptoPayments to delete.
     * @example
     * // Delete a few CryptoPayments
     * const { count } = await prisma.cryptoPayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CryptoPaymentDeleteManyArgs>(args?: SelectSubset<T, CryptoPaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CryptoPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoPaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CryptoPayments
     * const cryptoPayment = await prisma.cryptoPayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CryptoPaymentUpdateManyArgs>(args: SelectSubset<T, CryptoPaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CryptoPayments and returns the data updated in the database.
     * @param {CryptoPaymentUpdateManyAndReturnArgs} args - Arguments to update many CryptoPayments.
     * @example
     * // Update many CryptoPayments
     * const cryptoPayment = await prisma.cryptoPayment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CryptoPayments and only return the `id`
     * const cryptoPaymentWithIdOnly = await prisma.cryptoPayment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CryptoPaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, CryptoPaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CryptoPaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CryptoPayment.
     * @param {CryptoPaymentUpsertArgs} args - Arguments to update or create a CryptoPayment.
     * @example
     * // Update or create a CryptoPayment
     * const cryptoPayment = await prisma.cryptoPayment.upsert({
     *   create: {
     *     // ... data to create a CryptoPayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CryptoPayment we want to update
     *   }
     * })
     */
    upsert<T extends CryptoPaymentUpsertArgs>(args: SelectSubset<T, CryptoPaymentUpsertArgs<ExtArgs>>): Prisma__CryptoPaymentClient<$Result.GetResult<Prisma.$CryptoPaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CryptoPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoPaymentCountArgs} args - Arguments to filter CryptoPayments to count.
     * @example
     * // Count the number of CryptoPayments
     * const count = await prisma.cryptoPayment.count({
     *   where: {
     *     // ... the filter for the CryptoPayments we want to count
     *   }
     * })
    **/
    count<T extends CryptoPaymentCountArgs>(
      args?: Subset<T, CryptoPaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CryptoPaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CryptoPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoPaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CryptoPaymentAggregateArgs>(args: Subset<T, CryptoPaymentAggregateArgs>): Prisma.PrismaPromise<GetCryptoPaymentAggregateType<T>>

    /**
     * Group by CryptoPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoPaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CryptoPaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CryptoPaymentGroupByArgs['orderBy'] }
        : { orderBy?: CryptoPaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CryptoPaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCryptoPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CryptoPayment model
   */
  readonly fields: CryptoPaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CryptoPayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CryptoPaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    wallet<T extends CryptoWalletDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CryptoWalletDefaultArgs<ExtArgs>>): Prisma__CryptoWalletClient<$Result.GetResult<Prisma.$CryptoWalletPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    invoice<T extends CryptoPayment$invoiceArgs<ExtArgs> = {}>(args?: Subset<T, CryptoPayment$invoiceArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CryptoPayment model
   */
  interface CryptoPaymentFieldRefs {
    readonly id: FieldRef<"CryptoPayment", 'String'>
    readonly walletId: FieldRef<"CryptoPayment", 'String'>
    readonly invoiceId: FieldRef<"CryptoPayment", 'String'>
    readonly amount: FieldRef<"CryptoPayment", 'String'>
    readonly currency: FieldRef<"CryptoPayment", 'String'>
    readonly txHash: FieldRef<"CryptoPayment", 'String'>
    readonly confirmations: FieldRef<"CryptoPayment", 'Int'>
    readonly status: FieldRef<"CryptoPayment", 'String'>
    readonly detectedAt: FieldRef<"CryptoPayment", 'DateTime'>
    readonly confirmedAt: FieldRef<"CryptoPayment", 'DateTime'>
    readonly metadata: FieldRef<"CryptoPayment", 'Json'>
    readonly createdAt: FieldRef<"CryptoPayment", 'DateTime'>
    readonly updatedAt: FieldRef<"CryptoPayment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CryptoPayment findUnique
   */
  export type CryptoPaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoPayment
     */
    select?: CryptoPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoPayment
     */
    omit?: CryptoPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoPaymentInclude<ExtArgs> | null
    /**
     * Filter, which CryptoPayment to fetch.
     */
    where: CryptoPaymentWhereUniqueInput
  }

  /**
   * CryptoPayment findUniqueOrThrow
   */
  export type CryptoPaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoPayment
     */
    select?: CryptoPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoPayment
     */
    omit?: CryptoPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoPaymentInclude<ExtArgs> | null
    /**
     * Filter, which CryptoPayment to fetch.
     */
    where: CryptoPaymentWhereUniqueInput
  }

  /**
   * CryptoPayment findFirst
   */
  export type CryptoPaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoPayment
     */
    select?: CryptoPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoPayment
     */
    omit?: CryptoPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoPaymentInclude<ExtArgs> | null
    /**
     * Filter, which CryptoPayment to fetch.
     */
    where?: CryptoPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CryptoPayments to fetch.
     */
    orderBy?: CryptoPaymentOrderByWithRelationInput | CryptoPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CryptoPayments.
     */
    cursor?: CryptoPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CryptoPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CryptoPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CryptoPayments.
     */
    distinct?: CryptoPaymentScalarFieldEnum | CryptoPaymentScalarFieldEnum[]
  }

  /**
   * CryptoPayment findFirstOrThrow
   */
  export type CryptoPaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoPayment
     */
    select?: CryptoPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoPayment
     */
    omit?: CryptoPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoPaymentInclude<ExtArgs> | null
    /**
     * Filter, which CryptoPayment to fetch.
     */
    where?: CryptoPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CryptoPayments to fetch.
     */
    orderBy?: CryptoPaymentOrderByWithRelationInput | CryptoPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CryptoPayments.
     */
    cursor?: CryptoPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CryptoPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CryptoPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CryptoPayments.
     */
    distinct?: CryptoPaymentScalarFieldEnum | CryptoPaymentScalarFieldEnum[]
  }

  /**
   * CryptoPayment findMany
   */
  export type CryptoPaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoPayment
     */
    select?: CryptoPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoPayment
     */
    omit?: CryptoPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoPaymentInclude<ExtArgs> | null
    /**
     * Filter, which CryptoPayments to fetch.
     */
    where?: CryptoPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CryptoPayments to fetch.
     */
    orderBy?: CryptoPaymentOrderByWithRelationInput | CryptoPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CryptoPayments.
     */
    cursor?: CryptoPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CryptoPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CryptoPayments.
     */
    skip?: number
    distinct?: CryptoPaymentScalarFieldEnum | CryptoPaymentScalarFieldEnum[]
  }

  /**
   * CryptoPayment create
   */
  export type CryptoPaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoPayment
     */
    select?: CryptoPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoPayment
     */
    omit?: CryptoPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoPaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a CryptoPayment.
     */
    data: XOR<CryptoPaymentCreateInput, CryptoPaymentUncheckedCreateInput>
  }

  /**
   * CryptoPayment createMany
   */
  export type CryptoPaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CryptoPayments.
     */
    data: CryptoPaymentCreateManyInput | CryptoPaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CryptoPayment createManyAndReturn
   */
  export type CryptoPaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoPayment
     */
    select?: CryptoPaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoPayment
     */
    omit?: CryptoPaymentOmit<ExtArgs> | null
    /**
     * The data used to create many CryptoPayments.
     */
    data: CryptoPaymentCreateManyInput | CryptoPaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoPaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CryptoPayment update
   */
  export type CryptoPaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoPayment
     */
    select?: CryptoPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoPayment
     */
    omit?: CryptoPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoPaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a CryptoPayment.
     */
    data: XOR<CryptoPaymentUpdateInput, CryptoPaymentUncheckedUpdateInput>
    /**
     * Choose, which CryptoPayment to update.
     */
    where: CryptoPaymentWhereUniqueInput
  }

  /**
   * CryptoPayment updateMany
   */
  export type CryptoPaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CryptoPayments.
     */
    data: XOR<CryptoPaymentUpdateManyMutationInput, CryptoPaymentUncheckedUpdateManyInput>
    /**
     * Filter which CryptoPayments to update
     */
    where?: CryptoPaymentWhereInput
    /**
     * Limit how many CryptoPayments to update.
     */
    limit?: number
  }

  /**
   * CryptoPayment updateManyAndReturn
   */
  export type CryptoPaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoPayment
     */
    select?: CryptoPaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoPayment
     */
    omit?: CryptoPaymentOmit<ExtArgs> | null
    /**
     * The data used to update CryptoPayments.
     */
    data: XOR<CryptoPaymentUpdateManyMutationInput, CryptoPaymentUncheckedUpdateManyInput>
    /**
     * Filter which CryptoPayments to update
     */
    where?: CryptoPaymentWhereInput
    /**
     * Limit how many CryptoPayments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoPaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CryptoPayment upsert
   */
  export type CryptoPaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoPayment
     */
    select?: CryptoPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoPayment
     */
    omit?: CryptoPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoPaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the CryptoPayment to update in case it exists.
     */
    where: CryptoPaymentWhereUniqueInput
    /**
     * In case the CryptoPayment found by the `where` argument doesn't exist, create a new CryptoPayment with this data.
     */
    create: XOR<CryptoPaymentCreateInput, CryptoPaymentUncheckedCreateInput>
    /**
     * In case the CryptoPayment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CryptoPaymentUpdateInput, CryptoPaymentUncheckedUpdateInput>
  }

  /**
   * CryptoPayment delete
   */
  export type CryptoPaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoPayment
     */
    select?: CryptoPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoPayment
     */
    omit?: CryptoPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoPaymentInclude<ExtArgs> | null
    /**
     * Filter which CryptoPayment to delete.
     */
    where: CryptoPaymentWhereUniqueInput
  }

  /**
   * CryptoPayment deleteMany
   */
  export type CryptoPaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CryptoPayments to delete
     */
    where?: CryptoPaymentWhereInput
    /**
     * Limit how many CryptoPayments to delete.
     */
    limit?: number
  }

  /**
   * CryptoPayment.invoice
   */
  export type CryptoPayment$invoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
  }

  /**
   * CryptoPayment without action
   */
  export type CryptoPaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoPayment
     */
    select?: CryptoPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoPayment
     */
    omit?: CryptoPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoPaymentInclude<ExtArgs> | null
  }


  /**
   * Model ExpenseCategory
   */

  export type AggregateExpenseCategory = {
    _count: ExpenseCategoryCountAggregateOutputType | null
    _min: ExpenseCategoryMinAggregateOutputType | null
    _max: ExpenseCategoryMaxAggregateOutputType | null
  }

  export type ExpenseCategoryMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    description: string | null
    isDefault: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExpenseCategoryMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    description: string | null
    isDefault: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExpenseCategoryCountAggregateOutputType = {
    id: number
    tenantId: number
    name: number
    description: number
    isDefault: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExpenseCategoryMinAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    description?: true
    isDefault?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExpenseCategoryMaxAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    description?: true
    isDefault?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExpenseCategoryCountAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    description?: true
    isDefault?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExpenseCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExpenseCategory to aggregate.
     */
    where?: ExpenseCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseCategories to fetch.
     */
    orderBy?: ExpenseCategoryOrderByWithRelationInput | ExpenseCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExpenseCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExpenseCategories
    **/
    _count?: true | ExpenseCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExpenseCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExpenseCategoryMaxAggregateInputType
  }

  export type GetExpenseCategoryAggregateType<T extends ExpenseCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateExpenseCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExpenseCategory[P]>
      : GetScalarType<T[P], AggregateExpenseCategory[P]>
  }




  export type ExpenseCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseCategoryWhereInput
    orderBy?: ExpenseCategoryOrderByWithAggregationInput | ExpenseCategoryOrderByWithAggregationInput[]
    by: ExpenseCategoryScalarFieldEnum[] | ExpenseCategoryScalarFieldEnum
    having?: ExpenseCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExpenseCategoryCountAggregateInputType | true
    _min?: ExpenseCategoryMinAggregateInputType
    _max?: ExpenseCategoryMaxAggregateInputType
  }

  export type ExpenseCategoryGroupByOutputType = {
    id: string
    tenantId: string
    name: string
    description: string | null
    isDefault: boolean
    createdAt: Date
    updatedAt: Date
    _count: ExpenseCategoryCountAggregateOutputType | null
    _min: ExpenseCategoryMinAggregateOutputType | null
    _max: ExpenseCategoryMaxAggregateOutputType | null
  }

  type GetExpenseCategoryGroupByPayload<T extends ExpenseCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExpenseCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExpenseCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExpenseCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ExpenseCategoryGroupByOutputType[P]>
        }
      >
    >


  export type ExpenseCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    description?: boolean
    isDefault?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    expenses?: boolean | ExpenseCategory$expensesArgs<ExtArgs>
    _count?: boolean | ExpenseCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expenseCategory"]>

  export type ExpenseCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    description?: boolean
    isDefault?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expenseCategory"]>

  export type ExpenseCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    description?: boolean
    isDefault?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expenseCategory"]>

  export type ExpenseCategorySelectScalar = {
    id?: boolean
    tenantId?: boolean
    name?: boolean
    description?: boolean
    isDefault?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExpenseCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "name" | "description" | "isDefault" | "createdAt" | "updatedAt", ExtArgs["result"]["expenseCategory"]>
  export type ExpenseCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    expenses?: boolean | ExpenseCategory$expensesArgs<ExtArgs>
    _count?: boolean | ExpenseCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ExpenseCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type ExpenseCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $ExpenseCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExpenseCategory"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      expenses: Prisma.$ExpensePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      name: string
      description: string | null
      isDefault: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["expenseCategory"]>
    composites: {}
  }

  type ExpenseCategoryGetPayload<S extends boolean | null | undefined | ExpenseCategoryDefaultArgs> = $Result.GetResult<Prisma.$ExpenseCategoryPayload, S>

  type ExpenseCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExpenseCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExpenseCategoryCountAggregateInputType | true
    }

  export interface ExpenseCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExpenseCategory'], meta: { name: 'ExpenseCategory' } }
    /**
     * Find zero or one ExpenseCategory that matches the filter.
     * @param {ExpenseCategoryFindUniqueArgs} args - Arguments to find a ExpenseCategory
     * @example
     * // Get one ExpenseCategory
     * const expenseCategory = await prisma.expenseCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExpenseCategoryFindUniqueArgs>(args: SelectSubset<T, ExpenseCategoryFindUniqueArgs<ExtArgs>>): Prisma__ExpenseCategoryClient<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ExpenseCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExpenseCategoryFindUniqueOrThrowArgs} args - Arguments to find a ExpenseCategory
     * @example
     * // Get one ExpenseCategory
     * const expenseCategory = await prisma.expenseCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExpenseCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ExpenseCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExpenseCategoryClient<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExpenseCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCategoryFindFirstArgs} args - Arguments to find a ExpenseCategory
     * @example
     * // Get one ExpenseCategory
     * const expenseCategory = await prisma.expenseCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExpenseCategoryFindFirstArgs>(args?: SelectSubset<T, ExpenseCategoryFindFirstArgs<ExtArgs>>): Prisma__ExpenseCategoryClient<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExpenseCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCategoryFindFirstOrThrowArgs} args - Arguments to find a ExpenseCategory
     * @example
     * // Get one ExpenseCategory
     * const expenseCategory = await prisma.expenseCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExpenseCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ExpenseCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExpenseCategoryClient<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExpenseCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExpenseCategories
     * const expenseCategories = await prisma.expenseCategory.findMany()
     * 
     * // Get first 10 ExpenseCategories
     * const expenseCategories = await prisma.expenseCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const expenseCategoryWithIdOnly = await prisma.expenseCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExpenseCategoryFindManyArgs>(args?: SelectSubset<T, ExpenseCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ExpenseCategory.
     * @param {ExpenseCategoryCreateArgs} args - Arguments to create a ExpenseCategory.
     * @example
     * // Create one ExpenseCategory
     * const ExpenseCategory = await prisma.expenseCategory.create({
     *   data: {
     *     // ... data to create a ExpenseCategory
     *   }
     * })
     * 
     */
    create<T extends ExpenseCategoryCreateArgs>(args: SelectSubset<T, ExpenseCategoryCreateArgs<ExtArgs>>): Prisma__ExpenseCategoryClient<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ExpenseCategories.
     * @param {ExpenseCategoryCreateManyArgs} args - Arguments to create many ExpenseCategories.
     * @example
     * // Create many ExpenseCategories
     * const expenseCategory = await prisma.expenseCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExpenseCategoryCreateManyArgs>(args?: SelectSubset<T, ExpenseCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExpenseCategories and returns the data saved in the database.
     * @param {ExpenseCategoryCreateManyAndReturnArgs} args - Arguments to create many ExpenseCategories.
     * @example
     * // Create many ExpenseCategories
     * const expenseCategory = await prisma.expenseCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExpenseCategories and only return the `id`
     * const expenseCategoryWithIdOnly = await prisma.expenseCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExpenseCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ExpenseCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ExpenseCategory.
     * @param {ExpenseCategoryDeleteArgs} args - Arguments to delete one ExpenseCategory.
     * @example
     * // Delete one ExpenseCategory
     * const ExpenseCategory = await prisma.expenseCategory.delete({
     *   where: {
     *     // ... filter to delete one ExpenseCategory
     *   }
     * })
     * 
     */
    delete<T extends ExpenseCategoryDeleteArgs>(args: SelectSubset<T, ExpenseCategoryDeleteArgs<ExtArgs>>): Prisma__ExpenseCategoryClient<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ExpenseCategory.
     * @param {ExpenseCategoryUpdateArgs} args - Arguments to update one ExpenseCategory.
     * @example
     * // Update one ExpenseCategory
     * const expenseCategory = await prisma.expenseCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExpenseCategoryUpdateArgs>(args: SelectSubset<T, ExpenseCategoryUpdateArgs<ExtArgs>>): Prisma__ExpenseCategoryClient<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ExpenseCategories.
     * @param {ExpenseCategoryDeleteManyArgs} args - Arguments to filter ExpenseCategories to delete.
     * @example
     * // Delete a few ExpenseCategories
     * const { count } = await prisma.expenseCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExpenseCategoryDeleteManyArgs>(args?: SelectSubset<T, ExpenseCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExpenseCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExpenseCategories
     * const expenseCategory = await prisma.expenseCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExpenseCategoryUpdateManyArgs>(args: SelectSubset<T, ExpenseCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExpenseCategories and returns the data updated in the database.
     * @param {ExpenseCategoryUpdateManyAndReturnArgs} args - Arguments to update many ExpenseCategories.
     * @example
     * // Update many ExpenseCategories
     * const expenseCategory = await prisma.expenseCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ExpenseCategories and only return the `id`
     * const expenseCategoryWithIdOnly = await prisma.expenseCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExpenseCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, ExpenseCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ExpenseCategory.
     * @param {ExpenseCategoryUpsertArgs} args - Arguments to update or create a ExpenseCategory.
     * @example
     * // Update or create a ExpenseCategory
     * const expenseCategory = await prisma.expenseCategory.upsert({
     *   create: {
     *     // ... data to create a ExpenseCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExpenseCategory we want to update
     *   }
     * })
     */
    upsert<T extends ExpenseCategoryUpsertArgs>(args: SelectSubset<T, ExpenseCategoryUpsertArgs<ExtArgs>>): Prisma__ExpenseCategoryClient<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ExpenseCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCategoryCountArgs} args - Arguments to filter ExpenseCategories to count.
     * @example
     * // Count the number of ExpenseCategories
     * const count = await prisma.expenseCategory.count({
     *   where: {
     *     // ... the filter for the ExpenseCategories we want to count
     *   }
     * })
    **/
    count<T extends ExpenseCategoryCountArgs>(
      args?: Subset<T, ExpenseCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExpenseCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExpenseCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExpenseCategoryAggregateArgs>(args: Subset<T, ExpenseCategoryAggregateArgs>): Prisma.PrismaPromise<GetExpenseCategoryAggregateType<T>>

    /**
     * Group by ExpenseCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExpenseCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExpenseCategoryGroupByArgs['orderBy'] }
        : { orderBy?: ExpenseCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExpenseCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExpenseCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExpenseCategory model
   */
  readonly fields: ExpenseCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExpenseCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExpenseCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    expenses<T extends ExpenseCategory$expensesArgs<ExtArgs> = {}>(args?: Subset<T, ExpenseCategory$expensesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExpenseCategory model
   */
  interface ExpenseCategoryFieldRefs {
    readonly id: FieldRef<"ExpenseCategory", 'String'>
    readonly tenantId: FieldRef<"ExpenseCategory", 'String'>
    readonly name: FieldRef<"ExpenseCategory", 'String'>
    readonly description: FieldRef<"ExpenseCategory", 'String'>
    readonly isDefault: FieldRef<"ExpenseCategory", 'Boolean'>
    readonly createdAt: FieldRef<"ExpenseCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"ExpenseCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExpenseCategory findUnique
   */
  export type ExpenseCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseCategory
     */
    omit?: ExpenseCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseCategory to fetch.
     */
    where: ExpenseCategoryWhereUniqueInput
  }

  /**
   * ExpenseCategory findUniqueOrThrow
   */
  export type ExpenseCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseCategory
     */
    omit?: ExpenseCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseCategory to fetch.
     */
    where: ExpenseCategoryWhereUniqueInput
  }

  /**
   * ExpenseCategory findFirst
   */
  export type ExpenseCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseCategory
     */
    omit?: ExpenseCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseCategory to fetch.
     */
    where?: ExpenseCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseCategories to fetch.
     */
    orderBy?: ExpenseCategoryOrderByWithRelationInput | ExpenseCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExpenseCategories.
     */
    cursor?: ExpenseCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExpenseCategories.
     */
    distinct?: ExpenseCategoryScalarFieldEnum | ExpenseCategoryScalarFieldEnum[]
  }

  /**
   * ExpenseCategory findFirstOrThrow
   */
  export type ExpenseCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseCategory
     */
    omit?: ExpenseCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseCategory to fetch.
     */
    where?: ExpenseCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseCategories to fetch.
     */
    orderBy?: ExpenseCategoryOrderByWithRelationInput | ExpenseCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExpenseCategories.
     */
    cursor?: ExpenseCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExpenseCategories.
     */
    distinct?: ExpenseCategoryScalarFieldEnum | ExpenseCategoryScalarFieldEnum[]
  }

  /**
   * ExpenseCategory findMany
   */
  export type ExpenseCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseCategory
     */
    omit?: ExpenseCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseCategories to fetch.
     */
    where?: ExpenseCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseCategories to fetch.
     */
    orderBy?: ExpenseCategoryOrderByWithRelationInput | ExpenseCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExpenseCategories.
     */
    cursor?: ExpenseCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseCategories.
     */
    skip?: number
    distinct?: ExpenseCategoryScalarFieldEnum | ExpenseCategoryScalarFieldEnum[]
  }

  /**
   * ExpenseCategory create
   */
  export type ExpenseCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseCategory
     */
    omit?: ExpenseCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ExpenseCategory.
     */
    data: XOR<ExpenseCategoryCreateInput, ExpenseCategoryUncheckedCreateInput>
  }

  /**
   * ExpenseCategory createMany
   */
  export type ExpenseCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExpenseCategories.
     */
    data: ExpenseCategoryCreateManyInput | ExpenseCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExpenseCategory createManyAndReturn
   */
  export type ExpenseCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseCategory
     */
    omit?: ExpenseCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many ExpenseCategories.
     */
    data: ExpenseCategoryCreateManyInput | ExpenseCategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExpenseCategory update
   */
  export type ExpenseCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseCategory
     */
    omit?: ExpenseCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ExpenseCategory.
     */
    data: XOR<ExpenseCategoryUpdateInput, ExpenseCategoryUncheckedUpdateInput>
    /**
     * Choose, which ExpenseCategory to update.
     */
    where: ExpenseCategoryWhereUniqueInput
  }

  /**
   * ExpenseCategory updateMany
   */
  export type ExpenseCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExpenseCategories.
     */
    data: XOR<ExpenseCategoryUpdateManyMutationInput, ExpenseCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ExpenseCategories to update
     */
    where?: ExpenseCategoryWhereInput
    /**
     * Limit how many ExpenseCategories to update.
     */
    limit?: number
  }

  /**
   * ExpenseCategory updateManyAndReturn
   */
  export type ExpenseCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseCategory
     */
    omit?: ExpenseCategoryOmit<ExtArgs> | null
    /**
     * The data used to update ExpenseCategories.
     */
    data: XOR<ExpenseCategoryUpdateManyMutationInput, ExpenseCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ExpenseCategories to update
     */
    where?: ExpenseCategoryWhereInput
    /**
     * Limit how many ExpenseCategories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExpenseCategory upsert
   */
  export type ExpenseCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseCategory
     */
    omit?: ExpenseCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ExpenseCategory to update in case it exists.
     */
    where: ExpenseCategoryWhereUniqueInput
    /**
     * In case the ExpenseCategory found by the `where` argument doesn't exist, create a new ExpenseCategory with this data.
     */
    create: XOR<ExpenseCategoryCreateInput, ExpenseCategoryUncheckedCreateInput>
    /**
     * In case the ExpenseCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExpenseCategoryUpdateInput, ExpenseCategoryUncheckedUpdateInput>
  }

  /**
   * ExpenseCategory delete
   */
  export type ExpenseCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseCategory
     */
    omit?: ExpenseCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
    /**
     * Filter which ExpenseCategory to delete.
     */
    where: ExpenseCategoryWhereUniqueInput
  }

  /**
   * ExpenseCategory deleteMany
   */
  export type ExpenseCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExpenseCategories to delete
     */
    where?: ExpenseCategoryWhereInput
    /**
     * Limit how many ExpenseCategories to delete.
     */
    limit?: number
  }

  /**
   * ExpenseCategory.expenses
   */
  export type ExpenseCategory$expensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    where?: ExpenseWhereInput
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    cursor?: ExpenseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * ExpenseCategory without action
   */
  export type ExpenseCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseCategory
     */
    omit?: ExpenseCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
  }


  /**
   * Model Expense
   */

  export type AggregateExpense = {
    _count: ExpenseCountAggregateOutputType | null
    _avg: ExpenseAvgAggregateOutputType | null
    _sum: ExpenseSumAggregateOutputType | null
    _min: ExpenseMinAggregateOutputType | null
    _max: ExpenseMaxAggregateOutputType | null
  }

  export type ExpenseAvgAggregateOutputType = {
    amount: Decimal | null
    taxAmount: Decimal | null
    reimbursedAmount: Decimal | null
  }

  export type ExpenseSumAggregateOutputType = {
    amount: Decimal | null
    taxAmount: Decimal | null
    reimbursedAmount: Decimal | null
  }

  export type ExpenseMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    categoryId: string | null
    description: string | null
    amount: Decimal | null
    currency: string | null
    date: Date | null
    vendor: string | null
    receiptUrl: string | null
    taxAmount: Decimal | null
    isTaxDeductible: boolean | null
    status: $Enums.ExpenseStatus | null
    approvedBy: string | null
    approvedAt: Date | null
    rejectedReason: string | null
    reimbursedAt: Date | null
    reimbursedAmount: Decimal | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExpenseMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    categoryId: string | null
    description: string | null
    amount: Decimal | null
    currency: string | null
    date: Date | null
    vendor: string | null
    receiptUrl: string | null
    taxAmount: Decimal | null
    isTaxDeductible: boolean | null
    status: $Enums.ExpenseStatus | null
    approvedBy: string | null
    approvedAt: Date | null
    rejectedReason: string | null
    reimbursedAt: Date | null
    reimbursedAmount: Decimal | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExpenseCountAggregateOutputType = {
    id: number
    tenantId: number
    categoryId: number
    description: number
    amount: number
    currency: number
    date: number
    vendor: number
    receiptUrl: number
    receiptOcrData: number
    taxAmount: number
    isTaxDeductible: number
    status: number
    approvedBy: number
    approvedAt: number
    rejectedReason: number
    reimbursedAt: number
    reimbursedAmount: number
    notes: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExpenseAvgAggregateInputType = {
    amount?: true
    taxAmount?: true
    reimbursedAmount?: true
  }

  export type ExpenseSumAggregateInputType = {
    amount?: true
    taxAmount?: true
    reimbursedAmount?: true
  }

  export type ExpenseMinAggregateInputType = {
    id?: true
    tenantId?: true
    categoryId?: true
    description?: true
    amount?: true
    currency?: true
    date?: true
    vendor?: true
    receiptUrl?: true
    taxAmount?: true
    isTaxDeductible?: true
    status?: true
    approvedBy?: true
    approvedAt?: true
    rejectedReason?: true
    reimbursedAt?: true
    reimbursedAmount?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExpenseMaxAggregateInputType = {
    id?: true
    tenantId?: true
    categoryId?: true
    description?: true
    amount?: true
    currency?: true
    date?: true
    vendor?: true
    receiptUrl?: true
    taxAmount?: true
    isTaxDeductible?: true
    status?: true
    approvedBy?: true
    approvedAt?: true
    rejectedReason?: true
    reimbursedAt?: true
    reimbursedAmount?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExpenseCountAggregateInputType = {
    id?: true
    tenantId?: true
    categoryId?: true
    description?: true
    amount?: true
    currency?: true
    date?: true
    vendor?: true
    receiptUrl?: true
    receiptOcrData?: true
    taxAmount?: true
    isTaxDeductible?: true
    status?: true
    approvedBy?: true
    approvedAt?: true
    rejectedReason?: true
    reimbursedAt?: true
    reimbursedAmount?: true
    notes?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExpenseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Expense to aggregate.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Expenses
    **/
    _count?: true | ExpenseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExpenseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExpenseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExpenseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExpenseMaxAggregateInputType
  }

  export type GetExpenseAggregateType<T extends ExpenseAggregateArgs> = {
        [P in keyof T & keyof AggregateExpense]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExpense[P]>
      : GetScalarType<T[P], AggregateExpense[P]>
  }




  export type ExpenseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseWhereInput
    orderBy?: ExpenseOrderByWithAggregationInput | ExpenseOrderByWithAggregationInput[]
    by: ExpenseScalarFieldEnum[] | ExpenseScalarFieldEnum
    having?: ExpenseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExpenseCountAggregateInputType | true
    _avg?: ExpenseAvgAggregateInputType
    _sum?: ExpenseSumAggregateInputType
    _min?: ExpenseMinAggregateInputType
    _max?: ExpenseMaxAggregateInputType
  }

  export type ExpenseGroupByOutputType = {
    id: string
    tenantId: string
    categoryId: string
    description: string
    amount: Decimal
    currency: string
    date: Date
    vendor: string | null
    receiptUrl: string | null
    receiptOcrData: JsonValue | null
    taxAmount: Decimal | null
    isTaxDeductible: boolean
    status: $Enums.ExpenseStatus
    approvedBy: string | null
    approvedAt: Date | null
    rejectedReason: string | null
    reimbursedAt: Date | null
    reimbursedAmount: Decimal | null
    notes: string | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: ExpenseCountAggregateOutputType | null
    _avg: ExpenseAvgAggregateOutputType | null
    _sum: ExpenseSumAggregateOutputType | null
    _min: ExpenseMinAggregateOutputType | null
    _max: ExpenseMaxAggregateOutputType | null
  }

  type GetExpenseGroupByPayload<T extends ExpenseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExpenseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExpenseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExpenseGroupByOutputType[P]>
            : GetScalarType<T[P], ExpenseGroupByOutputType[P]>
        }
      >
    >


  export type ExpenseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    categoryId?: boolean
    description?: boolean
    amount?: boolean
    currency?: boolean
    date?: boolean
    vendor?: boolean
    receiptUrl?: boolean
    receiptOcrData?: boolean
    taxAmount?: boolean
    isTaxDeductible?: boolean
    status?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    rejectedReason?: boolean
    reimbursedAt?: boolean
    reimbursedAmount?: boolean
    notes?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    category?: boolean | ExpenseCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expense"]>

  export type ExpenseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    categoryId?: boolean
    description?: boolean
    amount?: boolean
    currency?: boolean
    date?: boolean
    vendor?: boolean
    receiptUrl?: boolean
    receiptOcrData?: boolean
    taxAmount?: boolean
    isTaxDeductible?: boolean
    status?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    rejectedReason?: boolean
    reimbursedAt?: boolean
    reimbursedAmount?: boolean
    notes?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    category?: boolean | ExpenseCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expense"]>

  export type ExpenseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    categoryId?: boolean
    description?: boolean
    amount?: boolean
    currency?: boolean
    date?: boolean
    vendor?: boolean
    receiptUrl?: boolean
    receiptOcrData?: boolean
    taxAmount?: boolean
    isTaxDeductible?: boolean
    status?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    rejectedReason?: boolean
    reimbursedAt?: boolean
    reimbursedAmount?: boolean
    notes?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    category?: boolean | ExpenseCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expense"]>

  export type ExpenseSelectScalar = {
    id?: boolean
    tenantId?: boolean
    categoryId?: boolean
    description?: boolean
    amount?: boolean
    currency?: boolean
    date?: boolean
    vendor?: boolean
    receiptUrl?: boolean
    receiptOcrData?: boolean
    taxAmount?: boolean
    isTaxDeductible?: boolean
    status?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    rejectedReason?: boolean
    reimbursedAt?: boolean
    reimbursedAmount?: boolean
    notes?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExpenseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "categoryId" | "description" | "amount" | "currency" | "date" | "vendor" | "receiptUrl" | "receiptOcrData" | "taxAmount" | "isTaxDeductible" | "status" | "approvedBy" | "approvedAt" | "rejectedReason" | "reimbursedAt" | "reimbursedAmount" | "notes" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["expense"]>
  export type ExpenseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    category?: boolean | ExpenseCategoryDefaultArgs<ExtArgs>
  }
  export type ExpenseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    category?: boolean | ExpenseCategoryDefaultArgs<ExtArgs>
  }
  export type ExpenseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    category?: boolean | ExpenseCategoryDefaultArgs<ExtArgs>
  }

  export type $ExpensePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Expense"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      category: Prisma.$ExpenseCategoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      categoryId: string
      description: string
      amount: Prisma.Decimal
      currency: string
      date: Date
      vendor: string | null
      receiptUrl: string | null
      receiptOcrData: Prisma.JsonValue | null
      taxAmount: Prisma.Decimal | null
      isTaxDeductible: boolean
      status: $Enums.ExpenseStatus
      approvedBy: string | null
      approvedAt: Date | null
      rejectedReason: string | null
      reimbursedAt: Date | null
      reimbursedAmount: Prisma.Decimal | null
      notes: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["expense"]>
    composites: {}
  }

  type ExpenseGetPayload<S extends boolean | null | undefined | ExpenseDefaultArgs> = $Result.GetResult<Prisma.$ExpensePayload, S>

  type ExpenseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExpenseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExpenseCountAggregateInputType | true
    }

  export interface ExpenseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Expense'], meta: { name: 'Expense' } }
    /**
     * Find zero or one Expense that matches the filter.
     * @param {ExpenseFindUniqueArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExpenseFindUniqueArgs>(args: SelectSubset<T, ExpenseFindUniqueArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Expense that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExpenseFindUniqueOrThrowArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExpenseFindUniqueOrThrowArgs>(args: SelectSubset<T, ExpenseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Expense that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindFirstArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExpenseFindFirstArgs>(args?: SelectSubset<T, ExpenseFindFirstArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Expense that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindFirstOrThrowArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExpenseFindFirstOrThrowArgs>(args?: SelectSubset<T, ExpenseFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Expenses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Expenses
     * const expenses = await prisma.expense.findMany()
     * 
     * // Get first 10 Expenses
     * const expenses = await prisma.expense.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const expenseWithIdOnly = await prisma.expense.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExpenseFindManyArgs>(args?: SelectSubset<T, ExpenseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Expense.
     * @param {ExpenseCreateArgs} args - Arguments to create a Expense.
     * @example
     * // Create one Expense
     * const Expense = await prisma.expense.create({
     *   data: {
     *     // ... data to create a Expense
     *   }
     * })
     * 
     */
    create<T extends ExpenseCreateArgs>(args: SelectSubset<T, ExpenseCreateArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Expenses.
     * @param {ExpenseCreateManyArgs} args - Arguments to create many Expenses.
     * @example
     * // Create many Expenses
     * const expense = await prisma.expense.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExpenseCreateManyArgs>(args?: SelectSubset<T, ExpenseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Expenses and returns the data saved in the database.
     * @param {ExpenseCreateManyAndReturnArgs} args - Arguments to create many Expenses.
     * @example
     * // Create many Expenses
     * const expense = await prisma.expense.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Expenses and only return the `id`
     * const expenseWithIdOnly = await prisma.expense.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExpenseCreateManyAndReturnArgs>(args?: SelectSubset<T, ExpenseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Expense.
     * @param {ExpenseDeleteArgs} args - Arguments to delete one Expense.
     * @example
     * // Delete one Expense
     * const Expense = await prisma.expense.delete({
     *   where: {
     *     // ... filter to delete one Expense
     *   }
     * })
     * 
     */
    delete<T extends ExpenseDeleteArgs>(args: SelectSubset<T, ExpenseDeleteArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Expense.
     * @param {ExpenseUpdateArgs} args - Arguments to update one Expense.
     * @example
     * // Update one Expense
     * const expense = await prisma.expense.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExpenseUpdateArgs>(args: SelectSubset<T, ExpenseUpdateArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Expenses.
     * @param {ExpenseDeleteManyArgs} args - Arguments to filter Expenses to delete.
     * @example
     * // Delete a few Expenses
     * const { count } = await prisma.expense.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExpenseDeleteManyArgs>(args?: SelectSubset<T, ExpenseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Expenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Expenses
     * const expense = await prisma.expense.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExpenseUpdateManyArgs>(args: SelectSubset<T, ExpenseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Expenses and returns the data updated in the database.
     * @param {ExpenseUpdateManyAndReturnArgs} args - Arguments to update many Expenses.
     * @example
     * // Update many Expenses
     * const expense = await prisma.expense.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Expenses and only return the `id`
     * const expenseWithIdOnly = await prisma.expense.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExpenseUpdateManyAndReturnArgs>(args: SelectSubset<T, ExpenseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Expense.
     * @param {ExpenseUpsertArgs} args - Arguments to update or create a Expense.
     * @example
     * // Update or create a Expense
     * const expense = await prisma.expense.upsert({
     *   create: {
     *     // ... data to create a Expense
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Expense we want to update
     *   }
     * })
     */
    upsert<T extends ExpenseUpsertArgs>(args: SelectSubset<T, ExpenseUpsertArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Expenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCountArgs} args - Arguments to filter Expenses to count.
     * @example
     * // Count the number of Expenses
     * const count = await prisma.expense.count({
     *   where: {
     *     // ... the filter for the Expenses we want to count
     *   }
     * })
    **/
    count<T extends ExpenseCountArgs>(
      args?: Subset<T, ExpenseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExpenseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Expense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExpenseAggregateArgs>(args: Subset<T, ExpenseAggregateArgs>): Prisma.PrismaPromise<GetExpenseAggregateType<T>>

    /**
     * Group by Expense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExpenseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExpenseGroupByArgs['orderBy'] }
        : { orderBy?: ExpenseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExpenseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExpenseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Expense model
   */
  readonly fields: ExpenseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Expense.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExpenseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    category<T extends ExpenseCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExpenseCategoryDefaultArgs<ExtArgs>>): Prisma__ExpenseCategoryClient<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Expense model
   */
  interface ExpenseFieldRefs {
    readonly id: FieldRef<"Expense", 'String'>
    readonly tenantId: FieldRef<"Expense", 'String'>
    readonly categoryId: FieldRef<"Expense", 'String'>
    readonly description: FieldRef<"Expense", 'String'>
    readonly amount: FieldRef<"Expense", 'Decimal'>
    readonly currency: FieldRef<"Expense", 'String'>
    readonly date: FieldRef<"Expense", 'DateTime'>
    readonly vendor: FieldRef<"Expense", 'String'>
    readonly receiptUrl: FieldRef<"Expense", 'String'>
    readonly receiptOcrData: FieldRef<"Expense", 'Json'>
    readonly taxAmount: FieldRef<"Expense", 'Decimal'>
    readonly isTaxDeductible: FieldRef<"Expense", 'Boolean'>
    readonly status: FieldRef<"Expense", 'ExpenseStatus'>
    readonly approvedBy: FieldRef<"Expense", 'String'>
    readonly approvedAt: FieldRef<"Expense", 'DateTime'>
    readonly rejectedReason: FieldRef<"Expense", 'String'>
    readonly reimbursedAt: FieldRef<"Expense", 'DateTime'>
    readonly reimbursedAmount: FieldRef<"Expense", 'Decimal'>
    readonly notes: FieldRef<"Expense", 'String'>
    readonly metadata: FieldRef<"Expense", 'Json'>
    readonly createdAt: FieldRef<"Expense", 'DateTime'>
    readonly updatedAt: FieldRef<"Expense", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Expense findUnique
   */
  export type ExpenseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense findUniqueOrThrow
   */
  export type ExpenseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense findFirst
   */
  export type ExpenseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Expenses.
     */
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense findFirstOrThrow
   */
  export type ExpenseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Expenses.
     */
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense findMany
   */
  export type ExpenseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expenses to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense create
   */
  export type ExpenseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * The data needed to create a Expense.
     */
    data: XOR<ExpenseCreateInput, ExpenseUncheckedCreateInput>
  }

  /**
   * Expense createMany
   */
  export type ExpenseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Expenses.
     */
    data: ExpenseCreateManyInput | ExpenseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Expense createManyAndReturn
   */
  export type ExpenseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * The data used to create many Expenses.
     */
    data: ExpenseCreateManyInput | ExpenseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Expense update
   */
  export type ExpenseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * The data needed to update a Expense.
     */
    data: XOR<ExpenseUpdateInput, ExpenseUncheckedUpdateInput>
    /**
     * Choose, which Expense to update.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense updateMany
   */
  export type ExpenseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Expenses.
     */
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyInput>
    /**
     * Filter which Expenses to update
     */
    where?: ExpenseWhereInput
    /**
     * Limit how many Expenses to update.
     */
    limit?: number
  }

  /**
   * Expense updateManyAndReturn
   */
  export type ExpenseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * The data used to update Expenses.
     */
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyInput>
    /**
     * Filter which Expenses to update
     */
    where?: ExpenseWhereInput
    /**
     * Limit how many Expenses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Expense upsert
   */
  export type ExpenseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * The filter to search for the Expense to update in case it exists.
     */
    where: ExpenseWhereUniqueInput
    /**
     * In case the Expense found by the `where` argument doesn't exist, create a new Expense with this data.
     */
    create: XOR<ExpenseCreateInput, ExpenseUncheckedCreateInput>
    /**
     * In case the Expense was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExpenseUpdateInput, ExpenseUncheckedUpdateInput>
  }

  /**
   * Expense delete
   */
  export type ExpenseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter which Expense to delete.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense deleteMany
   */
  export type ExpenseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Expenses to delete
     */
    where?: ExpenseWhereInput
    /**
     * Limit how many Expenses to delete.
     */
    limit?: number
  }

  /**
   * Expense without action
   */
  export type ExpenseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
  }


  /**
   * Model RecurringInvoiceTemplate
   */

  export type AggregateRecurringInvoiceTemplate = {
    _count: RecurringInvoiceTemplateCountAggregateOutputType | null
    _min: RecurringInvoiceTemplateMinAggregateOutputType | null
    _max: RecurringInvoiceTemplateMaxAggregateOutputType | null
  }

  export type RecurringInvoiceTemplateMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    frequency: string | null
    nextInvoiceDate: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RecurringInvoiceTemplateMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    frequency: string | null
    nextInvoiceDate: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RecurringInvoiceTemplateCountAggregateOutputType = {
    id: number
    tenantId: number
    frequency: number
    nextInvoiceDate: number
    isActive: number
    invoiceTemplate: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RecurringInvoiceTemplateMinAggregateInputType = {
    id?: true
    tenantId?: true
    frequency?: true
    nextInvoiceDate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RecurringInvoiceTemplateMaxAggregateInputType = {
    id?: true
    tenantId?: true
    frequency?: true
    nextInvoiceDate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RecurringInvoiceTemplateCountAggregateInputType = {
    id?: true
    tenantId?: true
    frequency?: true
    nextInvoiceDate?: true
    isActive?: true
    invoiceTemplate?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RecurringInvoiceTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecurringInvoiceTemplate to aggregate.
     */
    where?: RecurringInvoiceTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecurringInvoiceTemplates to fetch.
     */
    orderBy?: RecurringInvoiceTemplateOrderByWithRelationInput | RecurringInvoiceTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecurringInvoiceTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecurringInvoiceTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecurringInvoiceTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RecurringInvoiceTemplates
    **/
    _count?: true | RecurringInvoiceTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecurringInvoiceTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecurringInvoiceTemplateMaxAggregateInputType
  }

  export type GetRecurringInvoiceTemplateAggregateType<T extends RecurringInvoiceTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateRecurringInvoiceTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecurringInvoiceTemplate[P]>
      : GetScalarType<T[P], AggregateRecurringInvoiceTemplate[P]>
  }




  export type RecurringInvoiceTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecurringInvoiceTemplateWhereInput
    orderBy?: RecurringInvoiceTemplateOrderByWithAggregationInput | RecurringInvoiceTemplateOrderByWithAggregationInput[]
    by: RecurringInvoiceTemplateScalarFieldEnum[] | RecurringInvoiceTemplateScalarFieldEnum
    having?: RecurringInvoiceTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecurringInvoiceTemplateCountAggregateInputType | true
    _min?: RecurringInvoiceTemplateMinAggregateInputType
    _max?: RecurringInvoiceTemplateMaxAggregateInputType
  }

  export type RecurringInvoiceTemplateGroupByOutputType = {
    id: string
    tenantId: string
    frequency: string
    nextInvoiceDate: Date
    isActive: boolean
    invoiceTemplate: JsonValue
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: RecurringInvoiceTemplateCountAggregateOutputType | null
    _min: RecurringInvoiceTemplateMinAggregateOutputType | null
    _max: RecurringInvoiceTemplateMaxAggregateOutputType | null
  }

  type GetRecurringInvoiceTemplateGroupByPayload<T extends RecurringInvoiceTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecurringInvoiceTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecurringInvoiceTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecurringInvoiceTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], RecurringInvoiceTemplateGroupByOutputType[P]>
        }
      >
    >


  export type RecurringInvoiceTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    frequency?: boolean
    nextInvoiceDate?: boolean
    isActive?: boolean
    invoiceTemplate?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recurringInvoiceTemplate"]>

  export type RecurringInvoiceTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    frequency?: boolean
    nextInvoiceDate?: boolean
    isActive?: boolean
    invoiceTemplate?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recurringInvoiceTemplate"]>

  export type RecurringInvoiceTemplateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    frequency?: boolean
    nextInvoiceDate?: boolean
    isActive?: boolean
    invoiceTemplate?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recurringInvoiceTemplate"]>

  export type RecurringInvoiceTemplateSelectScalar = {
    id?: boolean
    tenantId?: boolean
    frequency?: boolean
    nextInvoiceDate?: boolean
    isActive?: boolean
    invoiceTemplate?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RecurringInvoiceTemplateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "frequency" | "nextInvoiceDate" | "isActive" | "invoiceTemplate" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["recurringInvoiceTemplate"]>
  export type RecurringInvoiceTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type RecurringInvoiceTemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type RecurringInvoiceTemplateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $RecurringInvoiceTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RecurringInvoiceTemplate"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      frequency: string
      nextInvoiceDate: Date
      isActive: boolean
      invoiceTemplate: Prisma.JsonValue
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["recurringInvoiceTemplate"]>
    composites: {}
  }

  type RecurringInvoiceTemplateGetPayload<S extends boolean | null | undefined | RecurringInvoiceTemplateDefaultArgs> = $Result.GetResult<Prisma.$RecurringInvoiceTemplatePayload, S>

  type RecurringInvoiceTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RecurringInvoiceTemplateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RecurringInvoiceTemplateCountAggregateInputType | true
    }

  export interface RecurringInvoiceTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RecurringInvoiceTemplate'], meta: { name: 'RecurringInvoiceTemplate' } }
    /**
     * Find zero or one RecurringInvoiceTemplate that matches the filter.
     * @param {RecurringInvoiceTemplateFindUniqueArgs} args - Arguments to find a RecurringInvoiceTemplate
     * @example
     * // Get one RecurringInvoiceTemplate
     * const recurringInvoiceTemplate = await prisma.recurringInvoiceTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RecurringInvoiceTemplateFindUniqueArgs>(args: SelectSubset<T, RecurringInvoiceTemplateFindUniqueArgs<ExtArgs>>): Prisma__RecurringInvoiceTemplateClient<$Result.GetResult<Prisma.$RecurringInvoiceTemplatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RecurringInvoiceTemplate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RecurringInvoiceTemplateFindUniqueOrThrowArgs} args - Arguments to find a RecurringInvoiceTemplate
     * @example
     * // Get one RecurringInvoiceTemplate
     * const recurringInvoiceTemplate = await prisma.recurringInvoiceTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RecurringInvoiceTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, RecurringInvoiceTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RecurringInvoiceTemplateClient<$Result.GetResult<Prisma.$RecurringInvoiceTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecurringInvoiceTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringInvoiceTemplateFindFirstArgs} args - Arguments to find a RecurringInvoiceTemplate
     * @example
     * // Get one RecurringInvoiceTemplate
     * const recurringInvoiceTemplate = await prisma.recurringInvoiceTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RecurringInvoiceTemplateFindFirstArgs>(args?: SelectSubset<T, RecurringInvoiceTemplateFindFirstArgs<ExtArgs>>): Prisma__RecurringInvoiceTemplateClient<$Result.GetResult<Prisma.$RecurringInvoiceTemplatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecurringInvoiceTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringInvoiceTemplateFindFirstOrThrowArgs} args - Arguments to find a RecurringInvoiceTemplate
     * @example
     * // Get one RecurringInvoiceTemplate
     * const recurringInvoiceTemplate = await prisma.recurringInvoiceTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RecurringInvoiceTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, RecurringInvoiceTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__RecurringInvoiceTemplateClient<$Result.GetResult<Prisma.$RecurringInvoiceTemplatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RecurringInvoiceTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringInvoiceTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RecurringInvoiceTemplates
     * const recurringInvoiceTemplates = await prisma.recurringInvoiceTemplate.findMany()
     * 
     * // Get first 10 RecurringInvoiceTemplates
     * const recurringInvoiceTemplates = await prisma.recurringInvoiceTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recurringInvoiceTemplateWithIdOnly = await prisma.recurringInvoiceTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RecurringInvoiceTemplateFindManyArgs>(args?: SelectSubset<T, RecurringInvoiceTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecurringInvoiceTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RecurringInvoiceTemplate.
     * @param {RecurringInvoiceTemplateCreateArgs} args - Arguments to create a RecurringInvoiceTemplate.
     * @example
     * // Create one RecurringInvoiceTemplate
     * const RecurringInvoiceTemplate = await prisma.recurringInvoiceTemplate.create({
     *   data: {
     *     // ... data to create a RecurringInvoiceTemplate
     *   }
     * })
     * 
     */
    create<T extends RecurringInvoiceTemplateCreateArgs>(args: SelectSubset<T, RecurringInvoiceTemplateCreateArgs<ExtArgs>>): Prisma__RecurringInvoiceTemplateClient<$Result.GetResult<Prisma.$RecurringInvoiceTemplatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RecurringInvoiceTemplates.
     * @param {RecurringInvoiceTemplateCreateManyArgs} args - Arguments to create many RecurringInvoiceTemplates.
     * @example
     * // Create many RecurringInvoiceTemplates
     * const recurringInvoiceTemplate = await prisma.recurringInvoiceTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RecurringInvoiceTemplateCreateManyArgs>(args?: SelectSubset<T, RecurringInvoiceTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RecurringInvoiceTemplates and returns the data saved in the database.
     * @param {RecurringInvoiceTemplateCreateManyAndReturnArgs} args - Arguments to create many RecurringInvoiceTemplates.
     * @example
     * // Create many RecurringInvoiceTemplates
     * const recurringInvoiceTemplate = await prisma.recurringInvoiceTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RecurringInvoiceTemplates and only return the `id`
     * const recurringInvoiceTemplateWithIdOnly = await prisma.recurringInvoiceTemplate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RecurringInvoiceTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, RecurringInvoiceTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecurringInvoiceTemplatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RecurringInvoiceTemplate.
     * @param {RecurringInvoiceTemplateDeleteArgs} args - Arguments to delete one RecurringInvoiceTemplate.
     * @example
     * // Delete one RecurringInvoiceTemplate
     * const RecurringInvoiceTemplate = await prisma.recurringInvoiceTemplate.delete({
     *   where: {
     *     // ... filter to delete one RecurringInvoiceTemplate
     *   }
     * })
     * 
     */
    delete<T extends RecurringInvoiceTemplateDeleteArgs>(args: SelectSubset<T, RecurringInvoiceTemplateDeleteArgs<ExtArgs>>): Prisma__RecurringInvoiceTemplateClient<$Result.GetResult<Prisma.$RecurringInvoiceTemplatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RecurringInvoiceTemplate.
     * @param {RecurringInvoiceTemplateUpdateArgs} args - Arguments to update one RecurringInvoiceTemplate.
     * @example
     * // Update one RecurringInvoiceTemplate
     * const recurringInvoiceTemplate = await prisma.recurringInvoiceTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RecurringInvoiceTemplateUpdateArgs>(args: SelectSubset<T, RecurringInvoiceTemplateUpdateArgs<ExtArgs>>): Prisma__RecurringInvoiceTemplateClient<$Result.GetResult<Prisma.$RecurringInvoiceTemplatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RecurringInvoiceTemplates.
     * @param {RecurringInvoiceTemplateDeleteManyArgs} args - Arguments to filter RecurringInvoiceTemplates to delete.
     * @example
     * // Delete a few RecurringInvoiceTemplates
     * const { count } = await prisma.recurringInvoiceTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RecurringInvoiceTemplateDeleteManyArgs>(args?: SelectSubset<T, RecurringInvoiceTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecurringInvoiceTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringInvoiceTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RecurringInvoiceTemplates
     * const recurringInvoiceTemplate = await prisma.recurringInvoiceTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RecurringInvoiceTemplateUpdateManyArgs>(args: SelectSubset<T, RecurringInvoiceTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecurringInvoiceTemplates and returns the data updated in the database.
     * @param {RecurringInvoiceTemplateUpdateManyAndReturnArgs} args - Arguments to update many RecurringInvoiceTemplates.
     * @example
     * // Update many RecurringInvoiceTemplates
     * const recurringInvoiceTemplate = await prisma.recurringInvoiceTemplate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RecurringInvoiceTemplates and only return the `id`
     * const recurringInvoiceTemplateWithIdOnly = await prisma.recurringInvoiceTemplate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RecurringInvoiceTemplateUpdateManyAndReturnArgs>(args: SelectSubset<T, RecurringInvoiceTemplateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecurringInvoiceTemplatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RecurringInvoiceTemplate.
     * @param {RecurringInvoiceTemplateUpsertArgs} args - Arguments to update or create a RecurringInvoiceTemplate.
     * @example
     * // Update or create a RecurringInvoiceTemplate
     * const recurringInvoiceTemplate = await prisma.recurringInvoiceTemplate.upsert({
     *   create: {
     *     // ... data to create a RecurringInvoiceTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RecurringInvoiceTemplate we want to update
     *   }
     * })
     */
    upsert<T extends RecurringInvoiceTemplateUpsertArgs>(args: SelectSubset<T, RecurringInvoiceTemplateUpsertArgs<ExtArgs>>): Prisma__RecurringInvoiceTemplateClient<$Result.GetResult<Prisma.$RecurringInvoiceTemplatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RecurringInvoiceTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringInvoiceTemplateCountArgs} args - Arguments to filter RecurringInvoiceTemplates to count.
     * @example
     * // Count the number of RecurringInvoiceTemplates
     * const count = await prisma.recurringInvoiceTemplate.count({
     *   where: {
     *     // ... the filter for the RecurringInvoiceTemplates we want to count
     *   }
     * })
    **/
    count<T extends RecurringInvoiceTemplateCountArgs>(
      args?: Subset<T, RecurringInvoiceTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecurringInvoiceTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RecurringInvoiceTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringInvoiceTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecurringInvoiceTemplateAggregateArgs>(args: Subset<T, RecurringInvoiceTemplateAggregateArgs>): Prisma.PrismaPromise<GetRecurringInvoiceTemplateAggregateType<T>>

    /**
     * Group by RecurringInvoiceTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringInvoiceTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecurringInvoiceTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecurringInvoiceTemplateGroupByArgs['orderBy'] }
        : { orderBy?: RecurringInvoiceTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecurringInvoiceTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecurringInvoiceTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RecurringInvoiceTemplate model
   */
  readonly fields: RecurringInvoiceTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RecurringInvoiceTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecurringInvoiceTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RecurringInvoiceTemplate model
   */
  interface RecurringInvoiceTemplateFieldRefs {
    readonly id: FieldRef<"RecurringInvoiceTemplate", 'String'>
    readonly tenantId: FieldRef<"RecurringInvoiceTemplate", 'String'>
    readonly frequency: FieldRef<"RecurringInvoiceTemplate", 'String'>
    readonly nextInvoiceDate: FieldRef<"RecurringInvoiceTemplate", 'DateTime'>
    readonly isActive: FieldRef<"RecurringInvoiceTemplate", 'Boolean'>
    readonly invoiceTemplate: FieldRef<"RecurringInvoiceTemplate", 'Json'>
    readonly metadata: FieldRef<"RecurringInvoiceTemplate", 'Json'>
    readonly createdAt: FieldRef<"RecurringInvoiceTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"RecurringInvoiceTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RecurringInvoiceTemplate findUnique
   */
  export type RecurringInvoiceTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringInvoiceTemplate
     */
    select?: RecurringInvoiceTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringInvoiceTemplate
     */
    omit?: RecurringInvoiceTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringInvoiceTemplateInclude<ExtArgs> | null
    /**
     * Filter, which RecurringInvoiceTemplate to fetch.
     */
    where: RecurringInvoiceTemplateWhereUniqueInput
  }

  /**
   * RecurringInvoiceTemplate findUniqueOrThrow
   */
  export type RecurringInvoiceTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringInvoiceTemplate
     */
    select?: RecurringInvoiceTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringInvoiceTemplate
     */
    omit?: RecurringInvoiceTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringInvoiceTemplateInclude<ExtArgs> | null
    /**
     * Filter, which RecurringInvoiceTemplate to fetch.
     */
    where: RecurringInvoiceTemplateWhereUniqueInput
  }

  /**
   * RecurringInvoiceTemplate findFirst
   */
  export type RecurringInvoiceTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringInvoiceTemplate
     */
    select?: RecurringInvoiceTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringInvoiceTemplate
     */
    omit?: RecurringInvoiceTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringInvoiceTemplateInclude<ExtArgs> | null
    /**
     * Filter, which RecurringInvoiceTemplate to fetch.
     */
    where?: RecurringInvoiceTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecurringInvoiceTemplates to fetch.
     */
    orderBy?: RecurringInvoiceTemplateOrderByWithRelationInput | RecurringInvoiceTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecurringInvoiceTemplates.
     */
    cursor?: RecurringInvoiceTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecurringInvoiceTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecurringInvoiceTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecurringInvoiceTemplates.
     */
    distinct?: RecurringInvoiceTemplateScalarFieldEnum | RecurringInvoiceTemplateScalarFieldEnum[]
  }

  /**
   * RecurringInvoiceTemplate findFirstOrThrow
   */
  export type RecurringInvoiceTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringInvoiceTemplate
     */
    select?: RecurringInvoiceTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringInvoiceTemplate
     */
    omit?: RecurringInvoiceTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringInvoiceTemplateInclude<ExtArgs> | null
    /**
     * Filter, which RecurringInvoiceTemplate to fetch.
     */
    where?: RecurringInvoiceTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecurringInvoiceTemplates to fetch.
     */
    orderBy?: RecurringInvoiceTemplateOrderByWithRelationInput | RecurringInvoiceTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecurringInvoiceTemplates.
     */
    cursor?: RecurringInvoiceTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecurringInvoiceTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecurringInvoiceTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecurringInvoiceTemplates.
     */
    distinct?: RecurringInvoiceTemplateScalarFieldEnum | RecurringInvoiceTemplateScalarFieldEnum[]
  }

  /**
   * RecurringInvoiceTemplate findMany
   */
  export type RecurringInvoiceTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringInvoiceTemplate
     */
    select?: RecurringInvoiceTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringInvoiceTemplate
     */
    omit?: RecurringInvoiceTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringInvoiceTemplateInclude<ExtArgs> | null
    /**
     * Filter, which RecurringInvoiceTemplates to fetch.
     */
    where?: RecurringInvoiceTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecurringInvoiceTemplates to fetch.
     */
    orderBy?: RecurringInvoiceTemplateOrderByWithRelationInput | RecurringInvoiceTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RecurringInvoiceTemplates.
     */
    cursor?: RecurringInvoiceTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecurringInvoiceTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecurringInvoiceTemplates.
     */
    skip?: number
    distinct?: RecurringInvoiceTemplateScalarFieldEnum | RecurringInvoiceTemplateScalarFieldEnum[]
  }

  /**
   * RecurringInvoiceTemplate create
   */
  export type RecurringInvoiceTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringInvoiceTemplate
     */
    select?: RecurringInvoiceTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringInvoiceTemplate
     */
    omit?: RecurringInvoiceTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringInvoiceTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a RecurringInvoiceTemplate.
     */
    data: XOR<RecurringInvoiceTemplateCreateInput, RecurringInvoiceTemplateUncheckedCreateInput>
  }

  /**
   * RecurringInvoiceTemplate createMany
   */
  export type RecurringInvoiceTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RecurringInvoiceTemplates.
     */
    data: RecurringInvoiceTemplateCreateManyInput | RecurringInvoiceTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RecurringInvoiceTemplate createManyAndReturn
   */
  export type RecurringInvoiceTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringInvoiceTemplate
     */
    select?: RecurringInvoiceTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringInvoiceTemplate
     */
    omit?: RecurringInvoiceTemplateOmit<ExtArgs> | null
    /**
     * The data used to create many RecurringInvoiceTemplates.
     */
    data: RecurringInvoiceTemplateCreateManyInput | RecurringInvoiceTemplateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringInvoiceTemplateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RecurringInvoiceTemplate update
   */
  export type RecurringInvoiceTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringInvoiceTemplate
     */
    select?: RecurringInvoiceTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringInvoiceTemplate
     */
    omit?: RecurringInvoiceTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringInvoiceTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a RecurringInvoiceTemplate.
     */
    data: XOR<RecurringInvoiceTemplateUpdateInput, RecurringInvoiceTemplateUncheckedUpdateInput>
    /**
     * Choose, which RecurringInvoiceTemplate to update.
     */
    where: RecurringInvoiceTemplateWhereUniqueInput
  }

  /**
   * RecurringInvoiceTemplate updateMany
   */
  export type RecurringInvoiceTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RecurringInvoiceTemplates.
     */
    data: XOR<RecurringInvoiceTemplateUpdateManyMutationInput, RecurringInvoiceTemplateUncheckedUpdateManyInput>
    /**
     * Filter which RecurringInvoiceTemplates to update
     */
    where?: RecurringInvoiceTemplateWhereInput
    /**
     * Limit how many RecurringInvoiceTemplates to update.
     */
    limit?: number
  }

  /**
   * RecurringInvoiceTemplate updateManyAndReturn
   */
  export type RecurringInvoiceTemplateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringInvoiceTemplate
     */
    select?: RecurringInvoiceTemplateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringInvoiceTemplate
     */
    omit?: RecurringInvoiceTemplateOmit<ExtArgs> | null
    /**
     * The data used to update RecurringInvoiceTemplates.
     */
    data: XOR<RecurringInvoiceTemplateUpdateManyMutationInput, RecurringInvoiceTemplateUncheckedUpdateManyInput>
    /**
     * Filter which RecurringInvoiceTemplates to update
     */
    where?: RecurringInvoiceTemplateWhereInput
    /**
     * Limit how many RecurringInvoiceTemplates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringInvoiceTemplateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RecurringInvoiceTemplate upsert
   */
  export type RecurringInvoiceTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringInvoiceTemplate
     */
    select?: RecurringInvoiceTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringInvoiceTemplate
     */
    omit?: RecurringInvoiceTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringInvoiceTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the RecurringInvoiceTemplate to update in case it exists.
     */
    where: RecurringInvoiceTemplateWhereUniqueInput
    /**
     * In case the RecurringInvoiceTemplate found by the `where` argument doesn't exist, create a new RecurringInvoiceTemplate with this data.
     */
    create: XOR<RecurringInvoiceTemplateCreateInput, RecurringInvoiceTemplateUncheckedCreateInput>
    /**
     * In case the RecurringInvoiceTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecurringInvoiceTemplateUpdateInput, RecurringInvoiceTemplateUncheckedUpdateInput>
  }

  /**
   * RecurringInvoiceTemplate delete
   */
  export type RecurringInvoiceTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringInvoiceTemplate
     */
    select?: RecurringInvoiceTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringInvoiceTemplate
     */
    omit?: RecurringInvoiceTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringInvoiceTemplateInclude<ExtArgs> | null
    /**
     * Filter which RecurringInvoiceTemplate to delete.
     */
    where: RecurringInvoiceTemplateWhereUniqueInput
  }

  /**
   * RecurringInvoiceTemplate deleteMany
   */
  export type RecurringInvoiceTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecurringInvoiceTemplates to delete
     */
    where?: RecurringInvoiceTemplateWhereInput
    /**
     * Limit how many RecurringInvoiceTemplates to delete.
     */
    limit?: number
  }

  /**
   * RecurringInvoiceTemplate without action
   */
  export type RecurringInvoiceTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringInvoiceTemplate
     */
    select?: RecurringInvoiceTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringInvoiceTemplate
     */
    omit?: RecurringInvoiceTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringInvoiceTemplateInclude<ExtArgs> | null
  }


  /**
   * Model PushSubscription
   */

  export type AggregatePushSubscription = {
    _count: PushSubscriptionCountAggregateOutputType | null
    _min: PushSubscriptionMinAggregateOutputType | null
    _max: PushSubscriptionMaxAggregateOutputType | null
  }

  export type PushSubscriptionMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    clientId: string | null
    endpoint: string | null
    p256dh: string | null
    auth: string | null
    userAgent: string | null
    deviceName: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PushSubscriptionMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    clientId: string | null
    endpoint: string | null
    p256dh: string | null
    auth: string | null
    userAgent: string | null
    deviceName: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PushSubscriptionCountAggregateOutputType = {
    id: number
    tenantId: number
    userId: number
    clientId: number
    endpoint: number
    p256dh: number
    auth: number
    userAgent: number
    deviceName: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PushSubscriptionMinAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    clientId?: true
    endpoint?: true
    p256dh?: true
    auth?: true
    userAgent?: true
    deviceName?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PushSubscriptionMaxAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    clientId?: true
    endpoint?: true
    p256dh?: true
    auth?: true
    userAgent?: true
    deviceName?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PushSubscriptionCountAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    clientId?: true
    endpoint?: true
    p256dh?: true
    auth?: true
    userAgent?: true
    deviceName?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PushSubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PushSubscription to aggregate.
     */
    where?: PushSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PushSubscriptions to fetch.
     */
    orderBy?: PushSubscriptionOrderByWithRelationInput | PushSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PushSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PushSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PushSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PushSubscriptions
    **/
    _count?: true | PushSubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PushSubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PushSubscriptionMaxAggregateInputType
  }

  export type GetPushSubscriptionAggregateType<T extends PushSubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregatePushSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePushSubscription[P]>
      : GetScalarType<T[P], AggregatePushSubscription[P]>
  }




  export type PushSubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PushSubscriptionWhereInput
    orderBy?: PushSubscriptionOrderByWithAggregationInput | PushSubscriptionOrderByWithAggregationInput[]
    by: PushSubscriptionScalarFieldEnum[] | PushSubscriptionScalarFieldEnum
    having?: PushSubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PushSubscriptionCountAggregateInputType | true
    _min?: PushSubscriptionMinAggregateInputType
    _max?: PushSubscriptionMaxAggregateInputType
  }

  export type PushSubscriptionGroupByOutputType = {
    id: string
    tenantId: string
    userId: string | null
    clientId: string | null
    endpoint: string
    p256dh: string
    auth: string
    userAgent: string | null
    deviceName: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: PushSubscriptionCountAggregateOutputType | null
    _min: PushSubscriptionMinAggregateOutputType | null
    _max: PushSubscriptionMaxAggregateOutputType | null
  }

  type GetPushSubscriptionGroupByPayload<T extends PushSubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PushSubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PushSubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PushSubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], PushSubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type PushSubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    clientId?: boolean
    endpoint?: boolean
    p256dh?: boolean
    auth?: boolean
    userAgent?: boolean
    deviceName?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["pushSubscription"]>

  export type PushSubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    clientId?: boolean
    endpoint?: boolean
    p256dh?: boolean
    auth?: boolean
    userAgent?: boolean
    deviceName?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["pushSubscription"]>

  export type PushSubscriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    clientId?: boolean
    endpoint?: boolean
    p256dh?: boolean
    auth?: boolean
    userAgent?: boolean
    deviceName?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["pushSubscription"]>

  export type PushSubscriptionSelectScalar = {
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    clientId?: boolean
    endpoint?: boolean
    p256dh?: boolean
    auth?: boolean
    userAgent?: boolean
    deviceName?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PushSubscriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "userId" | "clientId" | "endpoint" | "p256dh" | "auth" | "userAgent" | "deviceName" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["pushSubscription"]>

  export type $PushSubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PushSubscription"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      userId: string | null
      clientId: string | null
      endpoint: string
      p256dh: string
      auth: string
      userAgent: string | null
      deviceName: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pushSubscription"]>
    composites: {}
  }

  type PushSubscriptionGetPayload<S extends boolean | null | undefined | PushSubscriptionDefaultArgs> = $Result.GetResult<Prisma.$PushSubscriptionPayload, S>

  type PushSubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PushSubscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PushSubscriptionCountAggregateInputType | true
    }

  export interface PushSubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PushSubscription'], meta: { name: 'PushSubscription' } }
    /**
     * Find zero or one PushSubscription that matches the filter.
     * @param {PushSubscriptionFindUniqueArgs} args - Arguments to find a PushSubscription
     * @example
     * // Get one PushSubscription
     * const pushSubscription = await prisma.pushSubscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PushSubscriptionFindUniqueArgs>(args: SelectSubset<T, PushSubscriptionFindUniqueArgs<ExtArgs>>): Prisma__PushSubscriptionClient<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PushSubscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PushSubscriptionFindUniqueOrThrowArgs} args - Arguments to find a PushSubscription
     * @example
     * // Get one PushSubscription
     * const pushSubscription = await prisma.pushSubscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PushSubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, PushSubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PushSubscriptionClient<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PushSubscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionFindFirstArgs} args - Arguments to find a PushSubscription
     * @example
     * // Get one PushSubscription
     * const pushSubscription = await prisma.pushSubscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PushSubscriptionFindFirstArgs>(args?: SelectSubset<T, PushSubscriptionFindFirstArgs<ExtArgs>>): Prisma__PushSubscriptionClient<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PushSubscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionFindFirstOrThrowArgs} args - Arguments to find a PushSubscription
     * @example
     * // Get one PushSubscription
     * const pushSubscription = await prisma.pushSubscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PushSubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, PushSubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PushSubscriptionClient<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PushSubscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PushSubscriptions
     * const pushSubscriptions = await prisma.pushSubscription.findMany()
     * 
     * // Get first 10 PushSubscriptions
     * const pushSubscriptions = await prisma.pushSubscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pushSubscriptionWithIdOnly = await prisma.pushSubscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PushSubscriptionFindManyArgs>(args?: SelectSubset<T, PushSubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PushSubscription.
     * @param {PushSubscriptionCreateArgs} args - Arguments to create a PushSubscription.
     * @example
     * // Create one PushSubscription
     * const PushSubscription = await prisma.pushSubscription.create({
     *   data: {
     *     // ... data to create a PushSubscription
     *   }
     * })
     * 
     */
    create<T extends PushSubscriptionCreateArgs>(args: SelectSubset<T, PushSubscriptionCreateArgs<ExtArgs>>): Prisma__PushSubscriptionClient<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PushSubscriptions.
     * @param {PushSubscriptionCreateManyArgs} args - Arguments to create many PushSubscriptions.
     * @example
     * // Create many PushSubscriptions
     * const pushSubscription = await prisma.pushSubscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PushSubscriptionCreateManyArgs>(args?: SelectSubset<T, PushSubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PushSubscriptions and returns the data saved in the database.
     * @param {PushSubscriptionCreateManyAndReturnArgs} args - Arguments to create many PushSubscriptions.
     * @example
     * // Create many PushSubscriptions
     * const pushSubscription = await prisma.pushSubscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PushSubscriptions and only return the `id`
     * const pushSubscriptionWithIdOnly = await prisma.pushSubscription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PushSubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, PushSubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PushSubscription.
     * @param {PushSubscriptionDeleteArgs} args - Arguments to delete one PushSubscription.
     * @example
     * // Delete one PushSubscription
     * const PushSubscription = await prisma.pushSubscription.delete({
     *   where: {
     *     // ... filter to delete one PushSubscription
     *   }
     * })
     * 
     */
    delete<T extends PushSubscriptionDeleteArgs>(args: SelectSubset<T, PushSubscriptionDeleteArgs<ExtArgs>>): Prisma__PushSubscriptionClient<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PushSubscription.
     * @param {PushSubscriptionUpdateArgs} args - Arguments to update one PushSubscription.
     * @example
     * // Update one PushSubscription
     * const pushSubscription = await prisma.pushSubscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PushSubscriptionUpdateArgs>(args: SelectSubset<T, PushSubscriptionUpdateArgs<ExtArgs>>): Prisma__PushSubscriptionClient<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PushSubscriptions.
     * @param {PushSubscriptionDeleteManyArgs} args - Arguments to filter PushSubscriptions to delete.
     * @example
     * // Delete a few PushSubscriptions
     * const { count } = await prisma.pushSubscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PushSubscriptionDeleteManyArgs>(args?: SelectSubset<T, PushSubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PushSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PushSubscriptions
     * const pushSubscription = await prisma.pushSubscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PushSubscriptionUpdateManyArgs>(args: SelectSubset<T, PushSubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PushSubscriptions and returns the data updated in the database.
     * @param {PushSubscriptionUpdateManyAndReturnArgs} args - Arguments to update many PushSubscriptions.
     * @example
     * // Update many PushSubscriptions
     * const pushSubscription = await prisma.pushSubscription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PushSubscriptions and only return the `id`
     * const pushSubscriptionWithIdOnly = await prisma.pushSubscription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PushSubscriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, PushSubscriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PushSubscription.
     * @param {PushSubscriptionUpsertArgs} args - Arguments to update or create a PushSubscription.
     * @example
     * // Update or create a PushSubscription
     * const pushSubscription = await prisma.pushSubscription.upsert({
     *   create: {
     *     // ... data to create a PushSubscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PushSubscription we want to update
     *   }
     * })
     */
    upsert<T extends PushSubscriptionUpsertArgs>(args: SelectSubset<T, PushSubscriptionUpsertArgs<ExtArgs>>): Prisma__PushSubscriptionClient<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PushSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionCountArgs} args - Arguments to filter PushSubscriptions to count.
     * @example
     * // Count the number of PushSubscriptions
     * const count = await prisma.pushSubscription.count({
     *   where: {
     *     // ... the filter for the PushSubscriptions we want to count
     *   }
     * })
    **/
    count<T extends PushSubscriptionCountArgs>(
      args?: Subset<T, PushSubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PushSubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PushSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PushSubscriptionAggregateArgs>(args: Subset<T, PushSubscriptionAggregateArgs>): Prisma.PrismaPromise<GetPushSubscriptionAggregateType<T>>

    /**
     * Group by PushSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PushSubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PushSubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: PushSubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PushSubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPushSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PushSubscription model
   */
  readonly fields: PushSubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PushSubscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PushSubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PushSubscription model
   */
  interface PushSubscriptionFieldRefs {
    readonly id: FieldRef<"PushSubscription", 'String'>
    readonly tenantId: FieldRef<"PushSubscription", 'String'>
    readonly userId: FieldRef<"PushSubscription", 'String'>
    readonly clientId: FieldRef<"PushSubscription", 'String'>
    readonly endpoint: FieldRef<"PushSubscription", 'String'>
    readonly p256dh: FieldRef<"PushSubscription", 'String'>
    readonly auth: FieldRef<"PushSubscription", 'String'>
    readonly userAgent: FieldRef<"PushSubscription", 'String'>
    readonly deviceName: FieldRef<"PushSubscription", 'String'>
    readonly isActive: FieldRef<"PushSubscription", 'Boolean'>
    readonly createdAt: FieldRef<"PushSubscription", 'DateTime'>
    readonly updatedAt: FieldRef<"PushSubscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PushSubscription findUnique
   */
  export type PushSubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * Filter, which PushSubscription to fetch.
     */
    where: PushSubscriptionWhereUniqueInput
  }

  /**
   * PushSubscription findUniqueOrThrow
   */
  export type PushSubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * Filter, which PushSubscription to fetch.
     */
    where: PushSubscriptionWhereUniqueInput
  }

  /**
   * PushSubscription findFirst
   */
  export type PushSubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * Filter, which PushSubscription to fetch.
     */
    where?: PushSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PushSubscriptions to fetch.
     */
    orderBy?: PushSubscriptionOrderByWithRelationInput | PushSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PushSubscriptions.
     */
    cursor?: PushSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PushSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PushSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PushSubscriptions.
     */
    distinct?: PushSubscriptionScalarFieldEnum | PushSubscriptionScalarFieldEnum[]
  }

  /**
   * PushSubscription findFirstOrThrow
   */
  export type PushSubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * Filter, which PushSubscription to fetch.
     */
    where?: PushSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PushSubscriptions to fetch.
     */
    orderBy?: PushSubscriptionOrderByWithRelationInput | PushSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PushSubscriptions.
     */
    cursor?: PushSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PushSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PushSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PushSubscriptions.
     */
    distinct?: PushSubscriptionScalarFieldEnum | PushSubscriptionScalarFieldEnum[]
  }

  /**
   * PushSubscription findMany
   */
  export type PushSubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * Filter, which PushSubscriptions to fetch.
     */
    where?: PushSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PushSubscriptions to fetch.
     */
    orderBy?: PushSubscriptionOrderByWithRelationInput | PushSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PushSubscriptions.
     */
    cursor?: PushSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PushSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PushSubscriptions.
     */
    skip?: number
    distinct?: PushSubscriptionScalarFieldEnum | PushSubscriptionScalarFieldEnum[]
  }

  /**
   * PushSubscription create
   */
  export type PushSubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * The data needed to create a PushSubscription.
     */
    data: XOR<PushSubscriptionCreateInput, PushSubscriptionUncheckedCreateInput>
  }

  /**
   * PushSubscription createMany
   */
  export type PushSubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PushSubscriptions.
     */
    data: PushSubscriptionCreateManyInput | PushSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PushSubscription createManyAndReturn
   */
  export type PushSubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * The data used to create many PushSubscriptions.
     */
    data: PushSubscriptionCreateManyInput | PushSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PushSubscription update
   */
  export type PushSubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * The data needed to update a PushSubscription.
     */
    data: XOR<PushSubscriptionUpdateInput, PushSubscriptionUncheckedUpdateInput>
    /**
     * Choose, which PushSubscription to update.
     */
    where: PushSubscriptionWhereUniqueInput
  }

  /**
   * PushSubscription updateMany
   */
  export type PushSubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PushSubscriptions.
     */
    data: XOR<PushSubscriptionUpdateManyMutationInput, PushSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which PushSubscriptions to update
     */
    where?: PushSubscriptionWhereInput
    /**
     * Limit how many PushSubscriptions to update.
     */
    limit?: number
  }

  /**
   * PushSubscription updateManyAndReturn
   */
  export type PushSubscriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * The data used to update PushSubscriptions.
     */
    data: XOR<PushSubscriptionUpdateManyMutationInput, PushSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which PushSubscriptions to update
     */
    where?: PushSubscriptionWhereInput
    /**
     * Limit how many PushSubscriptions to update.
     */
    limit?: number
  }

  /**
   * PushSubscription upsert
   */
  export type PushSubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * The filter to search for the PushSubscription to update in case it exists.
     */
    where: PushSubscriptionWhereUniqueInput
    /**
     * In case the PushSubscription found by the `where` argument doesn't exist, create a new PushSubscription with this data.
     */
    create: XOR<PushSubscriptionCreateInput, PushSubscriptionUncheckedCreateInput>
    /**
     * In case the PushSubscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PushSubscriptionUpdateInput, PushSubscriptionUncheckedUpdateInput>
  }

  /**
   * PushSubscription delete
   */
  export type PushSubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * Filter which PushSubscription to delete.
     */
    where: PushSubscriptionWhereUniqueInput
  }

  /**
   * PushSubscription deleteMany
   */
  export type PushSubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PushSubscriptions to delete
     */
    where?: PushSubscriptionWhereInput
    /**
     * Limit how many PushSubscriptions to delete.
     */
    limit?: number
  }

  /**
   * PushSubscription without action
   */
  export type PushSubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
  }


  /**
   * Model NotificationPreference
   */

  export type AggregateNotificationPreference = {
    _count: NotificationPreferenceCountAggregateOutputType | null
    _avg: NotificationPreferenceAvgAggregateOutputType | null
    _sum: NotificationPreferenceSumAggregateOutputType | null
    _min: NotificationPreferenceMinAggregateOutputType | null
    _max: NotificationPreferenceMaxAggregateOutputType | null
  }

  export type NotificationPreferenceAvgAggregateOutputType = {
    reminderMinutesBefore: number | null
  }

  export type NotificationPreferenceSumAggregateOutputType = {
    reminderMinutesBefore: number | null
  }

  export type NotificationPreferenceMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    clientId: string | null
    sessionReminders: boolean | null
    classReminders: boolean | null
    invoiceNotifications: boolean | null
    paymentNotifications: boolean | null
    atRiskAlerts: boolean | null
    reminderMinutesBefore: number | null
    emailEnabled: boolean | null
    pushEnabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationPreferenceMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    clientId: string | null
    sessionReminders: boolean | null
    classReminders: boolean | null
    invoiceNotifications: boolean | null
    paymentNotifications: boolean | null
    atRiskAlerts: boolean | null
    reminderMinutesBefore: number | null
    emailEnabled: boolean | null
    pushEnabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationPreferenceCountAggregateOutputType = {
    id: number
    tenantId: number
    userId: number
    clientId: number
    sessionReminders: number
    classReminders: number
    invoiceNotifications: number
    paymentNotifications: number
    atRiskAlerts: number
    reminderMinutesBefore: number
    emailEnabled: number
    pushEnabled: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationPreferenceAvgAggregateInputType = {
    reminderMinutesBefore?: true
  }

  export type NotificationPreferenceSumAggregateInputType = {
    reminderMinutesBefore?: true
  }

  export type NotificationPreferenceMinAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    clientId?: true
    sessionReminders?: true
    classReminders?: true
    invoiceNotifications?: true
    paymentNotifications?: true
    atRiskAlerts?: true
    reminderMinutesBefore?: true
    emailEnabled?: true
    pushEnabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationPreferenceMaxAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    clientId?: true
    sessionReminders?: true
    classReminders?: true
    invoiceNotifications?: true
    paymentNotifications?: true
    atRiskAlerts?: true
    reminderMinutesBefore?: true
    emailEnabled?: true
    pushEnabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationPreferenceCountAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    clientId?: true
    sessionReminders?: true
    classReminders?: true
    invoiceNotifications?: true
    paymentNotifications?: true
    atRiskAlerts?: true
    reminderMinutesBefore?: true
    emailEnabled?: true
    pushEnabled?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationPreferenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationPreference to aggregate.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationPreferences
    **/
    _count?: true | NotificationPreferenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationPreferenceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationPreferenceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationPreferenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationPreferenceMaxAggregateInputType
  }

  export type GetNotificationPreferenceAggregateType<T extends NotificationPreferenceAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationPreference]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationPreference[P]>
      : GetScalarType<T[P], AggregateNotificationPreference[P]>
  }




  export type NotificationPreferenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationPreferenceWhereInput
    orderBy?: NotificationPreferenceOrderByWithAggregationInput | NotificationPreferenceOrderByWithAggregationInput[]
    by: NotificationPreferenceScalarFieldEnum[] | NotificationPreferenceScalarFieldEnum
    having?: NotificationPreferenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationPreferenceCountAggregateInputType | true
    _avg?: NotificationPreferenceAvgAggregateInputType
    _sum?: NotificationPreferenceSumAggregateInputType
    _min?: NotificationPreferenceMinAggregateInputType
    _max?: NotificationPreferenceMaxAggregateInputType
  }

  export type NotificationPreferenceGroupByOutputType = {
    id: string
    tenantId: string
    userId: string | null
    clientId: string | null
    sessionReminders: boolean
    classReminders: boolean
    invoiceNotifications: boolean
    paymentNotifications: boolean
    atRiskAlerts: boolean
    reminderMinutesBefore: number
    emailEnabled: boolean
    pushEnabled: boolean
    createdAt: Date
    updatedAt: Date
    _count: NotificationPreferenceCountAggregateOutputType | null
    _avg: NotificationPreferenceAvgAggregateOutputType | null
    _sum: NotificationPreferenceSumAggregateOutputType | null
    _min: NotificationPreferenceMinAggregateOutputType | null
    _max: NotificationPreferenceMaxAggregateOutputType | null
  }

  type GetNotificationPreferenceGroupByPayload<T extends NotificationPreferenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationPreferenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationPreferenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationPreferenceGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationPreferenceGroupByOutputType[P]>
        }
      >
    >


  export type NotificationPreferenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    clientId?: boolean
    sessionReminders?: boolean
    classReminders?: boolean
    invoiceNotifications?: boolean
    paymentNotifications?: boolean
    atRiskAlerts?: boolean
    reminderMinutesBefore?: boolean
    emailEnabled?: boolean
    pushEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["notificationPreference"]>

  export type NotificationPreferenceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    clientId?: boolean
    sessionReminders?: boolean
    classReminders?: boolean
    invoiceNotifications?: boolean
    paymentNotifications?: boolean
    atRiskAlerts?: boolean
    reminderMinutesBefore?: boolean
    emailEnabled?: boolean
    pushEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["notificationPreference"]>

  export type NotificationPreferenceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    clientId?: boolean
    sessionReminders?: boolean
    classReminders?: boolean
    invoiceNotifications?: boolean
    paymentNotifications?: boolean
    atRiskAlerts?: boolean
    reminderMinutesBefore?: boolean
    emailEnabled?: boolean
    pushEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["notificationPreference"]>

  export type NotificationPreferenceSelectScalar = {
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    clientId?: boolean
    sessionReminders?: boolean
    classReminders?: boolean
    invoiceNotifications?: boolean
    paymentNotifications?: boolean
    atRiskAlerts?: boolean
    reminderMinutesBefore?: boolean
    emailEnabled?: boolean
    pushEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationPreferenceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "userId" | "clientId" | "sessionReminders" | "classReminders" | "invoiceNotifications" | "paymentNotifications" | "atRiskAlerts" | "reminderMinutesBefore" | "emailEnabled" | "pushEnabled" | "createdAt" | "updatedAt", ExtArgs["result"]["notificationPreference"]>

  export type $NotificationPreferencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationPreference"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      userId: string | null
      clientId: string | null
      sessionReminders: boolean
      classReminders: boolean
      invoiceNotifications: boolean
      paymentNotifications: boolean
      atRiskAlerts: boolean
      reminderMinutesBefore: number
      emailEnabled: boolean
      pushEnabled: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notificationPreference"]>
    composites: {}
  }

  type NotificationPreferenceGetPayload<S extends boolean | null | undefined | NotificationPreferenceDefaultArgs> = $Result.GetResult<Prisma.$NotificationPreferencePayload, S>

  type NotificationPreferenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationPreferenceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationPreferenceCountAggregateInputType | true
    }

  export interface NotificationPreferenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationPreference'], meta: { name: 'NotificationPreference' } }
    /**
     * Find zero or one NotificationPreference that matches the filter.
     * @param {NotificationPreferenceFindUniqueArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationPreferenceFindUniqueArgs>(args: SelectSubset<T, NotificationPreferenceFindUniqueArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NotificationPreference that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationPreferenceFindUniqueOrThrowArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationPreferenceFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationPreferenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationPreference that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceFindFirstArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationPreferenceFindFirstArgs>(args?: SelectSubset<T, NotificationPreferenceFindFirstArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationPreference that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceFindFirstOrThrowArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationPreferenceFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationPreferenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NotificationPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationPreferences
     * const notificationPreferences = await prisma.notificationPreference.findMany()
     * 
     * // Get first 10 NotificationPreferences
     * const notificationPreferences = await prisma.notificationPreference.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationPreferenceWithIdOnly = await prisma.notificationPreference.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationPreferenceFindManyArgs>(args?: SelectSubset<T, NotificationPreferenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NotificationPreference.
     * @param {NotificationPreferenceCreateArgs} args - Arguments to create a NotificationPreference.
     * @example
     * // Create one NotificationPreference
     * const NotificationPreference = await prisma.notificationPreference.create({
     *   data: {
     *     // ... data to create a NotificationPreference
     *   }
     * })
     * 
     */
    create<T extends NotificationPreferenceCreateArgs>(args: SelectSubset<T, NotificationPreferenceCreateArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NotificationPreferences.
     * @param {NotificationPreferenceCreateManyArgs} args - Arguments to create many NotificationPreferences.
     * @example
     * // Create many NotificationPreferences
     * const notificationPreference = await prisma.notificationPreference.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationPreferenceCreateManyArgs>(args?: SelectSubset<T, NotificationPreferenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationPreferences and returns the data saved in the database.
     * @param {NotificationPreferenceCreateManyAndReturnArgs} args - Arguments to create many NotificationPreferences.
     * @example
     * // Create many NotificationPreferences
     * const notificationPreference = await prisma.notificationPreference.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationPreferences and only return the `id`
     * const notificationPreferenceWithIdOnly = await prisma.notificationPreference.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationPreferenceCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationPreferenceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NotificationPreference.
     * @param {NotificationPreferenceDeleteArgs} args - Arguments to delete one NotificationPreference.
     * @example
     * // Delete one NotificationPreference
     * const NotificationPreference = await prisma.notificationPreference.delete({
     *   where: {
     *     // ... filter to delete one NotificationPreference
     *   }
     * })
     * 
     */
    delete<T extends NotificationPreferenceDeleteArgs>(args: SelectSubset<T, NotificationPreferenceDeleteArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NotificationPreference.
     * @param {NotificationPreferenceUpdateArgs} args - Arguments to update one NotificationPreference.
     * @example
     * // Update one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationPreferenceUpdateArgs>(args: SelectSubset<T, NotificationPreferenceUpdateArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NotificationPreferences.
     * @param {NotificationPreferenceDeleteManyArgs} args - Arguments to filter NotificationPreferences to delete.
     * @example
     * // Delete a few NotificationPreferences
     * const { count } = await prisma.notificationPreference.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationPreferenceDeleteManyArgs>(args?: SelectSubset<T, NotificationPreferenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationPreferences
     * const notificationPreference = await prisma.notificationPreference.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationPreferenceUpdateManyArgs>(args: SelectSubset<T, NotificationPreferenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationPreferences and returns the data updated in the database.
     * @param {NotificationPreferenceUpdateManyAndReturnArgs} args - Arguments to update many NotificationPreferences.
     * @example
     * // Update many NotificationPreferences
     * const notificationPreference = await prisma.notificationPreference.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NotificationPreferences and only return the `id`
     * const notificationPreferenceWithIdOnly = await prisma.notificationPreference.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationPreferenceUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationPreferenceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NotificationPreference.
     * @param {NotificationPreferenceUpsertArgs} args - Arguments to update or create a NotificationPreference.
     * @example
     * // Update or create a NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.upsert({
     *   create: {
     *     // ... data to create a NotificationPreference
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationPreference we want to update
     *   }
     * })
     */
    upsert<T extends NotificationPreferenceUpsertArgs>(args: SelectSubset<T, NotificationPreferenceUpsertArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NotificationPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceCountArgs} args - Arguments to filter NotificationPreferences to count.
     * @example
     * // Count the number of NotificationPreferences
     * const count = await prisma.notificationPreference.count({
     *   where: {
     *     // ... the filter for the NotificationPreferences we want to count
     *   }
     * })
    **/
    count<T extends NotificationPreferenceCountArgs>(
      args?: Subset<T, NotificationPreferenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationPreferenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationPreferenceAggregateArgs>(args: Subset<T, NotificationPreferenceAggregateArgs>): Prisma.PrismaPromise<GetNotificationPreferenceAggregateType<T>>

    /**
     * Group by NotificationPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationPreferenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationPreferenceGroupByArgs['orderBy'] }
        : { orderBy?: NotificationPreferenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationPreferenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationPreferenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationPreference model
   */
  readonly fields: NotificationPreferenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationPreference.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationPreferenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationPreference model
   */
  interface NotificationPreferenceFieldRefs {
    readonly id: FieldRef<"NotificationPreference", 'String'>
    readonly tenantId: FieldRef<"NotificationPreference", 'String'>
    readonly userId: FieldRef<"NotificationPreference", 'String'>
    readonly clientId: FieldRef<"NotificationPreference", 'String'>
    readonly sessionReminders: FieldRef<"NotificationPreference", 'Boolean'>
    readonly classReminders: FieldRef<"NotificationPreference", 'Boolean'>
    readonly invoiceNotifications: FieldRef<"NotificationPreference", 'Boolean'>
    readonly paymentNotifications: FieldRef<"NotificationPreference", 'Boolean'>
    readonly atRiskAlerts: FieldRef<"NotificationPreference", 'Boolean'>
    readonly reminderMinutesBefore: FieldRef<"NotificationPreference", 'Int'>
    readonly emailEnabled: FieldRef<"NotificationPreference", 'Boolean'>
    readonly pushEnabled: FieldRef<"NotificationPreference", 'Boolean'>
    readonly createdAt: FieldRef<"NotificationPreference", 'DateTime'>
    readonly updatedAt: FieldRef<"NotificationPreference", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NotificationPreference findUnique
   */
  export type NotificationPreferenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where: NotificationPreferenceWhereUniqueInput
  }

  /**
   * NotificationPreference findUniqueOrThrow
   */
  export type NotificationPreferenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where: NotificationPreferenceWhereUniqueInput
  }

  /**
   * NotificationPreference findFirst
   */
  export type NotificationPreferenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationPreferences.
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationPreferences.
     */
    distinct?: NotificationPreferenceScalarFieldEnum | NotificationPreferenceScalarFieldEnum[]
  }

  /**
   * NotificationPreference findFirstOrThrow
   */
  export type NotificationPreferenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationPreferences.
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationPreferences.
     */
    distinct?: NotificationPreferenceScalarFieldEnum | NotificationPreferenceScalarFieldEnum[]
  }

  /**
   * NotificationPreference findMany
   */
  export type NotificationPreferenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Filter, which NotificationPreferences to fetch.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationPreferences.
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    distinct?: NotificationPreferenceScalarFieldEnum | NotificationPreferenceScalarFieldEnum[]
  }

  /**
   * NotificationPreference create
   */
  export type NotificationPreferenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * The data needed to create a NotificationPreference.
     */
    data: XOR<NotificationPreferenceCreateInput, NotificationPreferenceUncheckedCreateInput>
  }

  /**
   * NotificationPreference createMany
   */
  export type NotificationPreferenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationPreferences.
     */
    data: NotificationPreferenceCreateManyInput | NotificationPreferenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationPreference createManyAndReturn
   */
  export type NotificationPreferenceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * The data used to create many NotificationPreferences.
     */
    data: NotificationPreferenceCreateManyInput | NotificationPreferenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationPreference update
   */
  export type NotificationPreferenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * The data needed to update a NotificationPreference.
     */
    data: XOR<NotificationPreferenceUpdateInput, NotificationPreferenceUncheckedUpdateInput>
    /**
     * Choose, which NotificationPreference to update.
     */
    where: NotificationPreferenceWhereUniqueInput
  }

  /**
   * NotificationPreference updateMany
   */
  export type NotificationPreferenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationPreferences.
     */
    data: XOR<NotificationPreferenceUpdateManyMutationInput, NotificationPreferenceUncheckedUpdateManyInput>
    /**
     * Filter which NotificationPreferences to update
     */
    where?: NotificationPreferenceWhereInput
    /**
     * Limit how many NotificationPreferences to update.
     */
    limit?: number
  }

  /**
   * NotificationPreference updateManyAndReturn
   */
  export type NotificationPreferenceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * The data used to update NotificationPreferences.
     */
    data: XOR<NotificationPreferenceUpdateManyMutationInput, NotificationPreferenceUncheckedUpdateManyInput>
    /**
     * Filter which NotificationPreferences to update
     */
    where?: NotificationPreferenceWhereInput
    /**
     * Limit how many NotificationPreferences to update.
     */
    limit?: number
  }

  /**
   * NotificationPreference upsert
   */
  export type NotificationPreferenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * The filter to search for the NotificationPreference to update in case it exists.
     */
    where: NotificationPreferenceWhereUniqueInput
    /**
     * In case the NotificationPreference found by the `where` argument doesn't exist, create a new NotificationPreference with this data.
     */
    create: XOR<NotificationPreferenceCreateInput, NotificationPreferenceUncheckedCreateInput>
    /**
     * In case the NotificationPreference was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationPreferenceUpdateInput, NotificationPreferenceUncheckedUpdateInput>
  }

  /**
   * NotificationPreference delete
   */
  export type NotificationPreferenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Filter which NotificationPreference to delete.
     */
    where: NotificationPreferenceWhereUniqueInput
  }

  /**
   * NotificationPreference deleteMany
   */
  export type NotificationPreferenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationPreferences to delete
     */
    where?: NotificationPreferenceWhereInput
    /**
     * Limit how many NotificationPreferences to delete.
     */
    limit?: number
  }

  /**
   * NotificationPreference without action
   */
  export type NotificationPreferenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
  }


  /**
   * Model NotificationLog
   */

  export type AggregateNotificationLog = {
    _count: NotificationLogCountAggregateOutputType | null
    _min: NotificationLogMinAggregateOutputType | null
    _max: NotificationLogMaxAggregateOutputType | null
  }

  export type NotificationLogMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    type: string | null
    recipientType: string | null
    recipientId: string | null
    title: string | null
    body: string | null
    channel: string | null
    status: string | null
    error: string | null
    sentAt: Date | null
    createdAt: Date | null
  }

  export type NotificationLogMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    type: string | null
    recipientType: string | null
    recipientId: string | null
    title: string | null
    body: string | null
    channel: string | null
    status: string | null
    error: string | null
    sentAt: Date | null
    createdAt: Date | null
  }

  export type NotificationLogCountAggregateOutputType = {
    id: number
    tenantId: number
    type: number
    recipientType: number
    recipientId: number
    title: number
    body: number
    data: number
    channel: number
    status: number
    error: number
    sentAt: number
    createdAt: number
    _all: number
  }


  export type NotificationLogMinAggregateInputType = {
    id?: true
    tenantId?: true
    type?: true
    recipientType?: true
    recipientId?: true
    title?: true
    body?: true
    channel?: true
    status?: true
    error?: true
    sentAt?: true
    createdAt?: true
  }

  export type NotificationLogMaxAggregateInputType = {
    id?: true
    tenantId?: true
    type?: true
    recipientType?: true
    recipientId?: true
    title?: true
    body?: true
    channel?: true
    status?: true
    error?: true
    sentAt?: true
    createdAt?: true
  }

  export type NotificationLogCountAggregateInputType = {
    id?: true
    tenantId?: true
    type?: true
    recipientType?: true
    recipientId?: true
    title?: true
    body?: true
    data?: true
    channel?: true
    status?: true
    error?: true
    sentAt?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationLog to aggregate.
     */
    where?: NotificationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationLogs to fetch.
     */
    orderBy?: NotificationLogOrderByWithRelationInput | NotificationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationLogs
    **/
    _count?: true | NotificationLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationLogMaxAggregateInputType
  }

  export type GetNotificationLogAggregateType<T extends NotificationLogAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationLog[P]>
      : GetScalarType<T[P], AggregateNotificationLog[P]>
  }




  export type NotificationLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationLogWhereInput
    orderBy?: NotificationLogOrderByWithAggregationInput | NotificationLogOrderByWithAggregationInput[]
    by: NotificationLogScalarFieldEnum[] | NotificationLogScalarFieldEnum
    having?: NotificationLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationLogCountAggregateInputType | true
    _min?: NotificationLogMinAggregateInputType
    _max?: NotificationLogMaxAggregateInputType
  }

  export type NotificationLogGroupByOutputType = {
    id: string
    tenantId: string
    type: string
    recipientType: string
    recipientId: string
    title: string
    body: string
    data: JsonValue | null
    channel: string
    status: string
    error: string | null
    sentAt: Date | null
    createdAt: Date
    _count: NotificationLogCountAggregateOutputType | null
    _min: NotificationLogMinAggregateOutputType | null
    _max: NotificationLogMaxAggregateOutputType | null
  }

  type GetNotificationLogGroupByPayload<T extends NotificationLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationLogGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationLogGroupByOutputType[P]>
        }
      >
    >


  export type NotificationLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    type?: boolean
    recipientType?: boolean
    recipientId?: boolean
    title?: boolean
    body?: boolean
    data?: boolean
    channel?: boolean
    status?: boolean
    error?: boolean
    sentAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["notificationLog"]>

  export type NotificationLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    type?: boolean
    recipientType?: boolean
    recipientId?: boolean
    title?: boolean
    body?: boolean
    data?: boolean
    channel?: boolean
    status?: boolean
    error?: boolean
    sentAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["notificationLog"]>

  export type NotificationLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    type?: boolean
    recipientType?: boolean
    recipientId?: boolean
    title?: boolean
    body?: boolean
    data?: boolean
    channel?: boolean
    status?: boolean
    error?: boolean
    sentAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["notificationLog"]>

  export type NotificationLogSelectScalar = {
    id?: boolean
    tenantId?: boolean
    type?: boolean
    recipientType?: boolean
    recipientId?: boolean
    title?: boolean
    body?: boolean
    data?: boolean
    channel?: boolean
    status?: boolean
    error?: boolean
    sentAt?: boolean
    createdAt?: boolean
  }

  export type NotificationLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "type" | "recipientType" | "recipientId" | "title" | "body" | "data" | "channel" | "status" | "error" | "sentAt" | "createdAt", ExtArgs["result"]["notificationLog"]>

  export type $NotificationLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      type: string
      recipientType: string
      recipientId: string
      title: string
      body: string
      data: Prisma.JsonValue | null
      channel: string
      status: string
      error: string | null
      sentAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["notificationLog"]>
    composites: {}
  }

  type NotificationLogGetPayload<S extends boolean | null | undefined | NotificationLogDefaultArgs> = $Result.GetResult<Prisma.$NotificationLogPayload, S>

  type NotificationLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationLogCountAggregateInputType | true
    }

  export interface NotificationLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationLog'], meta: { name: 'NotificationLog' } }
    /**
     * Find zero or one NotificationLog that matches the filter.
     * @param {NotificationLogFindUniqueArgs} args - Arguments to find a NotificationLog
     * @example
     * // Get one NotificationLog
     * const notificationLog = await prisma.notificationLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationLogFindUniqueArgs>(args: SelectSubset<T, NotificationLogFindUniqueArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NotificationLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationLogFindUniqueOrThrowArgs} args - Arguments to find a NotificationLog
     * @example
     * // Get one NotificationLog
     * const notificationLog = await prisma.notificationLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationLogFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogFindFirstArgs} args - Arguments to find a NotificationLog
     * @example
     * // Get one NotificationLog
     * const notificationLog = await prisma.notificationLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationLogFindFirstArgs>(args?: SelectSubset<T, NotificationLogFindFirstArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogFindFirstOrThrowArgs} args - Arguments to find a NotificationLog
     * @example
     * // Get one NotificationLog
     * const notificationLog = await prisma.notificationLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationLogFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NotificationLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationLogs
     * const notificationLogs = await prisma.notificationLog.findMany()
     * 
     * // Get first 10 NotificationLogs
     * const notificationLogs = await prisma.notificationLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationLogWithIdOnly = await prisma.notificationLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationLogFindManyArgs>(args?: SelectSubset<T, NotificationLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NotificationLog.
     * @param {NotificationLogCreateArgs} args - Arguments to create a NotificationLog.
     * @example
     * // Create one NotificationLog
     * const NotificationLog = await prisma.notificationLog.create({
     *   data: {
     *     // ... data to create a NotificationLog
     *   }
     * })
     * 
     */
    create<T extends NotificationLogCreateArgs>(args: SelectSubset<T, NotificationLogCreateArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NotificationLogs.
     * @param {NotificationLogCreateManyArgs} args - Arguments to create many NotificationLogs.
     * @example
     * // Create many NotificationLogs
     * const notificationLog = await prisma.notificationLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationLogCreateManyArgs>(args?: SelectSubset<T, NotificationLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationLogs and returns the data saved in the database.
     * @param {NotificationLogCreateManyAndReturnArgs} args - Arguments to create many NotificationLogs.
     * @example
     * // Create many NotificationLogs
     * const notificationLog = await prisma.notificationLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationLogs and only return the `id`
     * const notificationLogWithIdOnly = await prisma.notificationLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationLogCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NotificationLog.
     * @param {NotificationLogDeleteArgs} args - Arguments to delete one NotificationLog.
     * @example
     * // Delete one NotificationLog
     * const NotificationLog = await prisma.notificationLog.delete({
     *   where: {
     *     // ... filter to delete one NotificationLog
     *   }
     * })
     * 
     */
    delete<T extends NotificationLogDeleteArgs>(args: SelectSubset<T, NotificationLogDeleteArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NotificationLog.
     * @param {NotificationLogUpdateArgs} args - Arguments to update one NotificationLog.
     * @example
     * // Update one NotificationLog
     * const notificationLog = await prisma.notificationLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationLogUpdateArgs>(args: SelectSubset<T, NotificationLogUpdateArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NotificationLogs.
     * @param {NotificationLogDeleteManyArgs} args - Arguments to filter NotificationLogs to delete.
     * @example
     * // Delete a few NotificationLogs
     * const { count } = await prisma.notificationLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationLogDeleteManyArgs>(args?: SelectSubset<T, NotificationLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationLogs
     * const notificationLog = await prisma.notificationLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationLogUpdateManyArgs>(args: SelectSubset<T, NotificationLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationLogs and returns the data updated in the database.
     * @param {NotificationLogUpdateManyAndReturnArgs} args - Arguments to update many NotificationLogs.
     * @example
     * // Update many NotificationLogs
     * const notificationLog = await prisma.notificationLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NotificationLogs and only return the `id`
     * const notificationLogWithIdOnly = await prisma.notificationLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationLogUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NotificationLog.
     * @param {NotificationLogUpsertArgs} args - Arguments to update or create a NotificationLog.
     * @example
     * // Update or create a NotificationLog
     * const notificationLog = await prisma.notificationLog.upsert({
     *   create: {
     *     // ... data to create a NotificationLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationLog we want to update
     *   }
     * })
     */
    upsert<T extends NotificationLogUpsertArgs>(args: SelectSubset<T, NotificationLogUpsertArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NotificationLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogCountArgs} args - Arguments to filter NotificationLogs to count.
     * @example
     * // Count the number of NotificationLogs
     * const count = await prisma.notificationLog.count({
     *   where: {
     *     // ... the filter for the NotificationLogs we want to count
     *   }
     * })
    **/
    count<T extends NotificationLogCountArgs>(
      args?: Subset<T, NotificationLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationLogAggregateArgs>(args: Subset<T, NotificationLogAggregateArgs>): Prisma.PrismaPromise<GetNotificationLogAggregateType<T>>

    /**
     * Group by NotificationLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationLogGroupByArgs['orderBy'] }
        : { orderBy?: NotificationLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationLog model
   */
  readonly fields: NotificationLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationLog model
   */
  interface NotificationLogFieldRefs {
    readonly id: FieldRef<"NotificationLog", 'String'>
    readonly tenantId: FieldRef<"NotificationLog", 'String'>
    readonly type: FieldRef<"NotificationLog", 'String'>
    readonly recipientType: FieldRef<"NotificationLog", 'String'>
    readonly recipientId: FieldRef<"NotificationLog", 'String'>
    readonly title: FieldRef<"NotificationLog", 'String'>
    readonly body: FieldRef<"NotificationLog", 'String'>
    readonly data: FieldRef<"NotificationLog", 'Json'>
    readonly channel: FieldRef<"NotificationLog", 'String'>
    readonly status: FieldRef<"NotificationLog", 'String'>
    readonly error: FieldRef<"NotificationLog", 'String'>
    readonly sentAt: FieldRef<"NotificationLog", 'DateTime'>
    readonly createdAt: FieldRef<"NotificationLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NotificationLog findUnique
   */
  export type NotificationLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * Filter, which NotificationLog to fetch.
     */
    where: NotificationLogWhereUniqueInput
  }

  /**
   * NotificationLog findUniqueOrThrow
   */
  export type NotificationLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * Filter, which NotificationLog to fetch.
     */
    where: NotificationLogWhereUniqueInput
  }

  /**
   * NotificationLog findFirst
   */
  export type NotificationLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * Filter, which NotificationLog to fetch.
     */
    where?: NotificationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationLogs to fetch.
     */
    orderBy?: NotificationLogOrderByWithRelationInput | NotificationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationLogs.
     */
    cursor?: NotificationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationLogs.
     */
    distinct?: NotificationLogScalarFieldEnum | NotificationLogScalarFieldEnum[]
  }

  /**
   * NotificationLog findFirstOrThrow
   */
  export type NotificationLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * Filter, which NotificationLog to fetch.
     */
    where?: NotificationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationLogs to fetch.
     */
    orderBy?: NotificationLogOrderByWithRelationInput | NotificationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationLogs.
     */
    cursor?: NotificationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationLogs.
     */
    distinct?: NotificationLogScalarFieldEnum | NotificationLogScalarFieldEnum[]
  }

  /**
   * NotificationLog findMany
   */
  export type NotificationLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * Filter, which NotificationLogs to fetch.
     */
    where?: NotificationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationLogs to fetch.
     */
    orderBy?: NotificationLogOrderByWithRelationInput | NotificationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationLogs.
     */
    cursor?: NotificationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationLogs.
     */
    skip?: number
    distinct?: NotificationLogScalarFieldEnum | NotificationLogScalarFieldEnum[]
  }

  /**
   * NotificationLog create
   */
  export type NotificationLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * The data needed to create a NotificationLog.
     */
    data: XOR<NotificationLogCreateInput, NotificationLogUncheckedCreateInput>
  }

  /**
   * NotificationLog createMany
   */
  export type NotificationLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationLogs.
     */
    data: NotificationLogCreateManyInput | NotificationLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationLog createManyAndReturn
   */
  export type NotificationLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * The data used to create many NotificationLogs.
     */
    data: NotificationLogCreateManyInput | NotificationLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationLog update
   */
  export type NotificationLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * The data needed to update a NotificationLog.
     */
    data: XOR<NotificationLogUpdateInput, NotificationLogUncheckedUpdateInput>
    /**
     * Choose, which NotificationLog to update.
     */
    where: NotificationLogWhereUniqueInput
  }

  /**
   * NotificationLog updateMany
   */
  export type NotificationLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationLogs.
     */
    data: XOR<NotificationLogUpdateManyMutationInput, NotificationLogUncheckedUpdateManyInput>
    /**
     * Filter which NotificationLogs to update
     */
    where?: NotificationLogWhereInput
    /**
     * Limit how many NotificationLogs to update.
     */
    limit?: number
  }

  /**
   * NotificationLog updateManyAndReturn
   */
  export type NotificationLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * The data used to update NotificationLogs.
     */
    data: XOR<NotificationLogUpdateManyMutationInput, NotificationLogUncheckedUpdateManyInput>
    /**
     * Filter which NotificationLogs to update
     */
    where?: NotificationLogWhereInput
    /**
     * Limit how many NotificationLogs to update.
     */
    limit?: number
  }

  /**
   * NotificationLog upsert
   */
  export type NotificationLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * The filter to search for the NotificationLog to update in case it exists.
     */
    where: NotificationLogWhereUniqueInput
    /**
     * In case the NotificationLog found by the `where` argument doesn't exist, create a new NotificationLog with this data.
     */
    create: XOR<NotificationLogCreateInput, NotificationLogUncheckedCreateInput>
    /**
     * In case the NotificationLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationLogUpdateInput, NotificationLogUncheckedUpdateInput>
  }

  /**
   * NotificationLog delete
   */
  export type NotificationLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * Filter which NotificationLog to delete.
     */
    where: NotificationLogWhereUniqueInput
  }

  /**
   * NotificationLog deleteMany
   */
  export type NotificationLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationLogs to delete
     */
    where?: NotificationLogWhereInput
    /**
     * Limit how many NotificationLogs to delete.
     */
    limit?: number
  }

  /**
   * NotificationLog without action
   */
  export type NotificationLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
  }


  /**
   * Model CalendarIntegration
   */

  export type AggregateCalendarIntegration = {
    _count: CalendarIntegrationCountAggregateOutputType | null
    _min: CalendarIntegrationMinAggregateOutputType | null
    _max: CalendarIntegrationMaxAggregateOutputType | null
  }

  export type CalendarIntegrationMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    provider: string | null
    accessToken: string | null
    refreshToken: string | null
    tokenExpiry: Date | null
    calendarId: string | null
    calendarEmail: string | null
    syncEnabled: boolean | null
    syncDirection: string | null
    lastSyncAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CalendarIntegrationMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    provider: string | null
    accessToken: string | null
    refreshToken: string | null
    tokenExpiry: Date | null
    calendarId: string | null
    calendarEmail: string | null
    syncEnabled: boolean | null
    syncDirection: string | null
    lastSyncAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CalendarIntegrationCountAggregateOutputType = {
    id: number
    tenantId: number
    userId: number
    provider: number
    accessToken: number
    refreshToken: number
    tokenExpiry: number
    calendarId: number
    calendarEmail: number
    syncEnabled: number
    syncDirection: number
    lastSyncAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CalendarIntegrationMinAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    provider?: true
    accessToken?: true
    refreshToken?: true
    tokenExpiry?: true
    calendarId?: true
    calendarEmail?: true
    syncEnabled?: true
    syncDirection?: true
    lastSyncAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CalendarIntegrationMaxAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    provider?: true
    accessToken?: true
    refreshToken?: true
    tokenExpiry?: true
    calendarId?: true
    calendarEmail?: true
    syncEnabled?: true
    syncDirection?: true
    lastSyncAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CalendarIntegrationCountAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    provider?: true
    accessToken?: true
    refreshToken?: true
    tokenExpiry?: true
    calendarId?: true
    calendarEmail?: true
    syncEnabled?: true
    syncDirection?: true
    lastSyncAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CalendarIntegrationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CalendarIntegration to aggregate.
     */
    where?: CalendarIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarIntegrations to fetch.
     */
    orderBy?: CalendarIntegrationOrderByWithRelationInput | CalendarIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CalendarIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarIntegrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CalendarIntegrations
    **/
    _count?: true | CalendarIntegrationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CalendarIntegrationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CalendarIntegrationMaxAggregateInputType
  }

  export type GetCalendarIntegrationAggregateType<T extends CalendarIntegrationAggregateArgs> = {
        [P in keyof T & keyof AggregateCalendarIntegration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCalendarIntegration[P]>
      : GetScalarType<T[P], AggregateCalendarIntegration[P]>
  }




  export type CalendarIntegrationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalendarIntegrationWhereInput
    orderBy?: CalendarIntegrationOrderByWithAggregationInput | CalendarIntegrationOrderByWithAggregationInput[]
    by: CalendarIntegrationScalarFieldEnum[] | CalendarIntegrationScalarFieldEnum
    having?: CalendarIntegrationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CalendarIntegrationCountAggregateInputType | true
    _min?: CalendarIntegrationMinAggregateInputType
    _max?: CalendarIntegrationMaxAggregateInputType
  }

  export type CalendarIntegrationGroupByOutputType = {
    id: string
    tenantId: string
    userId: string
    provider: string
    accessToken: string | null
    refreshToken: string | null
    tokenExpiry: Date | null
    calendarId: string | null
    calendarEmail: string | null
    syncEnabled: boolean
    syncDirection: string
    lastSyncAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: CalendarIntegrationCountAggregateOutputType | null
    _min: CalendarIntegrationMinAggregateOutputType | null
    _max: CalendarIntegrationMaxAggregateOutputType | null
  }

  type GetCalendarIntegrationGroupByPayload<T extends CalendarIntegrationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CalendarIntegrationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CalendarIntegrationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CalendarIntegrationGroupByOutputType[P]>
            : GetScalarType<T[P], CalendarIntegrationGroupByOutputType[P]>
        }
      >
    >


  export type CalendarIntegrationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    provider?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    tokenExpiry?: boolean
    calendarId?: boolean
    calendarEmail?: boolean
    syncEnabled?: boolean
    syncDirection?: boolean
    lastSyncAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    eventSyncs?: boolean | CalendarIntegration$eventSyncsArgs<ExtArgs>
    _count?: boolean | CalendarIntegrationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["calendarIntegration"]>

  export type CalendarIntegrationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    provider?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    tokenExpiry?: boolean
    calendarId?: boolean
    calendarEmail?: boolean
    syncEnabled?: boolean
    syncDirection?: boolean
    lastSyncAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["calendarIntegration"]>

  export type CalendarIntegrationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    provider?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    tokenExpiry?: boolean
    calendarId?: boolean
    calendarEmail?: boolean
    syncEnabled?: boolean
    syncDirection?: boolean
    lastSyncAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["calendarIntegration"]>

  export type CalendarIntegrationSelectScalar = {
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    provider?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    tokenExpiry?: boolean
    calendarId?: boolean
    calendarEmail?: boolean
    syncEnabled?: boolean
    syncDirection?: boolean
    lastSyncAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CalendarIntegrationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "userId" | "provider" | "accessToken" | "refreshToken" | "tokenExpiry" | "calendarId" | "calendarEmail" | "syncEnabled" | "syncDirection" | "lastSyncAt" | "createdAt" | "updatedAt", ExtArgs["result"]["calendarIntegration"]>
  export type CalendarIntegrationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    eventSyncs?: boolean | CalendarIntegration$eventSyncsArgs<ExtArgs>
    _count?: boolean | CalendarIntegrationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CalendarIntegrationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CalendarIntegrationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CalendarIntegrationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CalendarIntegration"
    objects: {
      eventSyncs: Prisma.$CalendarEventSyncPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      userId: string
      provider: string
      accessToken: string | null
      refreshToken: string | null
      tokenExpiry: Date | null
      calendarId: string | null
      calendarEmail: string | null
      syncEnabled: boolean
      syncDirection: string
      lastSyncAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["calendarIntegration"]>
    composites: {}
  }

  type CalendarIntegrationGetPayload<S extends boolean | null | undefined | CalendarIntegrationDefaultArgs> = $Result.GetResult<Prisma.$CalendarIntegrationPayload, S>

  type CalendarIntegrationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CalendarIntegrationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CalendarIntegrationCountAggregateInputType | true
    }

  export interface CalendarIntegrationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CalendarIntegration'], meta: { name: 'CalendarIntegration' } }
    /**
     * Find zero or one CalendarIntegration that matches the filter.
     * @param {CalendarIntegrationFindUniqueArgs} args - Arguments to find a CalendarIntegration
     * @example
     * // Get one CalendarIntegration
     * const calendarIntegration = await prisma.calendarIntegration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CalendarIntegrationFindUniqueArgs>(args: SelectSubset<T, CalendarIntegrationFindUniqueArgs<ExtArgs>>): Prisma__CalendarIntegrationClient<$Result.GetResult<Prisma.$CalendarIntegrationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CalendarIntegration that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CalendarIntegrationFindUniqueOrThrowArgs} args - Arguments to find a CalendarIntegration
     * @example
     * // Get one CalendarIntegration
     * const calendarIntegration = await prisma.calendarIntegration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CalendarIntegrationFindUniqueOrThrowArgs>(args: SelectSubset<T, CalendarIntegrationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CalendarIntegrationClient<$Result.GetResult<Prisma.$CalendarIntegrationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CalendarIntegration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarIntegrationFindFirstArgs} args - Arguments to find a CalendarIntegration
     * @example
     * // Get one CalendarIntegration
     * const calendarIntegration = await prisma.calendarIntegration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CalendarIntegrationFindFirstArgs>(args?: SelectSubset<T, CalendarIntegrationFindFirstArgs<ExtArgs>>): Prisma__CalendarIntegrationClient<$Result.GetResult<Prisma.$CalendarIntegrationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CalendarIntegration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarIntegrationFindFirstOrThrowArgs} args - Arguments to find a CalendarIntegration
     * @example
     * // Get one CalendarIntegration
     * const calendarIntegration = await prisma.calendarIntegration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CalendarIntegrationFindFirstOrThrowArgs>(args?: SelectSubset<T, CalendarIntegrationFindFirstOrThrowArgs<ExtArgs>>): Prisma__CalendarIntegrationClient<$Result.GetResult<Prisma.$CalendarIntegrationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CalendarIntegrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarIntegrationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CalendarIntegrations
     * const calendarIntegrations = await prisma.calendarIntegration.findMany()
     * 
     * // Get first 10 CalendarIntegrations
     * const calendarIntegrations = await prisma.calendarIntegration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const calendarIntegrationWithIdOnly = await prisma.calendarIntegration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CalendarIntegrationFindManyArgs>(args?: SelectSubset<T, CalendarIntegrationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarIntegrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CalendarIntegration.
     * @param {CalendarIntegrationCreateArgs} args - Arguments to create a CalendarIntegration.
     * @example
     * // Create one CalendarIntegration
     * const CalendarIntegration = await prisma.calendarIntegration.create({
     *   data: {
     *     // ... data to create a CalendarIntegration
     *   }
     * })
     * 
     */
    create<T extends CalendarIntegrationCreateArgs>(args: SelectSubset<T, CalendarIntegrationCreateArgs<ExtArgs>>): Prisma__CalendarIntegrationClient<$Result.GetResult<Prisma.$CalendarIntegrationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CalendarIntegrations.
     * @param {CalendarIntegrationCreateManyArgs} args - Arguments to create many CalendarIntegrations.
     * @example
     * // Create many CalendarIntegrations
     * const calendarIntegration = await prisma.calendarIntegration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CalendarIntegrationCreateManyArgs>(args?: SelectSubset<T, CalendarIntegrationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CalendarIntegrations and returns the data saved in the database.
     * @param {CalendarIntegrationCreateManyAndReturnArgs} args - Arguments to create many CalendarIntegrations.
     * @example
     * // Create many CalendarIntegrations
     * const calendarIntegration = await prisma.calendarIntegration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CalendarIntegrations and only return the `id`
     * const calendarIntegrationWithIdOnly = await prisma.calendarIntegration.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CalendarIntegrationCreateManyAndReturnArgs>(args?: SelectSubset<T, CalendarIntegrationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarIntegrationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CalendarIntegration.
     * @param {CalendarIntegrationDeleteArgs} args - Arguments to delete one CalendarIntegration.
     * @example
     * // Delete one CalendarIntegration
     * const CalendarIntegration = await prisma.calendarIntegration.delete({
     *   where: {
     *     // ... filter to delete one CalendarIntegration
     *   }
     * })
     * 
     */
    delete<T extends CalendarIntegrationDeleteArgs>(args: SelectSubset<T, CalendarIntegrationDeleteArgs<ExtArgs>>): Prisma__CalendarIntegrationClient<$Result.GetResult<Prisma.$CalendarIntegrationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CalendarIntegration.
     * @param {CalendarIntegrationUpdateArgs} args - Arguments to update one CalendarIntegration.
     * @example
     * // Update one CalendarIntegration
     * const calendarIntegration = await prisma.calendarIntegration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CalendarIntegrationUpdateArgs>(args: SelectSubset<T, CalendarIntegrationUpdateArgs<ExtArgs>>): Prisma__CalendarIntegrationClient<$Result.GetResult<Prisma.$CalendarIntegrationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CalendarIntegrations.
     * @param {CalendarIntegrationDeleteManyArgs} args - Arguments to filter CalendarIntegrations to delete.
     * @example
     * // Delete a few CalendarIntegrations
     * const { count } = await prisma.calendarIntegration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CalendarIntegrationDeleteManyArgs>(args?: SelectSubset<T, CalendarIntegrationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CalendarIntegrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarIntegrationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CalendarIntegrations
     * const calendarIntegration = await prisma.calendarIntegration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CalendarIntegrationUpdateManyArgs>(args: SelectSubset<T, CalendarIntegrationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CalendarIntegrations and returns the data updated in the database.
     * @param {CalendarIntegrationUpdateManyAndReturnArgs} args - Arguments to update many CalendarIntegrations.
     * @example
     * // Update many CalendarIntegrations
     * const calendarIntegration = await prisma.calendarIntegration.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CalendarIntegrations and only return the `id`
     * const calendarIntegrationWithIdOnly = await prisma.calendarIntegration.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CalendarIntegrationUpdateManyAndReturnArgs>(args: SelectSubset<T, CalendarIntegrationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarIntegrationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CalendarIntegration.
     * @param {CalendarIntegrationUpsertArgs} args - Arguments to update or create a CalendarIntegration.
     * @example
     * // Update or create a CalendarIntegration
     * const calendarIntegration = await prisma.calendarIntegration.upsert({
     *   create: {
     *     // ... data to create a CalendarIntegration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CalendarIntegration we want to update
     *   }
     * })
     */
    upsert<T extends CalendarIntegrationUpsertArgs>(args: SelectSubset<T, CalendarIntegrationUpsertArgs<ExtArgs>>): Prisma__CalendarIntegrationClient<$Result.GetResult<Prisma.$CalendarIntegrationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CalendarIntegrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarIntegrationCountArgs} args - Arguments to filter CalendarIntegrations to count.
     * @example
     * // Count the number of CalendarIntegrations
     * const count = await prisma.calendarIntegration.count({
     *   where: {
     *     // ... the filter for the CalendarIntegrations we want to count
     *   }
     * })
    **/
    count<T extends CalendarIntegrationCountArgs>(
      args?: Subset<T, CalendarIntegrationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CalendarIntegrationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CalendarIntegration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarIntegrationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CalendarIntegrationAggregateArgs>(args: Subset<T, CalendarIntegrationAggregateArgs>): Prisma.PrismaPromise<GetCalendarIntegrationAggregateType<T>>

    /**
     * Group by CalendarIntegration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarIntegrationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CalendarIntegrationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CalendarIntegrationGroupByArgs['orderBy'] }
        : { orderBy?: CalendarIntegrationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CalendarIntegrationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCalendarIntegrationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CalendarIntegration model
   */
  readonly fields: CalendarIntegrationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CalendarIntegration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CalendarIntegrationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    eventSyncs<T extends CalendarIntegration$eventSyncsArgs<ExtArgs> = {}>(args?: Subset<T, CalendarIntegration$eventSyncsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarEventSyncPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CalendarIntegration model
   */
  interface CalendarIntegrationFieldRefs {
    readonly id: FieldRef<"CalendarIntegration", 'String'>
    readonly tenantId: FieldRef<"CalendarIntegration", 'String'>
    readonly userId: FieldRef<"CalendarIntegration", 'String'>
    readonly provider: FieldRef<"CalendarIntegration", 'String'>
    readonly accessToken: FieldRef<"CalendarIntegration", 'String'>
    readonly refreshToken: FieldRef<"CalendarIntegration", 'String'>
    readonly tokenExpiry: FieldRef<"CalendarIntegration", 'DateTime'>
    readonly calendarId: FieldRef<"CalendarIntegration", 'String'>
    readonly calendarEmail: FieldRef<"CalendarIntegration", 'String'>
    readonly syncEnabled: FieldRef<"CalendarIntegration", 'Boolean'>
    readonly syncDirection: FieldRef<"CalendarIntegration", 'String'>
    readonly lastSyncAt: FieldRef<"CalendarIntegration", 'DateTime'>
    readonly createdAt: FieldRef<"CalendarIntegration", 'DateTime'>
    readonly updatedAt: FieldRef<"CalendarIntegration", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CalendarIntegration findUnique
   */
  export type CalendarIntegrationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarIntegration
     */
    select?: CalendarIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarIntegration
     */
    omit?: CalendarIntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarIntegrationInclude<ExtArgs> | null
    /**
     * Filter, which CalendarIntegration to fetch.
     */
    where: CalendarIntegrationWhereUniqueInput
  }

  /**
   * CalendarIntegration findUniqueOrThrow
   */
  export type CalendarIntegrationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarIntegration
     */
    select?: CalendarIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarIntegration
     */
    omit?: CalendarIntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarIntegrationInclude<ExtArgs> | null
    /**
     * Filter, which CalendarIntegration to fetch.
     */
    where: CalendarIntegrationWhereUniqueInput
  }

  /**
   * CalendarIntegration findFirst
   */
  export type CalendarIntegrationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarIntegration
     */
    select?: CalendarIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarIntegration
     */
    omit?: CalendarIntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarIntegrationInclude<ExtArgs> | null
    /**
     * Filter, which CalendarIntegration to fetch.
     */
    where?: CalendarIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarIntegrations to fetch.
     */
    orderBy?: CalendarIntegrationOrderByWithRelationInput | CalendarIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CalendarIntegrations.
     */
    cursor?: CalendarIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarIntegrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CalendarIntegrations.
     */
    distinct?: CalendarIntegrationScalarFieldEnum | CalendarIntegrationScalarFieldEnum[]
  }

  /**
   * CalendarIntegration findFirstOrThrow
   */
  export type CalendarIntegrationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarIntegration
     */
    select?: CalendarIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarIntegration
     */
    omit?: CalendarIntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarIntegrationInclude<ExtArgs> | null
    /**
     * Filter, which CalendarIntegration to fetch.
     */
    where?: CalendarIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarIntegrations to fetch.
     */
    orderBy?: CalendarIntegrationOrderByWithRelationInput | CalendarIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CalendarIntegrations.
     */
    cursor?: CalendarIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarIntegrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CalendarIntegrations.
     */
    distinct?: CalendarIntegrationScalarFieldEnum | CalendarIntegrationScalarFieldEnum[]
  }

  /**
   * CalendarIntegration findMany
   */
  export type CalendarIntegrationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarIntegration
     */
    select?: CalendarIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarIntegration
     */
    omit?: CalendarIntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarIntegrationInclude<ExtArgs> | null
    /**
     * Filter, which CalendarIntegrations to fetch.
     */
    where?: CalendarIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarIntegrations to fetch.
     */
    orderBy?: CalendarIntegrationOrderByWithRelationInput | CalendarIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CalendarIntegrations.
     */
    cursor?: CalendarIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarIntegrations.
     */
    skip?: number
    distinct?: CalendarIntegrationScalarFieldEnum | CalendarIntegrationScalarFieldEnum[]
  }

  /**
   * CalendarIntegration create
   */
  export type CalendarIntegrationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarIntegration
     */
    select?: CalendarIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarIntegration
     */
    omit?: CalendarIntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarIntegrationInclude<ExtArgs> | null
    /**
     * The data needed to create a CalendarIntegration.
     */
    data: XOR<CalendarIntegrationCreateInput, CalendarIntegrationUncheckedCreateInput>
  }

  /**
   * CalendarIntegration createMany
   */
  export type CalendarIntegrationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CalendarIntegrations.
     */
    data: CalendarIntegrationCreateManyInput | CalendarIntegrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CalendarIntegration createManyAndReturn
   */
  export type CalendarIntegrationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarIntegration
     */
    select?: CalendarIntegrationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarIntegration
     */
    omit?: CalendarIntegrationOmit<ExtArgs> | null
    /**
     * The data used to create many CalendarIntegrations.
     */
    data: CalendarIntegrationCreateManyInput | CalendarIntegrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CalendarIntegration update
   */
  export type CalendarIntegrationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarIntegration
     */
    select?: CalendarIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarIntegration
     */
    omit?: CalendarIntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarIntegrationInclude<ExtArgs> | null
    /**
     * The data needed to update a CalendarIntegration.
     */
    data: XOR<CalendarIntegrationUpdateInput, CalendarIntegrationUncheckedUpdateInput>
    /**
     * Choose, which CalendarIntegration to update.
     */
    where: CalendarIntegrationWhereUniqueInput
  }

  /**
   * CalendarIntegration updateMany
   */
  export type CalendarIntegrationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CalendarIntegrations.
     */
    data: XOR<CalendarIntegrationUpdateManyMutationInput, CalendarIntegrationUncheckedUpdateManyInput>
    /**
     * Filter which CalendarIntegrations to update
     */
    where?: CalendarIntegrationWhereInput
    /**
     * Limit how many CalendarIntegrations to update.
     */
    limit?: number
  }

  /**
   * CalendarIntegration updateManyAndReturn
   */
  export type CalendarIntegrationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarIntegration
     */
    select?: CalendarIntegrationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarIntegration
     */
    omit?: CalendarIntegrationOmit<ExtArgs> | null
    /**
     * The data used to update CalendarIntegrations.
     */
    data: XOR<CalendarIntegrationUpdateManyMutationInput, CalendarIntegrationUncheckedUpdateManyInput>
    /**
     * Filter which CalendarIntegrations to update
     */
    where?: CalendarIntegrationWhereInput
    /**
     * Limit how many CalendarIntegrations to update.
     */
    limit?: number
  }

  /**
   * CalendarIntegration upsert
   */
  export type CalendarIntegrationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarIntegration
     */
    select?: CalendarIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarIntegration
     */
    omit?: CalendarIntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarIntegrationInclude<ExtArgs> | null
    /**
     * The filter to search for the CalendarIntegration to update in case it exists.
     */
    where: CalendarIntegrationWhereUniqueInput
    /**
     * In case the CalendarIntegration found by the `where` argument doesn't exist, create a new CalendarIntegration with this data.
     */
    create: XOR<CalendarIntegrationCreateInput, CalendarIntegrationUncheckedCreateInput>
    /**
     * In case the CalendarIntegration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CalendarIntegrationUpdateInput, CalendarIntegrationUncheckedUpdateInput>
  }

  /**
   * CalendarIntegration delete
   */
  export type CalendarIntegrationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarIntegration
     */
    select?: CalendarIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarIntegration
     */
    omit?: CalendarIntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarIntegrationInclude<ExtArgs> | null
    /**
     * Filter which CalendarIntegration to delete.
     */
    where: CalendarIntegrationWhereUniqueInput
  }

  /**
   * CalendarIntegration deleteMany
   */
  export type CalendarIntegrationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CalendarIntegrations to delete
     */
    where?: CalendarIntegrationWhereInput
    /**
     * Limit how many CalendarIntegrations to delete.
     */
    limit?: number
  }

  /**
   * CalendarIntegration.eventSyncs
   */
  export type CalendarIntegration$eventSyncsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEventSync
     */
    select?: CalendarEventSyncSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEventSync
     */
    omit?: CalendarEventSyncOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventSyncInclude<ExtArgs> | null
    where?: CalendarEventSyncWhereInput
    orderBy?: CalendarEventSyncOrderByWithRelationInput | CalendarEventSyncOrderByWithRelationInput[]
    cursor?: CalendarEventSyncWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CalendarEventSyncScalarFieldEnum | CalendarEventSyncScalarFieldEnum[]
  }

  /**
   * CalendarIntegration without action
   */
  export type CalendarIntegrationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarIntegration
     */
    select?: CalendarIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarIntegration
     */
    omit?: CalendarIntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarIntegrationInclude<ExtArgs> | null
  }


  /**
   * Model CalendarEventSync
   */

  export type AggregateCalendarEventSync = {
    _count: CalendarEventSyncCountAggregateOutputType | null
    _min: CalendarEventSyncMinAggregateOutputType | null
    _max: CalendarEventSyncMaxAggregateOutputType | null
  }

  export type CalendarEventSyncMinAggregateOutputType = {
    id: string | null
    integrationId: string | null
    entityType: string | null
    entityId: string | null
    externalEventId: string | null
    lastSyncedAt: Date | null
    syncHash: string | null
  }

  export type CalendarEventSyncMaxAggregateOutputType = {
    id: string | null
    integrationId: string | null
    entityType: string | null
    entityId: string | null
    externalEventId: string | null
    lastSyncedAt: Date | null
    syncHash: string | null
  }

  export type CalendarEventSyncCountAggregateOutputType = {
    id: number
    integrationId: number
    entityType: number
    entityId: number
    externalEventId: number
    lastSyncedAt: number
    syncHash: number
    _all: number
  }


  export type CalendarEventSyncMinAggregateInputType = {
    id?: true
    integrationId?: true
    entityType?: true
    entityId?: true
    externalEventId?: true
    lastSyncedAt?: true
    syncHash?: true
  }

  export type CalendarEventSyncMaxAggregateInputType = {
    id?: true
    integrationId?: true
    entityType?: true
    entityId?: true
    externalEventId?: true
    lastSyncedAt?: true
    syncHash?: true
  }

  export type CalendarEventSyncCountAggregateInputType = {
    id?: true
    integrationId?: true
    entityType?: true
    entityId?: true
    externalEventId?: true
    lastSyncedAt?: true
    syncHash?: true
    _all?: true
  }

  export type CalendarEventSyncAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CalendarEventSync to aggregate.
     */
    where?: CalendarEventSyncWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarEventSyncs to fetch.
     */
    orderBy?: CalendarEventSyncOrderByWithRelationInput | CalendarEventSyncOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CalendarEventSyncWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarEventSyncs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarEventSyncs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CalendarEventSyncs
    **/
    _count?: true | CalendarEventSyncCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CalendarEventSyncMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CalendarEventSyncMaxAggregateInputType
  }

  export type GetCalendarEventSyncAggregateType<T extends CalendarEventSyncAggregateArgs> = {
        [P in keyof T & keyof AggregateCalendarEventSync]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCalendarEventSync[P]>
      : GetScalarType<T[P], AggregateCalendarEventSync[P]>
  }




  export type CalendarEventSyncGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalendarEventSyncWhereInput
    orderBy?: CalendarEventSyncOrderByWithAggregationInput | CalendarEventSyncOrderByWithAggregationInput[]
    by: CalendarEventSyncScalarFieldEnum[] | CalendarEventSyncScalarFieldEnum
    having?: CalendarEventSyncScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CalendarEventSyncCountAggregateInputType | true
    _min?: CalendarEventSyncMinAggregateInputType
    _max?: CalendarEventSyncMaxAggregateInputType
  }

  export type CalendarEventSyncGroupByOutputType = {
    id: string
    integrationId: string
    entityType: string
    entityId: string
    externalEventId: string
    lastSyncedAt: Date
    syncHash: string
    _count: CalendarEventSyncCountAggregateOutputType | null
    _min: CalendarEventSyncMinAggregateOutputType | null
    _max: CalendarEventSyncMaxAggregateOutputType | null
  }

  type GetCalendarEventSyncGroupByPayload<T extends CalendarEventSyncGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CalendarEventSyncGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CalendarEventSyncGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CalendarEventSyncGroupByOutputType[P]>
            : GetScalarType<T[P], CalendarEventSyncGroupByOutputType[P]>
        }
      >
    >


  export type CalendarEventSyncSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    integrationId?: boolean
    entityType?: boolean
    entityId?: boolean
    externalEventId?: boolean
    lastSyncedAt?: boolean
    syncHash?: boolean
    integration?: boolean | CalendarIntegrationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["calendarEventSync"]>

  export type CalendarEventSyncSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    integrationId?: boolean
    entityType?: boolean
    entityId?: boolean
    externalEventId?: boolean
    lastSyncedAt?: boolean
    syncHash?: boolean
    integration?: boolean | CalendarIntegrationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["calendarEventSync"]>

  export type CalendarEventSyncSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    integrationId?: boolean
    entityType?: boolean
    entityId?: boolean
    externalEventId?: boolean
    lastSyncedAt?: boolean
    syncHash?: boolean
    integration?: boolean | CalendarIntegrationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["calendarEventSync"]>

  export type CalendarEventSyncSelectScalar = {
    id?: boolean
    integrationId?: boolean
    entityType?: boolean
    entityId?: boolean
    externalEventId?: boolean
    lastSyncedAt?: boolean
    syncHash?: boolean
  }

  export type CalendarEventSyncOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "integrationId" | "entityType" | "entityId" | "externalEventId" | "lastSyncedAt" | "syncHash", ExtArgs["result"]["calendarEventSync"]>
  export type CalendarEventSyncInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    integration?: boolean | CalendarIntegrationDefaultArgs<ExtArgs>
  }
  export type CalendarEventSyncIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    integration?: boolean | CalendarIntegrationDefaultArgs<ExtArgs>
  }
  export type CalendarEventSyncIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    integration?: boolean | CalendarIntegrationDefaultArgs<ExtArgs>
  }

  export type $CalendarEventSyncPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CalendarEventSync"
    objects: {
      integration: Prisma.$CalendarIntegrationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      integrationId: string
      entityType: string
      entityId: string
      externalEventId: string
      lastSyncedAt: Date
      syncHash: string
    }, ExtArgs["result"]["calendarEventSync"]>
    composites: {}
  }

  type CalendarEventSyncGetPayload<S extends boolean | null | undefined | CalendarEventSyncDefaultArgs> = $Result.GetResult<Prisma.$CalendarEventSyncPayload, S>

  type CalendarEventSyncCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CalendarEventSyncFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CalendarEventSyncCountAggregateInputType | true
    }

  export interface CalendarEventSyncDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CalendarEventSync'], meta: { name: 'CalendarEventSync' } }
    /**
     * Find zero or one CalendarEventSync that matches the filter.
     * @param {CalendarEventSyncFindUniqueArgs} args - Arguments to find a CalendarEventSync
     * @example
     * // Get one CalendarEventSync
     * const calendarEventSync = await prisma.calendarEventSync.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CalendarEventSyncFindUniqueArgs>(args: SelectSubset<T, CalendarEventSyncFindUniqueArgs<ExtArgs>>): Prisma__CalendarEventSyncClient<$Result.GetResult<Prisma.$CalendarEventSyncPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CalendarEventSync that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CalendarEventSyncFindUniqueOrThrowArgs} args - Arguments to find a CalendarEventSync
     * @example
     * // Get one CalendarEventSync
     * const calendarEventSync = await prisma.calendarEventSync.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CalendarEventSyncFindUniqueOrThrowArgs>(args: SelectSubset<T, CalendarEventSyncFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CalendarEventSyncClient<$Result.GetResult<Prisma.$CalendarEventSyncPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CalendarEventSync that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventSyncFindFirstArgs} args - Arguments to find a CalendarEventSync
     * @example
     * // Get one CalendarEventSync
     * const calendarEventSync = await prisma.calendarEventSync.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CalendarEventSyncFindFirstArgs>(args?: SelectSubset<T, CalendarEventSyncFindFirstArgs<ExtArgs>>): Prisma__CalendarEventSyncClient<$Result.GetResult<Prisma.$CalendarEventSyncPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CalendarEventSync that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventSyncFindFirstOrThrowArgs} args - Arguments to find a CalendarEventSync
     * @example
     * // Get one CalendarEventSync
     * const calendarEventSync = await prisma.calendarEventSync.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CalendarEventSyncFindFirstOrThrowArgs>(args?: SelectSubset<T, CalendarEventSyncFindFirstOrThrowArgs<ExtArgs>>): Prisma__CalendarEventSyncClient<$Result.GetResult<Prisma.$CalendarEventSyncPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CalendarEventSyncs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventSyncFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CalendarEventSyncs
     * const calendarEventSyncs = await prisma.calendarEventSync.findMany()
     * 
     * // Get first 10 CalendarEventSyncs
     * const calendarEventSyncs = await prisma.calendarEventSync.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const calendarEventSyncWithIdOnly = await prisma.calendarEventSync.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CalendarEventSyncFindManyArgs>(args?: SelectSubset<T, CalendarEventSyncFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarEventSyncPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CalendarEventSync.
     * @param {CalendarEventSyncCreateArgs} args - Arguments to create a CalendarEventSync.
     * @example
     * // Create one CalendarEventSync
     * const CalendarEventSync = await prisma.calendarEventSync.create({
     *   data: {
     *     // ... data to create a CalendarEventSync
     *   }
     * })
     * 
     */
    create<T extends CalendarEventSyncCreateArgs>(args: SelectSubset<T, CalendarEventSyncCreateArgs<ExtArgs>>): Prisma__CalendarEventSyncClient<$Result.GetResult<Prisma.$CalendarEventSyncPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CalendarEventSyncs.
     * @param {CalendarEventSyncCreateManyArgs} args - Arguments to create many CalendarEventSyncs.
     * @example
     * // Create many CalendarEventSyncs
     * const calendarEventSync = await prisma.calendarEventSync.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CalendarEventSyncCreateManyArgs>(args?: SelectSubset<T, CalendarEventSyncCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CalendarEventSyncs and returns the data saved in the database.
     * @param {CalendarEventSyncCreateManyAndReturnArgs} args - Arguments to create many CalendarEventSyncs.
     * @example
     * // Create many CalendarEventSyncs
     * const calendarEventSync = await prisma.calendarEventSync.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CalendarEventSyncs and only return the `id`
     * const calendarEventSyncWithIdOnly = await prisma.calendarEventSync.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CalendarEventSyncCreateManyAndReturnArgs>(args?: SelectSubset<T, CalendarEventSyncCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarEventSyncPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CalendarEventSync.
     * @param {CalendarEventSyncDeleteArgs} args - Arguments to delete one CalendarEventSync.
     * @example
     * // Delete one CalendarEventSync
     * const CalendarEventSync = await prisma.calendarEventSync.delete({
     *   where: {
     *     // ... filter to delete one CalendarEventSync
     *   }
     * })
     * 
     */
    delete<T extends CalendarEventSyncDeleteArgs>(args: SelectSubset<T, CalendarEventSyncDeleteArgs<ExtArgs>>): Prisma__CalendarEventSyncClient<$Result.GetResult<Prisma.$CalendarEventSyncPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CalendarEventSync.
     * @param {CalendarEventSyncUpdateArgs} args - Arguments to update one CalendarEventSync.
     * @example
     * // Update one CalendarEventSync
     * const calendarEventSync = await prisma.calendarEventSync.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CalendarEventSyncUpdateArgs>(args: SelectSubset<T, CalendarEventSyncUpdateArgs<ExtArgs>>): Prisma__CalendarEventSyncClient<$Result.GetResult<Prisma.$CalendarEventSyncPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CalendarEventSyncs.
     * @param {CalendarEventSyncDeleteManyArgs} args - Arguments to filter CalendarEventSyncs to delete.
     * @example
     * // Delete a few CalendarEventSyncs
     * const { count } = await prisma.calendarEventSync.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CalendarEventSyncDeleteManyArgs>(args?: SelectSubset<T, CalendarEventSyncDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CalendarEventSyncs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventSyncUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CalendarEventSyncs
     * const calendarEventSync = await prisma.calendarEventSync.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CalendarEventSyncUpdateManyArgs>(args: SelectSubset<T, CalendarEventSyncUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CalendarEventSyncs and returns the data updated in the database.
     * @param {CalendarEventSyncUpdateManyAndReturnArgs} args - Arguments to update many CalendarEventSyncs.
     * @example
     * // Update many CalendarEventSyncs
     * const calendarEventSync = await prisma.calendarEventSync.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CalendarEventSyncs and only return the `id`
     * const calendarEventSyncWithIdOnly = await prisma.calendarEventSync.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CalendarEventSyncUpdateManyAndReturnArgs>(args: SelectSubset<T, CalendarEventSyncUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarEventSyncPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CalendarEventSync.
     * @param {CalendarEventSyncUpsertArgs} args - Arguments to update or create a CalendarEventSync.
     * @example
     * // Update or create a CalendarEventSync
     * const calendarEventSync = await prisma.calendarEventSync.upsert({
     *   create: {
     *     // ... data to create a CalendarEventSync
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CalendarEventSync we want to update
     *   }
     * })
     */
    upsert<T extends CalendarEventSyncUpsertArgs>(args: SelectSubset<T, CalendarEventSyncUpsertArgs<ExtArgs>>): Prisma__CalendarEventSyncClient<$Result.GetResult<Prisma.$CalendarEventSyncPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CalendarEventSyncs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventSyncCountArgs} args - Arguments to filter CalendarEventSyncs to count.
     * @example
     * // Count the number of CalendarEventSyncs
     * const count = await prisma.calendarEventSync.count({
     *   where: {
     *     // ... the filter for the CalendarEventSyncs we want to count
     *   }
     * })
    **/
    count<T extends CalendarEventSyncCountArgs>(
      args?: Subset<T, CalendarEventSyncCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CalendarEventSyncCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CalendarEventSync.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventSyncAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CalendarEventSyncAggregateArgs>(args: Subset<T, CalendarEventSyncAggregateArgs>): Prisma.PrismaPromise<GetCalendarEventSyncAggregateType<T>>

    /**
     * Group by CalendarEventSync.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventSyncGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CalendarEventSyncGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CalendarEventSyncGroupByArgs['orderBy'] }
        : { orderBy?: CalendarEventSyncGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CalendarEventSyncGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCalendarEventSyncGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CalendarEventSync model
   */
  readonly fields: CalendarEventSyncFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CalendarEventSync.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CalendarEventSyncClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    integration<T extends CalendarIntegrationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CalendarIntegrationDefaultArgs<ExtArgs>>): Prisma__CalendarIntegrationClient<$Result.GetResult<Prisma.$CalendarIntegrationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CalendarEventSync model
   */
  interface CalendarEventSyncFieldRefs {
    readonly id: FieldRef<"CalendarEventSync", 'String'>
    readonly integrationId: FieldRef<"CalendarEventSync", 'String'>
    readonly entityType: FieldRef<"CalendarEventSync", 'String'>
    readonly entityId: FieldRef<"CalendarEventSync", 'String'>
    readonly externalEventId: FieldRef<"CalendarEventSync", 'String'>
    readonly lastSyncedAt: FieldRef<"CalendarEventSync", 'DateTime'>
    readonly syncHash: FieldRef<"CalendarEventSync", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CalendarEventSync findUnique
   */
  export type CalendarEventSyncFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEventSync
     */
    select?: CalendarEventSyncSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEventSync
     */
    omit?: CalendarEventSyncOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventSyncInclude<ExtArgs> | null
    /**
     * Filter, which CalendarEventSync to fetch.
     */
    where: CalendarEventSyncWhereUniqueInput
  }

  /**
   * CalendarEventSync findUniqueOrThrow
   */
  export type CalendarEventSyncFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEventSync
     */
    select?: CalendarEventSyncSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEventSync
     */
    omit?: CalendarEventSyncOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventSyncInclude<ExtArgs> | null
    /**
     * Filter, which CalendarEventSync to fetch.
     */
    where: CalendarEventSyncWhereUniqueInput
  }

  /**
   * CalendarEventSync findFirst
   */
  export type CalendarEventSyncFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEventSync
     */
    select?: CalendarEventSyncSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEventSync
     */
    omit?: CalendarEventSyncOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventSyncInclude<ExtArgs> | null
    /**
     * Filter, which CalendarEventSync to fetch.
     */
    where?: CalendarEventSyncWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarEventSyncs to fetch.
     */
    orderBy?: CalendarEventSyncOrderByWithRelationInput | CalendarEventSyncOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CalendarEventSyncs.
     */
    cursor?: CalendarEventSyncWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarEventSyncs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarEventSyncs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CalendarEventSyncs.
     */
    distinct?: CalendarEventSyncScalarFieldEnum | CalendarEventSyncScalarFieldEnum[]
  }

  /**
   * CalendarEventSync findFirstOrThrow
   */
  export type CalendarEventSyncFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEventSync
     */
    select?: CalendarEventSyncSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEventSync
     */
    omit?: CalendarEventSyncOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventSyncInclude<ExtArgs> | null
    /**
     * Filter, which CalendarEventSync to fetch.
     */
    where?: CalendarEventSyncWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarEventSyncs to fetch.
     */
    orderBy?: CalendarEventSyncOrderByWithRelationInput | CalendarEventSyncOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CalendarEventSyncs.
     */
    cursor?: CalendarEventSyncWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarEventSyncs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarEventSyncs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CalendarEventSyncs.
     */
    distinct?: CalendarEventSyncScalarFieldEnum | CalendarEventSyncScalarFieldEnum[]
  }

  /**
   * CalendarEventSync findMany
   */
  export type CalendarEventSyncFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEventSync
     */
    select?: CalendarEventSyncSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEventSync
     */
    omit?: CalendarEventSyncOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventSyncInclude<ExtArgs> | null
    /**
     * Filter, which CalendarEventSyncs to fetch.
     */
    where?: CalendarEventSyncWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarEventSyncs to fetch.
     */
    orderBy?: CalendarEventSyncOrderByWithRelationInput | CalendarEventSyncOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CalendarEventSyncs.
     */
    cursor?: CalendarEventSyncWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarEventSyncs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarEventSyncs.
     */
    skip?: number
    distinct?: CalendarEventSyncScalarFieldEnum | CalendarEventSyncScalarFieldEnum[]
  }

  /**
   * CalendarEventSync create
   */
  export type CalendarEventSyncCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEventSync
     */
    select?: CalendarEventSyncSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEventSync
     */
    omit?: CalendarEventSyncOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventSyncInclude<ExtArgs> | null
    /**
     * The data needed to create a CalendarEventSync.
     */
    data: XOR<CalendarEventSyncCreateInput, CalendarEventSyncUncheckedCreateInput>
  }

  /**
   * CalendarEventSync createMany
   */
  export type CalendarEventSyncCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CalendarEventSyncs.
     */
    data: CalendarEventSyncCreateManyInput | CalendarEventSyncCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CalendarEventSync createManyAndReturn
   */
  export type CalendarEventSyncCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEventSync
     */
    select?: CalendarEventSyncSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEventSync
     */
    omit?: CalendarEventSyncOmit<ExtArgs> | null
    /**
     * The data used to create many CalendarEventSyncs.
     */
    data: CalendarEventSyncCreateManyInput | CalendarEventSyncCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventSyncIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CalendarEventSync update
   */
  export type CalendarEventSyncUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEventSync
     */
    select?: CalendarEventSyncSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEventSync
     */
    omit?: CalendarEventSyncOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventSyncInclude<ExtArgs> | null
    /**
     * The data needed to update a CalendarEventSync.
     */
    data: XOR<CalendarEventSyncUpdateInput, CalendarEventSyncUncheckedUpdateInput>
    /**
     * Choose, which CalendarEventSync to update.
     */
    where: CalendarEventSyncWhereUniqueInput
  }

  /**
   * CalendarEventSync updateMany
   */
  export type CalendarEventSyncUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CalendarEventSyncs.
     */
    data: XOR<CalendarEventSyncUpdateManyMutationInput, CalendarEventSyncUncheckedUpdateManyInput>
    /**
     * Filter which CalendarEventSyncs to update
     */
    where?: CalendarEventSyncWhereInput
    /**
     * Limit how many CalendarEventSyncs to update.
     */
    limit?: number
  }

  /**
   * CalendarEventSync updateManyAndReturn
   */
  export type CalendarEventSyncUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEventSync
     */
    select?: CalendarEventSyncSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEventSync
     */
    omit?: CalendarEventSyncOmit<ExtArgs> | null
    /**
     * The data used to update CalendarEventSyncs.
     */
    data: XOR<CalendarEventSyncUpdateManyMutationInput, CalendarEventSyncUncheckedUpdateManyInput>
    /**
     * Filter which CalendarEventSyncs to update
     */
    where?: CalendarEventSyncWhereInput
    /**
     * Limit how many CalendarEventSyncs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventSyncIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CalendarEventSync upsert
   */
  export type CalendarEventSyncUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEventSync
     */
    select?: CalendarEventSyncSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEventSync
     */
    omit?: CalendarEventSyncOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventSyncInclude<ExtArgs> | null
    /**
     * The filter to search for the CalendarEventSync to update in case it exists.
     */
    where: CalendarEventSyncWhereUniqueInput
    /**
     * In case the CalendarEventSync found by the `where` argument doesn't exist, create a new CalendarEventSync with this data.
     */
    create: XOR<CalendarEventSyncCreateInput, CalendarEventSyncUncheckedCreateInput>
    /**
     * In case the CalendarEventSync was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CalendarEventSyncUpdateInput, CalendarEventSyncUncheckedUpdateInput>
  }

  /**
   * CalendarEventSync delete
   */
  export type CalendarEventSyncDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEventSync
     */
    select?: CalendarEventSyncSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEventSync
     */
    omit?: CalendarEventSyncOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventSyncInclude<ExtArgs> | null
    /**
     * Filter which CalendarEventSync to delete.
     */
    where: CalendarEventSyncWhereUniqueInput
  }

  /**
   * CalendarEventSync deleteMany
   */
  export type CalendarEventSyncDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CalendarEventSyncs to delete
     */
    where?: CalendarEventSyncWhereInput
    /**
     * Limit how many CalendarEventSyncs to delete.
     */
    limit?: number
  }

  /**
   * CalendarEventSync without action
   */
  export type CalendarEventSyncDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEventSync
     */
    select?: CalendarEventSyncSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEventSync
     */
    omit?: CalendarEventSyncOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventSyncInclude<ExtArgs> | null
  }


  /**
   * Model CalendarFeedToken
   */

  export type AggregateCalendarFeedToken = {
    _count: CalendarFeedTokenCountAggregateOutputType | null
    _min: CalendarFeedTokenMinAggregateOutputType | null
    _max: CalendarFeedTokenMaxAggregateOutputType | null
  }

  export type CalendarFeedTokenMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    token: string | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type CalendarFeedTokenMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    token: string | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type CalendarFeedTokenCountAggregateOutputType = {
    id: number
    tenantId: number
    userId: number
    token: number
    createdAt: number
    expiresAt: number
    _all: number
  }


  export type CalendarFeedTokenMinAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    token?: true
    createdAt?: true
    expiresAt?: true
  }

  export type CalendarFeedTokenMaxAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    token?: true
    createdAt?: true
    expiresAt?: true
  }

  export type CalendarFeedTokenCountAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    token?: true
    createdAt?: true
    expiresAt?: true
    _all?: true
  }

  export type CalendarFeedTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CalendarFeedToken to aggregate.
     */
    where?: CalendarFeedTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarFeedTokens to fetch.
     */
    orderBy?: CalendarFeedTokenOrderByWithRelationInput | CalendarFeedTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CalendarFeedTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarFeedTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarFeedTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CalendarFeedTokens
    **/
    _count?: true | CalendarFeedTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CalendarFeedTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CalendarFeedTokenMaxAggregateInputType
  }

  export type GetCalendarFeedTokenAggregateType<T extends CalendarFeedTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateCalendarFeedToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCalendarFeedToken[P]>
      : GetScalarType<T[P], AggregateCalendarFeedToken[P]>
  }




  export type CalendarFeedTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalendarFeedTokenWhereInput
    orderBy?: CalendarFeedTokenOrderByWithAggregationInput | CalendarFeedTokenOrderByWithAggregationInput[]
    by: CalendarFeedTokenScalarFieldEnum[] | CalendarFeedTokenScalarFieldEnum
    having?: CalendarFeedTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CalendarFeedTokenCountAggregateInputType | true
    _min?: CalendarFeedTokenMinAggregateInputType
    _max?: CalendarFeedTokenMaxAggregateInputType
  }

  export type CalendarFeedTokenGroupByOutputType = {
    id: string
    tenantId: string
    userId: string
    token: string
    createdAt: Date
    expiresAt: Date | null
    _count: CalendarFeedTokenCountAggregateOutputType | null
    _min: CalendarFeedTokenMinAggregateOutputType | null
    _max: CalendarFeedTokenMaxAggregateOutputType | null
  }

  type GetCalendarFeedTokenGroupByPayload<T extends CalendarFeedTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CalendarFeedTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CalendarFeedTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CalendarFeedTokenGroupByOutputType[P]>
            : GetScalarType<T[P], CalendarFeedTokenGroupByOutputType[P]>
        }
      >
    >


  export type CalendarFeedTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    token?: boolean
    createdAt?: boolean
    expiresAt?: boolean
  }, ExtArgs["result"]["calendarFeedToken"]>

  export type CalendarFeedTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    token?: boolean
    createdAt?: boolean
    expiresAt?: boolean
  }, ExtArgs["result"]["calendarFeedToken"]>

  export type CalendarFeedTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    token?: boolean
    createdAt?: boolean
    expiresAt?: boolean
  }, ExtArgs["result"]["calendarFeedToken"]>

  export type CalendarFeedTokenSelectScalar = {
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    token?: boolean
    createdAt?: boolean
    expiresAt?: boolean
  }

  export type CalendarFeedTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "userId" | "token" | "createdAt" | "expiresAt", ExtArgs["result"]["calendarFeedToken"]>

  export type $CalendarFeedTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CalendarFeedToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      userId: string
      token: string
      createdAt: Date
      expiresAt: Date | null
    }, ExtArgs["result"]["calendarFeedToken"]>
    composites: {}
  }

  type CalendarFeedTokenGetPayload<S extends boolean | null | undefined | CalendarFeedTokenDefaultArgs> = $Result.GetResult<Prisma.$CalendarFeedTokenPayload, S>

  type CalendarFeedTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CalendarFeedTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CalendarFeedTokenCountAggregateInputType | true
    }

  export interface CalendarFeedTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CalendarFeedToken'], meta: { name: 'CalendarFeedToken' } }
    /**
     * Find zero or one CalendarFeedToken that matches the filter.
     * @param {CalendarFeedTokenFindUniqueArgs} args - Arguments to find a CalendarFeedToken
     * @example
     * // Get one CalendarFeedToken
     * const calendarFeedToken = await prisma.calendarFeedToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CalendarFeedTokenFindUniqueArgs>(args: SelectSubset<T, CalendarFeedTokenFindUniqueArgs<ExtArgs>>): Prisma__CalendarFeedTokenClient<$Result.GetResult<Prisma.$CalendarFeedTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CalendarFeedToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CalendarFeedTokenFindUniqueOrThrowArgs} args - Arguments to find a CalendarFeedToken
     * @example
     * // Get one CalendarFeedToken
     * const calendarFeedToken = await prisma.calendarFeedToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CalendarFeedTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, CalendarFeedTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CalendarFeedTokenClient<$Result.GetResult<Prisma.$CalendarFeedTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CalendarFeedToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarFeedTokenFindFirstArgs} args - Arguments to find a CalendarFeedToken
     * @example
     * // Get one CalendarFeedToken
     * const calendarFeedToken = await prisma.calendarFeedToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CalendarFeedTokenFindFirstArgs>(args?: SelectSubset<T, CalendarFeedTokenFindFirstArgs<ExtArgs>>): Prisma__CalendarFeedTokenClient<$Result.GetResult<Prisma.$CalendarFeedTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CalendarFeedToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarFeedTokenFindFirstOrThrowArgs} args - Arguments to find a CalendarFeedToken
     * @example
     * // Get one CalendarFeedToken
     * const calendarFeedToken = await prisma.calendarFeedToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CalendarFeedTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, CalendarFeedTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__CalendarFeedTokenClient<$Result.GetResult<Prisma.$CalendarFeedTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CalendarFeedTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarFeedTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CalendarFeedTokens
     * const calendarFeedTokens = await prisma.calendarFeedToken.findMany()
     * 
     * // Get first 10 CalendarFeedTokens
     * const calendarFeedTokens = await prisma.calendarFeedToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const calendarFeedTokenWithIdOnly = await prisma.calendarFeedToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CalendarFeedTokenFindManyArgs>(args?: SelectSubset<T, CalendarFeedTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarFeedTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CalendarFeedToken.
     * @param {CalendarFeedTokenCreateArgs} args - Arguments to create a CalendarFeedToken.
     * @example
     * // Create one CalendarFeedToken
     * const CalendarFeedToken = await prisma.calendarFeedToken.create({
     *   data: {
     *     // ... data to create a CalendarFeedToken
     *   }
     * })
     * 
     */
    create<T extends CalendarFeedTokenCreateArgs>(args: SelectSubset<T, CalendarFeedTokenCreateArgs<ExtArgs>>): Prisma__CalendarFeedTokenClient<$Result.GetResult<Prisma.$CalendarFeedTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CalendarFeedTokens.
     * @param {CalendarFeedTokenCreateManyArgs} args - Arguments to create many CalendarFeedTokens.
     * @example
     * // Create many CalendarFeedTokens
     * const calendarFeedToken = await prisma.calendarFeedToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CalendarFeedTokenCreateManyArgs>(args?: SelectSubset<T, CalendarFeedTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CalendarFeedTokens and returns the data saved in the database.
     * @param {CalendarFeedTokenCreateManyAndReturnArgs} args - Arguments to create many CalendarFeedTokens.
     * @example
     * // Create many CalendarFeedTokens
     * const calendarFeedToken = await prisma.calendarFeedToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CalendarFeedTokens and only return the `id`
     * const calendarFeedTokenWithIdOnly = await prisma.calendarFeedToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CalendarFeedTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, CalendarFeedTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarFeedTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CalendarFeedToken.
     * @param {CalendarFeedTokenDeleteArgs} args - Arguments to delete one CalendarFeedToken.
     * @example
     * // Delete one CalendarFeedToken
     * const CalendarFeedToken = await prisma.calendarFeedToken.delete({
     *   where: {
     *     // ... filter to delete one CalendarFeedToken
     *   }
     * })
     * 
     */
    delete<T extends CalendarFeedTokenDeleteArgs>(args: SelectSubset<T, CalendarFeedTokenDeleteArgs<ExtArgs>>): Prisma__CalendarFeedTokenClient<$Result.GetResult<Prisma.$CalendarFeedTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CalendarFeedToken.
     * @param {CalendarFeedTokenUpdateArgs} args - Arguments to update one CalendarFeedToken.
     * @example
     * // Update one CalendarFeedToken
     * const calendarFeedToken = await prisma.calendarFeedToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CalendarFeedTokenUpdateArgs>(args: SelectSubset<T, CalendarFeedTokenUpdateArgs<ExtArgs>>): Prisma__CalendarFeedTokenClient<$Result.GetResult<Prisma.$CalendarFeedTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CalendarFeedTokens.
     * @param {CalendarFeedTokenDeleteManyArgs} args - Arguments to filter CalendarFeedTokens to delete.
     * @example
     * // Delete a few CalendarFeedTokens
     * const { count } = await prisma.calendarFeedToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CalendarFeedTokenDeleteManyArgs>(args?: SelectSubset<T, CalendarFeedTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CalendarFeedTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarFeedTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CalendarFeedTokens
     * const calendarFeedToken = await prisma.calendarFeedToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CalendarFeedTokenUpdateManyArgs>(args: SelectSubset<T, CalendarFeedTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CalendarFeedTokens and returns the data updated in the database.
     * @param {CalendarFeedTokenUpdateManyAndReturnArgs} args - Arguments to update many CalendarFeedTokens.
     * @example
     * // Update many CalendarFeedTokens
     * const calendarFeedToken = await prisma.calendarFeedToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CalendarFeedTokens and only return the `id`
     * const calendarFeedTokenWithIdOnly = await prisma.calendarFeedToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CalendarFeedTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, CalendarFeedTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarFeedTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CalendarFeedToken.
     * @param {CalendarFeedTokenUpsertArgs} args - Arguments to update or create a CalendarFeedToken.
     * @example
     * // Update or create a CalendarFeedToken
     * const calendarFeedToken = await prisma.calendarFeedToken.upsert({
     *   create: {
     *     // ... data to create a CalendarFeedToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CalendarFeedToken we want to update
     *   }
     * })
     */
    upsert<T extends CalendarFeedTokenUpsertArgs>(args: SelectSubset<T, CalendarFeedTokenUpsertArgs<ExtArgs>>): Prisma__CalendarFeedTokenClient<$Result.GetResult<Prisma.$CalendarFeedTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CalendarFeedTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarFeedTokenCountArgs} args - Arguments to filter CalendarFeedTokens to count.
     * @example
     * // Count the number of CalendarFeedTokens
     * const count = await prisma.calendarFeedToken.count({
     *   where: {
     *     // ... the filter for the CalendarFeedTokens we want to count
     *   }
     * })
    **/
    count<T extends CalendarFeedTokenCountArgs>(
      args?: Subset<T, CalendarFeedTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CalendarFeedTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CalendarFeedToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarFeedTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CalendarFeedTokenAggregateArgs>(args: Subset<T, CalendarFeedTokenAggregateArgs>): Prisma.PrismaPromise<GetCalendarFeedTokenAggregateType<T>>

    /**
     * Group by CalendarFeedToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarFeedTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CalendarFeedTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CalendarFeedTokenGroupByArgs['orderBy'] }
        : { orderBy?: CalendarFeedTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CalendarFeedTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCalendarFeedTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CalendarFeedToken model
   */
  readonly fields: CalendarFeedTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CalendarFeedToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CalendarFeedTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CalendarFeedToken model
   */
  interface CalendarFeedTokenFieldRefs {
    readonly id: FieldRef<"CalendarFeedToken", 'String'>
    readonly tenantId: FieldRef<"CalendarFeedToken", 'String'>
    readonly userId: FieldRef<"CalendarFeedToken", 'String'>
    readonly token: FieldRef<"CalendarFeedToken", 'String'>
    readonly createdAt: FieldRef<"CalendarFeedToken", 'DateTime'>
    readonly expiresAt: FieldRef<"CalendarFeedToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CalendarFeedToken findUnique
   */
  export type CalendarFeedTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarFeedToken
     */
    select?: CalendarFeedTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarFeedToken
     */
    omit?: CalendarFeedTokenOmit<ExtArgs> | null
    /**
     * Filter, which CalendarFeedToken to fetch.
     */
    where: CalendarFeedTokenWhereUniqueInput
  }

  /**
   * CalendarFeedToken findUniqueOrThrow
   */
  export type CalendarFeedTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarFeedToken
     */
    select?: CalendarFeedTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarFeedToken
     */
    omit?: CalendarFeedTokenOmit<ExtArgs> | null
    /**
     * Filter, which CalendarFeedToken to fetch.
     */
    where: CalendarFeedTokenWhereUniqueInput
  }

  /**
   * CalendarFeedToken findFirst
   */
  export type CalendarFeedTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarFeedToken
     */
    select?: CalendarFeedTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarFeedToken
     */
    omit?: CalendarFeedTokenOmit<ExtArgs> | null
    /**
     * Filter, which CalendarFeedToken to fetch.
     */
    where?: CalendarFeedTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarFeedTokens to fetch.
     */
    orderBy?: CalendarFeedTokenOrderByWithRelationInput | CalendarFeedTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CalendarFeedTokens.
     */
    cursor?: CalendarFeedTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarFeedTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarFeedTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CalendarFeedTokens.
     */
    distinct?: CalendarFeedTokenScalarFieldEnum | CalendarFeedTokenScalarFieldEnum[]
  }

  /**
   * CalendarFeedToken findFirstOrThrow
   */
  export type CalendarFeedTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarFeedToken
     */
    select?: CalendarFeedTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarFeedToken
     */
    omit?: CalendarFeedTokenOmit<ExtArgs> | null
    /**
     * Filter, which CalendarFeedToken to fetch.
     */
    where?: CalendarFeedTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarFeedTokens to fetch.
     */
    orderBy?: CalendarFeedTokenOrderByWithRelationInput | CalendarFeedTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CalendarFeedTokens.
     */
    cursor?: CalendarFeedTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarFeedTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarFeedTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CalendarFeedTokens.
     */
    distinct?: CalendarFeedTokenScalarFieldEnum | CalendarFeedTokenScalarFieldEnum[]
  }

  /**
   * CalendarFeedToken findMany
   */
  export type CalendarFeedTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarFeedToken
     */
    select?: CalendarFeedTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarFeedToken
     */
    omit?: CalendarFeedTokenOmit<ExtArgs> | null
    /**
     * Filter, which CalendarFeedTokens to fetch.
     */
    where?: CalendarFeedTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarFeedTokens to fetch.
     */
    orderBy?: CalendarFeedTokenOrderByWithRelationInput | CalendarFeedTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CalendarFeedTokens.
     */
    cursor?: CalendarFeedTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarFeedTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarFeedTokens.
     */
    skip?: number
    distinct?: CalendarFeedTokenScalarFieldEnum | CalendarFeedTokenScalarFieldEnum[]
  }

  /**
   * CalendarFeedToken create
   */
  export type CalendarFeedTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarFeedToken
     */
    select?: CalendarFeedTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarFeedToken
     */
    omit?: CalendarFeedTokenOmit<ExtArgs> | null
    /**
     * The data needed to create a CalendarFeedToken.
     */
    data: XOR<CalendarFeedTokenCreateInput, CalendarFeedTokenUncheckedCreateInput>
  }

  /**
   * CalendarFeedToken createMany
   */
  export type CalendarFeedTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CalendarFeedTokens.
     */
    data: CalendarFeedTokenCreateManyInput | CalendarFeedTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CalendarFeedToken createManyAndReturn
   */
  export type CalendarFeedTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarFeedToken
     */
    select?: CalendarFeedTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarFeedToken
     */
    omit?: CalendarFeedTokenOmit<ExtArgs> | null
    /**
     * The data used to create many CalendarFeedTokens.
     */
    data: CalendarFeedTokenCreateManyInput | CalendarFeedTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CalendarFeedToken update
   */
  export type CalendarFeedTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarFeedToken
     */
    select?: CalendarFeedTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarFeedToken
     */
    omit?: CalendarFeedTokenOmit<ExtArgs> | null
    /**
     * The data needed to update a CalendarFeedToken.
     */
    data: XOR<CalendarFeedTokenUpdateInput, CalendarFeedTokenUncheckedUpdateInput>
    /**
     * Choose, which CalendarFeedToken to update.
     */
    where: CalendarFeedTokenWhereUniqueInput
  }

  /**
   * CalendarFeedToken updateMany
   */
  export type CalendarFeedTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CalendarFeedTokens.
     */
    data: XOR<CalendarFeedTokenUpdateManyMutationInput, CalendarFeedTokenUncheckedUpdateManyInput>
    /**
     * Filter which CalendarFeedTokens to update
     */
    where?: CalendarFeedTokenWhereInput
    /**
     * Limit how many CalendarFeedTokens to update.
     */
    limit?: number
  }

  /**
   * CalendarFeedToken updateManyAndReturn
   */
  export type CalendarFeedTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarFeedToken
     */
    select?: CalendarFeedTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarFeedToken
     */
    omit?: CalendarFeedTokenOmit<ExtArgs> | null
    /**
     * The data used to update CalendarFeedTokens.
     */
    data: XOR<CalendarFeedTokenUpdateManyMutationInput, CalendarFeedTokenUncheckedUpdateManyInput>
    /**
     * Filter which CalendarFeedTokens to update
     */
    where?: CalendarFeedTokenWhereInput
    /**
     * Limit how many CalendarFeedTokens to update.
     */
    limit?: number
  }

  /**
   * CalendarFeedToken upsert
   */
  export type CalendarFeedTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarFeedToken
     */
    select?: CalendarFeedTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarFeedToken
     */
    omit?: CalendarFeedTokenOmit<ExtArgs> | null
    /**
     * The filter to search for the CalendarFeedToken to update in case it exists.
     */
    where: CalendarFeedTokenWhereUniqueInput
    /**
     * In case the CalendarFeedToken found by the `where` argument doesn't exist, create a new CalendarFeedToken with this data.
     */
    create: XOR<CalendarFeedTokenCreateInput, CalendarFeedTokenUncheckedCreateInput>
    /**
     * In case the CalendarFeedToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CalendarFeedTokenUpdateInput, CalendarFeedTokenUncheckedUpdateInput>
  }

  /**
   * CalendarFeedToken delete
   */
  export type CalendarFeedTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarFeedToken
     */
    select?: CalendarFeedTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarFeedToken
     */
    omit?: CalendarFeedTokenOmit<ExtArgs> | null
    /**
     * Filter which CalendarFeedToken to delete.
     */
    where: CalendarFeedTokenWhereUniqueInput
  }

  /**
   * CalendarFeedToken deleteMany
   */
  export type CalendarFeedTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CalendarFeedTokens to delete
     */
    where?: CalendarFeedTokenWhereInput
    /**
     * Limit how many CalendarFeedTokens to delete.
     */
    limit?: number
  }

  /**
   * CalendarFeedToken without action
   */
  export type CalendarFeedTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarFeedToken
     */
    select?: CalendarFeedTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarFeedToken
     */
    omit?: CalendarFeedTokenOmit<ExtArgs> | null
  }


  /**
   * Model Badge
   */

  export type AggregateBadge = {
    _count: BadgeCountAggregateOutputType | null
    _min: BadgeMinAggregateOutputType | null
    _max: BadgeMaxAggregateOutputType | null
  }

  export type BadgeMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    description: string | null
    icon: string | null
    color: string | null
    category: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BadgeMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    description: string | null
    icon: string | null
    color: string | null
    category: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BadgeCountAggregateOutputType = {
    id: number
    tenantId: number
    name: number
    description: number
    icon: number
    color: number
    category: number
    criteria: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BadgeMinAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    description?: true
    icon?: true
    color?: true
    category?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BadgeMaxAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    description?: true
    icon?: true
    color?: true
    category?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BadgeCountAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    description?: true
    icon?: true
    color?: true
    category?: true
    criteria?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BadgeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Badge to aggregate.
     */
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Badges
    **/
    _count?: true | BadgeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BadgeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BadgeMaxAggregateInputType
  }

  export type GetBadgeAggregateType<T extends BadgeAggregateArgs> = {
        [P in keyof T & keyof AggregateBadge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBadge[P]>
      : GetScalarType<T[P], AggregateBadge[P]>
  }




  export type BadgeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BadgeWhereInput
    orderBy?: BadgeOrderByWithAggregationInput | BadgeOrderByWithAggregationInput[]
    by: BadgeScalarFieldEnum[] | BadgeScalarFieldEnum
    having?: BadgeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BadgeCountAggregateInputType | true
    _min?: BadgeMinAggregateInputType
    _max?: BadgeMaxAggregateInputType
  }

  export type BadgeGroupByOutputType = {
    id: string
    tenantId: string
    name: string
    description: string
    icon: string
    color: string
    category: string
    criteria: JsonValue
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: BadgeCountAggregateOutputType | null
    _min: BadgeMinAggregateOutputType | null
    _max: BadgeMaxAggregateOutputType | null
  }

  type GetBadgeGroupByPayload<T extends BadgeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BadgeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BadgeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BadgeGroupByOutputType[P]>
            : GetScalarType<T[P], BadgeGroupByOutputType[P]>
        }
      >
    >


  export type BadgeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    color?: boolean
    category?: boolean
    criteria?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    clientBadges?: boolean | Badge$clientBadgesArgs<ExtArgs>
    _count?: boolean | BadgeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["badge"]>

  export type BadgeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    color?: boolean
    category?: boolean
    criteria?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["badge"]>

  export type BadgeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    color?: boolean
    category?: boolean
    criteria?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["badge"]>

  export type BadgeSelectScalar = {
    id?: boolean
    tenantId?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    color?: boolean
    category?: boolean
    criteria?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BadgeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "name" | "description" | "icon" | "color" | "category" | "criteria" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["badge"]>
  export type BadgeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    clientBadges?: boolean | Badge$clientBadgesArgs<ExtArgs>
    _count?: boolean | BadgeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BadgeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type BadgeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $BadgePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Badge"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      clientBadges: Prisma.$ClientBadgePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      name: string
      description: string
      icon: string
      color: string
      category: string
      criteria: Prisma.JsonValue
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["badge"]>
    composites: {}
  }

  type BadgeGetPayload<S extends boolean | null | undefined | BadgeDefaultArgs> = $Result.GetResult<Prisma.$BadgePayload, S>

  type BadgeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BadgeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BadgeCountAggregateInputType | true
    }

  export interface BadgeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Badge'], meta: { name: 'Badge' } }
    /**
     * Find zero or one Badge that matches the filter.
     * @param {BadgeFindUniqueArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BadgeFindUniqueArgs>(args: SelectSubset<T, BadgeFindUniqueArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Badge that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BadgeFindUniqueOrThrowArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BadgeFindUniqueOrThrowArgs>(args: SelectSubset<T, BadgeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Badge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeFindFirstArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BadgeFindFirstArgs>(args?: SelectSubset<T, BadgeFindFirstArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Badge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeFindFirstOrThrowArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BadgeFindFirstOrThrowArgs>(args?: SelectSubset<T, BadgeFindFirstOrThrowArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Badges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Badges
     * const badges = await prisma.badge.findMany()
     * 
     * // Get first 10 Badges
     * const badges = await prisma.badge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const badgeWithIdOnly = await prisma.badge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BadgeFindManyArgs>(args?: SelectSubset<T, BadgeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Badge.
     * @param {BadgeCreateArgs} args - Arguments to create a Badge.
     * @example
     * // Create one Badge
     * const Badge = await prisma.badge.create({
     *   data: {
     *     // ... data to create a Badge
     *   }
     * })
     * 
     */
    create<T extends BadgeCreateArgs>(args: SelectSubset<T, BadgeCreateArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Badges.
     * @param {BadgeCreateManyArgs} args - Arguments to create many Badges.
     * @example
     * // Create many Badges
     * const badge = await prisma.badge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BadgeCreateManyArgs>(args?: SelectSubset<T, BadgeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Badges and returns the data saved in the database.
     * @param {BadgeCreateManyAndReturnArgs} args - Arguments to create many Badges.
     * @example
     * // Create many Badges
     * const badge = await prisma.badge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Badges and only return the `id`
     * const badgeWithIdOnly = await prisma.badge.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BadgeCreateManyAndReturnArgs>(args?: SelectSubset<T, BadgeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Badge.
     * @param {BadgeDeleteArgs} args - Arguments to delete one Badge.
     * @example
     * // Delete one Badge
     * const Badge = await prisma.badge.delete({
     *   where: {
     *     // ... filter to delete one Badge
     *   }
     * })
     * 
     */
    delete<T extends BadgeDeleteArgs>(args: SelectSubset<T, BadgeDeleteArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Badge.
     * @param {BadgeUpdateArgs} args - Arguments to update one Badge.
     * @example
     * // Update one Badge
     * const badge = await prisma.badge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BadgeUpdateArgs>(args: SelectSubset<T, BadgeUpdateArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Badges.
     * @param {BadgeDeleteManyArgs} args - Arguments to filter Badges to delete.
     * @example
     * // Delete a few Badges
     * const { count } = await prisma.badge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BadgeDeleteManyArgs>(args?: SelectSubset<T, BadgeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Badges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Badges
     * const badge = await prisma.badge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BadgeUpdateManyArgs>(args: SelectSubset<T, BadgeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Badges and returns the data updated in the database.
     * @param {BadgeUpdateManyAndReturnArgs} args - Arguments to update many Badges.
     * @example
     * // Update many Badges
     * const badge = await prisma.badge.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Badges and only return the `id`
     * const badgeWithIdOnly = await prisma.badge.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BadgeUpdateManyAndReturnArgs>(args: SelectSubset<T, BadgeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Badge.
     * @param {BadgeUpsertArgs} args - Arguments to update or create a Badge.
     * @example
     * // Update or create a Badge
     * const badge = await prisma.badge.upsert({
     *   create: {
     *     // ... data to create a Badge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Badge we want to update
     *   }
     * })
     */
    upsert<T extends BadgeUpsertArgs>(args: SelectSubset<T, BadgeUpsertArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Badges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeCountArgs} args - Arguments to filter Badges to count.
     * @example
     * // Count the number of Badges
     * const count = await prisma.badge.count({
     *   where: {
     *     // ... the filter for the Badges we want to count
     *   }
     * })
    **/
    count<T extends BadgeCountArgs>(
      args?: Subset<T, BadgeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BadgeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Badge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BadgeAggregateArgs>(args: Subset<T, BadgeAggregateArgs>): Prisma.PrismaPromise<GetBadgeAggregateType<T>>

    /**
     * Group by Badge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BadgeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BadgeGroupByArgs['orderBy'] }
        : { orderBy?: BadgeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BadgeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBadgeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Badge model
   */
  readonly fields: BadgeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Badge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BadgeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    clientBadges<T extends Badge$clientBadgesArgs<ExtArgs> = {}>(args?: Subset<T, Badge$clientBadgesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientBadgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Badge model
   */
  interface BadgeFieldRefs {
    readonly id: FieldRef<"Badge", 'String'>
    readonly tenantId: FieldRef<"Badge", 'String'>
    readonly name: FieldRef<"Badge", 'String'>
    readonly description: FieldRef<"Badge", 'String'>
    readonly icon: FieldRef<"Badge", 'String'>
    readonly color: FieldRef<"Badge", 'String'>
    readonly category: FieldRef<"Badge", 'String'>
    readonly criteria: FieldRef<"Badge", 'Json'>
    readonly isActive: FieldRef<"Badge", 'Boolean'>
    readonly createdAt: FieldRef<"Badge", 'DateTime'>
    readonly updatedAt: FieldRef<"Badge", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Badge findUnique
   */
  export type BadgeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badge to fetch.
     */
    where: BadgeWhereUniqueInput
  }

  /**
   * Badge findUniqueOrThrow
   */
  export type BadgeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badge to fetch.
     */
    where: BadgeWhereUniqueInput
  }

  /**
   * Badge findFirst
   */
  export type BadgeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badge to fetch.
     */
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Badges.
     */
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Badges.
     */
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[]
  }

  /**
   * Badge findFirstOrThrow
   */
  export type BadgeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badge to fetch.
     */
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Badges.
     */
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Badges.
     */
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[]
  }

  /**
   * Badge findMany
   */
  export type BadgeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badges to fetch.
     */
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Badges.
     */
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[]
  }

  /**
   * Badge create
   */
  export type BadgeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * The data needed to create a Badge.
     */
    data: XOR<BadgeCreateInput, BadgeUncheckedCreateInput>
  }

  /**
   * Badge createMany
   */
  export type BadgeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Badges.
     */
    data: BadgeCreateManyInput | BadgeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Badge createManyAndReturn
   */
  export type BadgeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * The data used to create many Badges.
     */
    data: BadgeCreateManyInput | BadgeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Badge update
   */
  export type BadgeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * The data needed to update a Badge.
     */
    data: XOR<BadgeUpdateInput, BadgeUncheckedUpdateInput>
    /**
     * Choose, which Badge to update.
     */
    where: BadgeWhereUniqueInput
  }

  /**
   * Badge updateMany
   */
  export type BadgeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Badges.
     */
    data: XOR<BadgeUpdateManyMutationInput, BadgeUncheckedUpdateManyInput>
    /**
     * Filter which Badges to update
     */
    where?: BadgeWhereInput
    /**
     * Limit how many Badges to update.
     */
    limit?: number
  }

  /**
   * Badge updateManyAndReturn
   */
  export type BadgeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * The data used to update Badges.
     */
    data: XOR<BadgeUpdateManyMutationInput, BadgeUncheckedUpdateManyInput>
    /**
     * Filter which Badges to update
     */
    where?: BadgeWhereInput
    /**
     * Limit how many Badges to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Badge upsert
   */
  export type BadgeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * The filter to search for the Badge to update in case it exists.
     */
    where: BadgeWhereUniqueInput
    /**
     * In case the Badge found by the `where` argument doesn't exist, create a new Badge with this data.
     */
    create: XOR<BadgeCreateInput, BadgeUncheckedCreateInput>
    /**
     * In case the Badge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BadgeUpdateInput, BadgeUncheckedUpdateInput>
  }

  /**
   * Badge delete
   */
  export type BadgeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter which Badge to delete.
     */
    where: BadgeWhereUniqueInput
  }

  /**
   * Badge deleteMany
   */
  export type BadgeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Badges to delete
     */
    where?: BadgeWhereInput
    /**
     * Limit how many Badges to delete.
     */
    limit?: number
  }

  /**
   * Badge.clientBadges
   */
  export type Badge$clientBadgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientBadge
     */
    select?: ClientBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientBadge
     */
    omit?: ClientBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientBadgeInclude<ExtArgs> | null
    where?: ClientBadgeWhereInput
    orderBy?: ClientBadgeOrderByWithRelationInput | ClientBadgeOrderByWithRelationInput[]
    cursor?: ClientBadgeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientBadgeScalarFieldEnum | ClientBadgeScalarFieldEnum[]
  }

  /**
   * Badge without action
   */
  export type BadgeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
  }


  /**
   * Model ClientBadge
   */

  export type AggregateClientBadge = {
    _count: ClientBadgeCountAggregateOutputType | null
    _min: ClientBadgeMinAggregateOutputType | null
    _max: ClientBadgeMaxAggregateOutputType | null
  }

  export type ClientBadgeMinAggregateOutputType = {
    id: string | null
    clientId: string | null
    badgeId: string | null
    earnedAt: Date | null
    notified: boolean | null
  }

  export type ClientBadgeMaxAggregateOutputType = {
    id: string | null
    clientId: string | null
    badgeId: string | null
    earnedAt: Date | null
    notified: boolean | null
  }

  export type ClientBadgeCountAggregateOutputType = {
    id: number
    clientId: number
    badgeId: number
    earnedAt: number
    notified: number
    _all: number
  }


  export type ClientBadgeMinAggregateInputType = {
    id?: true
    clientId?: true
    badgeId?: true
    earnedAt?: true
    notified?: true
  }

  export type ClientBadgeMaxAggregateInputType = {
    id?: true
    clientId?: true
    badgeId?: true
    earnedAt?: true
    notified?: true
  }

  export type ClientBadgeCountAggregateInputType = {
    id?: true
    clientId?: true
    badgeId?: true
    earnedAt?: true
    notified?: true
    _all?: true
  }

  export type ClientBadgeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientBadge to aggregate.
     */
    where?: ClientBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientBadges to fetch.
     */
    orderBy?: ClientBadgeOrderByWithRelationInput | ClientBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientBadges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClientBadges
    **/
    _count?: true | ClientBadgeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientBadgeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientBadgeMaxAggregateInputType
  }

  export type GetClientBadgeAggregateType<T extends ClientBadgeAggregateArgs> = {
        [P in keyof T & keyof AggregateClientBadge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientBadge[P]>
      : GetScalarType<T[P], AggregateClientBadge[P]>
  }




  export type ClientBadgeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientBadgeWhereInput
    orderBy?: ClientBadgeOrderByWithAggregationInput | ClientBadgeOrderByWithAggregationInput[]
    by: ClientBadgeScalarFieldEnum[] | ClientBadgeScalarFieldEnum
    having?: ClientBadgeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientBadgeCountAggregateInputType | true
    _min?: ClientBadgeMinAggregateInputType
    _max?: ClientBadgeMaxAggregateInputType
  }

  export type ClientBadgeGroupByOutputType = {
    id: string
    clientId: string
    badgeId: string
    earnedAt: Date
    notified: boolean
    _count: ClientBadgeCountAggregateOutputType | null
    _min: ClientBadgeMinAggregateOutputType | null
    _max: ClientBadgeMaxAggregateOutputType | null
  }

  type GetClientBadgeGroupByPayload<T extends ClientBadgeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientBadgeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientBadgeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientBadgeGroupByOutputType[P]>
            : GetScalarType<T[P], ClientBadgeGroupByOutputType[P]>
        }
      >
    >


  export type ClientBadgeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    badgeId?: boolean
    earnedAt?: boolean
    notified?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    badge?: boolean | BadgeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientBadge"]>

  export type ClientBadgeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    badgeId?: boolean
    earnedAt?: boolean
    notified?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    badge?: boolean | BadgeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientBadge"]>

  export type ClientBadgeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    badgeId?: boolean
    earnedAt?: boolean
    notified?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    badge?: boolean | BadgeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientBadge"]>

  export type ClientBadgeSelectScalar = {
    id?: boolean
    clientId?: boolean
    badgeId?: boolean
    earnedAt?: boolean
    notified?: boolean
  }

  export type ClientBadgeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clientId" | "badgeId" | "earnedAt" | "notified", ExtArgs["result"]["clientBadge"]>
  export type ClientBadgeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    badge?: boolean | BadgeDefaultArgs<ExtArgs>
  }
  export type ClientBadgeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    badge?: boolean | BadgeDefaultArgs<ExtArgs>
  }
  export type ClientBadgeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    badge?: boolean | BadgeDefaultArgs<ExtArgs>
  }

  export type $ClientBadgePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClientBadge"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs>
      badge: Prisma.$BadgePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clientId: string
      badgeId: string
      earnedAt: Date
      notified: boolean
    }, ExtArgs["result"]["clientBadge"]>
    composites: {}
  }

  type ClientBadgeGetPayload<S extends boolean | null | undefined | ClientBadgeDefaultArgs> = $Result.GetResult<Prisma.$ClientBadgePayload, S>

  type ClientBadgeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClientBadgeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClientBadgeCountAggregateInputType | true
    }

  export interface ClientBadgeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClientBadge'], meta: { name: 'ClientBadge' } }
    /**
     * Find zero or one ClientBadge that matches the filter.
     * @param {ClientBadgeFindUniqueArgs} args - Arguments to find a ClientBadge
     * @example
     * // Get one ClientBadge
     * const clientBadge = await prisma.clientBadge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientBadgeFindUniqueArgs>(args: SelectSubset<T, ClientBadgeFindUniqueArgs<ExtArgs>>): Prisma__ClientBadgeClient<$Result.GetResult<Prisma.$ClientBadgePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClientBadge that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClientBadgeFindUniqueOrThrowArgs} args - Arguments to find a ClientBadge
     * @example
     * // Get one ClientBadge
     * const clientBadge = await prisma.clientBadge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientBadgeFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientBadgeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientBadgeClient<$Result.GetResult<Prisma.$ClientBadgePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientBadge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientBadgeFindFirstArgs} args - Arguments to find a ClientBadge
     * @example
     * // Get one ClientBadge
     * const clientBadge = await prisma.clientBadge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientBadgeFindFirstArgs>(args?: SelectSubset<T, ClientBadgeFindFirstArgs<ExtArgs>>): Prisma__ClientBadgeClient<$Result.GetResult<Prisma.$ClientBadgePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientBadge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientBadgeFindFirstOrThrowArgs} args - Arguments to find a ClientBadge
     * @example
     * // Get one ClientBadge
     * const clientBadge = await prisma.clientBadge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientBadgeFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientBadgeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientBadgeClient<$Result.GetResult<Prisma.$ClientBadgePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClientBadges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientBadgeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClientBadges
     * const clientBadges = await prisma.clientBadge.findMany()
     * 
     * // Get first 10 ClientBadges
     * const clientBadges = await prisma.clientBadge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientBadgeWithIdOnly = await prisma.clientBadge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientBadgeFindManyArgs>(args?: SelectSubset<T, ClientBadgeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientBadgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClientBadge.
     * @param {ClientBadgeCreateArgs} args - Arguments to create a ClientBadge.
     * @example
     * // Create one ClientBadge
     * const ClientBadge = await prisma.clientBadge.create({
     *   data: {
     *     // ... data to create a ClientBadge
     *   }
     * })
     * 
     */
    create<T extends ClientBadgeCreateArgs>(args: SelectSubset<T, ClientBadgeCreateArgs<ExtArgs>>): Prisma__ClientBadgeClient<$Result.GetResult<Prisma.$ClientBadgePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClientBadges.
     * @param {ClientBadgeCreateManyArgs} args - Arguments to create many ClientBadges.
     * @example
     * // Create many ClientBadges
     * const clientBadge = await prisma.clientBadge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientBadgeCreateManyArgs>(args?: SelectSubset<T, ClientBadgeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClientBadges and returns the data saved in the database.
     * @param {ClientBadgeCreateManyAndReturnArgs} args - Arguments to create many ClientBadges.
     * @example
     * // Create many ClientBadges
     * const clientBadge = await prisma.clientBadge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClientBadges and only return the `id`
     * const clientBadgeWithIdOnly = await prisma.clientBadge.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClientBadgeCreateManyAndReturnArgs>(args?: SelectSubset<T, ClientBadgeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientBadgePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ClientBadge.
     * @param {ClientBadgeDeleteArgs} args - Arguments to delete one ClientBadge.
     * @example
     * // Delete one ClientBadge
     * const ClientBadge = await prisma.clientBadge.delete({
     *   where: {
     *     // ... filter to delete one ClientBadge
     *   }
     * })
     * 
     */
    delete<T extends ClientBadgeDeleteArgs>(args: SelectSubset<T, ClientBadgeDeleteArgs<ExtArgs>>): Prisma__ClientBadgeClient<$Result.GetResult<Prisma.$ClientBadgePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClientBadge.
     * @param {ClientBadgeUpdateArgs} args - Arguments to update one ClientBadge.
     * @example
     * // Update one ClientBadge
     * const clientBadge = await prisma.clientBadge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientBadgeUpdateArgs>(args: SelectSubset<T, ClientBadgeUpdateArgs<ExtArgs>>): Prisma__ClientBadgeClient<$Result.GetResult<Prisma.$ClientBadgePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClientBadges.
     * @param {ClientBadgeDeleteManyArgs} args - Arguments to filter ClientBadges to delete.
     * @example
     * // Delete a few ClientBadges
     * const { count } = await prisma.clientBadge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientBadgeDeleteManyArgs>(args?: SelectSubset<T, ClientBadgeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientBadges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientBadgeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClientBadges
     * const clientBadge = await prisma.clientBadge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientBadgeUpdateManyArgs>(args: SelectSubset<T, ClientBadgeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientBadges and returns the data updated in the database.
     * @param {ClientBadgeUpdateManyAndReturnArgs} args - Arguments to update many ClientBadges.
     * @example
     * // Update many ClientBadges
     * const clientBadge = await prisma.clientBadge.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ClientBadges and only return the `id`
     * const clientBadgeWithIdOnly = await prisma.clientBadge.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClientBadgeUpdateManyAndReturnArgs>(args: SelectSubset<T, ClientBadgeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientBadgePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ClientBadge.
     * @param {ClientBadgeUpsertArgs} args - Arguments to update or create a ClientBadge.
     * @example
     * // Update or create a ClientBadge
     * const clientBadge = await prisma.clientBadge.upsert({
     *   create: {
     *     // ... data to create a ClientBadge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClientBadge we want to update
     *   }
     * })
     */
    upsert<T extends ClientBadgeUpsertArgs>(args: SelectSubset<T, ClientBadgeUpsertArgs<ExtArgs>>): Prisma__ClientBadgeClient<$Result.GetResult<Prisma.$ClientBadgePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClientBadges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientBadgeCountArgs} args - Arguments to filter ClientBadges to count.
     * @example
     * // Count the number of ClientBadges
     * const count = await prisma.clientBadge.count({
     *   where: {
     *     // ... the filter for the ClientBadges we want to count
     *   }
     * })
    **/
    count<T extends ClientBadgeCountArgs>(
      args?: Subset<T, ClientBadgeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientBadgeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClientBadge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientBadgeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientBadgeAggregateArgs>(args: Subset<T, ClientBadgeAggregateArgs>): Prisma.PrismaPromise<GetClientBadgeAggregateType<T>>

    /**
     * Group by ClientBadge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientBadgeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientBadgeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientBadgeGroupByArgs['orderBy'] }
        : { orderBy?: ClientBadgeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientBadgeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientBadgeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClientBadge model
   */
  readonly fields: ClientBadgeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClientBadge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientBadgeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    badge<T extends BadgeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BadgeDefaultArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClientBadge model
   */
  interface ClientBadgeFieldRefs {
    readonly id: FieldRef<"ClientBadge", 'String'>
    readonly clientId: FieldRef<"ClientBadge", 'String'>
    readonly badgeId: FieldRef<"ClientBadge", 'String'>
    readonly earnedAt: FieldRef<"ClientBadge", 'DateTime'>
    readonly notified: FieldRef<"ClientBadge", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * ClientBadge findUnique
   */
  export type ClientBadgeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientBadge
     */
    select?: ClientBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientBadge
     */
    omit?: ClientBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientBadgeInclude<ExtArgs> | null
    /**
     * Filter, which ClientBadge to fetch.
     */
    where: ClientBadgeWhereUniqueInput
  }

  /**
   * ClientBadge findUniqueOrThrow
   */
  export type ClientBadgeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientBadge
     */
    select?: ClientBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientBadge
     */
    omit?: ClientBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientBadgeInclude<ExtArgs> | null
    /**
     * Filter, which ClientBadge to fetch.
     */
    where: ClientBadgeWhereUniqueInput
  }

  /**
   * ClientBadge findFirst
   */
  export type ClientBadgeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientBadge
     */
    select?: ClientBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientBadge
     */
    omit?: ClientBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientBadgeInclude<ExtArgs> | null
    /**
     * Filter, which ClientBadge to fetch.
     */
    where?: ClientBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientBadges to fetch.
     */
    orderBy?: ClientBadgeOrderByWithRelationInput | ClientBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientBadges.
     */
    cursor?: ClientBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientBadges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientBadges.
     */
    distinct?: ClientBadgeScalarFieldEnum | ClientBadgeScalarFieldEnum[]
  }

  /**
   * ClientBadge findFirstOrThrow
   */
  export type ClientBadgeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientBadge
     */
    select?: ClientBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientBadge
     */
    omit?: ClientBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientBadgeInclude<ExtArgs> | null
    /**
     * Filter, which ClientBadge to fetch.
     */
    where?: ClientBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientBadges to fetch.
     */
    orderBy?: ClientBadgeOrderByWithRelationInput | ClientBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientBadges.
     */
    cursor?: ClientBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientBadges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientBadges.
     */
    distinct?: ClientBadgeScalarFieldEnum | ClientBadgeScalarFieldEnum[]
  }

  /**
   * ClientBadge findMany
   */
  export type ClientBadgeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientBadge
     */
    select?: ClientBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientBadge
     */
    omit?: ClientBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientBadgeInclude<ExtArgs> | null
    /**
     * Filter, which ClientBadges to fetch.
     */
    where?: ClientBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientBadges to fetch.
     */
    orderBy?: ClientBadgeOrderByWithRelationInput | ClientBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClientBadges.
     */
    cursor?: ClientBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientBadges.
     */
    skip?: number
    distinct?: ClientBadgeScalarFieldEnum | ClientBadgeScalarFieldEnum[]
  }

  /**
   * ClientBadge create
   */
  export type ClientBadgeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientBadge
     */
    select?: ClientBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientBadge
     */
    omit?: ClientBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientBadgeInclude<ExtArgs> | null
    /**
     * The data needed to create a ClientBadge.
     */
    data: XOR<ClientBadgeCreateInput, ClientBadgeUncheckedCreateInput>
  }

  /**
   * ClientBadge createMany
   */
  export type ClientBadgeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClientBadges.
     */
    data: ClientBadgeCreateManyInput | ClientBadgeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClientBadge createManyAndReturn
   */
  export type ClientBadgeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientBadge
     */
    select?: ClientBadgeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClientBadge
     */
    omit?: ClientBadgeOmit<ExtArgs> | null
    /**
     * The data used to create many ClientBadges.
     */
    data: ClientBadgeCreateManyInput | ClientBadgeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientBadgeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClientBadge update
   */
  export type ClientBadgeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientBadge
     */
    select?: ClientBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientBadge
     */
    omit?: ClientBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientBadgeInclude<ExtArgs> | null
    /**
     * The data needed to update a ClientBadge.
     */
    data: XOR<ClientBadgeUpdateInput, ClientBadgeUncheckedUpdateInput>
    /**
     * Choose, which ClientBadge to update.
     */
    where: ClientBadgeWhereUniqueInput
  }

  /**
   * ClientBadge updateMany
   */
  export type ClientBadgeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClientBadges.
     */
    data: XOR<ClientBadgeUpdateManyMutationInput, ClientBadgeUncheckedUpdateManyInput>
    /**
     * Filter which ClientBadges to update
     */
    where?: ClientBadgeWhereInput
    /**
     * Limit how many ClientBadges to update.
     */
    limit?: number
  }

  /**
   * ClientBadge updateManyAndReturn
   */
  export type ClientBadgeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientBadge
     */
    select?: ClientBadgeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClientBadge
     */
    omit?: ClientBadgeOmit<ExtArgs> | null
    /**
     * The data used to update ClientBadges.
     */
    data: XOR<ClientBadgeUpdateManyMutationInput, ClientBadgeUncheckedUpdateManyInput>
    /**
     * Filter which ClientBadges to update
     */
    where?: ClientBadgeWhereInput
    /**
     * Limit how many ClientBadges to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientBadgeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClientBadge upsert
   */
  export type ClientBadgeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientBadge
     */
    select?: ClientBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientBadge
     */
    omit?: ClientBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientBadgeInclude<ExtArgs> | null
    /**
     * The filter to search for the ClientBadge to update in case it exists.
     */
    where: ClientBadgeWhereUniqueInput
    /**
     * In case the ClientBadge found by the `where` argument doesn't exist, create a new ClientBadge with this data.
     */
    create: XOR<ClientBadgeCreateInput, ClientBadgeUncheckedCreateInput>
    /**
     * In case the ClientBadge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientBadgeUpdateInput, ClientBadgeUncheckedUpdateInput>
  }

  /**
   * ClientBadge delete
   */
  export type ClientBadgeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientBadge
     */
    select?: ClientBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientBadge
     */
    omit?: ClientBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientBadgeInclude<ExtArgs> | null
    /**
     * Filter which ClientBadge to delete.
     */
    where: ClientBadgeWhereUniqueInput
  }

  /**
   * ClientBadge deleteMany
   */
  export type ClientBadgeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientBadges to delete
     */
    where?: ClientBadgeWhereInput
    /**
     * Limit how many ClientBadges to delete.
     */
    limit?: number
  }

  /**
   * ClientBadge without action
   */
  export type ClientBadgeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientBadge
     */
    select?: ClientBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientBadge
     */
    omit?: ClientBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientBadgeInclude<ExtArgs> | null
  }


  /**
   * Model WorkoutTemplate
   */

  export type AggregateWorkoutTemplate = {
    _count: WorkoutTemplateCountAggregateOutputType | null
    _avg: WorkoutTemplateAvgAggregateOutputType | null
    _sum: WorkoutTemplateSumAggregateOutputType | null
    _min: WorkoutTemplateMinAggregateOutputType | null
    _max: WorkoutTemplateMaxAggregateOutputType | null
  }

  export type WorkoutTemplateAvgAggregateOutputType = {
    duration: number | null
    usageCount: number | null
  }

  export type WorkoutTemplateSumAggregateOutputType = {
    duration: number | null
    usageCount: number | null
  }

  export type WorkoutTemplateMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    description: string | null
    category: string | null
    difficulty: string | null
    duration: number | null
    isPublic: boolean | null
    usageCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkoutTemplateMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    description: string | null
    category: string | null
    difficulty: string | null
    duration: number | null
    isPublic: boolean | null
    usageCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkoutTemplateCountAggregateOutputType = {
    id: number
    tenantId: number
    name: number
    description: number
    category: number
    difficulty: number
    duration: number
    exercises: number
    muscleGroups: number
    equipment: number
    isPublic: number
    usageCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WorkoutTemplateAvgAggregateInputType = {
    duration?: true
    usageCount?: true
  }

  export type WorkoutTemplateSumAggregateInputType = {
    duration?: true
    usageCount?: true
  }

  export type WorkoutTemplateMinAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    description?: true
    category?: true
    difficulty?: true
    duration?: true
    isPublic?: true
    usageCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkoutTemplateMaxAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    description?: true
    category?: true
    difficulty?: true
    duration?: true
    isPublic?: true
    usageCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkoutTemplateCountAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    description?: true
    category?: true
    difficulty?: true
    duration?: true
    exercises?: true
    muscleGroups?: true
    equipment?: true
    isPublic?: true
    usageCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WorkoutTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkoutTemplate to aggregate.
     */
    where?: WorkoutTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkoutTemplates to fetch.
     */
    orderBy?: WorkoutTemplateOrderByWithRelationInput | WorkoutTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkoutTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkoutTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkoutTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkoutTemplates
    **/
    _count?: true | WorkoutTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkoutTemplateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkoutTemplateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkoutTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkoutTemplateMaxAggregateInputType
  }

  export type GetWorkoutTemplateAggregateType<T extends WorkoutTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkoutTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkoutTemplate[P]>
      : GetScalarType<T[P], AggregateWorkoutTemplate[P]>
  }




  export type WorkoutTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkoutTemplateWhereInput
    orderBy?: WorkoutTemplateOrderByWithAggregationInput | WorkoutTemplateOrderByWithAggregationInput[]
    by: WorkoutTemplateScalarFieldEnum[] | WorkoutTemplateScalarFieldEnum
    having?: WorkoutTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkoutTemplateCountAggregateInputType | true
    _avg?: WorkoutTemplateAvgAggregateInputType
    _sum?: WorkoutTemplateSumAggregateInputType
    _min?: WorkoutTemplateMinAggregateInputType
    _max?: WorkoutTemplateMaxAggregateInputType
  }

  export type WorkoutTemplateGroupByOutputType = {
    id: string
    tenantId: string
    name: string
    description: string | null
    category: string
    difficulty: string
    duration: number
    exercises: JsonValue[]
    muscleGroups: string[]
    equipment: string[]
    isPublic: boolean
    usageCount: number
    createdAt: Date
    updatedAt: Date
    _count: WorkoutTemplateCountAggregateOutputType | null
    _avg: WorkoutTemplateAvgAggregateOutputType | null
    _sum: WorkoutTemplateSumAggregateOutputType | null
    _min: WorkoutTemplateMinAggregateOutputType | null
    _max: WorkoutTemplateMaxAggregateOutputType | null
  }

  type GetWorkoutTemplateGroupByPayload<T extends WorkoutTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkoutTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkoutTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkoutTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], WorkoutTemplateGroupByOutputType[P]>
        }
      >
    >


  export type WorkoutTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    difficulty?: boolean
    duration?: boolean
    exercises?: boolean
    muscleGroups?: boolean
    equipment?: boolean
    isPublic?: boolean
    usageCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workoutTemplate"]>

  export type WorkoutTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    difficulty?: boolean
    duration?: boolean
    exercises?: boolean
    muscleGroups?: boolean
    equipment?: boolean
    isPublic?: boolean
    usageCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workoutTemplate"]>

  export type WorkoutTemplateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    difficulty?: boolean
    duration?: boolean
    exercises?: boolean
    muscleGroups?: boolean
    equipment?: boolean
    isPublic?: boolean
    usageCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workoutTemplate"]>

  export type WorkoutTemplateSelectScalar = {
    id?: boolean
    tenantId?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    difficulty?: boolean
    duration?: boolean
    exercises?: boolean
    muscleGroups?: boolean
    equipment?: boolean
    isPublic?: boolean
    usageCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WorkoutTemplateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "name" | "description" | "category" | "difficulty" | "duration" | "exercises" | "muscleGroups" | "equipment" | "isPublic" | "usageCount" | "createdAt" | "updatedAt", ExtArgs["result"]["workoutTemplate"]>
  export type WorkoutTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type WorkoutTemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type WorkoutTemplateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $WorkoutTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkoutTemplate"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      name: string
      description: string | null
      category: string
      difficulty: string
      duration: number
      exercises: Prisma.JsonValue[]
      muscleGroups: string[]
      equipment: string[]
      isPublic: boolean
      usageCount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["workoutTemplate"]>
    composites: {}
  }

  type WorkoutTemplateGetPayload<S extends boolean | null | undefined | WorkoutTemplateDefaultArgs> = $Result.GetResult<Prisma.$WorkoutTemplatePayload, S>

  type WorkoutTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkoutTemplateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkoutTemplateCountAggregateInputType | true
    }

  export interface WorkoutTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkoutTemplate'], meta: { name: 'WorkoutTemplate' } }
    /**
     * Find zero or one WorkoutTemplate that matches the filter.
     * @param {WorkoutTemplateFindUniqueArgs} args - Arguments to find a WorkoutTemplate
     * @example
     * // Get one WorkoutTemplate
     * const workoutTemplate = await prisma.workoutTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkoutTemplateFindUniqueArgs>(args: SelectSubset<T, WorkoutTemplateFindUniqueArgs<ExtArgs>>): Prisma__WorkoutTemplateClient<$Result.GetResult<Prisma.$WorkoutTemplatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WorkoutTemplate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkoutTemplateFindUniqueOrThrowArgs} args - Arguments to find a WorkoutTemplate
     * @example
     * // Get one WorkoutTemplate
     * const workoutTemplate = await prisma.workoutTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkoutTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkoutTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkoutTemplateClient<$Result.GetResult<Prisma.$WorkoutTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkoutTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutTemplateFindFirstArgs} args - Arguments to find a WorkoutTemplate
     * @example
     * // Get one WorkoutTemplate
     * const workoutTemplate = await prisma.workoutTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkoutTemplateFindFirstArgs>(args?: SelectSubset<T, WorkoutTemplateFindFirstArgs<ExtArgs>>): Prisma__WorkoutTemplateClient<$Result.GetResult<Prisma.$WorkoutTemplatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkoutTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutTemplateFindFirstOrThrowArgs} args - Arguments to find a WorkoutTemplate
     * @example
     * // Get one WorkoutTemplate
     * const workoutTemplate = await prisma.workoutTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkoutTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkoutTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkoutTemplateClient<$Result.GetResult<Prisma.$WorkoutTemplatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WorkoutTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkoutTemplates
     * const workoutTemplates = await prisma.workoutTemplate.findMany()
     * 
     * // Get first 10 WorkoutTemplates
     * const workoutTemplates = await prisma.workoutTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workoutTemplateWithIdOnly = await prisma.workoutTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkoutTemplateFindManyArgs>(args?: SelectSubset<T, WorkoutTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkoutTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WorkoutTemplate.
     * @param {WorkoutTemplateCreateArgs} args - Arguments to create a WorkoutTemplate.
     * @example
     * // Create one WorkoutTemplate
     * const WorkoutTemplate = await prisma.workoutTemplate.create({
     *   data: {
     *     // ... data to create a WorkoutTemplate
     *   }
     * })
     * 
     */
    create<T extends WorkoutTemplateCreateArgs>(args: SelectSubset<T, WorkoutTemplateCreateArgs<ExtArgs>>): Prisma__WorkoutTemplateClient<$Result.GetResult<Prisma.$WorkoutTemplatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WorkoutTemplates.
     * @param {WorkoutTemplateCreateManyArgs} args - Arguments to create many WorkoutTemplates.
     * @example
     * // Create many WorkoutTemplates
     * const workoutTemplate = await prisma.workoutTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkoutTemplateCreateManyArgs>(args?: SelectSubset<T, WorkoutTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkoutTemplates and returns the data saved in the database.
     * @param {WorkoutTemplateCreateManyAndReturnArgs} args - Arguments to create many WorkoutTemplates.
     * @example
     * // Create many WorkoutTemplates
     * const workoutTemplate = await prisma.workoutTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkoutTemplates and only return the `id`
     * const workoutTemplateWithIdOnly = await prisma.workoutTemplate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkoutTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkoutTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkoutTemplatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WorkoutTemplate.
     * @param {WorkoutTemplateDeleteArgs} args - Arguments to delete one WorkoutTemplate.
     * @example
     * // Delete one WorkoutTemplate
     * const WorkoutTemplate = await prisma.workoutTemplate.delete({
     *   where: {
     *     // ... filter to delete one WorkoutTemplate
     *   }
     * })
     * 
     */
    delete<T extends WorkoutTemplateDeleteArgs>(args: SelectSubset<T, WorkoutTemplateDeleteArgs<ExtArgs>>): Prisma__WorkoutTemplateClient<$Result.GetResult<Prisma.$WorkoutTemplatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WorkoutTemplate.
     * @param {WorkoutTemplateUpdateArgs} args - Arguments to update one WorkoutTemplate.
     * @example
     * // Update one WorkoutTemplate
     * const workoutTemplate = await prisma.workoutTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkoutTemplateUpdateArgs>(args: SelectSubset<T, WorkoutTemplateUpdateArgs<ExtArgs>>): Prisma__WorkoutTemplateClient<$Result.GetResult<Prisma.$WorkoutTemplatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WorkoutTemplates.
     * @param {WorkoutTemplateDeleteManyArgs} args - Arguments to filter WorkoutTemplates to delete.
     * @example
     * // Delete a few WorkoutTemplates
     * const { count } = await prisma.workoutTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkoutTemplateDeleteManyArgs>(args?: SelectSubset<T, WorkoutTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkoutTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkoutTemplates
     * const workoutTemplate = await prisma.workoutTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkoutTemplateUpdateManyArgs>(args: SelectSubset<T, WorkoutTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkoutTemplates and returns the data updated in the database.
     * @param {WorkoutTemplateUpdateManyAndReturnArgs} args - Arguments to update many WorkoutTemplates.
     * @example
     * // Update many WorkoutTemplates
     * const workoutTemplate = await prisma.workoutTemplate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WorkoutTemplates and only return the `id`
     * const workoutTemplateWithIdOnly = await prisma.workoutTemplate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkoutTemplateUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkoutTemplateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkoutTemplatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WorkoutTemplate.
     * @param {WorkoutTemplateUpsertArgs} args - Arguments to update or create a WorkoutTemplate.
     * @example
     * // Update or create a WorkoutTemplate
     * const workoutTemplate = await prisma.workoutTemplate.upsert({
     *   create: {
     *     // ... data to create a WorkoutTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkoutTemplate we want to update
     *   }
     * })
     */
    upsert<T extends WorkoutTemplateUpsertArgs>(args: SelectSubset<T, WorkoutTemplateUpsertArgs<ExtArgs>>): Prisma__WorkoutTemplateClient<$Result.GetResult<Prisma.$WorkoutTemplatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WorkoutTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutTemplateCountArgs} args - Arguments to filter WorkoutTemplates to count.
     * @example
     * // Count the number of WorkoutTemplates
     * const count = await prisma.workoutTemplate.count({
     *   where: {
     *     // ... the filter for the WorkoutTemplates we want to count
     *   }
     * })
    **/
    count<T extends WorkoutTemplateCountArgs>(
      args?: Subset<T, WorkoutTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkoutTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkoutTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkoutTemplateAggregateArgs>(args: Subset<T, WorkoutTemplateAggregateArgs>): Prisma.PrismaPromise<GetWorkoutTemplateAggregateType<T>>

    /**
     * Group by WorkoutTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkoutTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkoutTemplateGroupByArgs['orderBy'] }
        : { orderBy?: WorkoutTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkoutTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkoutTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkoutTemplate model
   */
  readonly fields: WorkoutTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkoutTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkoutTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkoutTemplate model
   */
  interface WorkoutTemplateFieldRefs {
    readonly id: FieldRef<"WorkoutTemplate", 'String'>
    readonly tenantId: FieldRef<"WorkoutTemplate", 'String'>
    readonly name: FieldRef<"WorkoutTemplate", 'String'>
    readonly description: FieldRef<"WorkoutTemplate", 'String'>
    readonly category: FieldRef<"WorkoutTemplate", 'String'>
    readonly difficulty: FieldRef<"WorkoutTemplate", 'String'>
    readonly duration: FieldRef<"WorkoutTemplate", 'Int'>
    readonly exercises: FieldRef<"WorkoutTemplate", 'Json[]'>
    readonly muscleGroups: FieldRef<"WorkoutTemplate", 'String[]'>
    readonly equipment: FieldRef<"WorkoutTemplate", 'String[]'>
    readonly isPublic: FieldRef<"WorkoutTemplate", 'Boolean'>
    readonly usageCount: FieldRef<"WorkoutTemplate", 'Int'>
    readonly createdAt: FieldRef<"WorkoutTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"WorkoutTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WorkoutTemplate findUnique
   */
  export type WorkoutTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutTemplate
     */
    select?: WorkoutTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutTemplate
     */
    omit?: WorkoutTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutTemplateInclude<ExtArgs> | null
    /**
     * Filter, which WorkoutTemplate to fetch.
     */
    where: WorkoutTemplateWhereUniqueInput
  }

  /**
   * WorkoutTemplate findUniqueOrThrow
   */
  export type WorkoutTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutTemplate
     */
    select?: WorkoutTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutTemplate
     */
    omit?: WorkoutTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutTemplateInclude<ExtArgs> | null
    /**
     * Filter, which WorkoutTemplate to fetch.
     */
    where: WorkoutTemplateWhereUniqueInput
  }

  /**
   * WorkoutTemplate findFirst
   */
  export type WorkoutTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutTemplate
     */
    select?: WorkoutTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutTemplate
     */
    omit?: WorkoutTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutTemplateInclude<ExtArgs> | null
    /**
     * Filter, which WorkoutTemplate to fetch.
     */
    where?: WorkoutTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkoutTemplates to fetch.
     */
    orderBy?: WorkoutTemplateOrderByWithRelationInput | WorkoutTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkoutTemplates.
     */
    cursor?: WorkoutTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkoutTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkoutTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkoutTemplates.
     */
    distinct?: WorkoutTemplateScalarFieldEnum | WorkoutTemplateScalarFieldEnum[]
  }

  /**
   * WorkoutTemplate findFirstOrThrow
   */
  export type WorkoutTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutTemplate
     */
    select?: WorkoutTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutTemplate
     */
    omit?: WorkoutTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutTemplateInclude<ExtArgs> | null
    /**
     * Filter, which WorkoutTemplate to fetch.
     */
    where?: WorkoutTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkoutTemplates to fetch.
     */
    orderBy?: WorkoutTemplateOrderByWithRelationInput | WorkoutTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkoutTemplates.
     */
    cursor?: WorkoutTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkoutTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkoutTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkoutTemplates.
     */
    distinct?: WorkoutTemplateScalarFieldEnum | WorkoutTemplateScalarFieldEnum[]
  }

  /**
   * WorkoutTemplate findMany
   */
  export type WorkoutTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutTemplate
     */
    select?: WorkoutTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutTemplate
     */
    omit?: WorkoutTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutTemplateInclude<ExtArgs> | null
    /**
     * Filter, which WorkoutTemplates to fetch.
     */
    where?: WorkoutTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkoutTemplates to fetch.
     */
    orderBy?: WorkoutTemplateOrderByWithRelationInput | WorkoutTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkoutTemplates.
     */
    cursor?: WorkoutTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkoutTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkoutTemplates.
     */
    skip?: number
    distinct?: WorkoutTemplateScalarFieldEnum | WorkoutTemplateScalarFieldEnum[]
  }

  /**
   * WorkoutTemplate create
   */
  export type WorkoutTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutTemplate
     */
    select?: WorkoutTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutTemplate
     */
    omit?: WorkoutTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkoutTemplate.
     */
    data: XOR<WorkoutTemplateCreateInput, WorkoutTemplateUncheckedCreateInput>
  }

  /**
   * WorkoutTemplate createMany
   */
  export type WorkoutTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkoutTemplates.
     */
    data: WorkoutTemplateCreateManyInput | WorkoutTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkoutTemplate createManyAndReturn
   */
  export type WorkoutTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutTemplate
     */
    select?: WorkoutTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutTemplate
     */
    omit?: WorkoutTemplateOmit<ExtArgs> | null
    /**
     * The data used to create many WorkoutTemplates.
     */
    data: WorkoutTemplateCreateManyInput | WorkoutTemplateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutTemplateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkoutTemplate update
   */
  export type WorkoutTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutTemplate
     */
    select?: WorkoutTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutTemplate
     */
    omit?: WorkoutTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkoutTemplate.
     */
    data: XOR<WorkoutTemplateUpdateInput, WorkoutTemplateUncheckedUpdateInput>
    /**
     * Choose, which WorkoutTemplate to update.
     */
    where: WorkoutTemplateWhereUniqueInput
  }

  /**
   * WorkoutTemplate updateMany
   */
  export type WorkoutTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkoutTemplates.
     */
    data: XOR<WorkoutTemplateUpdateManyMutationInput, WorkoutTemplateUncheckedUpdateManyInput>
    /**
     * Filter which WorkoutTemplates to update
     */
    where?: WorkoutTemplateWhereInput
    /**
     * Limit how many WorkoutTemplates to update.
     */
    limit?: number
  }

  /**
   * WorkoutTemplate updateManyAndReturn
   */
  export type WorkoutTemplateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutTemplate
     */
    select?: WorkoutTemplateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutTemplate
     */
    omit?: WorkoutTemplateOmit<ExtArgs> | null
    /**
     * The data used to update WorkoutTemplates.
     */
    data: XOR<WorkoutTemplateUpdateManyMutationInput, WorkoutTemplateUncheckedUpdateManyInput>
    /**
     * Filter which WorkoutTemplates to update
     */
    where?: WorkoutTemplateWhereInput
    /**
     * Limit how many WorkoutTemplates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutTemplateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkoutTemplate upsert
   */
  export type WorkoutTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutTemplate
     */
    select?: WorkoutTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutTemplate
     */
    omit?: WorkoutTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkoutTemplate to update in case it exists.
     */
    where: WorkoutTemplateWhereUniqueInput
    /**
     * In case the WorkoutTemplate found by the `where` argument doesn't exist, create a new WorkoutTemplate with this data.
     */
    create: XOR<WorkoutTemplateCreateInput, WorkoutTemplateUncheckedCreateInput>
    /**
     * In case the WorkoutTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkoutTemplateUpdateInput, WorkoutTemplateUncheckedUpdateInput>
  }

  /**
   * WorkoutTemplate delete
   */
  export type WorkoutTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutTemplate
     */
    select?: WorkoutTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutTemplate
     */
    omit?: WorkoutTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutTemplateInclude<ExtArgs> | null
    /**
     * Filter which WorkoutTemplate to delete.
     */
    where: WorkoutTemplateWhereUniqueInput
  }

  /**
   * WorkoutTemplate deleteMany
   */
  export type WorkoutTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkoutTemplates to delete
     */
    where?: WorkoutTemplateWhereInput
    /**
     * Limit how many WorkoutTemplates to delete.
     */
    limit?: number
  }

  /**
   * WorkoutTemplate without action
   */
  export type WorkoutTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutTemplate
     */
    select?: WorkoutTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkoutTemplate
     */
    omit?: WorkoutTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutTemplateInclude<ExtArgs> | null
  }


  /**
   * Model ScheduleTemplate
   */

  export type AggregateScheduleTemplate = {
    _count: ScheduleTemplateCountAggregateOutputType | null
    _min: ScheduleTemplateMinAggregateOutputType | null
    _max: ScheduleTemplateMaxAggregateOutputType | null
  }

  export type ScheduleTemplateMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScheduleTemplateMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScheduleTemplateCountAggregateOutputType = {
    id: number
    tenantId: number
    name: number
    description: number
    slots: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ScheduleTemplateMinAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScheduleTemplateMaxAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScheduleTemplateCountAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    description?: true
    slots?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ScheduleTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScheduleTemplate to aggregate.
     */
    where?: ScheduleTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduleTemplates to fetch.
     */
    orderBy?: ScheduleTemplateOrderByWithRelationInput | ScheduleTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScheduleTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduleTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduleTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ScheduleTemplates
    **/
    _count?: true | ScheduleTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScheduleTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScheduleTemplateMaxAggregateInputType
  }

  export type GetScheduleTemplateAggregateType<T extends ScheduleTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateScheduleTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScheduleTemplate[P]>
      : GetScalarType<T[P], AggregateScheduleTemplate[P]>
  }




  export type ScheduleTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleTemplateWhereInput
    orderBy?: ScheduleTemplateOrderByWithAggregationInput | ScheduleTemplateOrderByWithAggregationInput[]
    by: ScheduleTemplateScalarFieldEnum[] | ScheduleTemplateScalarFieldEnum
    having?: ScheduleTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScheduleTemplateCountAggregateInputType | true
    _min?: ScheduleTemplateMinAggregateInputType
    _max?: ScheduleTemplateMaxAggregateInputType
  }

  export type ScheduleTemplateGroupByOutputType = {
    id: string
    tenantId: string
    name: string
    description: string | null
    slots: JsonValue[]
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ScheduleTemplateCountAggregateOutputType | null
    _min: ScheduleTemplateMinAggregateOutputType | null
    _max: ScheduleTemplateMaxAggregateOutputType | null
  }

  type GetScheduleTemplateGroupByPayload<T extends ScheduleTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScheduleTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScheduleTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScheduleTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], ScheduleTemplateGroupByOutputType[P]>
        }
      >
    >


  export type ScheduleTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    description?: boolean
    slots?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scheduleTemplate"]>

  export type ScheduleTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    description?: boolean
    slots?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scheduleTemplate"]>

  export type ScheduleTemplateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    description?: boolean
    slots?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scheduleTemplate"]>

  export type ScheduleTemplateSelectScalar = {
    id?: boolean
    tenantId?: boolean
    name?: boolean
    description?: boolean
    slots?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ScheduleTemplateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "name" | "description" | "slots" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["scheduleTemplate"]>
  export type ScheduleTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type ScheduleTemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type ScheduleTemplateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $ScheduleTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ScheduleTemplate"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      name: string
      description: string | null
      slots: Prisma.JsonValue[]
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["scheduleTemplate"]>
    composites: {}
  }

  type ScheduleTemplateGetPayload<S extends boolean | null | undefined | ScheduleTemplateDefaultArgs> = $Result.GetResult<Prisma.$ScheduleTemplatePayload, S>

  type ScheduleTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ScheduleTemplateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ScheduleTemplateCountAggregateInputType | true
    }

  export interface ScheduleTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ScheduleTemplate'], meta: { name: 'ScheduleTemplate' } }
    /**
     * Find zero or one ScheduleTemplate that matches the filter.
     * @param {ScheduleTemplateFindUniqueArgs} args - Arguments to find a ScheduleTemplate
     * @example
     * // Get one ScheduleTemplate
     * const scheduleTemplate = await prisma.scheduleTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScheduleTemplateFindUniqueArgs>(args: SelectSubset<T, ScheduleTemplateFindUniqueArgs<ExtArgs>>): Prisma__ScheduleTemplateClient<$Result.GetResult<Prisma.$ScheduleTemplatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ScheduleTemplate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ScheduleTemplateFindUniqueOrThrowArgs} args - Arguments to find a ScheduleTemplate
     * @example
     * // Get one ScheduleTemplate
     * const scheduleTemplate = await prisma.scheduleTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScheduleTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, ScheduleTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScheduleTemplateClient<$Result.GetResult<Prisma.$ScheduleTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ScheduleTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleTemplateFindFirstArgs} args - Arguments to find a ScheduleTemplate
     * @example
     * // Get one ScheduleTemplate
     * const scheduleTemplate = await prisma.scheduleTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScheduleTemplateFindFirstArgs>(args?: SelectSubset<T, ScheduleTemplateFindFirstArgs<ExtArgs>>): Prisma__ScheduleTemplateClient<$Result.GetResult<Prisma.$ScheduleTemplatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ScheduleTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleTemplateFindFirstOrThrowArgs} args - Arguments to find a ScheduleTemplate
     * @example
     * // Get one ScheduleTemplate
     * const scheduleTemplate = await prisma.scheduleTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScheduleTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, ScheduleTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScheduleTemplateClient<$Result.GetResult<Prisma.$ScheduleTemplatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ScheduleTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ScheduleTemplates
     * const scheduleTemplates = await prisma.scheduleTemplate.findMany()
     * 
     * // Get first 10 ScheduleTemplates
     * const scheduleTemplates = await prisma.scheduleTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scheduleTemplateWithIdOnly = await prisma.scheduleTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScheduleTemplateFindManyArgs>(args?: SelectSubset<T, ScheduleTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduleTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ScheduleTemplate.
     * @param {ScheduleTemplateCreateArgs} args - Arguments to create a ScheduleTemplate.
     * @example
     * // Create one ScheduleTemplate
     * const ScheduleTemplate = await prisma.scheduleTemplate.create({
     *   data: {
     *     // ... data to create a ScheduleTemplate
     *   }
     * })
     * 
     */
    create<T extends ScheduleTemplateCreateArgs>(args: SelectSubset<T, ScheduleTemplateCreateArgs<ExtArgs>>): Prisma__ScheduleTemplateClient<$Result.GetResult<Prisma.$ScheduleTemplatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ScheduleTemplates.
     * @param {ScheduleTemplateCreateManyArgs} args - Arguments to create many ScheduleTemplates.
     * @example
     * // Create many ScheduleTemplates
     * const scheduleTemplate = await prisma.scheduleTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScheduleTemplateCreateManyArgs>(args?: SelectSubset<T, ScheduleTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ScheduleTemplates and returns the data saved in the database.
     * @param {ScheduleTemplateCreateManyAndReturnArgs} args - Arguments to create many ScheduleTemplates.
     * @example
     * // Create many ScheduleTemplates
     * const scheduleTemplate = await prisma.scheduleTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ScheduleTemplates and only return the `id`
     * const scheduleTemplateWithIdOnly = await prisma.scheduleTemplate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ScheduleTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, ScheduleTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduleTemplatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ScheduleTemplate.
     * @param {ScheduleTemplateDeleteArgs} args - Arguments to delete one ScheduleTemplate.
     * @example
     * // Delete one ScheduleTemplate
     * const ScheduleTemplate = await prisma.scheduleTemplate.delete({
     *   where: {
     *     // ... filter to delete one ScheduleTemplate
     *   }
     * })
     * 
     */
    delete<T extends ScheduleTemplateDeleteArgs>(args: SelectSubset<T, ScheduleTemplateDeleteArgs<ExtArgs>>): Prisma__ScheduleTemplateClient<$Result.GetResult<Prisma.$ScheduleTemplatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ScheduleTemplate.
     * @param {ScheduleTemplateUpdateArgs} args - Arguments to update one ScheduleTemplate.
     * @example
     * // Update one ScheduleTemplate
     * const scheduleTemplate = await prisma.scheduleTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScheduleTemplateUpdateArgs>(args: SelectSubset<T, ScheduleTemplateUpdateArgs<ExtArgs>>): Prisma__ScheduleTemplateClient<$Result.GetResult<Prisma.$ScheduleTemplatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ScheduleTemplates.
     * @param {ScheduleTemplateDeleteManyArgs} args - Arguments to filter ScheduleTemplates to delete.
     * @example
     * // Delete a few ScheduleTemplates
     * const { count } = await prisma.scheduleTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScheduleTemplateDeleteManyArgs>(args?: SelectSubset<T, ScheduleTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScheduleTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ScheduleTemplates
     * const scheduleTemplate = await prisma.scheduleTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScheduleTemplateUpdateManyArgs>(args: SelectSubset<T, ScheduleTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScheduleTemplates and returns the data updated in the database.
     * @param {ScheduleTemplateUpdateManyAndReturnArgs} args - Arguments to update many ScheduleTemplates.
     * @example
     * // Update many ScheduleTemplates
     * const scheduleTemplate = await prisma.scheduleTemplate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ScheduleTemplates and only return the `id`
     * const scheduleTemplateWithIdOnly = await prisma.scheduleTemplate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ScheduleTemplateUpdateManyAndReturnArgs>(args: SelectSubset<T, ScheduleTemplateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduleTemplatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ScheduleTemplate.
     * @param {ScheduleTemplateUpsertArgs} args - Arguments to update or create a ScheduleTemplate.
     * @example
     * // Update or create a ScheduleTemplate
     * const scheduleTemplate = await prisma.scheduleTemplate.upsert({
     *   create: {
     *     // ... data to create a ScheduleTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ScheduleTemplate we want to update
     *   }
     * })
     */
    upsert<T extends ScheduleTemplateUpsertArgs>(args: SelectSubset<T, ScheduleTemplateUpsertArgs<ExtArgs>>): Prisma__ScheduleTemplateClient<$Result.GetResult<Prisma.$ScheduleTemplatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ScheduleTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleTemplateCountArgs} args - Arguments to filter ScheduleTemplates to count.
     * @example
     * // Count the number of ScheduleTemplates
     * const count = await prisma.scheduleTemplate.count({
     *   where: {
     *     // ... the filter for the ScheduleTemplates we want to count
     *   }
     * })
    **/
    count<T extends ScheduleTemplateCountArgs>(
      args?: Subset<T, ScheduleTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScheduleTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ScheduleTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScheduleTemplateAggregateArgs>(args: Subset<T, ScheduleTemplateAggregateArgs>): Prisma.PrismaPromise<GetScheduleTemplateAggregateType<T>>

    /**
     * Group by ScheduleTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScheduleTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScheduleTemplateGroupByArgs['orderBy'] }
        : { orderBy?: ScheduleTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScheduleTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScheduleTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ScheduleTemplate model
   */
  readonly fields: ScheduleTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ScheduleTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScheduleTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ScheduleTemplate model
   */
  interface ScheduleTemplateFieldRefs {
    readonly id: FieldRef<"ScheduleTemplate", 'String'>
    readonly tenantId: FieldRef<"ScheduleTemplate", 'String'>
    readonly name: FieldRef<"ScheduleTemplate", 'String'>
    readonly description: FieldRef<"ScheduleTemplate", 'String'>
    readonly slots: FieldRef<"ScheduleTemplate", 'Json[]'>
    readonly isActive: FieldRef<"ScheduleTemplate", 'Boolean'>
    readonly createdAt: FieldRef<"ScheduleTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"ScheduleTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ScheduleTemplate findUnique
   */
  export type ScheduleTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleTemplate
     */
    select?: ScheduleTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleTemplate
     */
    omit?: ScheduleTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ScheduleTemplate to fetch.
     */
    where: ScheduleTemplateWhereUniqueInput
  }

  /**
   * ScheduleTemplate findUniqueOrThrow
   */
  export type ScheduleTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleTemplate
     */
    select?: ScheduleTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleTemplate
     */
    omit?: ScheduleTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ScheduleTemplate to fetch.
     */
    where: ScheduleTemplateWhereUniqueInput
  }

  /**
   * ScheduleTemplate findFirst
   */
  export type ScheduleTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleTemplate
     */
    select?: ScheduleTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleTemplate
     */
    omit?: ScheduleTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ScheduleTemplate to fetch.
     */
    where?: ScheduleTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduleTemplates to fetch.
     */
    orderBy?: ScheduleTemplateOrderByWithRelationInput | ScheduleTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScheduleTemplates.
     */
    cursor?: ScheduleTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduleTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduleTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScheduleTemplates.
     */
    distinct?: ScheduleTemplateScalarFieldEnum | ScheduleTemplateScalarFieldEnum[]
  }

  /**
   * ScheduleTemplate findFirstOrThrow
   */
  export type ScheduleTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleTemplate
     */
    select?: ScheduleTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleTemplate
     */
    omit?: ScheduleTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ScheduleTemplate to fetch.
     */
    where?: ScheduleTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduleTemplates to fetch.
     */
    orderBy?: ScheduleTemplateOrderByWithRelationInput | ScheduleTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScheduleTemplates.
     */
    cursor?: ScheduleTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduleTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduleTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScheduleTemplates.
     */
    distinct?: ScheduleTemplateScalarFieldEnum | ScheduleTemplateScalarFieldEnum[]
  }

  /**
   * ScheduleTemplate findMany
   */
  export type ScheduleTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleTemplate
     */
    select?: ScheduleTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleTemplate
     */
    omit?: ScheduleTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ScheduleTemplates to fetch.
     */
    where?: ScheduleTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduleTemplates to fetch.
     */
    orderBy?: ScheduleTemplateOrderByWithRelationInput | ScheduleTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ScheduleTemplates.
     */
    cursor?: ScheduleTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduleTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduleTemplates.
     */
    skip?: number
    distinct?: ScheduleTemplateScalarFieldEnum | ScheduleTemplateScalarFieldEnum[]
  }

  /**
   * ScheduleTemplate create
   */
  export type ScheduleTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleTemplate
     */
    select?: ScheduleTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleTemplate
     */
    omit?: ScheduleTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a ScheduleTemplate.
     */
    data: XOR<ScheduleTemplateCreateInput, ScheduleTemplateUncheckedCreateInput>
  }

  /**
   * ScheduleTemplate createMany
   */
  export type ScheduleTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ScheduleTemplates.
     */
    data: ScheduleTemplateCreateManyInput | ScheduleTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ScheduleTemplate createManyAndReturn
   */
  export type ScheduleTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleTemplate
     */
    select?: ScheduleTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleTemplate
     */
    omit?: ScheduleTemplateOmit<ExtArgs> | null
    /**
     * The data used to create many ScheduleTemplates.
     */
    data: ScheduleTemplateCreateManyInput | ScheduleTemplateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleTemplateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ScheduleTemplate update
   */
  export type ScheduleTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleTemplate
     */
    select?: ScheduleTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleTemplate
     */
    omit?: ScheduleTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a ScheduleTemplate.
     */
    data: XOR<ScheduleTemplateUpdateInput, ScheduleTemplateUncheckedUpdateInput>
    /**
     * Choose, which ScheduleTemplate to update.
     */
    where: ScheduleTemplateWhereUniqueInput
  }

  /**
   * ScheduleTemplate updateMany
   */
  export type ScheduleTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ScheduleTemplates.
     */
    data: XOR<ScheduleTemplateUpdateManyMutationInput, ScheduleTemplateUncheckedUpdateManyInput>
    /**
     * Filter which ScheduleTemplates to update
     */
    where?: ScheduleTemplateWhereInput
    /**
     * Limit how many ScheduleTemplates to update.
     */
    limit?: number
  }

  /**
   * ScheduleTemplate updateManyAndReturn
   */
  export type ScheduleTemplateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleTemplate
     */
    select?: ScheduleTemplateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleTemplate
     */
    omit?: ScheduleTemplateOmit<ExtArgs> | null
    /**
     * The data used to update ScheduleTemplates.
     */
    data: XOR<ScheduleTemplateUpdateManyMutationInput, ScheduleTemplateUncheckedUpdateManyInput>
    /**
     * Filter which ScheduleTemplates to update
     */
    where?: ScheduleTemplateWhereInput
    /**
     * Limit how many ScheduleTemplates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleTemplateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ScheduleTemplate upsert
   */
  export type ScheduleTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleTemplate
     */
    select?: ScheduleTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleTemplate
     */
    omit?: ScheduleTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the ScheduleTemplate to update in case it exists.
     */
    where: ScheduleTemplateWhereUniqueInput
    /**
     * In case the ScheduleTemplate found by the `where` argument doesn't exist, create a new ScheduleTemplate with this data.
     */
    create: XOR<ScheduleTemplateCreateInput, ScheduleTemplateUncheckedCreateInput>
    /**
     * In case the ScheduleTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScheduleTemplateUpdateInput, ScheduleTemplateUncheckedUpdateInput>
  }

  /**
   * ScheduleTemplate delete
   */
  export type ScheduleTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleTemplate
     */
    select?: ScheduleTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleTemplate
     */
    omit?: ScheduleTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleTemplateInclude<ExtArgs> | null
    /**
     * Filter which ScheduleTemplate to delete.
     */
    where: ScheduleTemplateWhereUniqueInput
  }

  /**
   * ScheduleTemplate deleteMany
   */
  export type ScheduleTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScheduleTemplates to delete
     */
    where?: ScheduleTemplateWhereInput
    /**
     * Limit how many ScheduleTemplates to delete.
     */
    limit?: number
  }

  /**
   * ScheduleTemplate without action
   */
  export type ScheduleTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleTemplate
     */
    select?: ScheduleTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleTemplate
     */
    omit?: ScheduleTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleTemplateInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const TenantScalarFieldEnum: {
    id: 'id',
    vertical: 'vertical',
    name: 'name',
    slug: 'slug',
    email: 'email',
    phone: 'phone',
    website: 'website',
    logo: 'logo',
    subscriptionTier: 'subscriptionTier',
    aiCredits: 'aiCredits',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TenantScalarFieldEnum = (typeof TenantScalarFieldEnum)[keyof typeof TenantScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    name: 'name',
    email: 'email',
    emailVerified: 'emailVerified',
    image: 'image',
    password: 'password',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    expires_at: 'expires_at',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const UserSessionScalarFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    userId: 'userId',
    expires: 'expires'
  };

  export type UserSessionScalarFieldEnum = (typeof UserSessionScalarFieldEnum)[keyof typeof UserSessionScalarFieldEnum]


  export const VerificationTokenScalarFieldEnum: {
    identifier: 'identifier',
    token: 'token',
    expires: 'expires'
  };

  export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


  export const PasswordResetTokenScalarFieldEnum: {
    id: 'id',
    email: 'email',
    token: 'token',
    expires: 'expires',
    createdAt: 'createdAt'
  };

  export type PasswordResetTokenScalarFieldEnum = (typeof PasswordResetTokenScalarFieldEnum)[keyof typeof PasswordResetTokenScalarFieldEnum]


  export const ClientScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    name: 'name',
    email: 'email',
    phone: 'phone',
    avatar: 'avatar',
    dateOfBirth: 'dateOfBirth',
    gender: 'gender',
    goals: 'goals',
    currentWeight: 'currentWeight',
    targetWeight: 'targetWeight',
    height: 'height',
    bodyMeasurements: 'bodyMeasurements',
    bodyFatPercent: 'bodyFatPercent',
    fitnessLevel: 'fitnessLevel',
    injuryHistory: 'injuryHistory',
    dietaryNotes: 'dietaryNotes',
    medicalNotes: 'medicalNotes',
    creditsRemaining: 'creditsRemaining',
    membershipType: 'membershipType',
    membershipExpiry: 'membershipExpiry',
    status: 'status',
    tags: 'tags',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClientScalarFieldEnum = (typeof ClientScalarFieldEnum)[keyof typeof ClientScalarFieldEnum]


  export const ClientMeasurementScalarFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    date: 'date',
    weight: 'weight',
    bodyFat: 'bodyFat',
    measurements: 'measurements',
    notes: 'notes',
    createdAt: 'createdAt'
  };

  export type ClientMeasurementScalarFieldEnum = (typeof ClientMeasurementScalarFieldEnum)[keyof typeof ClientMeasurementScalarFieldEnum]


  export const ProgressPhotoScalarFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    url: 'url',
    date: 'date',
    view: 'view',
    notes: 'notes',
    createdAt: 'createdAt'
  };

  export type ProgressPhotoScalarFieldEnum = (typeof ProgressPhotoScalarFieldEnum)[keyof typeof ProgressPhotoScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    clientId: 'clientId',
    scheduledAt: 'scheduledAt',
    duration: 'duration',
    status: 'status',
    workoutPlan: 'workoutPlan',
    exercisesLogged: 'exercisesLogged',
    caloriesBurned: 'caloriesBurned',
    heartRateAvg: 'heartRateAvg',
    muscleGroups: 'muscleGroups',
    clientFeedback: 'clientFeedback',
    trainerNotes: 'trainerNotes',
    intensity: 'intensity',
    clientRating: 'clientRating',
    price: 'price',
    paid: 'paid',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const ClassScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    name: 'name',
    description: 'description',
    type: 'type',
    scheduledAt: 'scheduledAt',
    duration: 'duration',
    capacity: 'capacity',
    instructor: 'instructor',
    location: 'location',
    price: 'price',
    isRecurring: 'isRecurring',
    recurrence: 'recurrence',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClassScalarFieldEnum = (typeof ClassScalarFieldEnum)[keyof typeof ClassScalarFieldEnum]


  export const ClassBookingScalarFieldEnum: {
    id: 'id',
    classId: 'classId',
    clientId: 'clientId',
    status: 'status',
    checkedIn: 'checkedIn',
    paid: 'paid',
    createdAt: 'createdAt'
  };

  export type ClassBookingScalarFieldEnum = (typeof ClassBookingScalarFieldEnum)[keyof typeof ClassBookingScalarFieldEnum]


  export const PackageScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    name: 'name',
    description: 'description',
    type: 'type',
    price: 'price',
    credits: 'credits',
    validityDays: 'validityDays',
    features: 'features',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PackageScalarFieldEnum = (typeof PackageScalarFieldEnum)[keyof typeof PackageScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    clientId: 'clientId',
    orderNumber: 'orderNumber',
    status: 'status',
    items: 'items',
    subtotal: 'subtotal',
    tax: 'tax',
    discount: 'discount',
    total: 'total',
    paymentMethod: 'paymentMethod',
    paymentStatus: 'paymentStatus',
    paidAmount: 'paidAmount',
    orderDate: 'orderDate',
    dueDate: 'dueDate',
    paidDate: 'paidDate',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    orderId: 'orderId',
    clientId: 'clientId',
    invoiceNumber: 'invoiceNumber',
    status: 'status',
    issueDate: 'issueDate',
    dueDate: 'dueDate',
    paidDate: 'paidDate',
    subtotal: 'subtotal',
    tax: 'tax',
    total: 'total',
    paymentMethod: 'paymentMethod',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const AILogScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    feature: 'feature',
    model: 'model',
    promptTokens: 'promptTokens',
    completionTokens: 'completionTokens',
    totalTokens: 'totalTokens',
    estimatedCost: 'estimatedCost',
    input: 'input',
    output: 'output',
    latencyMs: 'latencyMs',
    success: 'success',
    error: 'error',
    createdAt: 'createdAt'
  };

  export type AILogScalarFieldEnum = (typeof AILogScalarFieldEnum)[keyof typeof AILogScalarFieldEnum]


  export const CurrencyScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    symbol: 'symbol',
    decimals: 'decimals',
    isCrypto: 'isCrypto',
    isStablecoin: 'isStablecoin',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CurrencyScalarFieldEnum = (typeof CurrencyScalarFieldEnum)[keyof typeof CurrencyScalarFieldEnum]


  export const ExchangeRateScalarFieldEnum: {
    id: 'id',
    fromCurrencyId: 'fromCurrencyId',
    toCurrencyId: 'toCurrencyId',
    rate: 'rate',
    source: 'source',
    timestamp: 'timestamp'
  };

  export type ExchangeRateScalarFieldEnum = (typeof ExchangeRateScalarFieldEnum)[keyof typeof ExchangeRateScalarFieldEnum]


  export const BankAccountScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    accountName: 'accountName',
    accountNumber: 'accountNumber',
    bankCode: 'bankCode',
    iban: 'iban',
    swift: 'swift',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    currency: 'currency',
    balance: 'balance',
    balanceUpdatedAt: 'balanceUpdatedAt',
    autoSync: 'autoSync',
    lastSyncAt: 'lastSyncAt',
    syncFrequency: 'syncFrequency',
    credentials: 'credentials',
    isActive: 'isActive',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BankAccountScalarFieldEnum = (typeof BankAccountScalarFieldEnum)[keyof typeof BankAccountScalarFieldEnum]


  export const BankTransactionScalarFieldEnum: {
    id: 'id',
    bankAccountId: 'bankAccountId',
    tenantId: 'tenantId',
    transactionId: 'transactionId',
    date: 'date',
    amount: 'amount',
    currency: 'currency',
    type: 'type',
    counterpartyName: 'counterpartyName',
    counterpartyAccount: 'counterpartyAccount',
    counterpartyBankCode: 'counterpartyBankCode',
    description: 'description',
    note: 'note',
    variableSymbol: 'variableSymbol',
    constantSymbol: 'constantSymbol',
    specificSymbol: 'specificSymbol',
    reference: 'reference',
    isMatched: 'isMatched',
    matchedInvoiceId: 'matchedInvoiceId',
    matchedPaymentId: 'matchedPaymentId',
    matchConfidence: 'matchConfidence',
    aiSuggestions: 'aiSuggestions',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BankTransactionScalarFieldEnum = (typeof BankTransactionScalarFieldEnum)[keyof typeof BankTransactionScalarFieldEnum]


  export const InvoicePaymentScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    invoiceId: 'invoiceId',
    amount: 'amount',
    currency: 'currency',
    method: 'method',
    status: 'status',
    gatewayProvider: 'gatewayProvider',
    gatewayPaymentId: 'gatewayPaymentId',
    gatewayFee: 'gatewayFee',
    transactionId: 'transactionId',
    reference: 'reference',
    processedAt: 'processedAt',
    completedAt: 'completedAt',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InvoicePaymentScalarFieldEnum = (typeof InvoicePaymentScalarFieldEnum)[keyof typeof InvoicePaymentScalarFieldEnum]


  export const PaymentGatewayConfigScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    provider: 'provider',
    config: 'config',
    isActive: 'isActive',
    isTest: 'isTest',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentGatewayConfigScalarFieldEnum = (typeof PaymentGatewayConfigScalarFieldEnum)[keyof typeof PaymentGatewayConfigScalarFieldEnum]


  export const CryptoWalletScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    currency: 'currency',
    address: 'address',
    network: 'network',
    provider: 'provider',
    isActive: 'isActive',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CryptoWalletScalarFieldEnum = (typeof CryptoWalletScalarFieldEnum)[keyof typeof CryptoWalletScalarFieldEnum]


  export const CryptoPaymentScalarFieldEnum: {
    id: 'id',
    walletId: 'walletId',
    invoiceId: 'invoiceId',
    amount: 'amount',
    currency: 'currency',
    txHash: 'txHash',
    confirmations: 'confirmations',
    status: 'status',
    detectedAt: 'detectedAt',
    confirmedAt: 'confirmedAt',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CryptoPaymentScalarFieldEnum = (typeof CryptoPaymentScalarFieldEnum)[keyof typeof CryptoPaymentScalarFieldEnum]


  export const ExpenseCategoryScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    name: 'name',
    description: 'description',
    isDefault: 'isDefault',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExpenseCategoryScalarFieldEnum = (typeof ExpenseCategoryScalarFieldEnum)[keyof typeof ExpenseCategoryScalarFieldEnum]


  export const ExpenseScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    categoryId: 'categoryId',
    description: 'description',
    amount: 'amount',
    currency: 'currency',
    date: 'date',
    vendor: 'vendor',
    receiptUrl: 'receiptUrl',
    receiptOcrData: 'receiptOcrData',
    taxAmount: 'taxAmount',
    isTaxDeductible: 'isTaxDeductible',
    status: 'status',
    approvedBy: 'approvedBy',
    approvedAt: 'approvedAt',
    rejectedReason: 'rejectedReason',
    reimbursedAt: 'reimbursedAt',
    reimbursedAmount: 'reimbursedAmount',
    notes: 'notes',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExpenseScalarFieldEnum = (typeof ExpenseScalarFieldEnum)[keyof typeof ExpenseScalarFieldEnum]


  export const RecurringInvoiceTemplateScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    frequency: 'frequency',
    nextInvoiceDate: 'nextInvoiceDate',
    isActive: 'isActive',
    invoiceTemplate: 'invoiceTemplate',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RecurringInvoiceTemplateScalarFieldEnum = (typeof RecurringInvoiceTemplateScalarFieldEnum)[keyof typeof RecurringInvoiceTemplateScalarFieldEnum]


  export const PushSubscriptionScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    userId: 'userId',
    clientId: 'clientId',
    endpoint: 'endpoint',
    p256dh: 'p256dh',
    auth: 'auth',
    userAgent: 'userAgent',
    deviceName: 'deviceName',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PushSubscriptionScalarFieldEnum = (typeof PushSubscriptionScalarFieldEnum)[keyof typeof PushSubscriptionScalarFieldEnum]


  export const NotificationPreferenceScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    userId: 'userId',
    clientId: 'clientId',
    sessionReminders: 'sessionReminders',
    classReminders: 'classReminders',
    invoiceNotifications: 'invoiceNotifications',
    paymentNotifications: 'paymentNotifications',
    atRiskAlerts: 'atRiskAlerts',
    reminderMinutesBefore: 'reminderMinutesBefore',
    emailEnabled: 'emailEnabled',
    pushEnabled: 'pushEnabled',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationPreferenceScalarFieldEnum = (typeof NotificationPreferenceScalarFieldEnum)[keyof typeof NotificationPreferenceScalarFieldEnum]


  export const NotificationLogScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    type: 'type',
    recipientType: 'recipientType',
    recipientId: 'recipientId',
    title: 'title',
    body: 'body',
    data: 'data',
    channel: 'channel',
    status: 'status',
    error: 'error',
    sentAt: 'sentAt',
    createdAt: 'createdAt'
  };

  export type NotificationLogScalarFieldEnum = (typeof NotificationLogScalarFieldEnum)[keyof typeof NotificationLogScalarFieldEnum]


  export const CalendarIntegrationScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    userId: 'userId',
    provider: 'provider',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    tokenExpiry: 'tokenExpiry',
    calendarId: 'calendarId',
    calendarEmail: 'calendarEmail',
    syncEnabled: 'syncEnabled',
    syncDirection: 'syncDirection',
    lastSyncAt: 'lastSyncAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CalendarIntegrationScalarFieldEnum = (typeof CalendarIntegrationScalarFieldEnum)[keyof typeof CalendarIntegrationScalarFieldEnum]


  export const CalendarEventSyncScalarFieldEnum: {
    id: 'id',
    integrationId: 'integrationId',
    entityType: 'entityType',
    entityId: 'entityId',
    externalEventId: 'externalEventId',
    lastSyncedAt: 'lastSyncedAt',
    syncHash: 'syncHash'
  };

  export type CalendarEventSyncScalarFieldEnum = (typeof CalendarEventSyncScalarFieldEnum)[keyof typeof CalendarEventSyncScalarFieldEnum]


  export const CalendarFeedTokenScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    userId: 'userId',
    token: 'token',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt'
  };

  export type CalendarFeedTokenScalarFieldEnum = (typeof CalendarFeedTokenScalarFieldEnum)[keyof typeof CalendarFeedTokenScalarFieldEnum]


  export const BadgeScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    name: 'name',
    description: 'description',
    icon: 'icon',
    color: 'color',
    category: 'category',
    criteria: 'criteria',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BadgeScalarFieldEnum = (typeof BadgeScalarFieldEnum)[keyof typeof BadgeScalarFieldEnum]


  export const ClientBadgeScalarFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    badgeId: 'badgeId',
    earnedAt: 'earnedAt',
    notified: 'notified'
  };

  export type ClientBadgeScalarFieldEnum = (typeof ClientBadgeScalarFieldEnum)[keyof typeof ClientBadgeScalarFieldEnum]


  export const WorkoutTemplateScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    name: 'name',
    description: 'description',
    category: 'category',
    difficulty: 'difficulty',
    duration: 'duration',
    exercises: 'exercises',
    muscleGroups: 'muscleGroups',
    equipment: 'equipment',
    isPublic: 'isPublic',
    usageCount: 'usageCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WorkoutTemplateScalarFieldEnum = (typeof WorkoutTemplateScalarFieldEnum)[keyof typeof WorkoutTemplateScalarFieldEnum]


  export const ScheduleTemplateScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    name: 'name',
    description: 'description',
    slots: 'slots',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ScheduleTemplateScalarFieldEnum = (typeof ScheduleTemplateScalarFieldEnum)[keyof typeof ScheduleTemplateScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Vertical'
   */
  export type EnumVerticalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Vertical'>
    


  /**
   * Reference to a field of type 'Vertical[]'
   */
  export type ListEnumVerticalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Vertical[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Json[]'
   */
  export type ListJsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'BankProvider'
   */
  export type EnumBankProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BankProvider'>
    


  /**
   * Reference to a field of type 'BankProvider[]'
   */
  export type ListEnumBankProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BankProvider[]'>
    


  /**
   * Reference to a field of type 'TransactionType'
   */
  export type EnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType'>
    


  /**
   * Reference to a field of type 'TransactionType[]'
   */
  export type ListEnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType[]'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'PaymentMethod[]'
   */
  export type ListEnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod[]'>
    


  /**
   * Reference to a field of type 'ExpenseStatus'
   */
  export type EnumExpenseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExpenseStatus'>
    


  /**
   * Reference to a field of type 'ExpenseStatus[]'
   */
  export type ListEnumExpenseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExpenseStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type TenantWhereInput = {
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    id?: StringFilter<"Tenant"> | string
    vertical?: EnumVerticalFilter<"Tenant"> | $Enums.Vertical
    name?: StringFilter<"Tenant"> | string
    slug?: StringFilter<"Tenant"> | string
    email?: StringNullableFilter<"Tenant"> | string | null
    phone?: StringNullableFilter<"Tenant"> | string | null
    website?: StringNullableFilter<"Tenant"> | string | null
    logo?: StringNullableFilter<"Tenant"> | string | null
    subscriptionTier?: StringFilter<"Tenant"> | string
    aiCredits?: IntFilter<"Tenant"> | number
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
    users?: UserListRelationFilter
    clients?: ClientListRelationFilter
    sessions?: SessionListRelationFilter
    classes?: ClassListRelationFilter
    packages?: PackageListRelationFilter
    orders?: OrderListRelationFilter
    invoices?: InvoiceListRelationFilter
    aiLogs?: AILogListRelationFilter
    bankAccounts?: BankAccountListRelationFilter
    bankTransactions?: BankTransactionListRelationFilter
    invoicePayments?: InvoicePaymentListRelationFilter
    paymentGatewayConfigs?: PaymentGatewayConfigListRelationFilter
    cryptoWallets?: CryptoWalletListRelationFilter
    expenseCategories?: ExpenseCategoryListRelationFilter
    expenses?: ExpenseListRelationFilter
    recurringInvoiceTemplates?: RecurringInvoiceTemplateListRelationFilter
    badges?: BadgeListRelationFilter
    workoutTemplates?: WorkoutTemplateListRelationFilter
    scheduleTemplates?: ScheduleTemplateListRelationFilter
  }

  export type TenantOrderByWithRelationInput = {
    id?: SortOrder
    vertical?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    subscriptionTier?: SortOrder
    aiCredits?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
    clients?: ClientOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    classes?: ClassOrderByRelationAggregateInput
    packages?: PackageOrderByRelationAggregateInput
    orders?: OrderOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
    aiLogs?: AILogOrderByRelationAggregateInput
    bankAccounts?: BankAccountOrderByRelationAggregateInput
    bankTransactions?: BankTransactionOrderByRelationAggregateInput
    invoicePayments?: InvoicePaymentOrderByRelationAggregateInput
    paymentGatewayConfigs?: PaymentGatewayConfigOrderByRelationAggregateInput
    cryptoWallets?: CryptoWalletOrderByRelationAggregateInput
    expenseCategories?: ExpenseCategoryOrderByRelationAggregateInput
    expenses?: ExpenseOrderByRelationAggregateInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateOrderByRelationAggregateInput
    badges?: BadgeOrderByRelationAggregateInput
    workoutTemplates?: WorkoutTemplateOrderByRelationAggregateInput
    scheduleTemplates?: ScheduleTemplateOrderByRelationAggregateInput
  }

  export type TenantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    vertical?: EnumVerticalFilter<"Tenant"> | $Enums.Vertical
    name?: StringFilter<"Tenant"> | string
    email?: StringNullableFilter<"Tenant"> | string | null
    phone?: StringNullableFilter<"Tenant"> | string | null
    website?: StringNullableFilter<"Tenant"> | string | null
    logo?: StringNullableFilter<"Tenant"> | string | null
    subscriptionTier?: StringFilter<"Tenant"> | string
    aiCredits?: IntFilter<"Tenant"> | number
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
    users?: UserListRelationFilter
    clients?: ClientListRelationFilter
    sessions?: SessionListRelationFilter
    classes?: ClassListRelationFilter
    packages?: PackageListRelationFilter
    orders?: OrderListRelationFilter
    invoices?: InvoiceListRelationFilter
    aiLogs?: AILogListRelationFilter
    bankAccounts?: BankAccountListRelationFilter
    bankTransactions?: BankTransactionListRelationFilter
    invoicePayments?: InvoicePaymentListRelationFilter
    paymentGatewayConfigs?: PaymentGatewayConfigListRelationFilter
    cryptoWallets?: CryptoWalletListRelationFilter
    expenseCategories?: ExpenseCategoryListRelationFilter
    expenses?: ExpenseListRelationFilter
    recurringInvoiceTemplates?: RecurringInvoiceTemplateListRelationFilter
    badges?: BadgeListRelationFilter
    workoutTemplates?: WorkoutTemplateListRelationFilter
    scheduleTemplates?: ScheduleTemplateListRelationFilter
  }, "id" | "slug">

  export type TenantOrderByWithAggregationInput = {
    id?: SortOrder
    vertical?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    subscriptionTier?: SortOrder
    aiCredits?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TenantCountOrderByAggregateInput
    _avg?: TenantAvgOrderByAggregateInput
    _max?: TenantMaxOrderByAggregateInput
    _min?: TenantMinOrderByAggregateInput
    _sum?: TenantSumOrderByAggregateInput
  }

  export type TenantScalarWhereWithAggregatesInput = {
    AND?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    OR?: TenantScalarWhereWithAggregatesInput[]
    NOT?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tenant"> | string
    vertical?: EnumVerticalWithAggregatesFilter<"Tenant"> | $Enums.Vertical
    name?: StringWithAggregatesFilter<"Tenant"> | string
    slug?: StringWithAggregatesFilter<"Tenant"> | string
    email?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    website?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    logo?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    subscriptionTier?: StringWithAggregatesFilter<"Tenant"> | string
    aiCredits?: IntWithAggregatesFilter<"Tenant"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    tenantId?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    accounts?: AccountListRelationFilter
    sessions?: UserSessionListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    accounts?: AccountOrderByRelationAggregateInput
    sessions?: UserSessionOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    tenantId?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    accounts?: AccountListRelationFilter
    sessions?: UserSessionListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    tenantId?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringWithAggregatesFilter<"User"> | string
    emailVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "provider_providerAccountId">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    type?: StringWithAggregatesFilter<"Account"> | string
    provider?: StringWithAggregatesFilter<"Account"> | string
    providerAccountId?: StringWithAggregatesFilter<"Account"> | string
    refresh_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    access_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    expires_at?: IntNullableWithAggregatesFilter<"Account"> | number | null
    token_type?: StringNullableWithAggregatesFilter<"Account"> | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    id_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    session_state?: StringNullableWithAggregatesFilter<"Account"> | string | null
  }

  export type UserSessionWhereInput = {
    AND?: UserSessionWhereInput | UserSessionWhereInput[]
    OR?: UserSessionWhereInput[]
    NOT?: UserSessionWhereInput | UserSessionWhereInput[]
    id?: StringFilter<"UserSession"> | string
    sessionToken?: StringFilter<"UserSession"> | string
    userId?: StringFilter<"UserSession"> | string
    expires?: DateTimeFilter<"UserSession"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserSessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionToken?: string
    AND?: UserSessionWhereInput | UserSessionWhereInput[]
    OR?: UserSessionWhereInput[]
    NOT?: UserSessionWhereInput | UserSessionWhereInput[]
    userId?: StringFilter<"UserSession"> | string
    expires?: DateTimeFilter<"UserSession"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "sessionToken">

  export type UserSessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    _count?: UserSessionCountOrderByAggregateInput
    _max?: UserSessionMaxOrderByAggregateInput
    _min?: UserSessionMinOrderByAggregateInput
  }

  export type UserSessionScalarWhereWithAggregatesInput = {
    AND?: UserSessionScalarWhereWithAggregatesInput | UserSessionScalarWhereWithAggregatesInput[]
    OR?: UserSessionScalarWhereWithAggregatesInput[]
    NOT?: UserSessionScalarWhereWithAggregatesInput | UserSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserSession"> | string
    sessionToken?: StringWithAggregatesFilter<"UserSession"> | string
    userId?: StringWithAggregatesFilter<"UserSession"> | string
    expires?: DateTimeWithAggregatesFilter<"UserSession"> | Date | string
  }

  export type VerificationTokenWhereInput = {
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    token?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }

  export type VerificationTokenOrderByWithRelationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenWhereUniqueInput = Prisma.AtLeast<{
    token?: string
    identifier_token?: VerificationTokenIdentifierTokenCompoundUniqueInput
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }, "token" | "identifier_token">

  export type VerificationTokenOrderByWithAggregationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _count?: VerificationTokenCountOrderByAggregateInput
    _max?: VerificationTokenMaxOrderByAggregateInput
    _min?: VerificationTokenMinOrderByAggregateInput
  }

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    OR?: VerificationTokenScalarWhereWithAggregatesInput[]
    NOT?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    identifier?: StringWithAggregatesFilter<"VerificationToken"> | string
    token?: StringWithAggregatesFilter<"VerificationToken"> | string
    expires?: DateTimeWithAggregatesFilter<"VerificationToken"> | Date | string
  }

  export type PasswordResetTokenWhereInput = {
    AND?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    OR?: PasswordResetTokenWhereInput[]
    NOT?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    id?: StringFilter<"PasswordResetToken"> | string
    email?: StringFilter<"PasswordResetToken"> | string
    token?: StringFilter<"PasswordResetToken"> | string
    expires?: DateTimeFilter<"PasswordResetToken"> | Date | string
    createdAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
  }

  export type PasswordResetTokenOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordResetTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    OR?: PasswordResetTokenWhereInput[]
    NOT?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    email?: StringFilter<"PasswordResetToken"> | string
    expires?: DateTimeFilter<"PasswordResetToken"> | Date | string
    createdAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
  }, "id" | "token">

  export type PasswordResetTokenOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    _count?: PasswordResetTokenCountOrderByAggregateInput
    _max?: PasswordResetTokenMaxOrderByAggregateInput
    _min?: PasswordResetTokenMinOrderByAggregateInput
  }

  export type PasswordResetTokenScalarWhereWithAggregatesInput = {
    AND?: PasswordResetTokenScalarWhereWithAggregatesInput | PasswordResetTokenScalarWhereWithAggregatesInput[]
    OR?: PasswordResetTokenScalarWhereWithAggregatesInput[]
    NOT?: PasswordResetTokenScalarWhereWithAggregatesInput | PasswordResetTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    email?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    token?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    expires?: DateTimeWithAggregatesFilter<"PasswordResetToken"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"PasswordResetToken"> | Date | string
  }

  export type ClientWhereInput = {
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    id?: StringFilter<"Client"> | string
    tenantId?: StringFilter<"Client"> | string
    name?: StringFilter<"Client"> | string
    email?: StringFilter<"Client"> | string
    phone?: StringNullableFilter<"Client"> | string | null
    avatar?: StringNullableFilter<"Client"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"Client"> | Date | string | null
    gender?: StringNullableFilter<"Client"> | string | null
    goals?: StringNullableListFilter<"Client">
    currentWeight?: FloatNullableFilter<"Client"> | number | null
    targetWeight?: FloatNullableFilter<"Client"> | number | null
    height?: FloatNullableFilter<"Client"> | number | null
    bodyMeasurements?: JsonNullableFilter<"Client">
    bodyFatPercent?: FloatNullableFilter<"Client"> | number | null
    fitnessLevel?: StringNullableFilter<"Client"> | string | null
    injuryHistory?: StringNullableFilter<"Client"> | string | null
    dietaryNotes?: StringNullableFilter<"Client"> | string | null
    medicalNotes?: StringNullableFilter<"Client"> | string | null
    creditsRemaining?: IntFilter<"Client"> | number
    membershipType?: StringNullableFilter<"Client"> | string | null
    membershipExpiry?: DateTimeNullableFilter<"Client"> | Date | string | null
    status?: StringFilter<"Client"> | string
    tags?: StringNullableListFilter<"Client">
    notes?: StringNullableFilter<"Client"> | string | null
    createdAt?: DateTimeFilter<"Client"> | Date | string
    updatedAt?: DateTimeFilter<"Client"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    sessions?: SessionListRelationFilter
    orders?: OrderListRelationFilter
    invoices?: InvoiceListRelationFilter
    measurements?: ClientMeasurementListRelationFilter
    progressPhotos?: ProgressPhotoListRelationFilter
    badges?: ClientBadgeListRelationFilter
  }

  export type ClientOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    goals?: SortOrder
    currentWeight?: SortOrderInput | SortOrder
    targetWeight?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    bodyMeasurements?: SortOrderInput | SortOrder
    bodyFatPercent?: SortOrderInput | SortOrder
    fitnessLevel?: SortOrderInput | SortOrder
    injuryHistory?: SortOrderInput | SortOrder
    dietaryNotes?: SortOrderInput | SortOrder
    medicalNotes?: SortOrderInput | SortOrder
    creditsRemaining?: SortOrder
    membershipType?: SortOrderInput | SortOrder
    membershipExpiry?: SortOrderInput | SortOrder
    status?: SortOrder
    tags?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    sessions?: SessionOrderByRelationAggregateInput
    orders?: OrderOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
    measurements?: ClientMeasurementOrderByRelationAggregateInput
    progressPhotos?: ProgressPhotoOrderByRelationAggregateInput
    badges?: ClientBadgeOrderByRelationAggregateInput
  }

  export type ClientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    tenantId?: StringFilter<"Client"> | string
    name?: StringFilter<"Client"> | string
    email?: StringFilter<"Client"> | string
    phone?: StringNullableFilter<"Client"> | string | null
    avatar?: StringNullableFilter<"Client"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"Client"> | Date | string | null
    gender?: StringNullableFilter<"Client"> | string | null
    goals?: StringNullableListFilter<"Client">
    currentWeight?: FloatNullableFilter<"Client"> | number | null
    targetWeight?: FloatNullableFilter<"Client"> | number | null
    height?: FloatNullableFilter<"Client"> | number | null
    bodyMeasurements?: JsonNullableFilter<"Client">
    bodyFatPercent?: FloatNullableFilter<"Client"> | number | null
    fitnessLevel?: StringNullableFilter<"Client"> | string | null
    injuryHistory?: StringNullableFilter<"Client"> | string | null
    dietaryNotes?: StringNullableFilter<"Client"> | string | null
    medicalNotes?: StringNullableFilter<"Client"> | string | null
    creditsRemaining?: IntFilter<"Client"> | number
    membershipType?: StringNullableFilter<"Client"> | string | null
    membershipExpiry?: DateTimeNullableFilter<"Client"> | Date | string | null
    status?: StringFilter<"Client"> | string
    tags?: StringNullableListFilter<"Client">
    notes?: StringNullableFilter<"Client"> | string | null
    createdAt?: DateTimeFilter<"Client"> | Date | string
    updatedAt?: DateTimeFilter<"Client"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    sessions?: SessionListRelationFilter
    orders?: OrderListRelationFilter
    invoices?: InvoiceListRelationFilter
    measurements?: ClientMeasurementListRelationFilter
    progressPhotos?: ProgressPhotoListRelationFilter
    badges?: ClientBadgeListRelationFilter
  }, "id">

  export type ClientOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    goals?: SortOrder
    currentWeight?: SortOrderInput | SortOrder
    targetWeight?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    bodyMeasurements?: SortOrderInput | SortOrder
    bodyFatPercent?: SortOrderInput | SortOrder
    fitnessLevel?: SortOrderInput | SortOrder
    injuryHistory?: SortOrderInput | SortOrder
    dietaryNotes?: SortOrderInput | SortOrder
    medicalNotes?: SortOrderInput | SortOrder
    creditsRemaining?: SortOrder
    membershipType?: SortOrderInput | SortOrder
    membershipExpiry?: SortOrderInput | SortOrder
    status?: SortOrder
    tags?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClientCountOrderByAggregateInput
    _avg?: ClientAvgOrderByAggregateInput
    _max?: ClientMaxOrderByAggregateInput
    _min?: ClientMinOrderByAggregateInput
    _sum?: ClientSumOrderByAggregateInput
  }

  export type ClientScalarWhereWithAggregatesInput = {
    AND?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    OR?: ClientScalarWhereWithAggregatesInput[]
    NOT?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Client"> | string
    tenantId?: StringWithAggregatesFilter<"Client"> | string
    name?: StringWithAggregatesFilter<"Client"> | string
    email?: StringWithAggregatesFilter<"Client"> | string
    phone?: StringNullableWithAggregatesFilter<"Client"> | string | null
    avatar?: StringNullableWithAggregatesFilter<"Client"> | string | null
    dateOfBirth?: DateTimeNullableWithAggregatesFilter<"Client"> | Date | string | null
    gender?: StringNullableWithAggregatesFilter<"Client"> | string | null
    goals?: StringNullableListFilter<"Client">
    currentWeight?: FloatNullableWithAggregatesFilter<"Client"> | number | null
    targetWeight?: FloatNullableWithAggregatesFilter<"Client"> | number | null
    height?: FloatNullableWithAggregatesFilter<"Client"> | number | null
    bodyMeasurements?: JsonNullableWithAggregatesFilter<"Client">
    bodyFatPercent?: FloatNullableWithAggregatesFilter<"Client"> | number | null
    fitnessLevel?: StringNullableWithAggregatesFilter<"Client"> | string | null
    injuryHistory?: StringNullableWithAggregatesFilter<"Client"> | string | null
    dietaryNotes?: StringNullableWithAggregatesFilter<"Client"> | string | null
    medicalNotes?: StringNullableWithAggregatesFilter<"Client"> | string | null
    creditsRemaining?: IntWithAggregatesFilter<"Client"> | number
    membershipType?: StringNullableWithAggregatesFilter<"Client"> | string | null
    membershipExpiry?: DateTimeNullableWithAggregatesFilter<"Client"> | Date | string | null
    status?: StringWithAggregatesFilter<"Client"> | string
    tags?: StringNullableListFilter<"Client">
    notes?: StringNullableWithAggregatesFilter<"Client"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Client"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Client"> | Date | string
  }

  export type ClientMeasurementWhereInput = {
    AND?: ClientMeasurementWhereInput | ClientMeasurementWhereInput[]
    OR?: ClientMeasurementWhereInput[]
    NOT?: ClientMeasurementWhereInput | ClientMeasurementWhereInput[]
    id?: StringFilter<"ClientMeasurement"> | string
    clientId?: StringFilter<"ClientMeasurement"> | string
    date?: DateTimeFilter<"ClientMeasurement"> | Date | string
    weight?: FloatNullableFilter<"ClientMeasurement"> | number | null
    bodyFat?: FloatNullableFilter<"ClientMeasurement"> | number | null
    measurements?: JsonNullableFilter<"ClientMeasurement">
    notes?: StringNullableFilter<"ClientMeasurement"> | string | null
    createdAt?: DateTimeFilter<"ClientMeasurement"> | Date | string
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
  }

  export type ClientMeasurementOrderByWithRelationInput = {
    id?: SortOrder
    clientId?: SortOrder
    date?: SortOrder
    weight?: SortOrderInput | SortOrder
    bodyFat?: SortOrderInput | SortOrder
    measurements?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    client?: ClientOrderByWithRelationInput
  }

  export type ClientMeasurementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClientMeasurementWhereInput | ClientMeasurementWhereInput[]
    OR?: ClientMeasurementWhereInput[]
    NOT?: ClientMeasurementWhereInput | ClientMeasurementWhereInput[]
    clientId?: StringFilter<"ClientMeasurement"> | string
    date?: DateTimeFilter<"ClientMeasurement"> | Date | string
    weight?: FloatNullableFilter<"ClientMeasurement"> | number | null
    bodyFat?: FloatNullableFilter<"ClientMeasurement"> | number | null
    measurements?: JsonNullableFilter<"ClientMeasurement">
    notes?: StringNullableFilter<"ClientMeasurement"> | string | null
    createdAt?: DateTimeFilter<"ClientMeasurement"> | Date | string
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
  }, "id">

  export type ClientMeasurementOrderByWithAggregationInput = {
    id?: SortOrder
    clientId?: SortOrder
    date?: SortOrder
    weight?: SortOrderInput | SortOrder
    bodyFat?: SortOrderInput | SortOrder
    measurements?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ClientMeasurementCountOrderByAggregateInput
    _avg?: ClientMeasurementAvgOrderByAggregateInput
    _max?: ClientMeasurementMaxOrderByAggregateInput
    _min?: ClientMeasurementMinOrderByAggregateInput
    _sum?: ClientMeasurementSumOrderByAggregateInput
  }

  export type ClientMeasurementScalarWhereWithAggregatesInput = {
    AND?: ClientMeasurementScalarWhereWithAggregatesInput | ClientMeasurementScalarWhereWithAggregatesInput[]
    OR?: ClientMeasurementScalarWhereWithAggregatesInput[]
    NOT?: ClientMeasurementScalarWhereWithAggregatesInput | ClientMeasurementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClientMeasurement"> | string
    clientId?: StringWithAggregatesFilter<"ClientMeasurement"> | string
    date?: DateTimeWithAggregatesFilter<"ClientMeasurement"> | Date | string
    weight?: FloatNullableWithAggregatesFilter<"ClientMeasurement"> | number | null
    bodyFat?: FloatNullableWithAggregatesFilter<"ClientMeasurement"> | number | null
    measurements?: JsonNullableWithAggregatesFilter<"ClientMeasurement">
    notes?: StringNullableWithAggregatesFilter<"ClientMeasurement"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ClientMeasurement"> | Date | string
  }

  export type ProgressPhotoWhereInput = {
    AND?: ProgressPhotoWhereInput | ProgressPhotoWhereInput[]
    OR?: ProgressPhotoWhereInput[]
    NOT?: ProgressPhotoWhereInput | ProgressPhotoWhereInput[]
    id?: StringFilter<"ProgressPhoto"> | string
    clientId?: StringFilter<"ProgressPhoto"> | string
    url?: StringFilter<"ProgressPhoto"> | string
    date?: DateTimeFilter<"ProgressPhoto"> | Date | string
    view?: StringFilter<"ProgressPhoto"> | string
    notes?: StringNullableFilter<"ProgressPhoto"> | string | null
    createdAt?: DateTimeFilter<"ProgressPhoto"> | Date | string
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
  }

  export type ProgressPhotoOrderByWithRelationInput = {
    id?: SortOrder
    clientId?: SortOrder
    url?: SortOrder
    date?: SortOrder
    view?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    client?: ClientOrderByWithRelationInput
  }

  export type ProgressPhotoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProgressPhotoWhereInput | ProgressPhotoWhereInput[]
    OR?: ProgressPhotoWhereInput[]
    NOT?: ProgressPhotoWhereInput | ProgressPhotoWhereInput[]
    clientId?: StringFilter<"ProgressPhoto"> | string
    url?: StringFilter<"ProgressPhoto"> | string
    date?: DateTimeFilter<"ProgressPhoto"> | Date | string
    view?: StringFilter<"ProgressPhoto"> | string
    notes?: StringNullableFilter<"ProgressPhoto"> | string | null
    createdAt?: DateTimeFilter<"ProgressPhoto"> | Date | string
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
  }, "id">

  export type ProgressPhotoOrderByWithAggregationInput = {
    id?: SortOrder
    clientId?: SortOrder
    url?: SortOrder
    date?: SortOrder
    view?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ProgressPhotoCountOrderByAggregateInput
    _max?: ProgressPhotoMaxOrderByAggregateInput
    _min?: ProgressPhotoMinOrderByAggregateInput
  }

  export type ProgressPhotoScalarWhereWithAggregatesInput = {
    AND?: ProgressPhotoScalarWhereWithAggregatesInput | ProgressPhotoScalarWhereWithAggregatesInput[]
    OR?: ProgressPhotoScalarWhereWithAggregatesInput[]
    NOT?: ProgressPhotoScalarWhereWithAggregatesInput | ProgressPhotoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProgressPhoto"> | string
    clientId?: StringWithAggregatesFilter<"ProgressPhoto"> | string
    url?: StringWithAggregatesFilter<"ProgressPhoto"> | string
    date?: DateTimeWithAggregatesFilter<"ProgressPhoto"> | Date | string
    view?: StringWithAggregatesFilter<"ProgressPhoto"> | string
    notes?: StringNullableWithAggregatesFilter<"ProgressPhoto"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ProgressPhoto"> | Date | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    tenantId?: StringFilter<"Session"> | string
    clientId?: StringFilter<"Session"> | string
    scheduledAt?: DateTimeFilter<"Session"> | Date | string
    duration?: IntFilter<"Session"> | number
    status?: StringFilter<"Session"> | string
    workoutPlan?: JsonNullableFilter<"Session">
    exercisesLogged?: JsonNullableListFilter<"Session">
    caloriesBurned?: IntNullableFilter<"Session"> | number | null
    heartRateAvg?: IntNullableFilter<"Session"> | number | null
    muscleGroups?: StringNullableListFilter<"Session">
    clientFeedback?: StringNullableFilter<"Session"> | string | null
    trainerNotes?: StringNullableFilter<"Session"> | string | null
    intensity?: StringNullableFilter<"Session"> | string | null
    clientRating?: IntNullableFilter<"Session"> | number | null
    price?: FloatNullableFilter<"Session"> | number | null
    paid?: BoolFilter<"Session"> | boolean
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    clientId?: SortOrder
    scheduledAt?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    workoutPlan?: SortOrderInput | SortOrder
    exercisesLogged?: SortOrder
    caloriesBurned?: SortOrderInput | SortOrder
    heartRateAvg?: SortOrderInput | SortOrder
    muscleGroups?: SortOrder
    clientFeedback?: SortOrderInput | SortOrder
    trainerNotes?: SortOrderInput | SortOrder
    intensity?: SortOrderInput | SortOrder
    clientRating?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    paid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    client?: ClientOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    tenantId?: StringFilter<"Session"> | string
    clientId?: StringFilter<"Session"> | string
    scheduledAt?: DateTimeFilter<"Session"> | Date | string
    duration?: IntFilter<"Session"> | number
    status?: StringFilter<"Session"> | string
    workoutPlan?: JsonNullableFilter<"Session">
    exercisesLogged?: JsonNullableListFilter<"Session">
    caloriesBurned?: IntNullableFilter<"Session"> | number | null
    heartRateAvg?: IntNullableFilter<"Session"> | number | null
    muscleGroups?: StringNullableListFilter<"Session">
    clientFeedback?: StringNullableFilter<"Session"> | string | null
    trainerNotes?: StringNullableFilter<"Session"> | string | null
    intensity?: StringNullableFilter<"Session"> | string | null
    clientRating?: IntNullableFilter<"Session"> | number | null
    price?: FloatNullableFilter<"Session"> | number | null
    paid?: BoolFilter<"Session"> | boolean
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
  }, "id">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    clientId?: SortOrder
    scheduledAt?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    workoutPlan?: SortOrderInput | SortOrder
    exercisesLogged?: SortOrder
    caloriesBurned?: SortOrderInput | SortOrder
    heartRateAvg?: SortOrderInput | SortOrder
    muscleGroups?: SortOrder
    clientFeedback?: SortOrderInput | SortOrder
    trainerNotes?: SortOrderInput | SortOrder
    intensity?: SortOrderInput | SortOrder
    clientRating?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    paid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _avg?: SessionAvgOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
    _sum?: SessionSumOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    tenantId?: StringWithAggregatesFilter<"Session"> | string
    clientId?: StringWithAggregatesFilter<"Session"> | string
    scheduledAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    duration?: IntWithAggregatesFilter<"Session"> | number
    status?: StringWithAggregatesFilter<"Session"> | string
    workoutPlan?: JsonNullableWithAggregatesFilter<"Session">
    exercisesLogged?: JsonNullableListFilter<"Session">
    caloriesBurned?: IntNullableWithAggregatesFilter<"Session"> | number | null
    heartRateAvg?: IntNullableWithAggregatesFilter<"Session"> | number | null
    muscleGroups?: StringNullableListFilter<"Session">
    clientFeedback?: StringNullableWithAggregatesFilter<"Session"> | string | null
    trainerNotes?: StringNullableWithAggregatesFilter<"Session"> | string | null
    intensity?: StringNullableWithAggregatesFilter<"Session"> | string | null
    clientRating?: IntNullableWithAggregatesFilter<"Session"> | number | null
    price?: FloatNullableWithAggregatesFilter<"Session"> | number | null
    paid?: BoolWithAggregatesFilter<"Session"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type ClassWhereInput = {
    AND?: ClassWhereInput | ClassWhereInput[]
    OR?: ClassWhereInput[]
    NOT?: ClassWhereInput | ClassWhereInput[]
    id?: StringFilter<"Class"> | string
    tenantId?: StringFilter<"Class"> | string
    name?: StringFilter<"Class"> | string
    description?: StringNullableFilter<"Class"> | string | null
    type?: StringFilter<"Class"> | string
    scheduledAt?: DateTimeFilter<"Class"> | Date | string
    duration?: IntFilter<"Class"> | number
    capacity?: IntFilter<"Class"> | number
    instructor?: StringNullableFilter<"Class"> | string | null
    location?: StringNullableFilter<"Class"> | string | null
    price?: FloatFilter<"Class"> | number
    isRecurring?: BoolFilter<"Class"> | boolean
    recurrence?: StringNullableFilter<"Class"> | string | null
    status?: StringFilter<"Class"> | string
    createdAt?: DateTimeFilter<"Class"> | Date | string
    updatedAt?: DateTimeFilter<"Class"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    bookings?: ClassBookingListRelationFilter
  }

  export type ClassOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    scheduledAt?: SortOrder
    duration?: SortOrder
    capacity?: SortOrder
    instructor?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    price?: SortOrder
    isRecurring?: SortOrder
    recurrence?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    bookings?: ClassBookingOrderByRelationAggregateInput
  }

  export type ClassWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClassWhereInput | ClassWhereInput[]
    OR?: ClassWhereInput[]
    NOT?: ClassWhereInput | ClassWhereInput[]
    tenantId?: StringFilter<"Class"> | string
    name?: StringFilter<"Class"> | string
    description?: StringNullableFilter<"Class"> | string | null
    type?: StringFilter<"Class"> | string
    scheduledAt?: DateTimeFilter<"Class"> | Date | string
    duration?: IntFilter<"Class"> | number
    capacity?: IntFilter<"Class"> | number
    instructor?: StringNullableFilter<"Class"> | string | null
    location?: StringNullableFilter<"Class"> | string | null
    price?: FloatFilter<"Class"> | number
    isRecurring?: BoolFilter<"Class"> | boolean
    recurrence?: StringNullableFilter<"Class"> | string | null
    status?: StringFilter<"Class"> | string
    createdAt?: DateTimeFilter<"Class"> | Date | string
    updatedAt?: DateTimeFilter<"Class"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    bookings?: ClassBookingListRelationFilter
  }, "id">

  export type ClassOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    scheduledAt?: SortOrder
    duration?: SortOrder
    capacity?: SortOrder
    instructor?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    price?: SortOrder
    isRecurring?: SortOrder
    recurrence?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClassCountOrderByAggregateInput
    _avg?: ClassAvgOrderByAggregateInput
    _max?: ClassMaxOrderByAggregateInput
    _min?: ClassMinOrderByAggregateInput
    _sum?: ClassSumOrderByAggregateInput
  }

  export type ClassScalarWhereWithAggregatesInput = {
    AND?: ClassScalarWhereWithAggregatesInput | ClassScalarWhereWithAggregatesInput[]
    OR?: ClassScalarWhereWithAggregatesInput[]
    NOT?: ClassScalarWhereWithAggregatesInput | ClassScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Class"> | string
    tenantId?: StringWithAggregatesFilter<"Class"> | string
    name?: StringWithAggregatesFilter<"Class"> | string
    description?: StringNullableWithAggregatesFilter<"Class"> | string | null
    type?: StringWithAggregatesFilter<"Class"> | string
    scheduledAt?: DateTimeWithAggregatesFilter<"Class"> | Date | string
    duration?: IntWithAggregatesFilter<"Class"> | number
    capacity?: IntWithAggregatesFilter<"Class"> | number
    instructor?: StringNullableWithAggregatesFilter<"Class"> | string | null
    location?: StringNullableWithAggregatesFilter<"Class"> | string | null
    price?: FloatWithAggregatesFilter<"Class"> | number
    isRecurring?: BoolWithAggregatesFilter<"Class"> | boolean
    recurrence?: StringNullableWithAggregatesFilter<"Class"> | string | null
    status?: StringWithAggregatesFilter<"Class"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Class"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Class"> | Date | string
  }

  export type ClassBookingWhereInput = {
    AND?: ClassBookingWhereInput | ClassBookingWhereInput[]
    OR?: ClassBookingWhereInput[]
    NOT?: ClassBookingWhereInput | ClassBookingWhereInput[]
    id?: StringFilter<"ClassBooking"> | string
    classId?: StringFilter<"ClassBooking"> | string
    clientId?: StringFilter<"ClassBooking"> | string
    status?: StringFilter<"ClassBooking"> | string
    checkedIn?: BoolFilter<"ClassBooking"> | boolean
    paid?: BoolFilter<"ClassBooking"> | boolean
    createdAt?: DateTimeFilter<"ClassBooking"> | Date | string
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
  }

  export type ClassBookingOrderByWithRelationInput = {
    id?: SortOrder
    classId?: SortOrder
    clientId?: SortOrder
    status?: SortOrder
    checkedIn?: SortOrder
    paid?: SortOrder
    createdAt?: SortOrder
    class?: ClassOrderByWithRelationInput
  }

  export type ClassBookingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClassBookingWhereInput | ClassBookingWhereInput[]
    OR?: ClassBookingWhereInput[]
    NOT?: ClassBookingWhereInput | ClassBookingWhereInput[]
    classId?: StringFilter<"ClassBooking"> | string
    clientId?: StringFilter<"ClassBooking"> | string
    status?: StringFilter<"ClassBooking"> | string
    checkedIn?: BoolFilter<"ClassBooking"> | boolean
    paid?: BoolFilter<"ClassBooking"> | boolean
    createdAt?: DateTimeFilter<"ClassBooking"> | Date | string
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
  }, "id">

  export type ClassBookingOrderByWithAggregationInput = {
    id?: SortOrder
    classId?: SortOrder
    clientId?: SortOrder
    status?: SortOrder
    checkedIn?: SortOrder
    paid?: SortOrder
    createdAt?: SortOrder
    _count?: ClassBookingCountOrderByAggregateInput
    _max?: ClassBookingMaxOrderByAggregateInput
    _min?: ClassBookingMinOrderByAggregateInput
  }

  export type ClassBookingScalarWhereWithAggregatesInput = {
    AND?: ClassBookingScalarWhereWithAggregatesInput | ClassBookingScalarWhereWithAggregatesInput[]
    OR?: ClassBookingScalarWhereWithAggregatesInput[]
    NOT?: ClassBookingScalarWhereWithAggregatesInput | ClassBookingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClassBooking"> | string
    classId?: StringWithAggregatesFilter<"ClassBooking"> | string
    clientId?: StringWithAggregatesFilter<"ClassBooking"> | string
    status?: StringWithAggregatesFilter<"ClassBooking"> | string
    checkedIn?: BoolWithAggregatesFilter<"ClassBooking"> | boolean
    paid?: BoolWithAggregatesFilter<"ClassBooking"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ClassBooking"> | Date | string
  }

  export type PackageWhereInput = {
    AND?: PackageWhereInput | PackageWhereInput[]
    OR?: PackageWhereInput[]
    NOT?: PackageWhereInput | PackageWhereInput[]
    id?: StringFilter<"Package"> | string
    tenantId?: StringFilter<"Package"> | string
    name?: StringFilter<"Package"> | string
    description?: StringNullableFilter<"Package"> | string | null
    type?: StringFilter<"Package"> | string
    price?: FloatFilter<"Package"> | number
    credits?: IntFilter<"Package"> | number
    validityDays?: IntFilter<"Package"> | number
    features?: StringNullableListFilter<"Package">
    isActive?: BoolFilter<"Package"> | boolean
    createdAt?: DateTimeFilter<"Package"> | Date | string
    updatedAt?: DateTimeFilter<"Package"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type PackageOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    price?: SortOrder
    credits?: SortOrder
    validityDays?: SortOrder
    features?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
  }

  export type PackageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PackageWhereInput | PackageWhereInput[]
    OR?: PackageWhereInput[]
    NOT?: PackageWhereInput | PackageWhereInput[]
    tenantId?: StringFilter<"Package"> | string
    name?: StringFilter<"Package"> | string
    description?: StringNullableFilter<"Package"> | string | null
    type?: StringFilter<"Package"> | string
    price?: FloatFilter<"Package"> | number
    credits?: IntFilter<"Package"> | number
    validityDays?: IntFilter<"Package"> | number
    features?: StringNullableListFilter<"Package">
    isActive?: BoolFilter<"Package"> | boolean
    createdAt?: DateTimeFilter<"Package"> | Date | string
    updatedAt?: DateTimeFilter<"Package"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id">

  export type PackageOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    price?: SortOrder
    credits?: SortOrder
    validityDays?: SortOrder
    features?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PackageCountOrderByAggregateInput
    _avg?: PackageAvgOrderByAggregateInput
    _max?: PackageMaxOrderByAggregateInput
    _min?: PackageMinOrderByAggregateInput
    _sum?: PackageSumOrderByAggregateInput
  }

  export type PackageScalarWhereWithAggregatesInput = {
    AND?: PackageScalarWhereWithAggregatesInput | PackageScalarWhereWithAggregatesInput[]
    OR?: PackageScalarWhereWithAggregatesInput[]
    NOT?: PackageScalarWhereWithAggregatesInput | PackageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Package"> | string
    tenantId?: StringWithAggregatesFilter<"Package"> | string
    name?: StringWithAggregatesFilter<"Package"> | string
    description?: StringNullableWithAggregatesFilter<"Package"> | string | null
    type?: StringWithAggregatesFilter<"Package"> | string
    price?: FloatWithAggregatesFilter<"Package"> | number
    credits?: IntWithAggregatesFilter<"Package"> | number
    validityDays?: IntWithAggregatesFilter<"Package"> | number
    features?: StringNullableListFilter<"Package">
    isActive?: BoolWithAggregatesFilter<"Package"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Package"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Package"> | Date | string
  }

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    id?: StringFilter<"Order"> | string
    tenantId?: StringFilter<"Order"> | string
    clientId?: StringFilter<"Order"> | string
    orderNumber?: StringFilter<"Order"> | string
    status?: StringFilter<"Order"> | string
    items?: JsonNullableListFilter<"Order">
    subtotal?: FloatFilter<"Order"> | number
    tax?: FloatFilter<"Order"> | number
    discount?: FloatFilter<"Order"> | number
    total?: FloatFilter<"Order"> | number
    paymentMethod?: StringNullableFilter<"Order"> | string | null
    paymentStatus?: StringFilter<"Order"> | string
    paidAmount?: FloatFilter<"Order"> | number
    orderDate?: DateTimeFilter<"Order"> | Date | string
    dueDate?: DateTimeNullableFilter<"Order"> | Date | string | null
    paidDate?: DateTimeNullableFilter<"Order"> | Date | string | null
    notes?: StringNullableFilter<"Order"> | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    invoices?: InvoiceListRelationFilter
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    clientId?: SortOrder
    orderNumber?: SortOrder
    status?: SortOrder
    items?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    discount?: SortOrder
    total?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    paymentStatus?: SortOrder
    paidAmount?: SortOrder
    orderDate?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    paidDate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    client?: ClientOrderByWithRelationInput
    invoices?: InvoiceOrderByRelationAggregateInput
  }

  export type OrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    orderNumber?: string
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    tenantId?: StringFilter<"Order"> | string
    clientId?: StringFilter<"Order"> | string
    status?: StringFilter<"Order"> | string
    items?: JsonNullableListFilter<"Order">
    subtotal?: FloatFilter<"Order"> | number
    tax?: FloatFilter<"Order"> | number
    discount?: FloatFilter<"Order"> | number
    total?: FloatFilter<"Order"> | number
    paymentMethod?: StringNullableFilter<"Order"> | string | null
    paymentStatus?: StringFilter<"Order"> | string
    paidAmount?: FloatFilter<"Order"> | number
    orderDate?: DateTimeFilter<"Order"> | Date | string
    dueDate?: DateTimeNullableFilter<"Order"> | Date | string | null
    paidDate?: DateTimeNullableFilter<"Order"> | Date | string | null
    notes?: StringNullableFilter<"Order"> | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    invoices?: InvoiceListRelationFilter
  }, "id" | "orderNumber">

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    clientId?: SortOrder
    orderNumber?: SortOrder
    status?: SortOrder
    items?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    discount?: SortOrder
    total?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    paymentStatus?: SortOrder
    paidAmount?: SortOrder
    orderDate?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    paidDate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    OR?: OrderScalarWhereWithAggregatesInput[]
    NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Order"> | string
    tenantId?: StringWithAggregatesFilter<"Order"> | string
    clientId?: StringWithAggregatesFilter<"Order"> | string
    orderNumber?: StringWithAggregatesFilter<"Order"> | string
    status?: StringWithAggregatesFilter<"Order"> | string
    items?: JsonNullableListFilter<"Order">
    subtotal?: FloatWithAggregatesFilter<"Order"> | number
    tax?: FloatWithAggregatesFilter<"Order"> | number
    discount?: FloatWithAggregatesFilter<"Order"> | number
    total?: FloatWithAggregatesFilter<"Order"> | number
    paymentMethod?: StringNullableWithAggregatesFilter<"Order"> | string | null
    paymentStatus?: StringWithAggregatesFilter<"Order"> | string
    paidAmount?: FloatWithAggregatesFilter<"Order"> | number
    orderDate?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    dueDate?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    paidDate?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"Order"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
  }

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    id?: StringFilter<"Invoice"> | string
    tenantId?: StringFilter<"Invoice"> | string
    orderId?: StringNullableFilter<"Invoice"> | string | null
    clientId?: StringFilter<"Invoice"> | string
    invoiceNumber?: StringFilter<"Invoice"> | string
    status?: StringFilter<"Invoice"> | string
    issueDate?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    paidDate?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    subtotal?: FloatFilter<"Invoice"> | number
    tax?: FloatFilter<"Invoice"> | number
    total?: FloatFilter<"Invoice"> | number
    paymentMethod?: StringNullableFilter<"Invoice"> | string | null
    notes?: StringNullableFilter<"Invoice"> | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    order?: XOR<OrderNullableScalarRelationFilter, OrderWhereInput> | null
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    payments?: InvoicePaymentListRelationFilter
    bankTransactions?: BankTransactionListRelationFilter
    cryptoPayments?: CryptoPaymentListRelationFilter
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    orderId?: SortOrderInput | SortOrder
    clientId?: SortOrder
    invoiceNumber?: SortOrder
    status?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    paidDate?: SortOrderInput | SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    total?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    order?: OrderOrderByWithRelationInput
    client?: ClientOrderByWithRelationInput
    payments?: InvoicePaymentOrderByRelationAggregateInput
    bankTransactions?: BankTransactionOrderByRelationAggregateInput
    cryptoPayments?: CryptoPaymentOrderByRelationAggregateInput
  }

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    invoiceNumber?: string
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    tenantId?: StringFilter<"Invoice"> | string
    orderId?: StringNullableFilter<"Invoice"> | string | null
    clientId?: StringFilter<"Invoice"> | string
    status?: StringFilter<"Invoice"> | string
    issueDate?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    paidDate?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    subtotal?: FloatFilter<"Invoice"> | number
    tax?: FloatFilter<"Invoice"> | number
    total?: FloatFilter<"Invoice"> | number
    paymentMethod?: StringNullableFilter<"Invoice"> | string | null
    notes?: StringNullableFilter<"Invoice"> | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    order?: XOR<OrderNullableScalarRelationFilter, OrderWhereInput> | null
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    payments?: InvoicePaymentListRelationFilter
    bankTransactions?: BankTransactionListRelationFilter
    cryptoPayments?: CryptoPaymentListRelationFilter
  }, "id" | "invoiceNumber">

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    orderId?: SortOrderInput | SortOrder
    clientId?: SortOrder
    invoiceNumber?: SortOrder
    status?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    paidDate?: SortOrderInput | SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    total?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    OR?: InvoiceScalarWhereWithAggregatesInput[]
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Invoice"> | string
    tenantId?: StringWithAggregatesFilter<"Invoice"> | string
    orderId?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    clientId?: StringWithAggregatesFilter<"Invoice"> | string
    invoiceNumber?: StringWithAggregatesFilter<"Invoice"> | string
    status?: StringWithAggregatesFilter<"Invoice"> | string
    issueDate?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    dueDate?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    paidDate?: DateTimeNullableWithAggregatesFilter<"Invoice"> | Date | string | null
    subtotal?: FloatWithAggregatesFilter<"Invoice"> | number
    tax?: FloatWithAggregatesFilter<"Invoice"> | number
    total?: FloatWithAggregatesFilter<"Invoice"> | number
    paymentMethod?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
  }

  export type AILogWhereInput = {
    AND?: AILogWhereInput | AILogWhereInput[]
    OR?: AILogWhereInput[]
    NOT?: AILogWhereInput | AILogWhereInput[]
    id?: StringFilter<"AILog"> | string
    tenantId?: StringFilter<"AILog"> | string
    feature?: StringFilter<"AILog"> | string
    model?: StringFilter<"AILog"> | string
    promptTokens?: IntFilter<"AILog"> | number
    completionTokens?: IntFilter<"AILog"> | number
    totalTokens?: IntFilter<"AILog"> | number
    estimatedCost?: FloatFilter<"AILog"> | number
    input?: JsonFilter<"AILog">
    output?: JsonNullableFilter<"AILog">
    latencyMs?: IntNullableFilter<"AILog"> | number | null
    success?: BoolFilter<"AILog"> | boolean
    error?: StringNullableFilter<"AILog"> | string | null
    createdAt?: DateTimeFilter<"AILog"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type AILogOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    feature?: SortOrder
    model?: SortOrder
    promptTokens?: SortOrder
    completionTokens?: SortOrder
    totalTokens?: SortOrder
    estimatedCost?: SortOrder
    input?: SortOrder
    output?: SortOrderInput | SortOrder
    latencyMs?: SortOrderInput | SortOrder
    success?: SortOrder
    error?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
  }

  export type AILogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AILogWhereInput | AILogWhereInput[]
    OR?: AILogWhereInput[]
    NOT?: AILogWhereInput | AILogWhereInput[]
    tenantId?: StringFilter<"AILog"> | string
    feature?: StringFilter<"AILog"> | string
    model?: StringFilter<"AILog"> | string
    promptTokens?: IntFilter<"AILog"> | number
    completionTokens?: IntFilter<"AILog"> | number
    totalTokens?: IntFilter<"AILog"> | number
    estimatedCost?: FloatFilter<"AILog"> | number
    input?: JsonFilter<"AILog">
    output?: JsonNullableFilter<"AILog">
    latencyMs?: IntNullableFilter<"AILog"> | number | null
    success?: BoolFilter<"AILog"> | boolean
    error?: StringNullableFilter<"AILog"> | string | null
    createdAt?: DateTimeFilter<"AILog"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id">

  export type AILogOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    feature?: SortOrder
    model?: SortOrder
    promptTokens?: SortOrder
    completionTokens?: SortOrder
    totalTokens?: SortOrder
    estimatedCost?: SortOrder
    input?: SortOrder
    output?: SortOrderInput | SortOrder
    latencyMs?: SortOrderInput | SortOrder
    success?: SortOrder
    error?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AILogCountOrderByAggregateInput
    _avg?: AILogAvgOrderByAggregateInput
    _max?: AILogMaxOrderByAggregateInput
    _min?: AILogMinOrderByAggregateInput
    _sum?: AILogSumOrderByAggregateInput
  }

  export type AILogScalarWhereWithAggregatesInput = {
    AND?: AILogScalarWhereWithAggregatesInput | AILogScalarWhereWithAggregatesInput[]
    OR?: AILogScalarWhereWithAggregatesInput[]
    NOT?: AILogScalarWhereWithAggregatesInput | AILogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AILog"> | string
    tenantId?: StringWithAggregatesFilter<"AILog"> | string
    feature?: StringWithAggregatesFilter<"AILog"> | string
    model?: StringWithAggregatesFilter<"AILog"> | string
    promptTokens?: IntWithAggregatesFilter<"AILog"> | number
    completionTokens?: IntWithAggregatesFilter<"AILog"> | number
    totalTokens?: IntWithAggregatesFilter<"AILog"> | number
    estimatedCost?: FloatWithAggregatesFilter<"AILog"> | number
    input?: JsonWithAggregatesFilter<"AILog">
    output?: JsonNullableWithAggregatesFilter<"AILog">
    latencyMs?: IntNullableWithAggregatesFilter<"AILog"> | number | null
    success?: BoolWithAggregatesFilter<"AILog"> | boolean
    error?: StringNullableWithAggregatesFilter<"AILog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AILog"> | Date | string
  }

  export type CurrencyWhereInput = {
    AND?: CurrencyWhereInput | CurrencyWhereInput[]
    OR?: CurrencyWhereInput[]
    NOT?: CurrencyWhereInput | CurrencyWhereInput[]
    id?: StringFilter<"Currency"> | string
    code?: StringFilter<"Currency"> | string
    name?: StringFilter<"Currency"> | string
    symbol?: StringFilter<"Currency"> | string
    decimals?: IntFilter<"Currency"> | number
    isCrypto?: BoolFilter<"Currency"> | boolean
    isStablecoin?: BoolFilter<"Currency"> | boolean
    isActive?: BoolFilter<"Currency"> | boolean
    createdAt?: DateTimeFilter<"Currency"> | Date | string
    updatedAt?: DateTimeFilter<"Currency"> | Date | string
    exchangeRatesFrom?: ExchangeRateListRelationFilter
    exchangeRatesTo?: ExchangeRateListRelationFilter
  }

  export type CurrencyOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    decimals?: SortOrder
    isCrypto?: SortOrder
    isStablecoin?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    exchangeRatesFrom?: ExchangeRateOrderByRelationAggregateInput
    exchangeRatesTo?: ExchangeRateOrderByRelationAggregateInput
  }

  export type CurrencyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: CurrencyWhereInput | CurrencyWhereInput[]
    OR?: CurrencyWhereInput[]
    NOT?: CurrencyWhereInput | CurrencyWhereInput[]
    name?: StringFilter<"Currency"> | string
    symbol?: StringFilter<"Currency"> | string
    decimals?: IntFilter<"Currency"> | number
    isCrypto?: BoolFilter<"Currency"> | boolean
    isStablecoin?: BoolFilter<"Currency"> | boolean
    isActive?: BoolFilter<"Currency"> | boolean
    createdAt?: DateTimeFilter<"Currency"> | Date | string
    updatedAt?: DateTimeFilter<"Currency"> | Date | string
    exchangeRatesFrom?: ExchangeRateListRelationFilter
    exchangeRatesTo?: ExchangeRateListRelationFilter
  }, "id" | "code">

  export type CurrencyOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    decimals?: SortOrder
    isCrypto?: SortOrder
    isStablecoin?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CurrencyCountOrderByAggregateInput
    _avg?: CurrencyAvgOrderByAggregateInput
    _max?: CurrencyMaxOrderByAggregateInput
    _min?: CurrencyMinOrderByAggregateInput
    _sum?: CurrencySumOrderByAggregateInput
  }

  export type CurrencyScalarWhereWithAggregatesInput = {
    AND?: CurrencyScalarWhereWithAggregatesInput | CurrencyScalarWhereWithAggregatesInput[]
    OR?: CurrencyScalarWhereWithAggregatesInput[]
    NOT?: CurrencyScalarWhereWithAggregatesInput | CurrencyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Currency"> | string
    code?: StringWithAggregatesFilter<"Currency"> | string
    name?: StringWithAggregatesFilter<"Currency"> | string
    symbol?: StringWithAggregatesFilter<"Currency"> | string
    decimals?: IntWithAggregatesFilter<"Currency"> | number
    isCrypto?: BoolWithAggregatesFilter<"Currency"> | boolean
    isStablecoin?: BoolWithAggregatesFilter<"Currency"> | boolean
    isActive?: BoolWithAggregatesFilter<"Currency"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Currency"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Currency"> | Date | string
  }

  export type ExchangeRateWhereInput = {
    AND?: ExchangeRateWhereInput | ExchangeRateWhereInput[]
    OR?: ExchangeRateWhereInput[]
    NOT?: ExchangeRateWhereInput | ExchangeRateWhereInput[]
    id?: StringFilter<"ExchangeRate"> | string
    fromCurrencyId?: StringFilter<"ExchangeRate"> | string
    toCurrencyId?: StringFilter<"ExchangeRate"> | string
    rate?: DecimalFilter<"ExchangeRate"> | Decimal | DecimalJsLike | number | string
    source?: StringFilter<"ExchangeRate"> | string
    timestamp?: DateTimeFilter<"ExchangeRate"> | Date | string
    fromCurrency?: XOR<CurrencyScalarRelationFilter, CurrencyWhereInput>
    toCurrency?: XOR<CurrencyScalarRelationFilter, CurrencyWhereInput>
  }

  export type ExchangeRateOrderByWithRelationInput = {
    id?: SortOrder
    fromCurrencyId?: SortOrder
    toCurrencyId?: SortOrder
    rate?: SortOrder
    source?: SortOrder
    timestamp?: SortOrder
    fromCurrency?: CurrencyOrderByWithRelationInput
    toCurrency?: CurrencyOrderByWithRelationInput
  }

  export type ExchangeRateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    fromCurrencyId_toCurrencyId_timestamp?: ExchangeRateFromCurrencyIdToCurrencyIdTimestampCompoundUniqueInput
    AND?: ExchangeRateWhereInput | ExchangeRateWhereInput[]
    OR?: ExchangeRateWhereInput[]
    NOT?: ExchangeRateWhereInput | ExchangeRateWhereInput[]
    fromCurrencyId?: StringFilter<"ExchangeRate"> | string
    toCurrencyId?: StringFilter<"ExchangeRate"> | string
    rate?: DecimalFilter<"ExchangeRate"> | Decimal | DecimalJsLike | number | string
    source?: StringFilter<"ExchangeRate"> | string
    timestamp?: DateTimeFilter<"ExchangeRate"> | Date | string
    fromCurrency?: XOR<CurrencyScalarRelationFilter, CurrencyWhereInput>
    toCurrency?: XOR<CurrencyScalarRelationFilter, CurrencyWhereInput>
  }, "id" | "fromCurrencyId_toCurrencyId_timestamp">

  export type ExchangeRateOrderByWithAggregationInput = {
    id?: SortOrder
    fromCurrencyId?: SortOrder
    toCurrencyId?: SortOrder
    rate?: SortOrder
    source?: SortOrder
    timestamp?: SortOrder
    _count?: ExchangeRateCountOrderByAggregateInput
    _avg?: ExchangeRateAvgOrderByAggregateInput
    _max?: ExchangeRateMaxOrderByAggregateInput
    _min?: ExchangeRateMinOrderByAggregateInput
    _sum?: ExchangeRateSumOrderByAggregateInput
  }

  export type ExchangeRateScalarWhereWithAggregatesInput = {
    AND?: ExchangeRateScalarWhereWithAggregatesInput | ExchangeRateScalarWhereWithAggregatesInput[]
    OR?: ExchangeRateScalarWhereWithAggregatesInput[]
    NOT?: ExchangeRateScalarWhereWithAggregatesInput | ExchangeRateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExchangeRate"> | string
    fromCurrencyId?: StringWithAggregatesFilter<"ExchangeRate"> | string
    toCurrencyId?: StringWithAggregatesFilter<"ExchangeRate"> | string
    rate?: DecimalWithAggregatesFilter<"ExchangeRate"> | Decimal | DecimalJsLike | number | string
    source?: StringWithAggregatesFilter<"ExchangeRate"> | string
    timestamp?: DateTimeWithAggregatesFilter<"ExchangeRate"> | Date | string
  }

  export type BankAccountWhereInput = {
    AND?: BankAccountWhereInput | BankAccountWhereInput[]
    OR?: BankAccountWhereInput[]
    NOT?: BankAccountWhereInput | BankAccountWhereInput[]
    id?: StringFilter<"BankAccount"> | string
    tenantId?: StringFilter<"BankAccount"> | string
    accountName?: StringFilter<"BankAccount"> | string
    accountNumber?: StringFilter<"BankAccount"> | string
    bankCode?: StringNullableFilter<"BankAccount"> | string | null
    iban?: StringNullableFilter<"BankAccount"> | string | null
    swift?: StringNullableFilter<"BankAccount"> | string | null
    provider?: EnumBankProviderFilter<"BankAccount"> | $Enums.BankProvider
    providerAccountId?: StringNullableFilter<"BankAccount"> | string | null
    currency?: StringFilter<"BankAccount"> | string
    balance?: DecimalNullableFilter<"BankAccount"> | Decimal | DecimalJsLike | number | string | null
    balanceUpdatedAt?: DateTimeNullableFilter<"BankAccount"> | Date | string | null
    autoSync?: BoolFilter<"BankAccount"> | boolean
    lastSyncAt?: DateTimeNullableFilter<"BankAccount"> | Date | string | null
    syncFrequency?: StringFilter<"BankAccount"> | string
    credentials?: JsonNullableFilter<"BankAccount">
    isActive?: BoolFilter<"BankAccount"> | boolean
    metadata?: JsonNullableFilter<"BankAccount">
    createdAt?: DateTimeFilter<"BankAccount"> | Date | string
    updatedAt?: DateTimeFilter<"BankAccount"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    transactions?: BankTransactionListRelationFilter
  }

  export type BankAccountOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    accountName?: SortOrder
    accountNumber?: SortOrder
    bankCode?: SortOrderInput | SortOrder
    iban?: SortOrderInput | SortOrder
    swift?: SortOrderInput | SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrderInput | SortOrder
    currency?: SortOrder
    balance?: SortOrderInput | SortOrder
    balanceUpdatedAt?: SortOrderInput | SortOrder
    autoSync?: SortOrder
    lastSyncAt?: SortOrderInput | SortOrder
    syncFrequency?: SortOrder
    credentials?: SortOrderInput | SortOrder
    isActive?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    transactions?: BankTransactionOrderByRelationAggregateInput
  }

  export type BankAccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BankAccountWhereInput | BankAccountWhereInput[]
    OR?: BankAccountWhereInput[]
    NOT?: BankAccountWhereInput | BankAccountWhereInput[]
    tenantId?: StringFilter<"BankAccount"> | string
    accountName?: StringFilter<"BankAccount"> | string
    accountNumber?: StringFilter<"BankAccount"> | string
    bankCode?: StringNullableFilter<"BankAccount"> | string | null
    iban?: StringNullableFilter<"BankAccount"> | string | null
    swift?: StringNullableFilter<"BankAccount"> | string | null
    provider?: EnumBankProviderFilter<"BankAccount"> | $Enums.BankProvider
    providerAccountId?: StringNullableFilter<"BankAccount"> | string | null
    currency?: StringFilter<"BankAccount"> | string
    balance?: DecimalNullableFilter<"BankAccount"> | Decimal | DecimalJsLike | number | string | null
    balanceUpdatedAt?: DateTimeNullableFilter<"BankAccount"> | Date | string | null
    autoSync?: BoolFilter<"BankAccount"> | boolean
    lastSyncAt?: DateTimeNullableFilter<"BankAccount"> | Date | string | null
    syncFrequency?: StringFilter<"BankAccount"> | string
    credentials?: JsonNullableFilter<"BankAccount">
    isActive?: BoolFilter<"BankAccount"> | boolean
    metadata?: JsonNullableFilter<"BankAccount">
    createdAt?: DateTimeFilter<"BankAccount"> | Date | string
    updatedAt?: DateTimeFilter<"BankAccount"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    transactions?: BankTransactionListRelationFilter
  }, "id">

  export type BankAccountOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    accountName?: SortOrder
    accountNumber?: SortOrder
    bankCode?: SortOrderInput | SortOrder
    iban?: SortOrderInput | SortOrder
    swift?: SortOrderInput | SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrderInput | SortOrder
    currency?: SortOrder
    balance?: SortOrderInput | SortOrder
    balanceUpdatedAt?: SortOrderInput | SortOrder
    autoSync?: SortOrder
    lastSyncAt?: SortOrderInput | SortOrder
    syncFrequency?: SortOrder
    credentials?: SortOrderInput | SortOrder
    isActive?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BankAccountCountOrderByAggregateInput
    _avg?: BankAccountAvgOrderByAggregateInput
    _max?: BankAccountMaxOrderByAggregateInput
    _min?: BankAccountMinOrderByAggregateInput
    _sum?: BankAccountSumOrderByAggregateInput
  }

  export type BankAccountScalarWhereWithAggregatesInput = {
    AND?: BankAccountScalarWhereWithAggregatesInput | BankAccountScalarWhereWithAggregatesInput[]
    OR?: BankAccountScalarWhereWithAggregatesInput[]
    NOT?: BankAccountScalarWhereWithAggregatesInput | BankAccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BankAccount"> | string
    tenantId?: StringWithAggregatesFilter<"BankAccount"> | string
    accountName?: StringWithAggregatesFilter<"BankAccount"> | string
    accountNumber?: StringWithAggregatesFilter<"BankAccount"> | string
    bankCode?: StringNullableWithAggregatesFilter<"BankAccount"> | string | null
    iban?: StringNullableWithAggregatesFilter<"BankAccount"> | string | null
    swift?: StringNullableWithAggregatesFilter<"BankAccount"> | string | null
    provider?: EnumBankProviderWithAggregatesFilter<"BankAccount"> | $Enums.BankProvider
    providerAccountId?: StringNullableWithAggregatesFilter<"BankAccount"> | string | null
    currency?: StringWithAggregatesFilter<"BankAccount"> | string
    balance?: DecimalNullableWithAggregatesFilter<"BankAccount"> | Decimal | DecimalJsLike | number | string | null
    balanceUpdatedAt?: DateTimeNullableWithAggregatesFilter<"BankAccount"> | Date | string | null
    autoSync?: BoolWithAggregatesFilter<"BankAccount"> | boolean
    lastSyncAt?: DateTimeNullableWithAggregatesFilter<"BankAccount"> | Date | string | null
    syncFrequency?: StringWithAggregatesFilter<"BankAccount"> | string
    credentials?: JsonNullableWithAggregatesFilter<"BankAccount">
    isActive?: BoolWithAggregatesFilter<"BankAccount"> | boolean
    metadata?: JsonNullableWithAggregatesFilter<"BankAccount">
    createdAt?: DateTimeWithAggregatesFilter<"BankAccount"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BankAccount"> | Date | string
  }

  export type BankTransactionWhereInput = {
    AND?: BankTransactionWhereInput | BankTransactionWhereInput[]
    OR?: BankTransactionWhereInput[]
    NOT?: BankTransactionWhereInput | BankTransactionWhereInput[]
    id?: StringFilter<"BankTransaction"> | string
    bankAccountId?: StringFilter<"BankTransaction"> | string
    tenantId?: StringFilter<"BankTransaction"> | string
    transactionId?: StringFilter<"BankTransaction"> | string
    date?: DateTimeFilter<"BankTransaction"> | Date | string
    amount?: DecimalFilter<"BankTransaction"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"BankTransaction"> | string
    type?: EnumTransactionTypeFilter<"BankTransaction"> | $Enums.TransactionType
    counterpartyName?: StringNullableFilter<"BankTransaction"> | string | null
    counterpartyAccount?: StringNullableFilter<"BankTransaction"> | string | null
    counterpartyBankCode?: StringNullableFilter<"BankTransaction"> | string | null
    description?: StringNullableFilter<"BankTransaction"> | string | null
    note?: StringNullableFilter<"BankTransaction"> | string | null
    variableSymbol?: StringNullableFilter<"BankTransaction"> | string | null
    constantSymbol?: StringNullableFilter<"BankTransaction"> | string | null
    specificSymbol?: StringNullableFilter<"BankTransaction"> | string | null
    reference?: StringNullableFilter<"BankTransaction"> | string | null
    isMatched?: BoolFilter<"BankTransaction"> | boolean
    matchedInvoiceId?: StringNullableFilter<"BankTransaction"> | string | null
    matchedPaymentId?: StringNullableFilter<"BankTransaction"> | string | null
    matchConfidence?: DecimalNullableFilter<"BankTransaction"> | Decimal | DecimalJsLike | number | string | null
    aiSuggestions?: JsonNullableFilter<"BankTransaction">
    metadata?: JsonNullableFilter<"BankTransaction">
    createdAt?: DateTimeFilter<"BankTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"BankTransaction"> | Date | string
    bankAccount?: XOR<BankAccountScalarRelationFilter, BankAccountWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    matchedInvoice?: XOR<InvoiceNullableScalarRelationFilter, InvoiceWhereInput> | null
  }

  export type BankTransactionOrderByWithRelationInput = {
    id?: SortOrder
    bankAccountId?: SortOrder
    tenantId?: SortOrder
    transactionId?: SortOrder
    date?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    type?: SortOrder
    counterpartyName?: SortOrderInput | SortOrder
    counterpartyAccount?: SortOrderInput | SortOrder
    counterpartyBankCode?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    variableSymbol?: SortOrderInput | SortOrder
    constantSymbol?: SortOrderInput | SortOrder
    specificSymbol?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    isMatched?: SortOrder
    matchedInvoiceId?: SortOrderInput | SortOrder
    matchedPaymentId?: SortOrderInput | SortOrder
    matchConfidence?: SortOrderInput | SortOrder
    aiSuggestions?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bankAccount?: BankAccountOrderByWithRelationInput
    tenant?: TenantOrderByWithRelationInput
    matchedInvoice?: InvoiceOrderByWithRelationInput
  }

  export type BankTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    bankAccountId_transactionId?: BankTransactionBankAccountIdTransactionIdCompoundUniqueInput
    AND?: BankTransactionWhereInput | BankTransactionWhereInput[]
    OR?: BankTransactionWhereInput[]
    NOT?: BankTransactionWhereInput | BankTransactionWhereInput[]
    bankAccountId?: StringFilter<"BankTransaction"> | string
    tenantId?: StringFilter<"BankTransaction"> | string
    transactionId?: StringFilter<"BankTransaction"> | string
    date?: DateTimeFilter<"BankTransaction"> | Date | string
    amount?: DecimalFilter<"BankTransaction"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"BankTransaction"> | string
    type?: EnumTransactionTypeFilter<"BankTransaction"> | $Enums.TransactionType
    counterpartyName?: StringNullableFilter<"BankTransaction"> | string | null
    counterpartyAccount?: StringNullableFilter<"BankTransaction"> | string | null
    counterpartyBankCode?: StringNullableFilter<"BankTransaction"> | string | null
    description?: StringNullableFilter<"BankTransaction"> | string | null
    note?: StringNullableFilter<"BankTransaction"> | string | null
    variableSymbol?: StringNullableFilter<"BankTransaction"> | string | null
    constantSymbol?: StringNullableFilter<"BankTransaction"> | string | null
    specificSymbol?: StringNullableFilter<"BankTransaction"> | string | null
    reference?: StringNullableFilter<"BankTransaction"> | string | null
    isMatched?: BoolFilter<"BankTransaction"> | boolean
    matchedInvoiceId?: StringNullableFilter<"BankTransaction"> | string | null
    matchedPaymentId?: StringNullableFilter<"BankTransaction"> | string | null
    matchConfidence?: DecimalNullableFilter<"BankTransaction"> | Decimal | DecimalJsLike | number | string | null
    aiSuggestions?: JsonNullableFilter<"BankTransaction">
    metadata?: JsonNullableFilter<"BankTransaction">
    createdAt?: DateTimeFilter<"BankTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"BankTransaction"> | Date | string
    bankAccount?: XOR<BankAccountScalarRelationFilter, BankAccountWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    matchedInvoice?: XOR<InvoiceNullableScalarRelationFilter, InvoiceWhereInput> | null
  }, "id" | "bankAccountId_transactionId">

  export type BankTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    bankAccountId?: SortOrder
    tenantId?: SortOrder
    transactionId?: SortOrder
    date?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    type?: SortOrder
    counterpartyName?: SortOrderInput | SortOrder
    counterpartyAccount?: SortOrderInput | SortOrder
    counterpartyBankCode?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    variableSymbol?: SortOrderInput | SortOrder
    constantSymbol?: SortOrderInput | SortOrder
    specificSymbol?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    isMatched?: SortOrder
    matchedInvoiceId?: SortOrderInput | SortOrder
    matchedPaymentId?: SortOrderInput | SortOrder
    matchConfidence?: SortOrderInput | SortOrder
    aiSuggestions?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BankTransactionCountOrderByAggregateInput
    _avg?: BankTransactionAvgOrderByAggregateInput
    _max?: BankTransactionMaxOrderByAggregateInput
    _min?: BankTransactionMinOrderByAggregateInput
    _sum?: BankTransactionSumOrderByAggregateInput
  }

  export type BankTransactionScalarWhereWithAggregatesInput = {
    AND?: BankTransactionScalarWhereWithAggregatesInput | BankTransactionScalarWhereWithAggregatesInput[]
    OR?: BankTransactionScalarWhereWithAggregatesInput[]
    NOT?: BankTransactionScalarWhereWithAggregatesInput | BankTransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BankTransaction"> | string
    bankAccountId?: StringWithAggregatesFilter<"BankTransaction"> | string
    tenantId?: StringWithAggregatesFilter<"BankTransaction"> | string
    transactionId?: StringWithAggregatesFilter<"BankTransaction"> | string
    date?: DateTimeWithAggregatesFilter<"BankTransaction"> | Date | string
    amount?: DecimalWithAggregatesFilter<"BankTransaction"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"BankTransaction"> | string
    type?: EnumTransactionTypeWithAggregatesFilter<"BankTransaction"> | $Enums.TransactionType
    counterpartyName?: StringNullableWithAggregatesFilter<"BankTransaction"> | string | null
    counterpartyAccount?: StringNullableWithAggregatesFilter<"BankTransaction"> | string | null
    counterpartyBankCode?: StringNullableWithAggregatesFilter<"BankTransaction"> | string | null
    description?: StringNullableWithAggregatesFilter<"BankTransaction"> | string | null
    note?: StringNullableWithAggregatesFilter<"BankTransaction"> | string | null
    variableSymbol?: StringNullableWithAggregatesFilter<"BankTransaction"> | string | null
    constantSymbol?: StringNullableWithAggregatesFilter<"BankTransaction"> | string | null
    specificSymbol?: StringNullableWithAggregatesFilter<"BankTransaction"> | string | null
    reference?: StringNullableWithAggregatesFilter<"BankTransaction"> | string | null
    isMatched?: BoolWithAggregatesFilter<"BankTransaction"> | boolean
    matchedInvoiceId?: StringNullableWithAggregatesFilter<"BankTransaction"> | string | null
    matchedPaymentId?: StringNullableWithAggregatesFilter<"BankTransaction"> | string | null
    matchConfidence?: DecimalNullableWithAggregatesFilter<"BankTransaction"> | Decimal | DecimalJsLike | number | string | null
    aiSuggestions?: JsonNullableWithAggregatesFilter<"BankTransaction">
    metadata?: JsonNullableWithAggregatesFilter<"BankTransaction">
    createdAt?: DateTimeWithAggregatesFilter<"BankTransaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BankTransaction"> | Date | string
  }

  export type InvoicePaymentWhereInput = {
    AND?: InvoicePaymentWhereInput | InvoicePaymentWhereInput[]
    OR?: InvoicePaymentWhereInput[]
    NOT?: InvoicePaymentWhereInput | InvoicePaymentWhereInput[]
    id?: StringFilter<"InvoicePayment"> | string
    tenantId?: StringFilter<"InvoicePayment"> | string
    invoiceId?: StringFilter<"InvoicePayment"> | string
    amount?: DecimalFilter<"InvoicePayment"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"InvoicePayment"> | string
    method?: EnumPaymentMethodFilter<"InvoicePayment"> | $Enums.PaymentMethod
    status?: StringFilter<"InvoicePayment"> | string
    gatewayProvider?: StringNullableFilter<"InvoicePayment"> | string | null
    gatewayPaymentId?: StringNullableFilter<"InvoicePayment"> | string | null
    gatewayFee?: DecimalNullableFilter<"InvoicePayment"> | Decimal | DecimalJsLike | number | string | null
    transactionId?: StringNullableFilter<"InvoicePayment"> | string | null
    reference?: StringNullableFilter<"InvoicePayment"> | string | null
    processedAt?: DateTimeNullableFilter<"InvoicePayment"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"InvoicePayment"> | Date | string | null
    metadata?: JsonNullableFilter<"InvoicePayment">
    createdAt?: DateTimeFilter<"InvoicePayment"> | Date | string
    updatedAt?: DateTimeFilter<"InvoicePayment"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    invoice?: XOR<InvoiceScalarRelationFilter, InvoiceWhereInput>
  }

  export type InvoicePaymentOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    method?: SortOrder
    status?: SortOrder
    gatewayProvider?: SortOrderInput | SortOrder
    gatewayPaymentId?: SortOrderInput | SortOrder
    gatewayFee?: SortOrderInput | SortOrder
    transactionId?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    processedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    invoice?: InvoiceOrderByWithRelationInput
  }

  export type InvoicePaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InvoicePaymentWhereInput | InvoicePaymentWhereInput[]
    OR?: InvoicePaymentWhereInput[]
    NOT?: InvoicePaymentWhereInput | InvoicePaymentWhereInput[]
    tenantId?: StringFilter<"InvoicePayment"> | string
    invoiceId?: StringFilter<"InvoicePayment"> | string
    amount?: DecimalFilter<"InvoicePayment"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"InvoicePayment"> | string
    method?: EnumPaymentMethodFilter<"InvoicePayment"> | $Enums.PaymentMethod
    status?: StringFilter<"InvoicePayment"> | string
    gatewayProvider?: StringNullableFilter<"InvoicePayment"> | string | null
    gatewayPaymentId?: StringNullableFilter<"InvoicePayment"> | string | null
    gatewayFee?: DecimalNullableFilter<"InvoicePayment"> | Decimal | DecimalJsLike | number | string | null
    transactionId?: StringNullableFilter<"InvoicePayment"> | string | null
    reference?: StringNullableFilter<"InvoicePayment"> | string | null
    processedAt?: DateTimeNullableFilter<"InvoicePayment"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"InvoicePayment"> | Date | string | null
    metadata?: JsonNullableFilter<"InvoicePayment">
    createdAt?: DateTimeFilter<"InvoicePayment"> | Date | string
    updatedAt?: DateTimeFilter<"InvoicePayment"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    invoice?: XOR<InvoiceScalarRelationFilter, InvoiceWhereInput>
  }, "id">

  export type InvoicePaymentOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    method?: SortOrder
    status?: SortOrder
    gatewayProvider?: SortOrderInput | SortOrder
    gatewayPaymentId?: SortOrderInput | SortOrder
    gatewayFee?: SortOrderInput | SortOrder
    transactionId?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    processedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InvoicePaymentCountOrderByAggregateInput
    _avg?: InvoicePaymentAvgOrderByAggregateInput
    _max?: InvoicePaymentMaxOrderByAggregateInput
    _min?: InvoicePaymentMinOrderByAggregateInput
    _sum?: InvoicePaymentSumOrderByAggregateInput
  }

  export type InvoicePaymentScalarWhereWithAggregatesInput = {
    AND?: InvoicePaymentScalarWhereWithAggregatesInput | InvoicePaymentScalarWhereWithAggregatesInput[]
    OR?: InvoicePaymentScalarWhereWithAggregatesInput[]
    NOT?: InvoicePaymentScalarWhereWithAggregatesInput | InvoicePaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InvoicePayment"> | string
    tenantId?: StringWithAggregatesFilter<"InvoicePayment"> | string
    invoiceId?: StringWithAggregatesFilter<"InvoicePayment"> | string
    amount?: DecimalWithAggregatesFilter<"InvoicePayment"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"InvoicePayment"> | string
    method?: EnumPaymentMethodWithAggregatesFilter<"InvoicePayment"> | $Enums.PaymentMethod
    status?: StringWithAggregatesFilter<"InvoicePayment"> | string
    gatewayProvider?: StringNullableWithAggregatesFilter<"InvoicePayment"> | string | null
    gatewayPaymentId?: StringNullableWithAggregatesFilter<"InvoicePayment"> | string | null
    gatewayFee?: DecimalNullableWithAggregatesFilter<"InvoicePayment"> | Decimal | DecimalJsLike | number | string | null
    transactionId?: StringNullableWithAggregatesFilter<"InvoicePayment"> | string | null
    reference?: StringNullableWithAggregatesFilter<"InvoicePayment"> | string | null
    processedAt?: DateTimeNullableWithAggregatesFilter<"InvoicePayment"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"InvoicePayment"> | Date | string | null
    metadata?: JsonNullableWithAggregatesFilter<"InvoicePayment">
    createdAt?: DateTimeWithAggregatesFilter<"InvoicePayment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"InvoicePayment"> | Date | string
  }

  export type PaymentGatewayConfigWhereInput = {
    AND?: PaymentGatewayConfigWhereInput | PaymentGatewayConfigWhereInput[]
    OR?: PaymentGatewayConfigWhereInput[]
    NOT?: PaymentGatewayConfigWhereInput | PaymentGatewayConfigWhereInput[]
    id?: StringFilter<"PaymentGatewayConfig"> | string
    tenantId?: StringFilter<"PaymentGatewayConfig"> | string
    provider?: StringFilter<"PaymentGatewayConfig"> | string
    config?: JsonFilter<"PaymentGatewayConfig">
    isActive?: BoolFilter<"PaymentGatewayConfig"> | boolean
    isTest?: BoolFilter<"PaymentGatewayConfig"> | boolean
    createdAt?: DateTimeFilter<"PaymentGatewayConfig"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentGatewayConfig"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type PaymentGatewayConfigOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    provider?: SortOrder
    config?: SortOrder
    isActive?: SortOrder
    isTest?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
  }

  export type PaymentGatewayConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId_provider?: PaymentGatewayConfigTenantIdProviderCompoundUniqueInput
    AND?: PaymentGatewayConfigWhereInput | PaymentGatewayConfigWhereInput[]
    OR?: PaymentGatewayConfigWhereInput[]
    NOT?: PaymentGatewayConfigWhereInput | PaymentGatewayConfigWhereInput[]
    tenantId?: StringFilter<"PaymentGatewayConfig"> | string
    provider?: StringFilter<"PaymentGatewayConfig"> | string
    config?: JsonFilter<"PaymentGatewayConfig">
    isActive?: BoolFilter<"PaymentGatewayConfig"> | boolean
    isTest?: BoolFilter<"PaymentGatewayConfig"> | boolean
    createdAt?: DateTimeFilter<"PaymentGatewayConfig"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentGatewayConfig"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id" | "tenantId_provider">

  export type PaymentGatewayConfigOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    provider?: SortOrder
    config?: SortOrder
    isActive?: SortOrder
    isTest?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentGatewayConfigCountOrderByAggregateInput
    _max?: PaymentGatewayConfigMaxOrderByAggregateInput
    _min?: PaymentGatewayConfigMinOrderByAggregateInput
  }

  export type PaymentGatewayConfigScalarWhereWithAggregatesInput = {
    AND?: PaymentGatewayConfigScalarWhereWithAggregatesInput | PaymentGatewayConfigScalarWhereWithAggregatesInput[]
    OR?: PaymentGatewayConfigScalarWhereWithAggregatesInput[]
    NOT?: PaymentGatewayConfigScalarWhereWithAggregatesInput | PaymentGatewayConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PaymentGatewayConfig"> | string
    tenantId?: StringWithAggregatesFilter<"PaymentGatewayConfig"> | string
    provider?: StringWithAggregatesFilter<"PaymentGatewayConfig"> | string
    config?: JsonWithAggregatesFilter<"PaymentGatewayConfig">
    isActive?: BoolWithAggregatesFilter<"PaymentGatewayConfig"> | boolean
    isTest?: BoolWithAggregatesFilter<"PaymentGatewayConfig"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PaymentGatewayConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PaymentGatewayConfig"> | Date | string
  }

  export type CryptoWalletWhereInput = {
    AND?: CryptoWalletWhereInput | CryptoWalletWhereInput[]
    OR?: CryptoWalletWhereInput[]
    NOT?: CryptoWalletWhereInput | CryptoWalletWhereInput[]
    id?: StringFilter<"CryptoWallet"> | string
    tenantId?: StringFilter<"CryptoWallet"> | string
    currency?: StringFilter<"CryptoWallet"> | string
    address?: StringFilter<"CryptoWallet"> | string
    network?: StringNullableFilter<"CryptoWallet"> | string | null
    provider?: StringFilter<"CryptoWallet"> | string
    isActive?: BoolFilter<"CryptoWallet"> | boolean
    metadata?: JsonNullableFilter<"CryptoWallet">
    createdAt?: DateTimeFilter<"CryptoWallet"> | Date | string
    updatedAt?: DateTimeFilter<"CryptoWallet"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    payments?: CryptoPaymentListRelationFilter
  }

  export type CryptoWalletOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    currency?: SortOrder
    address?: SortOrder
    network?: SortOrderInput | SortOrder
    provider?: SortOrder
    isActive?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    payments?: CryptoPaymentOrderByRelationAggregateInput
  }

  export type CryptoWalletWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId_currency_address?: CryptoWalletTenantIdCurrencyAddressCompoundUniqueInput
    AND?: CryptoWalletWhereInput | CryptoWalletWhereInput[]
    OR?: CryptoWalletWhereInput[]
    NOT?: CryptoWalletWhereInput | CryptoWalletWhereInput[]
    tenantId?: StringFilter<"CryptoWallet"> | string
    currency?: StringFilter<"CryptoWallet"> | string
    address?: StringFilter<"CryptoWallet"> | string
    network?: StringNullableFilter<"CryptoWallet"> | string | null
    provider?: StringFilter<"CryptoWallet"> | string
    isActive?: BoolFilter<"CryptoWallet"> | boolean
    metadata?: JsonNullableFilter<"CryptoWallet">
    createdAt?: DateTimeFilter<"CryptoWallet"> | Date | string
    updatedAt?: DateTimeFilter<"CryptoWallet"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    payments?: CryptoPaymentListRelationFilter
  }, "id" | "tenantId_currency_address">

  export type CryptoWalletOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    currency?: SortOrder
    address?: SortOrder
    network?: SortOrderInput | SortOrder
    provider?: SortOrder
    isActive?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CryptoWalletCountOrderByAggregateInput
    _max?: CryptoWalletMaxOrderByAggregateInput
    _min?: CryptoWalletMinOrderByAggregateInput
  }

  export type CryptoWalletScalarWhereWithAggregatesInput = {
    AND?: CryptoWalletScalarWhereWithAggregatesInput | CryptoWalletScalarWhereWithAggregatesInput[]
    OR?: CryptoWalletScalarWhereWithAggregatesInput[]
    NOT?: CryptoWalletScalarWhereWithAggregatesInput | CryptoWalletScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CryptoWallet"> | string
    tenantId?: StringWithAggregatesFilter<"CryptoWallet"> | string
    currency?: StringWithAggregatesFilter<"CryptoWallet"> | string
    address?: StringWithAggregatesFilter<"CryptoWallet"> | string
    network?: StringNullableWithAggregatesFilter<"CryptoWallet"> | string | null
    provider?: StringWithAggregatesFilter<"CryptoWallet"> | string
    isActive?: BoolWithAggregatesFilter<"CryptoWallet"> | boolean
    metadata?: JsonNullableWithAggregatesFilter<"CryptoWallet">
    createdAt?: DateTimeWithAggregatesFilter<"CryptoWallet"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CryptoWallet"> | Date | string
  }

  export type CryptoPaymentWhereInput = {
    AND?: CryptoPaymentWhereInput | CryptoPaymentWhereInput[]
    OR?: CryptoPaymentWhereInput[]
    NOT?: CryptoPaymentWhereInput | CryptoPaymentWhereInput[]
    id?: StringFilter<"CryptoPayment"> | string
    walletId?: StringFilter<"CryptoPayment"> | string
    invoiceId?: StringNullableFilter<"CryptoPayment"> | string | null
    amount?: StringFilter<"CryptoPayment"> | string
    currency?: StringFilter<"CryptoPayment"> | string
    txHash?: StringNullableFilter<"CryptoPayment"> | string | null
    confirmations?: IntFilter<"CryptoPayment"> | number
    status?: StringFilter<"CryptoPayment"> | string
    detectedAt?: DateTimeNullableFilter<"CryptoPayment"> | Date | string | null
    confirmedAt?: DateTimeNullableFilter<"CryptoPayment"> | Date | string | null
    metadata?: JsonNullableFilter<"CryptoPayment">
    createdAt?: DateTimeFilter<"CryptoPayment"> | Date | string
    updatedAt?: DateTimeFilter<"CryptoPayment"> | Date | string
    wallet?: XOR<CryptoWalletScalarRelationFilter, CryptoWalletWhereInput>
    invoice?: XOR<InvoiceNullableScalarRelationFilter, InvoiceWhereInput> | null
  }

  export type CryptoPaymentOrderByWithRelationInput = {
    id?: SortOrder
    walletId?: SortOrder
    invoiceId?: SortOrderInput | SortOrder
    amount?: SortOrder
    currency?: SortOrder
    txHash?: SortOrderInput | SortOrder
    confirmations?: SortOrder
    status?: SortOrder
    detectedAt?: SortOrderInput | SortOrder
    confirmedAt?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    wallet?: CryptoWalletOrderByWithRelationInput
    invoice?: InvoiceOrderByWithRelationInput
  }

  export type CryptoPaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CryptoPaymentWhereInput | CryptoPaymentWhereInput[]
    OR?: CryptoPaymentWhereInput[]
    NOT?: CryptoPaymentWhereInput | CryptoPaymentWhereInput[]
    walletId?: StringFilter<"CryptoPayment"> | string
    invoiceId?: StringNullableFilter<"CryptoPayment"> | string | null
    amount?: StringFilter<"CryptoPayment"> | string
    currency?: StringFilter<"CryptoPayment"> | string
    txHash?: StringNullableFilter<"CryptoPayment"> | string | null
    confirmations?: IntFilter<"CryptoPayment"> | number
    status?: StringFilter<"CryptoPayment"> | string
    detectedAt?: DateTimeNullableFilter<"CryptoPayment"> | Date | string | null
    confirmedAt?: DateTimeNullableFilter<"CryptoPayment"> | Date | string | null
    metadata?: JsonNullableFilter<"CryptoPayment">
    createdAt?: DateTimeFilter<"CryptoPayment"> | Date | string
    updatedAt?: DateTimeFilter<"CryptoPayment"> | Date | string
    wallet?: XOR<CryptoWalletScalarRelationFilter, CryptoWalletWhereInput>
    invoice?: XOR<InvoiceNullableScalarRelationFilter, InvoiceWhereInput> | null
  }, "id">

  export type CryptoPaymentOrderByWithAggregationInput = {
    id?: SortOrder
    walletId?: SortOrder
    invoiceId?: SortOrderInput | SortOrder
    amount?: SortOrder
    currency?: SortOrder
    txHash?: SortOrderInput | SortOrder
    confirmations?: SortOrder
    status?: SortOrder
    detectedAt?: SortOrderInput | SortOrder
    confirmedAt?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CryptoPaymentCountOrderByAggregateInput
    _avg?: CryptoPaymentAvgOrderByAggregateInput
    _max?: CryptoPaymentMaxOrderByAggregateInput
    _min?: CryptoPaymentMinOrderByAggregateInput
    _sum?: CryptoPaymentSumOrderByAggregateInput
  }

  export type CryptoPaymentScalarWhereWithAggregatesInput = {
    AND?: CryptoPaymentScalarWhereWithAggregatesInput | CryptoPaymentScalarWhereWithAggregatesInput[]
    OR?: CryptoPaymentScalarWhereWithAggregatesInput[]
    NOT?: CryptoPaymentScalarWhereWithAggregatesInput | CryptoPaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CryptoPayment"> | string
    walletId?: StringWithAggregatesFilter<"CryptoPayment"> | string
    invoiceId?: StringNullableWithAggregatesFilter<"CryptoPayment"> | string | null
    amount?: StringWithAggregatesFilter<"CryptoPayment"> | string
    currency?: StringWithAggregatesFilter<"CryptoPayment"> | string
    txHash?: StringNullableWithAggregatesFilter<"CryptoPayment"> | string | null
    confirmations?: IntWithAggregatesFilter<"CryptoPayment"> | number
    status?: StringWithAggregatesFilter<"CryptoPayment"> | string
    detectedAt?: DateTimeNullableWithAggregatesFilter<"CryptoPayment"> | Date | string | null
    confirmedAt?: DateTimeNullableWithAggregatesFilter<"CryptoPayment"> | Date | string | null
    metadata?: JsonNullableWithAggregatesFilter<"CryptoPayment">
    createdAt?: DateTimeWithAggregatesFilter<"CryptoPayment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CryptoPayment"> | Date | string
  }

  export type ExpenseCategoryWhereInput = {
    AND?: ExpenseCategoryWhereInput | ExpenseCategoryWhereInput[]
    OR?: ExpenseCategoryWhereInput[]
    NOT?: ExpenseCategoryWhereInput | ExpenseCategoryWhereInput[]
    id?: StringFilter<"ExpenseCategory"> | string
    tenantId?: StringFilter<"ExpenseCategory"> | string
    name?: StringFilter<"ExpenseCategory"> | string
    description?: StringNullableFilter<"ExpenseCategory"> | string | null
    isDefault?: BoolFilter<"ExpenseCategory"> | boolean
    createdAt?: DateTimeFilter<"ExpenseCategory"> | Date | string
    updatedAt?: DateTimeFilter<"ExpenseCategory"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    expenses?: ExpenseListRelationFilter
  }

  export type ExpenseCategoryOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    expenses?: ExpenseOrderByRelationAggregateInput
  }

  export type ExpenseCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId_name?: ExpenseCategoryTenantIdNameCompoundUniqueInput
    AND?: ExpenseCategoryWhereInput | ExpenseCategoryWhereInput[]
    OR?: ExpenseCategoryWhereInput[]
    NOT?: ExpenseCategoryWhereInput | ExpenseCategoryWhereInput[]
    tenantId?: StringFilter<"ExpenseCategory"> | string
    name?: StringFilter<"ExpenseCategory"> | string
    description?: StringNullableFilter<"ExpenseCategory"> | string | null
    isDefault?: BoolFilter<"ExpenseCategory"> | boolean
    createdAt?: DateTimeFilter<"ExpenseCategory"> | Date | string
    updatedAt?: DateTimeFilter<"ExpenseCategory"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    expenses?: ExpenseListRelationFilter
  }, "id" | "tenantId_name">

  export type ExpenseCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExpenseCategoryCountOrderByAggregateInput
    _max?: ExpenseCategoryMaxOrderByAggregateInput
    _min?: ExpenseCategoryMinOrderByAggregateInput
  }

  export type ExpenseCategoryScalarWhereWithAggregatesInput = {
    AND?: ExpenseCategoryScalarWhereWithAggregatesInput | ExpenseCategoryScalarWhereWithAggregatesInput[]
    OR?: ExpenseCategoryScalarWhereWithAggregatesInput[]
    NOT?: ExpenseCategoryScalarWhereWithAggregatesInput | ExpenseCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExpenseCategory"> | string
    tenantId?: StringWithAggregatesFilter<"ExpenseCategory"> | string
    name?: StringWithAggregatesFilter<"ExpenseCategory"> | string
    description?: StringNullableWithAggregatesFilter<"ExpenseCategory"> | string | null
    isDefault?: BoolWithAggregatesFilter<"ExpenseCategory"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ExpenseCategory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ExpenseCategory"> | Date | string
  }

  export type ExpenseWhereInput = {
    AND?: ExpenseWhereInput | ExpenseWhereInput[]
    OR?: ExpenseWhereInput[]
    NOT?: ExpenseWhereInput | ExpenseWhereInput[]
    id?: StringFilter<"Expense"> | string
    tenantId?: StringFilter<"Expense"> | string
    categoryId?: StringFilter<"Expense"> | string
    description?: StringFilter<"Expense"> | string
    amount?: DecimalFilter<"Expense"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Expense"> | string
    date?: DateTimeFilter<"Expense"> | Date | string
    vendor?: StringNullableFilter<"Expense"> | string | null
    receiptUrl?: StringNullableFilter<"Expense"> | string | null
    receiptOcrData?: JsonNullableFilter<"Expense">
    taxAmount?: DecimalNullableFilter<"Expense"> | Decimal | DecimalJsLike | number | string | null
    isTaxDeductible?: BoolFilter<"Expense"> | boolean
    status?: EnumExpenseStatusFilter<"Expense"> | $Enums.ExpenseStatus
    approvedBy?: StringNullableFilter<"Expense"> | string | null
    approvedAt?: DateTimeNullableFilter<"Expense"> | Date | string | null
    rejectedReason?: StringNullableFilter<"Expense"> | string | null
    reimbursedAt?: DateTimeNullableFilter<"Expense"> | Date | string | null
    reimbursedAmount?: DecimalNullableFilter<"Expense"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"Expense"> | string | null
    metadata?: JsonNullableFilter<"Expense">
    createdAt?: DateTimeFilter<"Expense"> | Date | string
    updatedAt?: DateTimeFilter<"Expense"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    category?: XOR<ExpenseCategoryScalarRelationFilter, ExpenseCategoryWhereInput>
  }

  export type ExpenseOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    categoryId?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    date?: SortOrder
    vendor?: SortOrderInput | SortOrder
    receiptUrl?: SortOrderInput | SortOrder
    receiptOcrData?: SortOrderInput | SortOrder
    taxAmount?: SortOrderInput | SortOrder
    isTaxDeductible?: SortOrder
    status?: SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    rejectedReason?: SortOrderInput | SortOrder
    reimbursedAt?: SortOrderInput | SortOrder
    reimbursedAmount?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    category?: ExpenseCategoryOrderByWithRelationInput
  }

  export type ExpenseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExpenseWhereInput | ExpenseWhereInput[]
    OR?: ExpenseWhereInput[]
    NOT?: ExpenseWhereInput | ExpenseWhereInput[]
    tenantId?: StringFilter<"Expense"> | string
    categoryId?: StringFilter<"Expense"> | string
    description?: StringFilter<"Expense"> | string
    amount?: DecimalFilter<"Expense"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Expense"> | string
    date?: DateTimeFilter<"Expense"> | Date | string
    vendor?: StringNullableFilter<"Expense"> | string | null
    receiptUrl?: StringNullableFilter<"Expense"> | string | null
    receiptOcrData?: JsonNullableFilter<"Expense">
    taxAmount?: DecimalNullableFilter<"Expense"> | Decimal | DecimalJsLike | number | string | null
    isTaxDeductible?: BoolFilter<"Expense"> | boolean
    status?: EnumExpenseStatusFilter<"Expense"> | $Enums.ExpenseStatus
    approvedBy?: StringNullableFilter<"Expense"> | string | null
    approvedAt?: DateTimeNullableFilter<"Expense"> | Date | string | null
    rejectedReason?: StringNullableFilter<"Expense"> | string | null
    reimbursedAt?: DateTimeNullableFilter<"Expense"> | Date | string | null
    reimbursedAmount?: DecimalNullableFilter<"Expense"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"Expense"> | string | null
    metadata?: JsonNullableFilter<"Expense">
    createdAt?: DateTimeFilter<"Expense"> | Date | string
    updatedAt?: DateTimeFilter<"Expense"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    category?: XOR<ExpenseCategoryScalarRelationFilter, ExpenseCategoryWhereInput>
  }, "id">

  export type ExpenseOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    categoryId?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    date?: SortOrder
    vendor?: SortOrderInput | SortOrder
    receiptUrl?: SortOrderInput | SortOrder
    receiptOcrData?: SortOrderInput | SortOrder
    taxAmount?: SortOrderInput | SortOrder
    isTaxDeductible?: SortOrder
    status?: SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    rejectedReason?: SortOrderInput | SortOrder
    reimbursedAt?: SortOrderInput | SortOrder
    reimbursedAmount?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExpenseCountOrderByAggregateInput
    _avg?: ExpenseAvgOrderByAggregateInput
    _max?: ExpenseMaxOrderByAggregateInput
    _min?: ExpenseMinOrderByAggregateInput
    _sum?: ExpenseSumOrderByAggregateInput
  }

  export type ExpenseScalarWhereWithAggregatesInput = {
    AND?: ExpenseScalarWhereWithAggregatesInput | ExpenseScalarWhereWithAggregatesInput[]
    OR?: ExpenseScalarWhereWithAggregatesInput[]
    NOT?: ExpenseScalarWhereWithAggregatesInput | ExpenseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Expense"> | string
    tenantId?: StringWithAggregatesFilter<"Expense"> | string
    categoryId?: StringWithAggregatesFilter<"Expense"> | string
    description?: StringWithAggregatesFilter<"Expense"> | string
    amount?: DecimalWithAggregatesFilter<"Expense"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"Expense"> | string
    date?: DateTimeWithAggregatesFilter<"Expense"> | Date | string
    vendor?: StringNullableWithAggregatesFilter<"Expense"> | string | null
    receiptUrl?: StringNullableWithAggregatesFilter<"Expense"> | string | null
    receiptOcrData?: JsonNullableWithAggregatesFilter<"Expense">
    taxAmount?: DecimalNullableWithAggregatesFilter<"Expense"> | Decimal | DecimalJsLike | number | string | null
    isTaxDeductible?: BoolWithAggregatesFilter<"Expense"> | boolean
    status?: EnumExpenseStatusWithAggregatesFilter<"Expense"> | $Enums.ExpenseStatus
    approvedBy?: StringNullableWithAggregatesFilter<"Expense"> | string | null
    approvedAt?: DateTimeNullableWithAggregatesFilter<"Expense"> | Date | string | null
    rejectedReason?: StringNullableWithAggregatesFilter<"Expense"> | string | null
    reimbursedAt?: DateTimeNullableWithAggregatesFilter<"Expense"> | Date | string | null
    reimbursedAmount?: DecimalNullableWithAggregatesFilter<"Expense"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableWithAggregatesFilter<"Expense"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Expense">
    createdAt?: DateTimeWithAggregatesFilter<"Expense"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Expense"> | Date | string
  }

  export type RecurringInvoiceTemplateWhereInput = {
    AND?: RecurringInvoiceTemplateWhereInput | RecurringInvoiceTemplateWhereInput[]
    OR?: RecurringInvoiceTemplateWhereInput[]
    NOT?: RecurringInvoiceTemplateWhereInput | RecurringInvoiceTemplateWhereInput[]
    id?: StringFilter<"RecurringInvoiceTemplate"> | string
    tenantId?: StringFilter<"RecurringInvoiceTemplate"> | string
    frequency?: StringFilter<"RecurringInvoiceTemplate"> | string
    nextInvoiceDate?: DateTimeFilter<"RecurringInvoiceTemplate"> | Date | string
    isActive?: BoolFilter<"RecurringInvoiceTemplate"> | boolean
    invoiceTemplate?: JsonFilter<"RecurringInvoiceTemplate">
    metadata?: JsonNullableFilter<"RecurringInvoiceTemplate">
    createdAt?: DateTimeFilter<"RecurringInvoiceTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"RecurringInvoiceTemplate"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type RecurringInvoiceTemplateOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    frequency?: SortOrder
    nextInvoiceDate?: SortOrder
    isActive?: SortOrder
    invoiceTemplate?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
  }

  export type RecurringInvoiceTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RecurringInvoiceTemplateWhereInput | RecurringInvoiceTemplateWhereInput[]
    OR?: RecurringInvoiceTemplateWhereInput[]
    NOT?: RecurringInvoiceTemplateWhereInput | RecurringInvoiceTemplateWhereInput[]
    tenantId?: StringFilter<"RecurringInvoiceTemplate"> | string
    frequency?: StringFilter<"RecurringInvoiceTemplate"> | string
    nextInvoiceDate?: DateTimeFilter<"RecurringInvoiceTemplate"> | Date | string
    isActive?: BoolFilter<"RecurringInvoiceTemplate"> | boolean
    invoiceTemplate?: JsonFilter<"RecurringInvoiceTemplate">
    metadata?: JsonNullableFilter<"RecurringInvoiceTemplate">
    createdAt?: DateTimeFilter<"RecurringInvoiceTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"RecurringInvoiceTemplate"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id">

  export type RecurringInvoiceTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    frequency?: SortOrder
    nextInvoiceDate?: SortOrder
    isActive?: SortOrder
    invoiceTemplate?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RecurringInvoiceTemplateCountOrderByAggregateInput
    _max?: RecurringInvoiceTemplateMaxOrderByAggregateInput
    _min?: RecurringInvoiceTemplateMinOrderByAggregateInput
  }

  export type RecurringInvoiceTemplateScalarWhereWithAggregatesInput = {
    AND?: RecurringInvoiceTemplateScalarWhereWithAggregatesInput | RecurringInvoiceTemplateScalarWhereWithAggregatesInput[]
    OR?: RecurringInvoiceTemplateScalarWhereWithAggregatesInput[]
    NOT?: RecurringInvoiceTemplateScalarWhereWithAggregatesInput | RecurringInvoiceTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RecurringInvoiceTemplate"> | string
    tenantId?: StringWithAggregatesFilter<"RecurringInvoiceTemplate"> | string
    frequency?: StringWithAggregatesFilter<"RecurringInvoiceTemplate"> | string
    nextInvoiceDate?: DateTimeWithAggregatesFilter<"RecurringInvoiceTemplate"> | Date | string
    isActive?: BoolWithAggregatesFilter<"RecurringInvoiceTemplate"> | boolean
    invoiceTemplate?: JsonWithAggregatesFilter<"RecurringInvoiceTemplate">
    metadata?: JsonNullableWithAggregatesFilter<"RecurringInvoiceTemplate">
    createdAt?: DateTimeWithAggregatesFilter<"RecurringInvoiceTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RecurringInvoiceTemplate"> | Date | string
  }

  export type PushSubscriptionWhereInput = {
    AND?: PushSubscriptionWhereInput | PushSubscriptionWhereInput[]
    OR?: PushSubscriptionWhereInput[]
    NOT?: PushSubscriptionWhereInput | PushSubscriptionWhereInput[]
    id?: StringFilter<"PushSubscription"> | string
    tenantId?: StringFilter<"PushSubscription"> | string
    userId?: StringNullableFilter<"PushSubscription"> | string | null
    clientId?: StringNullableFilter<"PushSubscription"> | string | null
    endpoint?: StringFilter<"PushSubscription"> | string
    p256dh?: StringFilter<"PushSubscription"> | string
    auth?: StringFilter<"PushSubscription"> | string
    userAgent?: StringNullableFilter<"PushSubscription"> | string | null
    deviceName?: StringNullableFilter<"PushSubscription"> | string | null
    isActive?: BoolFilter<"PushSubscription"> | boolean
    createdAt?: DateTimeFilter<"PushSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"PushSubscription"> | Date | string
  }

  export type PushSubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrderInput | SortOrder
    clientId?: SortOrderInput | SortOrder
    endpoint?: SortOrder
    p256dh?: SortOrder
    auth?: SortOrder
    userAgent?: SortOrderInput | SortOrder
    deviceName?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PushSubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    endpoint?: string
    AND?: PushSubscriptionWhereInput | PushSubscriptionWhereInput[]
    OR?: PushSubscriptionWhereInput[]
    NOT?: PushSubscriptionWhereInput | PushSubscriptionWhereInput[]
    tenantId?: StringFilter<"PushSubscription"> | string
    userId?: StringNullableFilter<"PushSubscription"> | string | null
    clientId?: StringNullableFilter<"PushSubscription"> | string | null
    p256dh?: StringFilter<"PushSubscription"> | string
    auth?: StringFilter<"PushSubscription"> | string
    userAgent?: StringNullableFilter<"PushSubscription"> | string | null
    deviceName?: StringNullableFilter<"PushSubscription"> | string | null
    isActive?: BoolFilter<"PushSubscription"> | boolean
    createdAt?: DateTimeFilter<"PushSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"PushSubscription"> | Date | string
  }, "id" | "endpoint">

  export type PushSubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrderInput | SortOrder
    clientId?: SortOrderInput | SortOrder
    endpoint?: SortOrder
    p256dh?: SortOrder
    auth?: SortOrder
    userAgent?: SortOrderInput | SortOrder
    deviceName?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PushSubscriptionCountOrderByAggregateInput
    _max?: PushSubscriptionMaxOrderByAggregateInput
    _min?: PushSubscriptionMinOrderByAggregateInput
  }

  export type PushSubscriptionScalarWhereWithAggregatesInput = {
    AND?: PushSubscriptionScalarWhereWithAggregatesInput | PushSubscriptionScalarWhereWithAggregatesInput[]
    OR?: PushSubscriptionScalarWhereWithAggregatesInput[]
    NOT?: PushSubscriptionScalarWhereWithAggregatesInput | PushSubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PushSubscription"> | string
    tenantId?: StringWithAggregatesFilter<"PushSubscription"> | string
    userId?: StringNullableWithAggregatesFilter<"PushSubscription"> | string | null
    clientId?: StringNullableWithAggregatesFilter<"PushSubscription"> | string | null
    endpoint?: StringWithAggregatesFilter<"PushSubscription"> | string
    p256dh?: StringWithAggregatesFilter<"PushSubscription"> | string
    auth?: StringWithAggregatesFilter<"PushSubscription"> | string
    userAgent?: StringNullableWithAggregatesFilter<"PushSubscription"> | string | null
    deviceName?: StringNullableWithAggregatesFilter<"PushSubscription"> | string | null
    isActive?: BoolWithAggregatesFilter<"PushSubscription"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PushSubscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PushSubscription"> | Date | string
  }

  export type NotificationPreferenceWhereInput = {
    AND?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[]
    OR?: NotificationPreferenceWhereInput[]
    NOT?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[]
    id?: StringFilter<"NotificationPreference"> | string
    tenantId?: StringFilter<"NotificationPreference"> | string
    userId?: StringNullableFilter<"NotificationPreference"> | string | null
    clientId?: StringNullableFilter<"NotificationPreference"> | string | null
    sessionReminders?: BoolFilter<"NotificationPreference"> | boolean
    classReminders?: BoolFilter<"NotificationPreference"> | boolean
    invoiceNotifications?: BoolFilter<"NotificationPreference"> | boolean
    paymentNotifications?: BoolFilter<"NotificationPreference"> | boolean
    atRiskAlerts?: BoolFilter<"NotificationPreference"> | boolean
    reminderMinutesBefore?: IntFilter<"NotificationPreference"> | number
    emailEnabled?: BoolFilter<"NotificationPreference"> | boolean
    pushEnabled?: BoolFilter<"NotificationPreference"> | boolean
    createdAt?: DateTimeFilter<"NotificationPreference"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationPreference"> | Date | string
  }

  export type NotificationPreferenceOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrderInput | SortOrder
    clientId?: SortOrderInput | SortOrder
    sessionReminders?: SortOrder
    classReminders?: SortOrder
    invoiceNotifications?: SortOrder
    paymentNotifications?: SortOrder
    atRiskAlerts?: SortOrder
    reminderMinutesBefore?: SortOrder
    emailEnabled?: SortOrder
    pushEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationPreferenceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId_userId?: NotificationPreferenceTenantIdUserIdCompoundUniqueInput
    AND?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[]
    OR?: NotificationPreferenceWhereInput[]
    NOT?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[]
    tenantId?: StringFilter<"NotificationPreference"> | string
    userId?: StringNullableFilter<"NotificationPreference"> | string | null
    clientId?: StringNullableFilter<"NotificationPreference"> | string | null
    sessionReminders?: BoolFilter<"NotificationPreference"> | boolean
    classReminders?: BoolFilter<"NotificationPreference"> | boolean
    invoiceNotifications?: BoolFilter<"NotificationPreference"> | boolean
    paymentNotifications?: BoolFilter<"NotificationPreference"> | boolean
    atRiskAlerts?: BoolFilter<"NotificationPreference"> | boolean
    reminderMinutesBefore?: IntFilter<"NotificationPreference"> | number
    emailEnabled?: BoolFilter<"NotificationPreference"> | boolean
    pushEnabled?: BoolFilter<"NotificationPreference"> | boolean
    createdAt?: DateTimeFilter<"NotificationPreference"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationPreference"> | Date | string
  }, "id" | "tenantId_userId">

  export type NotificationPreferenceOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrderInput | SortOrder
    clientId?: SortOrderInput | SortOrder
    sessionReminders?: SortOrder
    classReminders?: SortOrder
    invoiceNotifications?: SortOrder
    paymentNotifications?: SortOrder
    atRiskAlerts?: SortOrder
    reminderMinutesBefore?: SortOrder
    emailEnabled?: SortOrder
    pushEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationPreferenceCountOrderByAggregateInput
    _avg?: NotificationPreferenceAvgOrderByAggregateInput
    _max?: NotificationPreferenceMaxOrderByAggregateInput
    _min?: NotificationPreferenceMinOrderByAggregateInput
    _sum?: NotificationPreferenceSumOrderByAggregateInput
  }

  export type NotificationPreferenceScalarWhereWithAggregatesInput = {
    AND?: NotificationPreferenceScalarWhereWithAggregatesInput | NotificationPreferenceScalarWhereWithAggregatesInput[]
    OR?: NotificationPreferenceScalarWhereWithAggregatesInput[]
    NOT?: NotificationPreferenceScalarWhereWithAggregatesInput | NotificationPreferenceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NotificationPreference"> | string
    tenantId?: StringWithAggregatesFilter<"NotificationPreference"> | string
    userId?: StringNullableWithAggregatesFilter<"NotificationPreference"> | string | null
    clientId?: StringNullableWithAggregatesFilter<"NotificationPreference"> | string | null
    sessionReminders?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    classReminders?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    invoiceNotifications?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    paymentNotifications?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    atRiskAlerts?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    reminderMinutesBefore?: IntWithAggregatesFilter<"NotificationPreference"> | number
    emailEnabled?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    pushEnabled?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"NotificationPreference"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NotificationPreference"> | Date | string
  }

  export type NotificationLogWhereInput = {
    AND?: NotificationLogWhereInput | NotificationLogWhereInput[]
    OR?: NotificationLogWhereInput[]
    NOT?: NotificationLogWhereInput | NotificationLogWhereInput[]
    id?: StringFilter<"NotificationLog"> | string
    tenantId?: StringFilter<"NotificationLog"> | string
    type?: StringFilter<"NotificationLog"> | string
    recipientType?: StringFilter<"NotificationLog"> | string
    recipientId?: StringFilter<"NotificationLog"> | string
    title?: StringFilter<"NotificationLog"> | string
    body?: StringFilter<"NotificationLog"> | string
    data?: JsonNullableFilter<"NotificationLog">
    channel?: StringFilter<"NotificationLog"> | string
    status?: StringFilter<"NotificationLog"> | string
    error?: StringNullableFilter<"NotificationLog"> | string | null
    sentAt?: DateTimeNullableFilter<"NotificationLog"> | Date | string | null
    createdAt?: DateTimeFilter<"NotificationLog"> | Date | string
  }

  export type NotificationLogOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    type?: SortOrder
    recipientType?: SortOrder
    recipientId?: SortOrder
    title?: SortOrder
    body?: SortOrder
    data?: SortOrderInput | SortOrder
    channel?: SortOrder
    status?: SortOrder
    error?: SortOrderInput | SortOrder
    sentAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type NotificationLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationLogWhereInput | NotificationLogWhereInput[]
    OR?: NotificationLogWhereInput[]
    NOT?: NotificationLogWhereInput | NotificationLogWhereInput[]
    tenantId?: StringFilter<"NotificationLog"> | string
    type?: StringFilter<"NotificationLog"> | string
    recipientType?: StringFilter<"NotificationLog"> | string
    recipientId?: StringFilter<"NotificationLog"> | string
    title?: StringFilter<"NotificationLog"> | string
    body?: StringFilter<"NotificationLog"> | string
    data?: JsonNullableFilter<"NotificationLog">
    channel?: StringFilter<"NotificationLog"> | string
    status?: StringFilter<"NotificationLog"> | string
    error?: StringNullableFilter<"NotificationLog"> | string | null
    sentAt?: DateTimeNullableFilter<"NotificationLog"> | Date | string | null
    createdAt?: DateTimeFilter<"NotificationLog"> | Date | string
  }, "id">

  export type NotificationLogOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    type?: SortOrder
    recipientType?: SortOrder
    recipientId?: SortOrder
    title?: SortOrder
    body?: SortOrder
    data?: SortOrderInput | SortOrder
    channel?: SortOrder
    status?: SortOrder
    error?: SortOrderInput | SortOrder
    sentAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: NotificationLogCountOrderByAggregateInput
    _max?: NotificationLogMaxOrderByAggregateInput
    _min?: NotificationLogMinOrderByAggregateInput
  }

  export type NotificationLogScalarWhereWithAggregatesInput = {
    AND?: NotificationLogScalarWhereWithAggregatesInput | NotificationLogScalarWhereWithAggregatesInput[]
    OR?: NotificationLogScalarWhereWithAggregatesInput[]
    NOT?: NotificationLogScalarWhereWithAggregatesInput | NotificationLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NotificationLog"> | string
    tenantId?: StringWithAggregatesFilter<"NotificationLog"> | string
    type?: StringWithAggregatesFilter<"NotificationLog"> | string
    recipientType?: StringWithAggregatesFilter<"NotificationLog"> | string
    recipientId?: StringWithAggregatesFilter<"NotificationLog"> | string
    title?: StringWithAggregatesFilter<"NotificationLog"> | string
    body?: StringWithAggregatesFilter<"NotificationLog"> | string
    data?: JsonNullableWithAggregatesFilter<"NotificationLog">
    channel?: StringWithAggregatesFilter<"NotificationLog"> | string
    status?: StringWithAggregatesFilter<"NotificationLog"> | string
    error?: StringNullableWithAggregatesFilter<"NotificationLog"> | string | null
    sentAt?: DateTimeNullableWithAggregatesFilter<"NotificationLog"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"NotificationLog"> | Date | string
  }

  export type CalendarIntegrationWhereInput = {
    AND?: CalendarIntegrationWhereInput | CalendarIntegrationWhereInput[]
    OR?: CalendarIntegrationWhereInput[]
    NOT?: CalendarIntegrationWhereInput | CalendarIntegrationWhereInput[]
    id?: StringFilter<"CalendarIntegration"> | string
    tenantId?: StringFilter<"CalendarIntegration"> | string
    userId?: StringFilter<"CalendarIntegration"> | string
    provider?: StringFilter<"CalendarIntegration"> | string
    accessToken?: StringNullableFilter<"CalendarIntegration"> | string | null
    refreshToken?: StringNullableFilter<"CalendarIntegration"> | string | null
    tokenExpiry?: DateTimeNullableFilter<"CalendarIntegration"> | Date | string | null
    calendarId?: StringNullableFilter<"CalendarIntegration"> | string | null
    calendarEmail?: StringNullableFilter<"CalendarIntegration"> | string | null
    syncEnabled?: BoolFilter<"CalendarIntegration"> | boolean
    syncDirection?: StringFilter<"CalendarIntegration"> | string
    lastSyncAt?: DateTimeNullableFilter<"CalendarIntegration"> | Date | string | null
    createdAt?: DateTimeFilter<"CalendarIntegration"> | Date | string
    updatedAt?: DateTimeFilter<"CalendarIntegration"> | Date | string
    eventSyncs?: CalendarEventSyncListRelationFilter
  }

  export type CalendarIntegrationOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    tokenExpiry?: SortOrderInput | SortOrder
    calendarId?: SortOrderInput | SortOrder
    calendarEmail?: SortOrderInput | SortOrder
    syncEnabled?: SortOrder
    syncDirection?: SortOrder
    lastSyncAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    eventSyncs?: CalendarEventSyncOrderByRelationAggregateInput
  }

  export type CalendarIntegrationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId_userId_provider?: CalendarIntegrationTenantIdUserIdProviderCompoundUniqueInput
    AND?: CalendarIntegrationWhereInput | CalendarIntegrationWhereInput[]
    OR?: CalendarIntegrationWhereInput[]
    NOT?: CalendarIntegrationWhereInput | CalendarIntegrationWhereInput[]
    tenantId?: StringFilter<"CalendarIntegration"> | string
    userId?: StringFilter<"CalendarIntegration"> | string
    provider?: StringFilter<"CalendarIntegration"> | string
    accessToken?: StringNullableFilter<"CalendarIntegration"> | string | null
    refreshToken?: StringNullableFilter<"CalendarIntegration"> | string | null
    tokenExpiry?: DateTimeNullableFilter<"CalendarIntegration"> | Date | string | null
    calendarId?: StringNullableFilter<"CalendarIntegration"> | string | null
    calendarEmail?: StringNullableFilter<"CalendarIntegration"> | string | null
    syncEnabled?: BoolFilter<"CalendarIntegration"> | boolean
    syncDirection?: StringFilter<"CalendarIntegration"> | string
    lastSyncAt?: DateTimeNullableFilter<"CalendarIntegration"> | Date | string | null
    createdAt?: DateTimeFilter<"CalendarIntegration"> | Date | string
    updatedAt?: DateTimeFilter<"CalendarIntegration"> | Date | string
    eventSyncs?: CalendarEventSyncListRelationFilter
  }, "id" | "tenantId_userId_provider">

  export type CalendarIntegrationOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    tokenExpiry?: SortOrderInput | SortOrder
    calendarId?: SortOrderInput | SortOrder
    calendarEmail?: SortOrderInput | SortOrder
    syncEnabled?: SortOrder
    syncDirection?: SortOrder
    lastSyncAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CalendarIntegrationCountOrderByAggregateInput
    _max?: CalendarIntegrationMaxOrderByAggregateInput
    _min?: CalendarIntegrationMinOrderByAggregateInput
  }

  export type CalendarIntegrationScalarWhereWithAggregatesInput = {
    AND?: CalendarIntegrationScalarWhereWithAggregatesInput | CalendarIntegrationScalarWhereWithAggregatesInput[]
    OR?: CalendarIntegrationScalarWhereWithAggregatesInput[]
    NOT?: CalendarIntegrationScalarWhereWithAggregatesInput | CalendarIntegrationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CalendarIntegration"> | string
    tenantId?: StringWithAggregatesFilter<"CalendarIntegration"> | string
    userId?: StringWithAggregatesFilter<"CalendarIntegration"> | string
    provider?: StringWithAggregatesFilter<"CalendarIntegration"> | string
    accessToken?: StringNullableWithAggregatesFilter<"CalendarIntegration"> | string | null
    refreshToken?: StringNullableWithAggregatesFilter<"CalendarIntegration"> | string | null
    tokenExpiry?: DateTimeNullableWithAggregatesFilter<"CalendarIntegration"> | Date | string | null
    calendarId?: StringNullableWithAggregatesFilter<"CalendarIntegration"> | string | null
    calendarEmail?: StringNullableWithAggregatesFilter<"CalendarIntegration"> | string | null
    syncEnabled?: BoolWithAggregatesFilter<"CalendarIntegration"> | boolean
    syncDirection?: StringWithAggregatesFilter<"CalendarIntegration"> | string
    lastSyncAt?: DateTimeNullableWithAggregatesFilter<"CalendarIntegration"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CalendarIntegration"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CalendarIntegration"> | Date | string
  }

  export type CalendarEventSyncWhereInput = {
    AND?: CalendarEventSyncWhereInput | CalendarEventSyncWhereInput[]
    OR?: CalendarEventSyncWhereInput[]
    NOT?: CalendarEventSyncWhereInput | CalendarEventSyncWhereInput[]
    id?: StringFilter<"CalendarEventSync"> | string
    integrationId?: StringFilter<"CalendarEventSync"> | string
    entityType?: StringFilter<"CalendarEventSync"> | string
    entityId?: StringFilter<"CalendarEventSync"> | string
    externalEventId?: StringFilter<"CalendarEventSync"> | string
    lastSyncedAt?: DateTimeFilter<"CalendarEventSync"> | Date | string
    syncHash?: StringFilter<"CalendarEventSync"> | string
    integration?: XOR<CalendarIntegrationScalarRelationFilter, CalendarIntegrationWhereInput>
  }

  export type CalendarEventSyncOrderByWithRelationInput = {
    id?: SortOrder
    integrationId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    externalEventId?: SortOrder
    lastSyncedAt?: SortOrder
    syncHash?: SortOrder
    integration?: CalendarIntegrationOrderByWithRelationInput
  }

  export type CalendarEventSyncWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    integrationId_entityType_entityId?: CalendarEventSyncIntegrationIdEntityTypeEntityIdCompoundUniqueInput
    AND?: CalendarEventSyncWhereInput | CalendarEventSyncWhereInput[]
    OR?: CalendarEventSyncWhereInput[]
    NOT?: CalendarEventSyncWhereInput | CalendarEventSyncWhereInput[]
    integrationId?: StringFilter<"CalendarEventSync"> | string
    entityType?: StringFilter<"CalendarEventSync"> | string
    entityId?: StringFilter<"CalendarEventSync"> | string
    externalEventId?: StringFilter<"CalendarEventSync"> | string
    lastSyncedAt?: DateTimeFilter<"CalendarEventSync"> | Date | string
    syncHash?: StringFilter<"CalendarEventSync"> | string
    integration?: XOR<CalendarIntegrationScalarRelationFilter, CalendarIntegrationWhereInput>
  }, "id" | "integrationId_entityType_entityId">

  export type CalendarEventSyncOrderByWithAggregationInput = {
    id?: SortOrder
    integrationId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    externalEventId?: SortOrder
    lastSyncedAt?: SortOrder
    syncHash?: SortOrder
    _count?: CalendarEventSyncCountOrderByAggregateInput
    _max?: CalendarEventSyncMaxOrderByAggregateInput
    _min?: CalendarEventSyncMinOrderByAggregateInput
  }

  export type CalendarEventSyncScalarWhereWithAggregatesInput = {
    AND?: CalendarEventSyncScalarWhereWithAggregatesInput | CalendarEventSyncScalarWhereWithAggregatesInput[]
    OR?: CalendarEventSyncScalarWhereWithAggregatesInput[]
    NOT?: CalendarEventSyncScalarWhereWithAggregatesInput | CalendarEventSyncScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CalendarEventSync"> | string
    integrationId?: StringWithAggregatesFilter<"CalendarEventSync"> | string
    entityType?: StringWithAggregatesFilter<"CalendarEventSync"> | string
    entityId?: StringWithAggregatesFilter<"CalendarEventSync"> | string
    externalEventId?: StringWithAggregatesFilter<"CalendarEventSync"> | string
    lastSyncedAt?: DateTimeWithAggregatesFilter<"CalendarEventSync"> | Date | string
    syncHash?: StringWithAggregatesFilter<"CalendarEventSync"> | string
  }

  export type CalendarFeedTokenWhereInput = {
    AND?: CalendarFeedTokenWhereInput | CalendarFeedTokenWhereInput[]
    OR?: CalendarFeedTokenWhereInput[]
    NOT?: CalendarFeedTokenWhereInput | CalendarFeedTokenWhereInput[]
    id?: StringFilter<"CalendarFeedToken"> | string
    tenantId?: StringFilter<"CalendarFeedToken"> | string
    userId?: StringFilter<"CalendarFeedToken"> | string
    token?: StringFilter<"CalendarFeedToken"> | string
    createdAt?: DateTimeFilter<"CalendarFeedToken"> | Date | string
    expiresAt?: DateTimeNullableFilter<"CalendarFeedToken"> | Date | string | null
  }

  export type CalendarFeedTokenOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
  }

  export type CalendarFeedTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: CalendarFeedTokenWhereInput | CalendarFeedTokenWhereInput[]
    OR?: CalendarFeedTokenWhereInput[]
    NOT?: CalendarFeedTokenWhereInput | CalendarFeedTokenWhereInput[]
    tenantId?: StringFilter<"CalendarFeedToken"> | string
    userId?: StringFilter<"CalendarFeedToken"> | string
    createdAt?: DateTimeFilter<"CalendarFeedToken"> | Date | string
    expiresAt?: DateTimeNullableFilter<"CalendarFeedToken"> | Date | string | null
  }, "id" | "token">

  export type CalendarFeedTokenOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    _count?: CalendarFeedTokenCountOrderByAggregateInput
    _max?: CalendarFeedTokenMaxOrderByAggregateInput
    _min?: CalendarFeedTokenMinOrderByAggregateInput
  }

  export type CalendarFeedTokenScalarWhereWithAggregatesInput = {
    AND?: CalendarFeedTokenScalarWhereWithAggregatesInput | CalendarFeedTokenScalarWhereWithAggregatesInput[]
    OR?: CalendarFeedTokenScalarWhereWithAggregatesInput[]
    NOT?: CalendarFeedTokenScalarWhereWithAggregatesInput | CalendarFeedTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CalendarFeedToken"> | string
    tenantId?: StringWithAggregatesFilter<"CalendarFeedToken"> | string
    userId?: StringWithAggregatesFilter<"CalendarFeedToken"> | string
    token?: StringWithAggregatesFilter<"CalendarFeedToken"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CalendarFeedToken"> | Date | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"CalendarFeedToken"> | Date | string | null
  }

  export type BadgeWhereInput = {
    AND?: BadgeWhereInput | BadgeWhereInput[]
    OR?: BadgeWhereInput[]
    NOT?: BadgeWhereInput | BadgeWhereInput[]
    id?: StringFilter<"Badge"> | string
    tenantId?: StringFilter<"Badge"> | string
    name?: StringFilter<"Badge"> | string
    description?: StringFilter<"Badge"> | string
    icon?: StringFilter<"Badge"> | string
    color?: StringFilter<"Badge"> | string
    category?: StringFilter<"Badge"> | string
    criteria?: JsonFilter<"Badge">
    isActive?: BoolFilter<"Badge"> | boolean
    createdAt?: DateTimeFilter<"Badge"> | Date | string
    updatedAt?: DateTimeFilter<"Badge"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    clientBadges?: ClientBadgeListRelationFilter
  }

  export type BadgeOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    category?: SortOrder
    criteria?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    clientBadges?: ClientBadgeOrderByRelationAggregateInput
  }

  export type BadgeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BadgeWhereInput | BadgeWhereInput[]
    OR?: BadgeWhereInput[]
    NOT?: BadgeWhereInput | BadgeWhereInput[]
    tenantId?: StringFilter<"Badge"> | string
    name?: StringFilter<"Badge"> | string
    description?: StringFilter<"Badge"> | string
    icon?: StringFilter<"Badge"> | string
    color?: StringFilter<"Badge"> | string
    category?: StringFilter<"Badge"> | string
    criteria?: JsonFilter<"Badge">
    isActive?: BoolFilter<"Badge"> | boolean
    createdAt?: DateTimeFilter<"Badge"> | Date | string
    updatedAt?: DateTimeFilter<"Badge"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    clientBadges?: ClientBadgeListRelationFilter
  }, "id">

  export type BadgeOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    category?: SortOrder
    criteria?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BadgeCountOrderByAggregateInput
    _max?: BadgeMaxOrderByAggregateInput
    _min?: BadgeMinOrderByAggregateInput
  }

  export type BadgeScalarWhereWithAggregatesInput = {
    AND?: BadgeScalarWhereWithAggregatesInput | BadgeScalarWhereWithAggregatesInput[]
    OR?: BadgeScalarWhereWithAggregatesInput[]
    NOT?: BadgeScalarWhereWithAggregatesInput | BadgeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Badge"> | string
    tenantId?: StringWithAggregatesFilter<"Badge"> | string
    name?: StringWithAggregatesFilter<"Badge"> | string
    description?: StringWithAggregatesFilter<"Badge"> | string
    icon?: StringWithAggregatesFilter<"Badge"> | string
    color?: StringWithAggregatesFilter<"Badge"> | string
    category?: StringWithAggregatesFilter<"Badge"> | string
    criteria?: JsonWithAggregatesFilter<"Badge">
    isActive?: BoolWithAggregatesFilter<"Badge"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Badge"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Badge"> | Date | string
  }

  export type ClientBadgeWhereInput = {
    AND?: ClientBadgeWhereInput | ClientBadgeWhereInput[]
    OR?: ClientBadgeWhereInput[]
    NOT?: ClientBadgeWhereInput | ClientBadgeWhereInput[]
    id?: StringFilter<"ClientBadge"> | string
    clientId?: StringFilter<"ClientBadge"> | string
    badgeId?: StringFilter<"ClientBadge"> | string
    earnedAt?: DateTimeFilter<"ClientBadge"> | Date | string
    notified?: BoolFilter<"ClientBadge"> | boolean
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    badge?: XOR<BadgeScalarRelationFilter, BadgeWhereInput>
  }

  export type ClientBadgeOrderByWithRelationInput = {
    id?: SortOrder
    clientId?: SortOrder
    badgeId?: SortOrder
    earnedAt?: SortOrder
    notified?: SortOrder
    client?: ClientOrderByWithRelationInput
    badge?: BadgeOrderByWithRelationInput
  }

  export type ClientBadgeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    clientId_badgeId?: ClientBadgeClientIdBadgeIdCompoundUniqueInput
    AND?: ClientBadgeWhereInput | ClientBadgeWhereInput[]
    OR?: ClientBadgeWhereInput[]
    NOT?: ClientBadgeWhereInput | ClientBadgeWhereInput[]
    clientId?: StringFilter<"ClientBadge"> | string
    badgeId?: StringFilter<"ClientBadge"> | string
    earnedAt?: DateTimeFilter<"ClientBadge"> | Date | string
    notified?: BoolFilter<"ClientBadge"> | boolean
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    badge?: XOR<BadgeScalarRelationFilter, BadgeWhereInput>
  }, "id" | "clientId_badgeId">

  export type ClientBadgeOrderByWithAggregationInput = {
    id?: SortOrder
    clientId?: SortOrder
    badgeId?: SortOrder
    earnedAt?: SortOrder
    notified?: SortOrder
    _count?: ClientBadgeCountOrderByAggregateInput
    _max?: ClientBadgeMaxOrderByAggregateInput
    _min?: ClientBadgeMinOrderByAggregateInput
  }

  export type ClientBadgeScalarWhereWithAggregatesInput = {
    AND?: ClientBadgeScalarWhereWithAggregatesInput | ClientBadgeScalarWhereWithAggregatesInput[]
    OR?: ClientBadgeScalarWhereWithAggregatesInput[]
    NOT?: ClientBadgeScalarWhereWithAggregatesInput | ClientBadgeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClientBadge"> | string
    clientId?: StringWithAggregatesFilter<"ClientBadge"> | string
    badgeId?: StringWithAggregatesFilter<"ClientBadge"> | string
    earnedAt?: DateTimeWithAggregatesFilter<"ClientBadge"> | Date | string
    notified?: BoolWithAggregatesFilter<"ClientBadge"> | boolean
  }

  export type WorkoutTemplateWhereInput = {
    AND?: WorkoutTemplateWhereInput | WorkoutTemplateWhereInput[]
    OR?: WorkoutTemplateWhereInput[]
    NOT?: WorkoutTemplateWhereInput | WorkoutTemplateWhereInput[]
    id?: StringFilter<"WorkoutTemplate"> | string
    tenantId?: StringFilter<"WorkoutTemplate"> | string
    name?: StringFilter<"WorkoutTemplate"> | string
    description?: StringNullableFilter<"WorkoutTemplate"> | string | null
    category?: StringFilter<"WorkoutTemplate"> | string
    difficulty?: StringFilter<"WorkoutTemplate"> | string
    duration?: IntFilter<"WorkoutTemplate"> | number
    exercises?: JsonNullableListFilter<"WorkoutTemplate">
    muscleGroups?: StringNullableListFilter<"WorkoutTemplate">
    equipment?: StringNullableListFilter<"WorkoutTemplate">
    isPublic?: BoolFilter<"WorkoutTemplate"> | boolean
    usageCount?: IntFilter<"WorkoutTemplate"> | number
    createdAt?: DateTimeFilter<"WorkoutTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"WorkoutTemplate"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type WorkoutTemplateOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    difficulty?: SortOrder
    duration?: SortOrder
    exercises?: SortOrder
    muscleGroups?: SortOrder
    equipment?: SortOrder
    isPublic?: SortOrder
    usageCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
  }

  export type WorkoutTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WorkoutTemplateWhereInput | WorkoutTemplateWhereInput[]
    OR?: WorkoutTemplateWhereInput[]
    NOT?: WorkoutTemplateWhereInput | WorkoutTemplateWhereInput[]
    tenantId?: StringFilter<"WorkoutTemplate"> | string
    name?: StringFilter<"WorkoutTemplate"> | string
    description?: StringNullableFilter<"WorkoutTemplate"> | string | null
    category?: StringFilter<"WorkoutTemplate"> | string
    difficulty?: StringFilter<"WorkoutTemplate"> | string
    duration?: IntFilter<"WorkoutTemplate"> | number
    exercises?: JsonNullableListFilter<"WorkoutTemplate">
    muscleGroups?: StringNullableListFilter<"WorkoutTemplate">
    equipment?: StringNullableListFilter<"WorkoutTemplate">
    isPublic?: BoolFilter<"WorkoutTemplate"> | boolean
    usageCount?: IntFilter<"WorkoutTemplate"> | number
    createdAt?: DateTimeFilter<"WorkoutTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"WorkoutTemplate"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id">

  export type WorkoutTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    difficulty?: SortOrder
    duration?: SortOrder
    exercises?: SortOrder
    muscleGroups?: SortOrder
    equipment?: SortOrder
    isPublic?: SortOrder
    usageCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WorkoutTemplateCountOrderByAggregateInput
    _avg?: WorkoutTemplateAvgOrderByAggregateInput
    _max?: WorkoutTemplateMaxOrderByAggregateInput
    _min?: WorkoutTemplateMinOrderByAggregateInput
    _sum?: WorkoutTemplateSumOrderByAggregateInput
  }

  export type WorkoutTemplateScalarWhereWithAggregatesInput = {
    AND?: WorkoutTemplateScalarWhereWithAggregatesInput | WorkoutTemplateScalarWhereWithAggregatesInput[]
    OR?: WorkoutTemplateScalarWhereWithAggregatesInput[]
    NOT?: WorkoutTemplateScalarWhereWithAggregatesInput | WorkoutTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkoutTemplate"> | string
    tenantId?: StringWithAggregatesFilter<"WorkoutTemplate"> | string
    name?: StringWithAggregatesFilter<"WorkoutTemplate"> | string
    description?: StringNullableWithAggregatesFilter<"WorkoutTemplate"> | string | null
    category?: StringWithAggregatesFilter<"WorkoutTemplate"> | string
    difficulty?: StringWithAggregatesFilter<"WorkoutTemplate"> | string
    duration?: IntWithAggregatesFilter<"WorkoutTemplate"> | number
    exercises?: JsonNullableListFilter<"WorkoutTemplate">
    muscleGroups?: StringNullableListFilter<"WorkoutTemplate">
    equipment?: StringNullableListFilter<"WorkoutTemplate">
    isPublic?: BoolWithAggregatesFilter<"WorkoutTemplate"> | boolean
    usageCount?: IntWithAggregatesFilter<"WorkoutTemplate"> | number
    createdAt?: DateTimeWithAggregatesFilter<"WorkoutTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WorkoutTemplate"> | Date | string
  }

  export type ScheduleTemplateWhereInput = {
    AND?: ScheduleTemplateWhereInput | ScheduleTemplateWhereInput[]
    OR?: ScheduleTemplateWhereInput[]
    NOT?: ScheduleTemplateWhereInput | ScheduleTemplateWhereInput[]
    id?: StringFilter<"ScheduleTemplate"> | string
    tenantId?: StringFilter<"ScheduleTemplate"> | string
    name?: StringFilter<"ScheduleTemplate"> | string
    description?: StringNullableFilter<"ScheduleTemplate"> | string | null
    slots?: JsonNullableListFilter<"ScheduleTemplate">
    isActive?: BoolFilter<"ScheduleTemplate"> | boolean
    createdAt?: DateTimeFilter<"ScheduleTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"ScheduleTemplate"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type ScheduleTemplateOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    slots?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
  }

  export type ScheduleTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ScheduleTemplateWhereInput | ScheduleTemplateWhereInput[]
    OR?: ScheduleTemplateWhereInput[]
    NOT?: ScheduleTemplateWhereInput | ScheduleTemplateWhereInput[]
    tenantId?: StringFilter<"ScheduleTemplate"> | string
    name?: StringFilter<"ScheduleTemplate"> | string
    description?: StringNullableFilter<"ScheduleTemplate"> | string | null
    slots?: JsonNullableListFilter<"ScheduleTemplate">
    isActive?: BoolFilter<"ScheduleTemplate"> | boolean
    createdAt?: DateTimeFilter<"ScheduleTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"ScheduleTemplate"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id">

  export type ScheduleTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    slots?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ScheduleTemplateCountOrderByAggregateInput
    _max?: ScheduleTemplateMaxOrderByAggregateInput
    _min?: ScheduleTemplateMinOrderByAggregateInput
  }

  export type ScheduleTemplateScalarWhereWithAggregatesInput = {
    AND?: ScheduleTemplateScalarWhereWithAggregatesInput | ScheduleTemplateScalarWhereWithAggregatesInput[]
    OR?: ScheduleTemplateScalarWhereWithAggregatesInput[]
    NOT?: ScheduleTemplateScalarWhereWithAggregatesInput | ScheduleTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ScheduleTemplate"> | string
    tenantId?: StringWithAggregatesFilter<"ScheduleTemplate"> | string
    name?: StringWithAggregatesFilter<"ScheduleTemplate"> | string
    description?: StringNullableWithAggregatesFilter<"ScheduleTemplate"> | string | null
    slots?: JsonNullableListFilter<"ScheduleTemplate">
    isActive?: BoolWithAggregatesFilter<"ScheduleTemplate"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ScheduleTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ScheduleTemplate"> | Date | string
  }

  export type TenantCreateInput = {
    id?: string
    vertical: $Enums.Vertical
    name: string
    slug: string
    email?: string | null
    phone?: string | null
    website?: string | null
    logo?: string | null
    subscriptionTier?: string
    aiCredits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    clients?: ClientCreateNestedManyWithoutTenantInput
    sessions?: SessionCreateNestedManyWithoutTenantInput
    classes?: ClassCreateNestedManyWithoutTenantInput
    packages?: PackageCreateNestedManyWithoutTenantInput
    orders?: OrderCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    aiLogs?: AILogCreateNestedManyWithoutTenantInput
    bankAccounts?: BankAccountCreateNestedManyWithoutTenantInput
    bankTransactions?: BankTransactionCreateNestedManyWithoutTenantInput
    invoicePayments?: InvoicePaymentCreateNestedManyWithoutTenantInput
    paymentGatewayConfigs?: PaymentGatewayConfigCreateNestedManyWithoutTenantInput
    cryptoWallets?: CryptoWalletCreateNestedManyWithoutTenantInput
    expenseCategories?: ExpenseCategoryCreateNestedManyWithoutTenantInput
    expenses?: ExpenseCreateNestedManyWithoutTenantInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateCreateNestedManyWithoutTenantInput
    badges?: BadgeCreateNestedManyWithoutTenantInput
    workoutTemplates?: WorkoutTemplateCreateNestedManyWithoutTenantInput
    scheduleTemplates?: ScheduleTemplateCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateInput = {
    id?: string
    vertical: $Enums.Vertical
    name: string
    slug: string
    email?: string | null
    phone?: string | null
    website?: string | null
    logo?: string | null
    subscriptionTier?: string
    aiCredits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    clients?: ClientUncheckedCreateNestedManyWithoutTenantInput
    sessions?: SessionUncheckedCreateNestedManyWithoutTenantInput
    classes?: ClassUncheckedCreateNestedManyWithoutTenantInput
    packages?: PackageUncheckedCreateNestedManyWithoutTenantInput
    orders?: OrderUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    aiLogs?: AILogUncheckedCreateNestedManyWithoutTenantInput
    bankAccounts?: BankAccountUncheckedCreateNestedManyWithoutTenantInput
    bankTransactions?: BankTransactionUncheckedCreateNestedManyWithoutTenantInput
    invoicePayments?: InvoicePaymentUncheckedCreateNestedManyWithoutTenantInput
    paymentGatewayConfigs?: PaymentGatewayConfigUncheckedCreateNestedManyWithoutTenantInput
    cryptoWallets?: CryptoWalletUncheckedCreateNestedManyWithoutTenantInput
    expenseCategories?: ExpenseCategoryUncheckedCreateNestedManyWithoutTenantInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutTenantInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateUncheckedCreateNestedManyWithoutTenantInput
    badges?: BadgeUncheckedCreateNestedManyWithoutTenantInput
    workoutTemplates?: WorkoutTemplateUncheckedCreateNestedManyWithoutTenantInput
    scheduleTemplates?: ScheduleTemplateUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vertical?: EnumVerticalFieldUpdateOperationsInput | $Enums.Vertical
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    aiCredits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    clients?: ClientUpdateManyWithoutTenantNestedInput
    sessions?: SessionUpdateManyWithoutTenantNestedInput
    classes?: ClassUpdateManyWithoutTenantNestedInput
    packages?: PackageUpdateManyWithoutTenantNestedInput
    orders?: OrderUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    aiLogs?: AILogUpdateManyWithoutTenantNestedInput
    bankAccounts?: BankAccountUpdateManyWithoutTenantNestedInput
    bankTransactions?: BankTransactionUpdateManyWithoutTenantNestedInput
    invoicePayments?: InvoicePaymentUpdateManyWithoutTenantNestedInput
    paymentGatewayConfigs?: PaymentGatewayConfigUpdateManyWithoutTenantNestedInput
    cryptoWallets?: CryptoWalletUpdateManyWithoutTenantNestedInput
    expenseCategories?: ExpenseCategoryUpdateManyWithoutTenantNestedInput
    expenses?: ExpenseUpdateManyWithoutTenantNestedInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateUpdateManyWithoutTenantNestedInput
    badges?: BadgeUpdateManyWithoutTenantNestedInput
    workoutTemplates?: WorkoutTemplateUpdateManyWithoutTenantNestedInput
    scheduleTemplates?: ScheduleTemplateUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vertical?: EnumVerticalFieldUpdateOperationsInput | $Enums.Vertical
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    aiCredits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    clients?: ClientUncheckedUpdateManyWithoutTenantNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutTenantNestedInput
    classes?: ClassUncheckedUpdateManyWithoutTenantNestedInput
    packages?: PackageUncheckedUpdateManyWithoutTenantNestedInput
    orders?: OrderUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    aiLogs?: AILogUncheckedUpdateManyWithoutTenantNestedInput
    bankAccounts?: BankAccountUncheckedUpdateManyWithoutTenantNestedInput
    bankTransactions?: BankTransactionUncheckedUpdateManyWithoutTenantNestedInput
    invoicePayments?: InvoicePaymentUncheckedUpdateManyWithoutTenantNestedInput
    paymentGatewayConfigs?: PaymentGatewayConfigUncheckedUpdateManyWithoutTenantNestedInput
    cryptoWallets?: CryptoWalletUncheckedUpdateManyWithoutTenantNestedInput
    expenseCategories?: ExpenseCategoryUncheckedUpdateManyWithoutTenantNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutTenantNestedInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateUncheckedUpdateManyWithoutTenantNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutTenantNestedInput
    workoutTemplates?: WorkoutTemplateUncheckedUpdateManyWithoutTenantNestedInput
    scheduleTemplates?: ScheduleTemplateUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateManyInput = {
    id?: string
    vertical: $Enums.Vertical
    name: string
    slug: string
    email?: string | null
    phone?: string | null
    website?: string | null
    logo?: string | null
    subscriptionTier?: string
    aiCredits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    vertical?: EnumVerticalFieldUpdateOperationsInput | $Enums.Vertical
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    aiCredits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    vertical?: EnumVerticalFieldUpdateOperationsInput | $Enums.Vertical
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    aiCredits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUsersInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    tenantId: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    tenantId: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserSessionCreateInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type UserSessionUncheckedCreateInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type UserSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type UserSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionCreateManyInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type UserSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUncheckedCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateManyInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateManyMutationInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateManyInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenCreateInput = {
    id?: string
    email: string
    token: string
    expires: Date | string
    createdAt?: Date | string
  }

  export type PasswordResetTokenUncheckedCreateInput = {
    id?: string
    email: string
    token: string
    expires: Date | string
    createdAt?: Date | string
  }

  export type PasswordResetTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenCreateManyInput = {
    id?: string
    email: string
    token: string
    expires: Date | string
    createdAt?: Date | string
  }

  export type PasswordResetTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCreateInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    avatar?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    goals?: ClientCreategoalsInput | string[]
    currentWeight?: number | null
    targetWeight?: number | null
    height?: number | null
    bodyMeasurements?: NullableJsonNullValueInput | InputJsonValue
    bodyFatPercent?: number | null
    fitnessLevel?: string | null
    injuryHistory?: string | null
    dietaryNotes?: string | null
    medicalNotes?: string | null
    creditsRemaining?: number
    membershipType?: string | null
    membershipExpiry?: Date | string | null
    status?: string
    tags?: ClientCreatetagsInput | string[]
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutClientsInput
    sessions?: SessionCreateNestedManyWithoutClientInput
    orders?: OrderCreateNestedManyWithoutClientInput
    invoices?: InvoiceCreateNestedManyWithoutClientInput
    measurements?: ClientMeasurementCreateNestedManyWithoutClientInput
    progressPhotos?: ProgressPhotoCreateNestedManyWithoutClientInput
    badges?: ClientBadgeCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateInput = {
    id?: string
    tenantId: string
    name: string
    email: string
    phone?: string | null
    avatar?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    goals?: ClientCreategoalsInput | string[]
    currentWeight?: number | null
    targetWeight?: number | null
    height?: number | null
    bodyMeasurements?: NullableJsonNullValueInput | InputJsonValue
    bodyFatPercent?: number | null
    fitnessLevel?: string | null
    injuryHistory?: string | null
    dietaryNotes?: string | null
    medicalNotes?: string | null
    creditsRemaining?: number
    membershipType?: string | null
    membershipExpiry?: Date | string | null
    status?: string
    tags?: ClientCreatetagsInput | string[]
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutClientInput
    orders?: OrderUncheckedCreateNestedManyWithoutClientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutClientInput
    measurements?: ClientMeasurementUncheckedCreateNestedManyWithoutClientInput
    progressPhotos?: ProgressPhotoUncheckedCreateNestedManyWithoutClientInput
    badges?: ClientBadgeUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    goals?: ClientUpdategoalsInput | string[]
    currentWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    targetWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    bodyMeasurements?: NullableJsonNullValueInput | InputJsonValue
    bodyFatPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    fitnessLevel?: NullableStringFieldUpdateOperationsInput | string | null
    injuryHistory?: NullableStringFieldUpdateOperationsInput | string | null
    dietaryNotes?: NullableStringFieldUpdateOperationsInput | string | null
    medicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    creditsRemaining?: IntFieldUpdateOperationsInput | number
    membershipType?: NullableStringFieldUpdateOperationsInput | string | null
    membershipExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    tags?: ClientUpdatetagsInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutClientsNestedInput
    sessions?: SessionUpdateManyWithoutClientNestedInput
    orders?: OrderUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUpdateManyWithoutClientNestedInput
    measurements?: ClientMeasurementUpdateManyWithoutClientNestedInput
    progressPhotos?: ProgressPhotoUpdateManyWithoutClientNestedInput
    badges?: ClientBadgeUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    goals?: ClientUpdategoalsInput | string[]
    currentWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    targetWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    bodyMeasurements?: NullableJsonNullValueInput | InputJsonValue
    bodyFatPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    fitnessLevel?: NullableStringFieldUpdateOperationsInput | string | null
    injuryHistory?: NullableStringFieldUpdateOperationsInput | string | null
    dietaryNotes?: NullableStringFieldUpdateOperationsInput | string | null
    medicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    creditsRemaining?: IntFieldUpdateOperationsInput | number
    membershipType?: NullableStringFieldUpdateOperationsInput | string | null
    membershipExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    tags?: ClientUpdatetagsInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutClientNestedInput
    orders?: OrderUncheckedUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutClientNestedInput
    measurements?: ClientMeasurementUncheckedUpdateManyWithoutClientNestedInput
    progressPhotos?: ProgressPhotoUncheckedUpdateManyWithoutClientNestedInput
    badges?: ClientBadgeUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientCreateManyInput = {
    id?: string
    tenantId: string
    name: string
    email: string
    phone?: string | null
    avatar?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    goals?: ClientCreategoalsInput | string[]
    currentWeight?: number | null
    targetWeight?: number | null
    height?: number | null
    bodyMeasurements?: NullableJsonNullValueInput | InputJsonValue
    bodyFatPercent?: number | null
    fitnessLevel?: string | null
    injuryHistory?: string | null
    dietaryNotes?: string | null
    medicalNotes?: string | null
    creditsRemaining?: number
    membershipType?: string | null
    membershipExpiry?: Date | string | null
    status?: string
    tags?: ClientCreatetagsInput | string[]
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    goals?: ClientUpdategoalsInput | string[]
    currentWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    targetWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    bodyMeasurements?: NullableJsonNullValueInput | InputJsonValue
    bodyFatPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    fitnessLevel?: NullableStringFieldUpdateOperationsInput | string | null
    injuryHistory?: NullableStringFieldUpdateOperationsInput | string | null
    dietaryNotes?: NullableStringFieldUpdateOperationsInput | string | null
    medicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    creditsRemaining?: IntFieldUpdateOperationsInput | number
    membershipType?: NullableStringFieldUpdateOperationsInput | string | null
    membershipExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    tags?: ClientUpdatetagsInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    goals?: ClientUpdategoalsInput | string[]
    currentWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    targetWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    bodyMeasurements?: NullableJsonNullValueInput | InputJsonValue
    bodyFatPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    fitnessLevel?: NullableStringFieldUpdateOperationsInput | string | null
    injuryHistory?: NullableStringFieldUpdateOperationsInput | string | null
    dietaryNotes?: NullableStringFieldUpdateOperationsInput | string | null
    medicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    creditsRemaining?: IntFieldUpdateOperationsInput | number
    membershipType?: NullableStringFieldUpdateOperationsInput | string | null
    membershipExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    tags?: ClientUpdatetagsInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientMeasurementCreateInput = {
    id?: string
    date?: Date | string
    weight?: number | null
    bodyFat?: number | null
    measurements?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdAt?: Date | string
    client: ClientCreateNestedOneWithoutMeasurementsInput
  }

  export type ClientMeasurementUncheckedCreateInput = {
    id?: string
    clientId: string
    date?: Date | string
    weight?: number | null
    bodyFat?: number | null
    measurements?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdAt?: Date | string
  }

  export type ClientMeasurementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    bodyFat?: NullableFloatFieldUpdateOperationsInput | number | null
    measurements?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutMeasurementsNestedInput
  }

  export type ClientMeasurementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    bodyFat?: NullableFloatFieldUpdateOperationsInput | number | null
    measurements?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientMeasurementCreateManyInput = {
    id?: string
    clientId: string
    date?: Date | string
    weight?: number | null
    bodyFat?: number | null
    measurements?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdAt?: Date | string
  }

  export type ClientMeasurementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    bodyFat?: NullableFloatFieldUpdateOperationsInput | number | null
    measurements?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientMeasurementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    bodyFat?: NullableFloatFieldUpdateOperationsInput | number | null
    measurements?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgressPhotoCreateInput = {
    id?: string
    url: string
    date?: Date | string
    view: string
    notes?: string | null
    createdAt?: Date | string
    client: ClientCreateNestedOneWithoutProgressPhotosInput
  }

  export type ProgressPhotoUncheckedCreateInput = {
    id?: string
    clientId: string
    url: string
    date?: Date | string
    view: string
    notes?: string | null
    createdAt?: Date | string
  }

  export type ProgressPhotoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    view?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutProgressPhotosNestedInput
  }

  export type ProgressPhotoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    view?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgressPhotoCreateManyInput = {
    id?: string
    clientId: string
    url: string
    date?: Date | string
    view: string
    notes?: string | null
    createdAt?: Date | string
  }

  export type ProgressPhotoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    view?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgressPhotoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    view?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateInput = {
    id?: string
    scheduledAt: Date | string
    duration?: number
    status?: string
    workoutPlan?: NullableJsonNullValueInput | InputJsonValue
    exercisesLogged?: SessionCreateexercisesLoggedInput | InputJsonValue[]
    caloriesBurned?: number | null
    heartRateAvg?: number | null
    muscleGroups?: SessionCreatemuscleGroupsInput | string[]
    clientFeedback?: string | null
    trainerNotes?: string | null
    intensity?: string | null
    clientRating?: number | null
    price?: number | null
    paid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSessionsInput
    client: ClientCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    tenantId: string
    clientId: string
    scheduledAt: Date | string
    duration?: number
    status?: string
    workoutPlan?: NullableJsonNullValueInput | InputJsonValue
    exercisesLogged?: SessionCreateexercisesLoggedInput | InputJsonValue[]
    caloriesBurned?: number | null
    heartRateAvg?: number | null
    muscleGroups?: SessionCreatemuscleGroupsInput | string[]
    clientFeedback?: string | null
    trainerNotes?: string | null
    intensity?: string | null
    clientRating?: number | null
    price?: number | null
    paid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    workoutPlan?: NullableJsonNullValueInput | InputJsonValue
    exercisesLogged?: SessionUpdateexercisesLoggedInput | InputJsonValue[]
    caloriesBurned?: NullableIntFieldUpdateOperationsInput | number | null
    heartRateAvg?: NullableIntFieldUpdateOperationsInput | number | null
    muscleGroups?: SessionUpdatemuscleGroupsInput | string[]
    clientFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    trainerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    intensity?: NullableStringFieldUpdateOperationsInput | string | null
    clientRating?: NullableIntFieldUpdateOperationsInput | number | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    paid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSessionsNestedInput
    client?: ClientUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    workoutPlan?: NullableJsonNullValueInput | InputJsonValue
    exercisesLogged?: SessionUpdateexercisesLoggedInput | InputJsonValue[]
    caloriesBurned?: NullableIntFieldUpdateOperationsInput | number | null
    heartRateAvg?: NullableIntFieldUpdateOperationsInput | number | null
    muscleGroups?: SessionUpdatemuscleGroupsInput | string[]
    clientFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    trainerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    intensity?: NullableStringFieldUpdateOperationsInput | string | null
    clientRating?: NullableIntFieldUpdateOperationsInput | number | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    paid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    tenantId: string
    clientId: string
    scheduledAt: Date | string
    duration?: number
    status?: string
    workoutPlan?: NullableJsonNullValueInput | InputJsonValue
    exercisesLogged?: SessionCreateexercisesLoggedInput | InputJsonValue[]
    caloriesBurned?: number | null
    heartRateAvg?: number | null
    muscleGroups?: SessionCreatemuscleGroupsInput | string[]
    clientFeedback?: string | null
    trainerNotes?: string | null
    intensity?: string | null
    clientRating?: number | null
    price?: number | null
    paid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    workoutPlan?: NullableJsonNullValueInput | InputJsonValue
    exercisesLogged?: SessionUpdateexercisesLoggedInput | InputJsonValue[]
    caloriesBurned?: NullableIntFieldUpdateOperationsInput | number | null
    heartRateAvg?: NullableIntFieldUpdateOperationsInput | number | null
    muscleGroups?: SessionUpdatemuscleGroupsInput | string[]
    clientFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    trainerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    intensity?: NullableStringFieldUpdateOperationsInput | string | null
    clientRating?: NullableIntFieldUpdateOperationsInput | number | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    paid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    workoutPlan?: NullableJsonNullValueInput | InputJsonValue
    exercisesLogged?: SessionUpdateexercisesLoggedInput | InputJsonValue[]
    caloriesBurned?: NullableIntFieldUpdateOperationsInput | number | null
    heartRateAvg?: NullableIntFieldUpdateOperationsInput | number | null
    muscleGroups?: SessionUpdatemuscleGroupsInput | string[]
    clientFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    trainerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    intensity?: NullableStringFieldUpdateOperationsInput | string | null
    clientRating?: NullableIntFieldUpdateOperationsInput | number | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    paid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassCreateInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    scheduledAt: Date | string
    duration: number
    capacity?: number
    instructor?: string | null
    location?: string | null
    price: number
    isRecurring?: boolean
    recurrence?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutClassesInput
    bookings?: ClassBookingCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    type: string
    scheduledAt: Date | string
    duration: number
    capacity?: number
    instructor?: string | null
    location?: string | null
    price: number
    isRecurring?: boolean
    recurrence?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: ClassBookingUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    instructor?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurrence?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutClassesNestedInput
    bookings?: ClassBookingUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    instructor?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurrence?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: ClassBookingUncheckedUpdateManyWithoutClassNestedInput
  }

  export type ClassCreateManyInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    type: string
    scheduledAt: Date | string
    duration: number
    capacity?: number
    instructor?: string | null
    location?: string | null
    price: number
    isRecurring?: boolean
    recurrence?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    instructor?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurrence?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    instructor?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurrence?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassBookingCreateInput = {
    id?: string
    clientId: string
    status?: string
    checkedIn?: boolean
    paid?: boolean
    createdAt?: Date | string
    class: ClassCreateNestedOneWithoutBookingsInput
  }

  export type ClassBookingUncheckedCreateInput = {
    id?: string
    classId: string
    clientId: string
    status?: string
    checkedIn?: boolean
    paid?: boolean
    createdAt?: Date | string
  }

  export type ClassBookingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    checkedIn?: BoolFieldUpdateOperationsInput | boolean
    paid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneRequiredWithoutBookingsNestedInput
  }

  export type ClassBookingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    checkedIn?: BoolFieldUpdateOperationsInput | boolean
    paid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassBookingCreateManyInput = {
    id?: string
    classId: string
    clientId: string
    status?: string
    checkedIn?: boolean
    paid?: boolean
    createdAt?: Date | string
  }

  export type ClassBookingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    checkedIn?: BoolFieldUpdateOperationsInput | boolean
    paid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassBookingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    checkedIn?: BoolFieldUpdateOperationsInput | boolean
    paid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PackageCreateInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    price: number
    credits: number
    validityDays: number
    features?: PackageCreatefeaturesInput | string[]
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutPackagesInput
  }

  export type PackageUncheckedCreateInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    type: string
    price: number
    credits: number
    validityDays: number
    features?: PackageCreatefeaturesInput | string[]
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PackageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    credits?: IntFieldUpdateOperationsInput | number
    validityDays?: IntFieldUpdateOperationsInput | number
    features?: PackageUpdatefeaturesInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutPackagesNestedInput
  }

  export type PackageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    credits?: IntFieldUpdateOperationsInput | number
    validityDays?: IntFieldUpdateOperationsInput | number
    features?: PackageUpdatefeaturesInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PackageCreateManyInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    type: string
    price: number
    credits: number
    validityDays: number
    features?: PackageCreatefeaturesInput | string[]
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PackageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    credits?: IntFieldUpdateOperationsInput | number
    validityDays?: IntFieldUpdateOperationsInput | number
    features?: PackageUpdatefeaturesInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PackageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    credits?: IntFieldUpdateOperationsInput | number
    validityDays?: IntFieldUpdateOperationsInput | number
    features?: PackageUpdatefeaturesInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateInput = {
    id?: string
    orderNumber: string
    status?: string
    items?: OrderCreateitemsInput | InputJsonValue[]
    subtotal: number
    tax?: number
    discount?: number
    total: number
    paymentMethod?: string | null
    paymentStatus?: string
    paidAmount?: number
    orderDate?: Date | string
    dueDate?: Date | string | null
    paidDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutOrdersInput
    client: ClientCreateNestedOneWithoutOrdersInput
    invoices?: InvoiceCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateInput = {
    id?: string
    tenantId: string
    clientId: string
    orderNumber: string
    status?: string
    items?: OrderCreateitemsInput | InputJsonValue[]
    subtotal: number
    tax?: number
    discount?: number
    total: number
    paymentMethod?: string | null
    paymentStatus?: string
    paidAmount?: number
    orderDate?: Date | string
    dueDate?: Date | string | null
    paidDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    items?: OrderUpdateitemsInput | InputJsonValue[]
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    paidAmount?: FloatFieldUpdateOperationsInput | number
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutOrdersNestedInput
    client?: ClientUpdateOneRequiredWithoutOrdersNestedInput
    invoices?: InvoiceUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    items?: OrderUpdateitemsInput | InputJsonValue[]
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    paidAmount?: FloatFieldUpdateOperationsInput | number
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderCreateManyInput = {
    id?: string
    tenantId: string
    clientId: string
    orderNumber: string
    status?: string
    items?: OrderCreateitemsInput | InputJsonValue[]
    subtotal: number
    tax?: number
    discount?: number
    total: number
    paymentMethod?: string | null
    paymentStatus?: string
    paidAmount?: number
    orderDate?: Date | string
    dueDate?: Date | string | null
    paidDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    items?: OrderUpdateitemsInput | InputJsonValue[]
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    paidAmount?: FloatFieldUpdateOperationsInput | number
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    items?: OrderUpdateitemsInput | InputJsonValue[]
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    paidAmount?: FloatFieldUpdateOperationsInput | number
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateInput = {
    id?: string
    invoiceNumber: string
    status?: string
    issueDate?: Date | string
    dueDate: Date | string
    paidDate?: Date | string | null
    subtotal: number
    tax?: number
    total: number
    paymentMethod?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutInvoicesInput
    order?: OrderCreateNestedOneWithoutInvoicesInput
    client: ClientCreateNestedOneWithoutInvoicesInput
    payments?: InvoicePaymentCreateNestedManyWithoutInvoiceInput
    bankTransactions?: BankTransactionCreateNestedManyWithoutMatchedInvoiceInput
    cryptoPayments?: CryptoPaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateInput = {
    id?: string
    tenantId: string
    orderId?: string | null
    clientId: string
    invoiceNumber: string
    status?: string
    issueDate?: Date | string
    dueDate: Date | string
    paidDate?: Date | string | null
    subtotal: number
    tax?: number
    total: number
    paymentMethod?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: InvoicePaymentUncheckedCreateNestedManyWithoutInvoiceInput
    bankTransactions?: BankTransactionUncheckedCreateNestedManyWithoutMatchedInvoiceInput
    cryptoPayments?: CryptoPaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutInvoicesNestedInput
    order?: OrderUpdateOneWithoutInvoicesNestedInput
    client?: ClientUpdateOneRequiredWithoutInvoicesNestedInput
    payments?: InvoicePaymentUpdateManyWithoutInvoiceNestedInput
    bankTransactions?: BankTransactionUpdateManyWithoutMatchedInvoiceNestedInput
    cryptoPayments?: CryptoPaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: InvoicePaymentUncheckedUpdateManyWithoutInvoiceNestedInput
    bankTransactions?: BankTransactionUncheckedUpdateManyWithoutMatchedInvoiceNestedInput
    cryptoPayments?: CryptoPaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceCreateManyInput = {
    id?: string
    tenantId: string
    orderId?: string | null
    clientId: string
    invoiceNumber: string
    status?: string
    issueDate?: Date | string
    dueDate: Date | string
    paidDate?: Date | string | null
    subtotal: number
    tax?: number
    total: number
    paymentMethod?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AILogCreateInput = {
    id?: string
    feature: string
    model: string
    promptTokens: number
    completionTokens: number
    totalTokens: number
    estimatedCost: number
    input: JsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    latencyMs?: number | null
    success?: boolean
    error?: string | null
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutAiLogsInput
  }

  export type AILogUncheckedCreateInput = {
    id?: string
    tenantId: string
    feature: string
    model: string
    promptTokens: number
    completionTokens: number
    totalTokens: number
    estimatedCost: number
    input: JsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    latencyMs?: number | null
    success?: boolean
    error?: string | null
    createdAt?: Date | string
  }

  export type AILogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    feature?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    promptTokens?: IntFieldUpdateOperationsInput | number
    completionTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    estimatedCost?: FloatFieldUpdateOperationsInput | number
    input?: JsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    latencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    success?: BoolFieldUpdateOperationsInput | boolean
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutAiLogsNestedInput
  }

  export type AILogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    feature?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    promptTokens?: IntFieldUpdateOperationsInput | number
    completionTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    estimatedCost?: FloatFieldUpdateOperationsInput | number
    input?: JsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    latencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    success?: BoolFieldUpdateOperationsInput | boolean
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AILogCreateManyInput = {
    id?: string
    tenantId: string
    feature: string
    model: string
    promptTokens: number
    completionTokens: number
    totalTokens: number
    estimatedCost: number
    input: JsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    latencyMs?: number | null
    success?: boolean
    error?: string | null
    createdAt?: Date | string
  }

  export type AILogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    feature?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    promptTokens?: IntFieldUpdateOperationsInput | number
    completionTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    estimatedCost?: FloatFieldUpdateOperationsInput | number
    input?: JsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    latencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    success?: BoolFieldUpdateOperationsInput | boolean
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AILogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    feature?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    promptTokens?: IntFieldUpdateOperationsInput | number
    completionTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    estimatedCost?: FloatFieldUpdateOperationsInput | number
    input?: JsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    latencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    success?: BoolFieldUpdateOperationsInput | boolean
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CurrencyCreateInput = {
    id?: string
    code: string
    name: string
    symbol: string
    decimals?: number
    isCrypto?: boolean
    isStablecoin?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    exchangeRatesFrom?: ExchangeRateCreateNestedManyWithoutFromCurrencyInput
    exchangeRatesTo?: ExchangeRateCreateNestedManyWithoutToCurrencyInput
  }

  export type CurrencyUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    symbol: string
    decimals?: number
    isCrypto?: boolean
    isStablecoin?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    exchangeRatesFrom?: ExchangeRateUncheckedCreateNestedManyWithoutFromCurrencyInput
    exchangeRatesTo?: ExchangeRateUncheckedCreateNestedManyWithoutToCurrencyInput
  }

  export type CurrencyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    isCrypto?: BoolFieldUpdateOperationsInput | boolean
    isStablecoin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exchangeRatesFrom?: ExchangeRateUpdateManyWithoutFromCurrencyNestedInput
    exchangeRatesTo?: ExchangeRateUpdateManyWithoutToCurrencyNestedInput
  }

  export type CurrencyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    isCrypto?: BoolFieldUpdateOperationsInput | boolean
    isStablecoin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exchangeRatesFrom?: ExchangeRateUncheckedUpdateManyWithoutFromCurrencyNestedInput
    exchangeRatesTo?: ExchangeRateUncheckedUpdateManyWithoutToCurrencyNestedInput
  }

  export type CurrencyCreateManyInput = {
    id?: string
    code: string
    name: string
    symbol: string
    decimals?: number
    isCrypto?: boolean
    isStablecoin?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CurrencyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    isCrypto?: BoolFieldUpdateOperationsInput | boolean
    isStablecoin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CurrencyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    isCrypto?: BoolFieldUpdateOperationsInput | boolean
    isStablecoin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExchangeRateCreateInput = {
    id?: string
    rate: Decimal | DecimalJsLike | number | string
    source: string
    timestamp: Date | string
    fromCurrency: CurrencyCreateNestedOneWithoutExchangeRatesFromInput
    toCurrency: CurrencyCreateNestedOneWithoutExchangeRatesToInput
  }

  export type ExchangeRateUncheckedCreateInput = {
    id?: string
    fromCurrencyId: string
    toCurrencyId: string
    rate: Decimal | DecimalJsLike | number | string
    source: string
    timestamp: Date | string
  }

  export type ExchangeRateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    source?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    fromCurrency?: CurrencyUpdateOneRequiredWithoutExchangeRatesFromNestedInput
    toCurrency?: CurrencyUpdateOneRequiredWithoutExchangeRatesToNestedInput
  }

  export type ExchangeRateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromCurrencyId?: StringFieldUpdateOperationsInput | string
    toCurrencyId?: StringFieldUpdateOperationsInput | string
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    source?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExchangeRateCreateManyInput = {
    id?: string
    fromCurrencyId: string
    toCurrencyId: string
    rate: Decimal | DecimalJsLike | number | string
    source: string
    timestamp: Date | string
  }

  export type ExchangeRateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    source?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExchangeRateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromCurrencyId?: StringFieldUpdateOperationsInput | string
    toCurrencyId?: StringFieldUpdateOperationsInput | string
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    source?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankAccountCreateInput = {
    id?: string
    accountName: string
    accountNumber: string
    bankCode?: string | null
    iban?: string | null
    swift?: string | null
    provider: $Enums.BankProvider
    providerAccountId?: string | null
    currency?: string
    balance?: Decimal | DecimalJsLike | number | string | null
    balanceUpdatedAt?: Date | string | null
    autoSync?: boolean
    lastSyncAt?: Date | string | null
    syncFrequency?: string
    credentials?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutBankAccountsInput
    transactions?: BankTransactionCreateNestedManyWithoutBankAccountInput
  }

  export type BankAccountUncheckedCreateInput = {
    id?: string
    tenantId: string
    accountName: string
    accountNumber: string
    bankCode?: string | null
    iban?: string | null
    swift?: string | null
    provider: $Enums.BankProvider
    providerAccountId?: string | null
    currency?: string
    balance?: Decimal | DecimalJsLike | number | string | null
    balanceUpdatedAt?: Date | string | null
    autoSync?: boolean
    lastSyncAt?: Date | string | null
    syncFrequency?: string
    credentials?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: BankTransactionUncheckedCreateNestedManyWithoutBankAccountInput
  }

  export type BankAccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    bankCode?: NullableStringFieldUpdateOperationsInput | string | null
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    swift?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: EnumBankProviderFieldUpdateOperationsInput | $Enums.BankProvider
    providerAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balanceUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoSync?: BoolFieldUpdateOperationsInput | boolean
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncFrequency?: StringFieldUpdateOperationsInput | string
    credentials?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutBankAccountsNestedInput
    transactions?: BankTransactionUpdateManyWithoutBankAccountNestedInput
  }

  export type BankAccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    bankCode?: NullableStringFieldUpdateOperationsInput | string | null
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    swift?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: EnumBankProviderFieldUpdateOperationsInput | $Enums.BankProvider
    providerAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balanceUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoSync?: BoolFieldUpdateOperationsInput | boolean
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncFrequency?: StringFieldUpdateOperationsInput | string
    credentials?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: BankTransactionUncheckedUpdateManyWithoutBankAccountNestedInput
  }

  export type BankAccountCreateManyInput = {
    id?: string
    tenantId: string
    accountName: string
    accountNumber: string
    bankCode?: string | null
    iban?: string | null
    swift?: string | null
    provider: $Enums.BankProvider
    providerAccountId?: string | null
    currency?: string
    balance?: Decimal | DecimalJsLike | number | string | null
    balanceUpdatedAt?: Date | string | null
    autoSync?: boolean
    lastSyncAt?: Date | string | null
    syncFrequency?: string
    credentials?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankAccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    bankCode?: NullableStringFieldUpdateOperationsInput | string | null
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    swift?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: EnumBankProviderFieldUpdateOperationsInput | $Enums.BankProvider
    providerAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balanceUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoSync?: BoolFieldUpdateOperationsInput | boolean
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncFrequency?: StringFieldUpdateOperationsInput | string
    credentials?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankAccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    bankCode?: NullableStringFieldUpdateOperationsInput | string | null
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    swift?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: EnumBankProviderFieldUpdateOperationsInput | $Enums.BankProvider
    providerAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balanceUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoSync?: BoolFieldUpdateOperationsInput | boolean
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncFrequency?: StringFieldUpdateOperationsInput | string
    credentials?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankTransactionCreateInput = {
    id?: string
    transactionId: string
    date: Date | string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    type: $Enums.TransactionType
    counterpartyName?: string | null
    counterpartyAccount?: string | null
    counterpartyBankCode?: string | null
    description?: string | null
    note?: string | null
    variableSymbol?: string | null
    constantSymbol?: string | null
    specificSymbol?: string | null
    reference?: string | null
    isMatched?: boolean
    matchedPaymentId?: string | null
    matchConfidence?: Decimal | DecimalJsLike | number | string | null
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    bankAccount: BankAccountCreateNestedOneWithoutTransactionsInput
    tenant: TenantCreateNestedOneWithoutBankTransactionsInput
    matchedInvoice?: InvoiceCreateNestedOneWithoutBankTransactionsInput
  }

  export type BankTransactionUncheckedCreateInput = {
    id?: string
    bankAccountId: string
    tenantId: string
    transactionId: string
    date: Date | string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    type: $Enums.TransactionType
    counterpartyName?: string | null
    counterpartyAccount?: string | null
    counterpartyBankCode?: string | null
    description?: string | null
    note?: string | null
    variableSymbol?: string | null
    constantSymbol?: string | null
    specificSymbol?: string | null
    reference?: string | null
    isMatched?: boolean
    matchedInvoiceId?: string | null
    matchedPaymentId?: string | null
    matchConfidence?: Decimal | DecimalJsLike | number | string | null
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankTransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    counterpartyName?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyAccount?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyBankCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    variableSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    constantSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    specificSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    isMatched?: BoolFieldUpdateOperationsInput | boolean
    matchedPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    matchConfidence?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankAccount?: BankAccountUpdateOneRequiredWithoutTransactionsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutBankTransactionsNestedInput
    matchedInvoice?: InvoiceUpdateOneWithoutBankTransactionsNestedInput
  }

  export type BankTransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bankAccountId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    counterpartyName?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyAccount?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyBankCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    variableSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    constantSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    specificSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    isMatched?: BoolFieldUpdateOperationsInput | boolean
    matchedInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    matchedPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    matchConfidence?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankTransactionCreateManyInput = {
    id?: string
    bankAccountId: string
    tenantId: string
    transactionId: string
    date: Date | string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    type: $Enums.TransactionType
    counterpartyName?: string | null
    counterpartyAccount?: string | null
    counterpartyBankCode?: string | null
    description?: string | null
    note?: string | null
    variableSymbol?: string | null
    constantSymbol?: string | null
    specificSymbol?: string | null
    reference?: string | null
    isMatched?: boolean
    matchedInvoiceId?: string | null
    matchedPaymentId?: string | null
    matchConfidence?: Decimal | DecimalJsLike | number | string | null
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankTransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    counterpartyName?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyAccount?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyBankCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    variableSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    constantSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    specificSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    isMatched?: BoolFieldUpdateOperationsInput | boolean
    matchedPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    matchConfidence?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankTransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bankAccountId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    counterpartyName?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyAccount?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyBankCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    variableSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    constantSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    specificSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    isMatched?: BoolFieldUpdateOperationsInput | boolean
    matchedInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    matchedPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    matchConfidence?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoicePaymentCreateInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    method: $Enums.PaymentMethod
    status?: string
    gatewayProvider?: string | null
    gatewayPaymentId?: string | null
    gatewayFee?: Decimal | DecimalJsLike | number | string | null
    transactionId?: string | null
    reference?: string | null
    processedAt?: Date | string | null
    completedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutInvoicePaymentsInput
    invoice: InvoiceCreateNestedOneWithoutPaymentsInput
  }

  export type InvoicePaymentUncheckedCreateInput = {
    id?: string
    tenantId: string
    invoiceId: string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    method: $Enums.PaymentMethod
    status?: string
    gatewayProvider?: string | null
    gatewayPaymentId?: string | null
    gatewayFee?: Decimal | DecimalJsLike | number | string | null
    transactionId?: string | null
    reference?: string | null
    processedAt?: Date | string | null
    completedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoicePaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: StringFieldUpdateOperationsInput | string
    gatewayProvider?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutInvoicePaymentsNestedInput
    invoice?: InvoiceUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type InvoicePaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: StringFieldUpdateOperationsInput | string
    gatewayProvider?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoicePaymentCreateManyInput = {
    id?: string
    tenantId: string
    invoiceId: string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    method: $Enums.PaymentMethod
    status?: string
    gatewayProvider?: string | null
    gatewayPaymentId?: string | null
    gatewayFee?: Decimal | DecimalJsLike | number | string | null
    transactionId?: string | null
    reference?: string | null
    processedAt?: Date | string | null
    completedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoicePaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: StringFieldUpdateOperationsInput | string
    gatewayProvider?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoicePaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: StringFieldUpdateOperationsInput | string
    gatewayProvider?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentGatewayConfigCreateInput = {
    id?: string
    provider: string
    config: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    isTest?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutPaymentGatewayConfigsInput
  }

  export type PaymentGatewayConfigUncheckedCreateInput = {
    id?: string
    tenantId: string
    provider: string
    config: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    isTest?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentGatewayConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isTest?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutPaymentGatewayConfigsNestedInput
  }

  export type PaymentGatewayConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isTest?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentGatewayConfigCreateManyInput = {
    id?: string
    tenantId: string
    provider: string
    config: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    isTest?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentGatewayConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isTest?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentGatewayConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isTest?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CryptoWalletCreateInput = {
    id?: string
    currency: string
    address: string
    network?: string | null
    provider: string
    isActive?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutCryptoWalletsInput
    payments?: CryptoPaymentCreateNestedManyWithoutWalletInput
  }

  export type CryptoWalletUncheckedCreateInput = {
    id?: string
    tenantId: string
    currency: string
    address: string
    network?: string | null
    provider: string
    isActive?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: CryptoPaymentUncheckedCreateNestedManyWithoutWalletInput
  }

  export type CryptoWalletUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    network?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutCryptoWalletsNestedInput
    payments?: CryptoPaymentUpdateManyWithoutWalletNestedInput
  }

  export type CryptoWalletUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    network?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: CryptoPaymentUncheckedUpdateManyWithoutWalletNestedInput
  }

  export type CryptoWalletCreateManyInput = {
    id?: string
    tenantId: string
    currency: string
    address: string
    network?: string | null
    provider: string
    isActive?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CryptoWalletUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    network?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CryptoWalletUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    network?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CryptoPaymentCreateInput = {
    id?: string
    amount: string
    currency: string
    txHash?: string | null
    confirmations?: number
    status?: string
    detectedAt?: Date | string | null
    confirmedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    wallet: CryptoWalletCreateNestedOneWithoutPaymentsInput
    invoice?: InvoiceCreateNestedOneWithoutCryptoPaymentsInput
  }

  export type CryptoPaymentUncheckedCreateInput = {
    id?: string
    walletId: string
    invoiceId?: string | null
    amount: string
    currency: string
    txHash?: string | null
    confirmations?: number
    status?: string
    detectedAt?: Date | string | null
    confirmedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CryptoPaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    confirmations?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    detectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wallet?: CryptoWalletUpdateOneRequiredWithoutPaymentsNestedInput
    invoice?: InvoiceUpdateOneWithoutCryptoPaymentsNestedInput
  }

  export type CryptoPaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletId?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    confirmations?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    detectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CryptoPaymentCreateManyInput = {
    id?: string
    walletId: string
    invoiceId?: string | null
    amount: string
    currency: string
    txHash?: string | null
    confirmations?: number
    status?: string
    detectedAt?: Date | string | null
    confirmedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CryptoPaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    confirmations?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    detectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CryptoPaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletId?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    confirmations?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    detectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseCategoryCreateInput = {
    id?: string
    name: string
    description?: string | null
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutExpenseCategoriesInput
    expenses?: ExpenseCreateNestedManyWithoutCategoryInput
  }

  export type ExpenseCategoryUncheckedCreateInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ExpenseCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutExpenseCategoriesNestedInput
    expenses?: ExpenseUpdateManyWithoutCategoryNestedInput
  }

  export type ExpenseCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expenses?: ExpenseUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ExpenseCategoryCreateManyInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseCreateInput = {
    id?: string
    description: string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    date: Date | string
    vendor?: string | null
    receiptUrl?: string | null
    receiptOcrData?: NullableJsonNullValueInput | InputJsonValue
    taxAmount?: Decimal | DecimalJsLike | number | string | null
    isTaxDeductible?: boolean
    status: $Enums.ExpenseStatus
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectedReason?: string | null
    reimbursedAt?: Date | string | null
    reimbursedAmount?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutExpensesInput
    category: ExpenseCategoryCreateNestedOneWithoutExpensesInput
  }

  export type ExpenseUncheckedCreateInput = {
    id?: string
    tenantId: string
    categoryId: string
    description: string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    date: Date | string
    vendor?: string | null
    receiptUrl?: string | null
    receiptOcrData?: NullableJsonNullValueInput | InputJsonValue
    taxAmount?: Decimal | DecimalJsLike | number | string | null
    isTaxDeductible?: boolean
    status: $Enums.ExpenseStatus
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectedReason?: string | null
    reimbursedAt?: Date | string | null
    reimbursedAmount?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    receiptOcrData?: NullableJsonNullValueInput | InputJsonValue
    taxAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isTaxDeductible?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumExpenseStatusFieldUpdateOperationsInput | $Enums.ExpenseStatus
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedReason?: NullableStringFieldUpdateOperationsInput | string | null
    reimbursedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reimbursedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutExpensesNestedInput
    category?: ExpenseCategoryUpdateOneRequiredWithoutExpensesNestedInput
  }

  export type ExpenseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    receiptOcrData?: NullableJsonNullValueInput | InputJsonValue
    taxAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isTaxDeductible?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumExpenseStatusFieldUpdateOperationsInput | $Enums.ExpenseStatus
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedReason?: NullableStringFieldUpdateOperationsInput | string | null
    reimbursedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reimbursedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseCreateManyInput = {
    id?: string
    tenantId: string
    categoryId: string
    description: string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    date: Date | string
    vendor?: string | null
    receiptUrl?: string | null
    receiptOcrData?: NullableJsonNullValueInput | InputJsonValue
    taxAmount?: Decimal | DecimalJsLike | number | string | null
    isTaxDeductible?: boolean
    status: $Enums.ExpenseStatus
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectedReason?: string | null
    reimbursedAt?: Date | string | null
    reimbursedAmount?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    receiptOcrData?: NullableJsonNullValueInput | InputJsonValue
    taxAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isTaxDeductible?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumExpenseStatusFieldUpdateOperationsInput | $Enums.ExpenseStatus
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedReason?: NullableStringFieldUpdateOperationsInput | string | null
    reimbursedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reimbursedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    receiptOcrData?: NullableJsonNullValueInput | InputJsonValue
    taxAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isTaxDeductible?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumExpenseStatusFieldUpdateOperationsInput | $Enums.ExpenseStatus
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedReason?: NullableStringFieldUpdateOperationsInput | string | null
    reimbursedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reimbursedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecurringInvoiceTemplateCreateInput = {
    id?: string
    frequency: string
    nextInvoiceDate: Date | string
    isActive?: boolean
    invoiceTemplate: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutRecurringInvoiceTemplatesInput
  }

  export type RecurringInvoiceTemplateUncheckedCreateInput = {
    id?: string
    tenantId: string
    frequency: string
    nextInvoiceDate: Date | string
    isActive?: boolean
    invoiceTemplate: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecurringInvoiceTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    nextInvoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    invoiceTemplate?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutRecurringInvoiceTemplatesNestedInput
  }

  export type RecurringInvoiceTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    nextInvoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    invoiceTemplate?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecurringInvoiceTemplateCreateManyInput = {
    id?: string
    tenantId: string
    frequency: string
    nextInvoiceDate: Date | string
    isActive?: boolean
    invoiceTemplate: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecurringInvoiceTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    nextInvoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    invoiceTemplate?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecurringInvoiceTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    nextInvoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    invoiceTemplate?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushSubscriptionCreateInput = {
    id?: string
    tenantId: string
    userId?: string | null
    clientId?: string | null
    endpoint: string
    p256dh: string
    auth: string
    userAgent?: string | null
    deviceName?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PushSubscriptionUncheckedCreateInput = {
    id?: string
    tenantId: string
    userId?: string | null
    clientId?: string | null
    endpoint: string
    p256dh: string
    auth: string
    userAgent?: string | null
    deviceName?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PushSubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: StringFieldUpdateOperationsInput | string
    p256dh?: StringFieldUpdateOperationsInput | string
    auth?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushSubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: StringFieldUpdateOperationsInput | string
    p256dh?: StringFieldUpdateOperationsInput | string
    auth?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushSubscriptionCreateManyInput = {
    id?: string
    tenantId: string
    userId?: string | null
    clientId?: string | null
    endpoint: string
    p256dh: string
    auth: string
    userAgent?: string | null
    deviceName?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PushSubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: StringFieldUpdateOperationsInput | string
    p256dh?: StringFieldUpdateOperationsInput | string
    auth?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushSubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: StringFieldUpdateOperationsInput | string
    p256dh?: StringFieldUpdateOperationsInput | string
    auth?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferenceCreateInput = {
    id?: string
    tenantId: string
    userId?: string | null
    clientId?: string | null
    sessionReminders?: boolean
    classReminders?: boolean
    invoiceNotifications?: boolean
    paymentNotifications?: boolean
    atRiskAlerts?: boolean
    reminderMinutesBefore?: number
    emailEnabled?: boolean
    pushEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPreferenceUncheckedCreateInput = {
    id?: string
    tenantId: string
    userId?: string | null
    clientId?: string | null
    sessionReminders?: boolean
    classReminders?: boolean
    invoiceNotifications?: boolean
    paymentNotifications?: boolean
    atRiskAlerts?: boolean
    reminderMinutesBefore?: number
    emailEnabled?: boolean
    pushEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPreferenceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionReminders?: BoolFieldUpdateOperationsInput | boolean
    classReminders?: BoolFieldUpdateOperationsInput | boolean
    invoiceNotifications?: BoolFieldUpdateOperationsInput | boolean
    paymentNotifications?: BoolFieldUpdateOperationsInput | boolean
    atRiskAlerts?: BoolFieldUpdateOperationsInput | boolean
    reminderMinutesBefore?: IntFieldUpdateOperationsInput | number
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
    pushEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferenceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionReminders?: BoolFieldUpdateOperationsInput | boolean
    classReminders?: BoolFieldUpdateOperationsInput | boolean
    invoiceNotifications?: BoolFieldUpdateOperationsInput | boolean
    paymentNotifications?: BoolFieldUpdateOperationsInput | boolean
    atRiskAlerts?: BoolFieldUpdateOperationsInput | boolean
    reminderMinutesBefore?: IntFieldUpdateOperationsInput | number
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
    pushEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferenceCreateManyInput = {
    id?: string
    tenantId: string
    userId?: string | null
    clientId?: string | null
    sessionReminders?: boolean
    classReminders?: boolean
    invoiceNotifications?: boolean
    paymentNotifications?: boolean
    atRiskAlerts?: boolean
    reminderMinutesBefore?: number
    emailEnabled?: boolean
    pushEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPreferenceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionReminders?: BoolFieldUpdateOperationsInput | boolean
    classReminders?: BoolFieldUpdateOperationsInput | boolean
    invoiceNotifications?: BoolFieldUpdateOperationsInput | boolean
    paymentNotifications?: BoolFieldUpdateOperationsInput | boolean
    atRiskAlerts?: BoolFieldUpdateOperationsInput | boolean
    reminderMinutesBefore?: IntFieldUpdateOperationsInput | number
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
    pushEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferenceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionReminders?: BoolFieldUpdateOperationsInput | boolean
    classReminders?: BoolFieldUpdateOperationsInput | boolean
    invoiceNotifications?: BoolFieldUpdateOperationsInput | boolean
    paymentNotifications?: BoolFieldUpdateOperationsInput | boolean
    atRiskAlerts?: BoolFieldUpdateOperationsInput | boolean
    reminderMinutesBefore?: IntFieldUpdateOperationsInput | number
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
    pushEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationLogCreateInput = {
    id?: string
    tenantId: string
    type: string
    recipientType: string
    recipientId: string
    title: string
    body: string
    data?: NullableJsonNullValueInput | InputJsonValue
    channel: string
    status: string
    error?: string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
  }

  export type NotificationLogUncheckedCreateInput = {
    id?: string
    tenantId: string
    type: string
    recipientType: string
    recipientId: string
    title: string
    body: string
    data?: NullableJsonNullValueInput | InputJsonValue
    channel: string
    status: string
    error?: string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
  }

  export type NotificationLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    recipientType?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    channel?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    recipientType?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    channel?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationLogCreateManyInput = {
    id?: string
    tenantId: string
    type: string
    recipientType: string
    recipientId: string
    title: string
    body: string
    data?: NullableJsonNullValueInput | InputJsonValue
    channel: string
    status: string
    error?: string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
  }

  export type NotificationLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    recipientType?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    channel?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    recipientType?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    channel?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarIntegrationCreateInput = {
    id?: string
    tenantId: string
    userId: string
    provider: string
    accessToken?: string | null
    refreshToken?: string | null
    tokenExpiry?: Date | string | null
    calendarId?: string | null
    calendarEmail?: string | null
    syncEnabled?: boolean
    syncDirection?: string
    lastSyncAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    eventSyncs?: CalendarEventSyncCreateNestedManyWithoutIntegrationInput
  }

  export type CalendarIntegrationUncheckedCreateInput = {
    id?: string
    tenantId: string
    userId: string
    provider: string
    accessToken?: string | null
    refreshToken?: string | null
    tokenExpiry?: Date | string | null
    calendarId?: string | null
    calendarEmail?: string | null
    syncEnabled?: boolean
    syncDirection?: string
    lastSyncAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    eventSyncs?: CalendarEventSyncUncheckedCreateNestedManyWithoutIntegrationInput
  }

  export type CalendarIntegrationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    calendarId?: NullableStringFieldUpdateOperationsInput | string | null
    calendarEmail?: NullableStringFieldUpdateOperationsInput | string | null
    syncEnabled?: BoolFieldUpdateOperationsInput | boolean
    syncDirection?: StringFieldUpdateOperationsInput | string
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventSyncs?: CalendarEventSyncUpdateManyWithoutIntegrationNestedInput
  }

  export type CalendarIntegrationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    calendarId?: NullableStringFieldUpdateOperationsInput | string | null
    calendarEmail?: NullableStringFieldUpdateOperationsInput | string | null
    syncEnabled?: BoolFieldUpdateOperationsInput | boolean
    syncDirection?: StringFieldUpdateOperationsInput | string
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventSyncs?: CalendarEventSyncUncheckedUpdateManyWithoutIntegrationNestedInput
  }

  export type CalendarIntegrationCreateManyInput = {
    id?: string
    tenantId: string
    userId: string
    provider: string
    accessToken?: string | null
    refreshToken?: string | null
    tokenExpiry?: Date | string | null
    calendarId?: string | null
    calendarEmail?: string | null
    syncEnabled?: boolean
    syncDirection?: string
    lastSyncAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CalendarIntegrationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    calendarId?: NullableStringFieldUpdateOperationsInput | string | null
    calendarEmail?: NullableStringFieldUpdateOperationsInput | string | null
    syncEnabled?: BoolFieldUpdateOperationsInput | boolean
    syncDirection?: StringFieldUpdateOperationsInput | string
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarIntegrationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    calendarId?: NullableStringFieldUpdateOperationsInput | string | null
    calendarEmail?: NullableStringFieldUpdateOperationsInput | string | null
    syncEnabled?: BoolFieldUpdateOperationsInput | boolean
    syncDirection?: StringFieldUpdateOperationsInput | string
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarEventSyncCreateInput = {
    id?: string
    entityType: string
    entityId: string
    externalEventId: string
    lastSyncedAt: Date | string
    syncHash: string
    integration: CalendarIntegrationCreateNestedOneWithoutEventSyncsInput
  }

  export type CalendarEventSyncUncheckedCreateInput = {
    id?: string
    integrationId: string
    entityType: string
    entityId: string
    externalEventId: string
    lastSyncedAt: Date | string
    syncHash: string
  }

  export type CalendarEventSyncUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    externalEventId?: StringFieldUpdateOperationsInput | string
    lastSyncedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncHash?: StringFieldUpdateOperationsInput | string
    integration?: CalendarIntegrationUpdateOneRequiredWithoutEventSyncsNestedInput
  }

  export type CalendarEventSyncUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    integrationId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    externalEventId?: StringFieldUpdateOperationsInput | string
    lastSyncedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncHash?: StringFieldUpdateOperationsInput | string
  }

  export type CalendarEventSyncCreateManyInput = {
    id?: string
    integrationId: string
    entityType: string
    entityId: string
    externalEventId: string
    lastSyncedAt: Date | string
    syncHash: string
  }

  export type CalendarEventSyncUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    externalEventId?: StringFieldUpdateOperationsInput | string
    lastSyncedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncHash?: StringFieldUpdateOperationsInput | string
  }

  export type CalendarEventSyncUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    integrationId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    externalEventId?: StringFieldUpdateOperationsInput | string
    lastSyncedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncHash?: StringFieldUpdateOperationsInput | string
  }

  export type CalendarFeedTokenCreateInput = {
    id?: string
    tenantId: string
    userId: string
    token: string
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type CalendarFeedTokenUncheckedCreateInput = {
    id?: string
    tenantId: string
    userId: string
    token: string
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type CalendarFeedTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CalendarFeedTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CalendarFeedTokenCreateManyInput = {
    id?: string
    tenantId: string
    userId: string
    token: string
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type CalendarFeedTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CalendarFeedTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BadgeCreateInput = {
    id?: string
    name: string
    description: string
    icon: string
    color: string
    category: string
    criteria: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutBadgesInput
    clientBadges?: ClientBadgeCreateNestedManyWithoutBadgeInput
  }

  export type BadgeUncheckedCreateInput = {
    id?: string
    tenantId: string
    name: string
    description: string
    icon: string
    color: string
    category: string
    criteria: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clientBadges?: ClientBadgeUncheckedCreateNestedManyWithoutBadgeInput
  }

  export type BadgeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    criteria?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutBadgesNestedInput
    clientBadges?: ClientBadgeUpdateManyWithoutBadgeNestedInput
  }

  export type BadgeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    criteria?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientBadges?: ClientBadgeUncheckedUpdateManyWithoutBadgeNestedInput
  }

  export type BadgeCreateManyInput = {
    id?: string
    tenantId: string
    name: string
    description: string
    icon: string
    color: string
    category: string
    criteria: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BadgeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    criteria?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BadgeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    criteria?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientBadgeCreateInput = {
    id?: string
    earnedAt?: Date | string
    notified?: boolean
    client: ClientCreateNestedOneWithoutBadgesInput
    badge: BadgeCreateNestedOneWithoutClientBadgesInput
  }

  export type ClientBadgeUncheckedCreateInput = {
    id?: string
    clientId: string
    badgeId: string
    earnedAt?: Date | string
    notified?: boolean
  }

  export type ClientBadgeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notified?: BoolFieldUpdateOperationsInput | boolean
    client?: ClientUpdateOneRequiredWithoutBadgesNestedInput
    badge?: BadgeUpdateOneRequiredWithoutClientBadgesNestedInput
  }

  export type ClientBadgeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    badgeId?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ClientBadgeCreateManyInput = {
    id?: string
    clientId: string
    badgeId: string
    earnedAt?: Date | string
    notified?: boolean
  }

  export type ClientBadgeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ClientBadgeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    badgeId?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WorkoutTemplateCreateInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    difficulty: string
    duration: number
    exercises?: WorkoutTemplateCreateexercisesInput | InputJsonValue[]
    muscleGroups?: WorkoutTemplateCreatemuscleGroupsInput | string[]
    equipment?: WorkoutTemplateCreateequipmentInput | string[]
    isPublic?: boolean
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutWorkoutTemplatesInput
  }

  export type WorkoutTemplateUncheckedCreateInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    category: string
    difficulty: string
    duration: number
    exercises?: WorkoutTemplateCreateexercisesInput | InputJsonValue[]
    muscleGroups?: WorkoutTemplateCreatemuscleGroupsInput | string[]
    equipment?: WorkoutTemplateCreateequipmentInput | string[]
    isPublic?: boolean
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkoutTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    exercises?: WorkoutTemplateUpdateexercisesInput | InputJsonValue[]
    muscleGroups?: WorkoutTemplateUpdatemuscleGroupsInput | string[]
    equipment?: WorkoutTemplateUpdateequipmentInput | string[]
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutWorkoutTemplatesNestedInput
  }

  export type WorkoutTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    exercises?: WorkoutTemplateUpdateexercisesInput | InputJsonValue[]
    muscleGroups?: WorkoutTemplateUpdatemuscleGroupsInput | string[]
    equipment?: WorkoutTemplateUpdateequipmentInput | string[]
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkoutTemplateCreateManyInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    category: string
    difficulty: string
    duration: number
    exercises?: WorkoutTemplateCreateexercisesInput | InputJsonValue[]
    muscleGroups?: WorkoutTemplateCreatemuscleGroupsInput | string[]
    equipment?: WorkoutTemplateCreateequipmentInput | string[]
    isPublic?: boolean
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkoutTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    exercises?: WorkoutTemplateUpdateexercisesInput | InputJsonValue[]
    muscleGroups?: WorkoutTemplateUpdatemuscleGroupsInput | string[]
    equipment?: WorkoutTemplateUpdateequipmentInput | string[]
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkoutTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    exercises?: WorkoutTemplateUpdateexercisesInput | InputJsonValue[]
    muscleGroups?: WorkoutTemplateUpdatemuscleGroupsInput | string[]
    equipment?: WorkoutTemplateUpdateequipmentInput | string[]
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleTemplateCreateInput = {
    id?: string
    name: string
    description?: string | null
    slots?: ScheduleTemplateCreateslotsInput | InputJsonValue[]
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutScheduleTemplatesInput
  }

  export type ScheduleTemplateUncheckedCreateInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    slots?: ScheduleTemplateCreateslotsInput | InputJsonValue[]
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduleTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slots?: ScheduleTemplateUpdateslotsInput | InputJsonValue[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutScheduleTemplatesNestedInput
  }

  export type ScheduleTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slots?: ScheduleTemplateUpdateslotsInput | InputJsonValue[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleTemplateCreateManyInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    slots?: ScheduleTemplateCreateslotsInput | InputJsonValue[]
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduleTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slots?: ScheduleTemplateUpdateslotsInput | InputJsonValue[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slots?: ScheduleTemplateUpdateslotsInput | InputJsonValue[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumVerticalFilter<$PrismaModel = never> = {
    equals?: $Enums.Vertical | EnumVerticalFieldRefInput<$PrismaModel>
    in?: $Enums.Vertical[] | ListEnumVerticalFieldRefInput<$PrismaModel>
    notIn?: $Enums.Vertical[] | ListEnumVerticalFieldRefInput<$PrismaModel>
    not?: NestedEnumVerticalFilter<$PrismaModel> | $Enums.Vertical
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type ClientListRelationFilter = {
    every?: ClientWhereInput
    some?: ClientWhereInput
    none?: ClientWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type ClassListRelationFilter = {
    every?: ClassWhereInput
    some?: ClassWhereInput
    none?: ClassWhereInput
  }

  export type PackageListRelationFilter = {
    every?: PackageWhereInput
    some?: PackageWhereInput
    none?: PackageWhereInput
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type InvoiceListRelationFilter = {
    every?: InvoiceWhereInput
    some?: InvoiceWhereInput
    none?: InvoiceWhereInput
  }

  export type AILogListRelationFilter = {
    every?: AILogWhereInput
    some?: AILogWhereInput
    none?: AILogWhereInput
  }

  export type BankAccountListRelationFilter = {
    every?: BankAccountWhereInput
    some?: BankAccountWhereInput
    none?: BankAccountWhereInput
  }

  export type BankTransactionListRelationFilter = {
    every?: BankTransactionWhereInput
    some?: BankTransactionWhereInput
    none?: BankTransactionWhereInput
  }

  export type InvoicePaymentListRelationFilter = {
    every?: InvoicePaymentWhereInput
    some?: InvoicePaymentWhereInput
    none?: InvoicePaymentWhereInput
  }

  export type PaymentGatewayConfigListRelationFilter = {
    every?: PaymentGatewayConfigWhereInput
    some?: PaymentGatewayConfigWhereInput
    none?: PaymentGatewayConfigWhereInput
  }

  export type CryptoWalletListRelationFilter = {
    every?: CryptoWalletWhereInput
    some?: CryptoWalletWhereInput
    none?: CryptoWalletWhereInput
  }

  export type ExpenseCategoryListRelationFilter = {
    every?: ExpenseCategoryWhereInput
    some?: ExpenseCategoryWhereInput
    none?: ExpenseCategoryWhereInput
  }

  export type ExpenseListRelationFilter = {
    every?: ExpenseWhereInput
    some?: ExpenseWhereInput
    none?: ExpenseWhereInput
  }

  export type RecurringInvoiceTemplateListRelationFilter = {
    every?: RecurringInvoiceTemplateWhereInput
    some?: RecurringInvoiceTemplateWhereInput
    none?: RecurringInvoiceTemplateWhereInput
  }

  export type BadgeListRelationFilter = {
    every?: BadgeWhereInput
    some?: BadgeWhereInput
    none?: BadgeWhereInput
  }

  export type WorkoutTemplateListRelationFilter = {
    every?: WorkoutTemplateWhereInput
    some?: WorkoutTemplateWhereInput
    none?: WorkoutTemplateWhereInput
  }

  export type ScheduleTemplateListRelationFilter = {
    every?: ScheduleTemplateWhereInput
    some?: ScheduleTemplateWhereInput
    none?: ScheduleTemplateWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClassOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PackageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AILogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BankAccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BankTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoicePaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentGatewayConfigOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CryptoWalletOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExpenseCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExpenseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RecurringInvoiceTemplateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BadgeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkoutTemplateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ScheduleTemplateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TenantCountOrderByAggregateInput = {
    id?: SortOrder
    vertical?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    website?: SortOrder
    logo?: SortOrder
    subscriptionTier?: SortOrder
    aiCredits?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantAvgOrderByAggregateInput = {
    aiCredits?: SortOrder
  }

  export type TenantMaxOrderByAggregateInput = {
    id?: SortOrder
    vertical?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    website?: SortOrder
    logo?: SortOrder
    subscriptionTier?: SortOrder
    aiCredits?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantMinOrderByAggregateInput = {
    id?: SortOrder
    vertical?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    website?: SortOrder
    logo?: SortOrder
    subscriptionTier?: SortOrder
    aiCredits?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantSumOrderByAggregateInput = {
    aiCredits?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumVerticalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Vertical | EnumVerticalFieldRefInput<$PrismaModel>
    in?: $Enums.Vertical[] | ListEnumVerticalFieldRefInput<$PrismaModel>
    notIn?: $Enums.Vertical[] | ListEnumVerticalFieldRefInput<$PrismaModel>
    not?: NestedEnumVerticalWithAggregatesFilter<$PrismaModel> | $Enums.Vertical
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVerticalFilter<$PrismaModel>
    _max?: NestedEnumVerticalFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type TenantScalarRelationFilter = {
    is?: TenantWhereInput
    isNot?: TenantWhereInput
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type UserSessionListRelationFilter = {
    every?: UserSessionWhereInput
    some?: UserSessionWhereInput
    none?: UserSessionWhereInput
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string
    providerAccountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type UserSessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type UserSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type UserSessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenIdentifierTokenCompoundUniqueInput = {
    identifier: string
    token: string
  }

  export type VerificationTokenCountOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMaxOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMinOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type PasswordResetTokenCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordResetTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordResetTokenMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ClientMeasurementListRelationFilter = {
    every?: ClientMeasurementWhereInput
    some?: ClientMeasurementWhereInput
    none?: ClientMeasurementWhereInput
  }

  export type ProgressPhotoListRelationFilter = {
    every?: ProgressPhotoWhereInput
    some?: ProgressPhotoWhereInput
    none?: ProgressPhotoWhereInput
  }

  export type ClientBadgeListRelationFilter = {
    every?: ClientBadgeWhereInput
    some?: ClientBadgeWhereInput
    none?: ClientBadgeWhereInput
  }

  export type ClientMeasurementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProgressPhotoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientBadgeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    avatar?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    goals?: SortOrder
    currentWeight?: SortOrder
    targetWeight?: SortOrder
    height?: SortOrder
    bodyMeasurements?: SortOrder
    bodyFatPercent?: SortOrder
    fitnessLevel?: SortOrder
    injuryHistory?: SortOrder
    dietaryNotes?: SortOrder
    medicalNotes?: SortOrder
    creditsRemaining?: SortOrder
    membershipType?: SortOrder
    membershipExpiry?: SortOrder
    status?: SortOrder
    tags?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientAvgOrderByAggregateInput = {
    currentWeight?: SortOrder
    targetWeight?: SortOrder
    height?: SortOrder
    bodyFatPercent?: SortOrder
    creditsRemaining?: SortOrder
  }

  export type ClientMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    avatar?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    currentWeight?: SortOrder
    targetWeight?: SortOrder
    height?: SortOrder
    bodyFatPercent?: SortOrder
    fitnessLevel?: SortOrder
    injuryHistory?: SortOrder
    dietaryNotes?: SortOrder
    medicalNotes?: SortOrder
    creditsRemaining?: SortOrder
    membershipType?: SortOrder
    membershipExpiry?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    avatar?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    currentWeight?: SortOrder
    targetWeight?: SortOrder
    height?: SortOrder
    bodyFatPercent?: SortOrder
    fitnessLevel?: SortOrder
    injuryHistory?: SortOrder
    dietaryNotes?: SortOrder
    medicalNotes?: SortOrder
    creditsRemaining?: SortOrder
    membershipType?: SortOrder
    membershipExpiry?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientSumOrderByAggregateInput = {
    currentWeight?: SortOrder
    targetWeight?: SortOrder
    height?: SortOrder
    bodyFatPercent?: SortOrder
    creditsRemaining?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type ClientScalarRelationFilter = {
    is?: ClientWhereInput
    isNot?: ClientWhereInput
  }

  export type ClientMeasurementCountOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    date?: SortOrder
    weight?: SortOrder
    bodyFat?: SortOrder
    measurements?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type ClientMeasurementAvgOrderByAggregateInput = {
    weight?: SortOrder
    bodyFat?: SortOrder
  }

  export type ClientMeasurementMaxOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    date?: SortOrder
    weight?: SortOrder
    bodyFat?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type ClientMeasurementMinOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    date?: SortOrder
    weight?: SortOrder
    bodyFat?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type ClientMeasurementSumOrderByAggregateInput = {
    weight?: SortOrder
    bodyFat?: SortOrder
  }

  export type ProgressPhotoCountOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    url?: SortOrder
    date?: SortOrder
    view?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type ProgressPhotoMaxOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    url?: SortOrder
    date?: SortOrder
    view?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type ProgressPhotoMinOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    url?: SortOrder
    date?: SortOrder
    view?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonNullableListFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableListFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableListFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableListFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableListFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableListFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue[] | ListJsonFieldRefInput<$PrismaModel> | null
    has?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    hasEvery?: InputJsonValue[] | ListJsonFieldRefInput<$PrismaModel>
    hasSome?: InputJsonValue[] | ListJsonFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    clientId?: SortOrder
    scheduledAt?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    workoutPlan?: SortOrder
    exercisesLogged?: SortOrder
    caloriesBurned?: SortOrder
    heartRateAvg?: SortOrder
    muscleGroups?: SortOrder
    clientFeedback?: SortOrder
    trainerNotes?: SortOrder
    intensity?: SortOrder
    clientRating?: SortOrder
    price?: SortOrder
    paid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionAvgOrderByAggregateInput = {
    duration?: SortOrder
    caloriesBurned?: SortOrder
    heartRateAvg?: SortOrder
    clientRating?: SortOrder
    price?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    clientId?: SortOrder
    scheduledAt?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    caloriesBurned?: SortOrder
    heartRateAvg?: SortOrder
    clientFeedback?: SortOrder
    trainerNotes?: SortOrder
    intensity?: SortOrder
    clientRating?: SortOrder
    price?: SortOrder
    paid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    clientId?: SortOrder
    scheduledAt?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    caloriesBurned?: SortOrder
    heartRateAvg?: SortOrder
    clientFeedback?: SortOrder
    trainerNotes?: SortOrder
    intensity?: SortOrder
    clientRating?: SortOrder
    price?: SortOrder
    paid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionSumOrderByAggregateInput = {
    duration?: SortOrder
    caloriesBurned?: SortOrder
    heartRateAvg?: SortOrder
    clientRating?: SortOrder
    price?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type ClassBookingListRelationFilter = {
    every?: ClassBookingWhereInput
    some?: ClassBookingWhereInput
    none?: ClassBookingWhereInput
  }

  export type ClassBookingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClassCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    scheduledAt?: SortOrder
    duration?: SortOrder
    capacity?: SortOrder
    instructor?: SortOrder
    location?: SortOrder
    price?: SortOrder
    isRecurring?: SortOrder
    recurrence?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClassAvgOrderByAggregateInput = {
    duration?: SortOrder
    capacity?: SortOrder
    price?: SortOrder
  }

  export type ClassMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    scheduledAt?: SortOrder
    duration?: SortOrder
    capacity?: SortOrder
    instructor?: SortOrder
    location?: SortOrder
    price?: SortOrder
    isRecurring?: SortOrder
    recurrence?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClassMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    scheduledAt?: SortOrder
    duration?: SortOrder
    capacity?: SortOrder
    instructor?: SortOrder
    location?: SortOrder
    price?: SortOrder
    isRecurring?: SortOrder
    recurrence?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClassSumOrderByAggregateInput = {
    duration?: SortOrder
    capacity?: SortOrder
    price?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type ClassScalarRelationFilter = {
    is?: ClassWhereInput
    isNot?: ClassWhereInput
  }

  export type ClassBookingCountOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    clientId?: SortOrder
    status?: SortOrder
    checkedIn?: SortOrder
    paid?: SortOrder
    createdAt?: SortOrder
  }

  export type ClassBookingMaxOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    clientId?: SortOrder
    status?: SortOrder
    checkedIn?: SortOrder
    paid?: SortOrder
    createdAt?: SortOrder
  }

  export type ClassBookingMinOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    clientId?: SortOrder
    status?: SortOrder
    checkedIn?: SortOrder
    paid?: SortOrder
    createdAt?: SortOrder
  }

  export type PackageCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    price?: SortOrder
    credits?: SortOrder
    validityDays?: SortOrder
    features?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PackageAvgOrderByAggregateInput = {
    price?: SortOrder
    credits?: SortOrder
    validityDays?: SortOrder
  }

  export type PackageMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    price?: SortOrder
    credits?: SortOrder
    validityDays?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PackageMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    price?: SortOrder
    credits?: SortOrder
    validityDays?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PackageSumOrderByAggregateInput = {
    price?: SortOrder
    credits?: SortOrder
    validityDays?: SortOrder
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    clientId?: SortOrder
    orderNumber?: SortOrder
    status?: SortOrder
    items?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    discount?: SortOrder
    total?: SortOrder
    paymentMethod?: SortOrder
    paymentStatus?: SortOrder
    paidAmount?: SortOrder
    orderDate?: SortOrder
    dueDate?: SortOrder
    paidDate?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    subtotal?: SortOrder
    tax?: SortOrder
    discount?: SortOrder
    total?: SortOrder
    paidAmount?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    clientId?: SortOrder
    orderNumber?: SortOrder
    status?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    discount?: SortOrder
    total?: SortOrder
    paymentMethod?: SortOrder
    paymentStatus?: SortOrder
    paidAmount?: SortOrder
    orderDate?: SortOrder
    dueDate?: SortOrder
    paidDate?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    clientId?: SortOrder
    orderNumber?: SortOrder
    status?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    discount?: SortOrder
    total?: SortOrder
    paymentMethod?: SortOrder
    paymentStatus?: SortOrder
    paidAmount?: SortOrder
    orderDate?: SortOrder
    dueDate?: SortOrder
    paidDate?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    subtotal?: SortOrder
    tax?: SortOrder
    discount?: SortOrder
    total?: SortOrder
    paidAmount?: SortOrder
  }

  export type OrderNullableScalarRelationFilter = {
    is?: OrderWhereInput | null
    isNot?: OrderWhereInput | null
  }

  export type CryptoPaymentListRelationFilter = {
    every?: CryptoPaymentWhereInput
    some?: CryptoPaymentWhereInput
    none?: CryptoPaymentWhereInput
  }

  export type CryptoPaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    orderId?: SortOrder
    clientId?: SortOrder
    invoiceNumber?: SortOrder
    status?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    paidDate?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    total?: SortOrder
    paymentMethod?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    subtotal?: SortOrder
    tax?: SortOrder
    total?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    orderId?: SortOrder
    clientId?: SortOrder
    invoiceNumber?: SortOrder
    status?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    paidDate?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    total?: SortOrder
    paymentMethod?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    orderId?: SortOrder
    clientId?: SortOrder
    invoiceNumber?: SortOrder
    status?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    paidDate?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    total?: SortOrder
    paymentMethod?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    subtotal?: SortOrder
    tax?: SortOrder
    total?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AILogCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    feature?: SortOrder
    model?: SortOrder
    promptTokens?: SortOrder
    completionTokens?: SortOrder
    totalTokens?: SortOrder
    estimatedCost?: SortOrder
    input?: SortOrder
    output?: SortOrder
    latencyMs?: SortOrder
    success?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
  }

  export type AILogAvgOrderByAggregateInput = {
    promptTokens?: SortOrder
    completionTokens?: SortOrder
    totalTokens?: SortOrder
    estimatedCost?: SortOrder
    latencyMs?: SortOrder
  }

  export type AILogMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    feature?: SortOrder
    model?: SortOrder
    promptTokens?: SortOrder
    completionTokens?: SortOrder
    totalTokens?: SortOrder
    estimatedCost?: SortOrder
    latencyMs?: SortOrder
    success?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
  }

  export type AILogMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    feature?: SortOrder
    model?: SortOrder
    promptTokens?: SortOrder
    completionTokens?: SortOrder
    totalTokens?: SortOrder
    estimatedCost?: SortOrder
    latencyMs?: SortOrder
    success?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
  }

  export type AILogSumOrderByAggregateInput = {
    promptTokens?: SortOrder
    completionTokens?: SortOrder
    totalTokens?: SortOrder
    estimatedCost?: SortOrder
    latencyMs?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type ExchangeRateListRelationFilter = {
    every?: ExchangeRateWhereInput
    some?: ExchangeRateWhereInput
    none?: ExchangeRateWhereInput
  }

  export type ExchangeRateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CurrencyCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    decimals?: SortOrder
    isCrypto?: SortOrder
    isStablecoin?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CurrencyAvgOrderByAggregateInput = {
    decimals?: SortOrder
  }

  export type CurrencyMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    decimals?: SortOrder
    isCrypto?: SortOrder
    isStablecoin?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CurrencyMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    decimals?: SortOrder
    isCrypto?: SortOrder
    isStablecoin?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CurrencySumOrderByAggregateInput = {
    decimals?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type CurrencyScalarRelationFilter = {
    is?: CurrencyWhereInput
    isNot?: CurrencyWhereInput
  }

  export type ExchangeRateFromCurrencyIdToCurrencyIdTimestampCompoundUniqueInput = {
    fromCurrencyId: string
    toCurrencyId: string
    timestamp: Date | string
  }

  export type ExchangeRateCountOrderByAggregateInput = {
    id?: SortOrder
    fromCurrencyId?: SortOrder
    toCurrencyId?: SortOrder
    rate?: SortOrder
    source?: SortOrder
    timestamp?: SortOrder
  }

  export type ExchangeRateAvgOrderByAggregateInput = {
    rate?: SortOrder
  }

  export type ExchangeRateMaxOrderByAggregateInput = {
    id?: SortOrder
    fromCurrencyId?: SortOrder
    toCurrencyId?: SortOrder
    rate?: SortOrder
    source?: SortOrder
    timestamp?: SortOrder
  }

  export type ExchangeRateMinOrderByAggregateInput = {
    id?: SortOrder
    fromCurrencyId?: SortOrder
    toCurrencyId?: SortOrder
    rate?: SortOrder
    source?: SortOrder
    timestamp?: SortOrder
  }

  export type ExchangeRateSumOrderByAggregateInput = {
    rate?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type EnumBankProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.BankProvider | EnumBankProviderFieldRefInput<$PrismaModel>
    in?: $Enums.BankProvider[] | ListEnumBankProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.BankProvider[] | ListEnumBankProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumBankProviderFilter<$PrismaModel> | $Enums.BankProvider
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type BankAccountCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    accountName?: SortOrder
    accountNumber?: SortOrder
    bankCode?: SortOrder
    iban?: SortOrder
    swift?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    currency?: SortOrder
    balance?: SortOrder
    balanceUpdatedAt?: SortOrder
    autoSync?: SortOrder
    lastSyncAt?: SortOrder
    syncFrequency?: SortOrder
    credentials?: SortOrder
    isActive?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BankAccountAvgOrderByAggregateInput = {
    balance?: SortOrder
  }

  export type BankAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    accountName?: SortOrder
    accountNumber?: SortOrder
    bankCode?: SortOrder
    iban?: SortOrder
    swift?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    currency?: SortOrder
    balance?: SortOrder
    balanceUpdatedAt?: SortOrder
    autoSync?: SortOrder
    lastSyncAt?: SortOrder
    syncFrequency?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BankAccountMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    accountName?: SortOrder
    accountNumber?: SortOrder
    bankCode?: SortOrder
    iban?: SortOrder
    swift?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    currency?: SortOrder
    balance?: SortOrder
    balanceUpdatedAt?: SortOrder
    autoSync?: SortOrder
    lastSyncAt?: SortOrder
    syncFrequency?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BankAccountSumOrderByAggregateInput = {
    balance?: SortOrder
  }

  export type EnumBankProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BankProvider | EnumBankProviderFieldRefInput<$PrismaModel>
    in?: $Enums.BankProvider[] | ListEnumBankProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.BankProvider[] | ListEnumBankProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumBankProviderWithAggregatesFilter<$PrismaModel> | $Enums.BankProvider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBankProviderFilter<$PrismaModel>
    _max?: NestedEnumBankProviderFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type EnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type BankAccountScalarRelationFilter = {
    is?: BankAccountWhereInput
    isNot?: BankAccountWhereInput
  }

  export type InvoiceNullableScalarRelationFilter = {
    is?: InvoiceWhereInput | null
    isNot?: InvoiceWhereInput | null
  }

  export type BankTransactionBankAccountIdTransactionIdCompoundUniqueInput = {
    bankAccountId: string
    transactionId: string
  }

  export type BankTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    bankAccountId?: SortOrder
    tenantId?: SortOrder
    transactionId?: SortOrder
    date?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    type?: SortOrder
    counterpartyName?: SortOrder
    counterpartyAccount?: SortOrder
    counterpartyBankCode?: SortOrder
    description?: SortOrder
    note?: SortOrder
    variableSymbol?: SortOrder
    constantSymbol?: SortOrder
    specificSymbol?: SortOrder
    reference?: SortOrder
    isMatched?: SortOrder
    matchedInvoiceId?: SortOrder
    matchedPaymentId?: SortOrder
    matchConfidence?: SortOrder
    aiSuggestions?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BankTransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
    matchConfidence?: SortOrder
  }

  export type BankTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    bankAccountId?: SortOrder
    tenantId?: SortOrder
    transactionId?: SortOrder
    date?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    type?: SortOrder
    counterpartyName?: SortOrder
    counterpartyAccount?: SortOrder
    counterpartyBankCode?: SortOrder
    description?: SortOrder
    note?: SortOrder
    variableSymbol?: SortOrder
    constantSymbol?: SortOrder
    specificSymbol?: SortOrder
    reference?: SortOrder
    isMatched?: SortOrder
    matchedInvoiceId?: SortOrder
    matchedPaymentId?: SortOrder
    matchConfidence?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BankTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    bankAccountId?: SortOrder
    tenantId?: SortOrder
    transactionId?: SortOrder
    date?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    type?: SortOrder
    counterpartyName?: SortOrder
    counterpartyAccount?: SortOrder
    counterpartyBankCode?: SortOrder
    description?: SortOrder
    note?: SortOrder
    variableSymbol?: SortOrder
    constantSymbol?: SortOrder
    specificSymbol?: SortOrder
    reference?: SortOrder
    isMatched?: SortOrder
    matchedInvoiceId?: SortOrder
    matchedPaymentId?: SortOrder
    matchConfidence?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BankTransactionSumOrderByAggregateInput = {
    amount?: SortOrder
    matchConfidence?: SortOrder
  }

  export type EnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type EnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type InvoiceScalarRelationFilter = {
    is?: InvoiceWhereInput
    isNot?: InvoiceWhereInput
  }

  export type InvoicePaymentCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    method?: SortOrder
    status?: SortOrder
    gatewayProvider?: SortOrder
    gatewayPaymentId?: SortOrder
    gatewayFee?: SortOrder
    transactionId?: SortOrder
    reference?: SortOrder
    processedAt?: SortOrder
    completedAt?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoicePaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
    gatewayFee?: SortOrder
  }

  export type InvoicePaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    method?: SortOrder
    status?: SortOrder
    gatewayProvider?: SortOrder
    gatewayPaymentId?: SortOrder
    gatewayFee?: SortOrder
    transactionId?: SortOrder
    reference?: SortOrder
    processedAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoicePaymentMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    method?: SortOrder
    status?: SortOrder
    gatewayProvider?: SortOrder
    gatewayPaymentId?: SortOrder
    gatewayFee?: SortOrder
    transactionId?: SortOrder
    reference?: SortOrder
    processedAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoicePaymentSumOrderByAggregateInput = {
    amount?: SortOrder
    gatewayFee?: SortOrder
  }

  export type EnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type PaymentGatewayConfigTenantIdProviderCompoundUniqueInput = {
    tenantId: string
    provider: string
  }

  export type PaymentGatewayConfigCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    provider?: SortOrder
    config?: SortOrder
    isActive?: SortOrder
    isTest?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentGatewayConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    provider?: SortOrder
    isActive?: SortOrder
    isTest?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentGatewayConfigMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    provider?: SortOrder
    isActive?: SortOrder
    isTest?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CryptoWalletTenantIdCurrencyAddressCompoundUniqueInput = {
    tenantId: string
    currency: string
    address: string
  }

  export type CryptoWalletCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    currency?: SortOrder
    address?: SortOrder
    network?: SortOrder
    provider?: SortOrder
    isActive?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CryptoWalletMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    currency?: SortOrder
    address?: SortOrder
    network?: SortOrder
    provider?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CryptoWalletMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    currency?: SortOrder
    address?: SortOrder
    network?: SortOrder
    provider?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CryptoWalletScalarRelationFilter = {
    is?: CryptoWalletWhereInput
    isNot?: CryptoWalletWhereInput
  }

  export type CryptoPaymentCountOrderByAggregateInput = {
    id?: SortOrder
    walletId?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    txHash?: SortOrder
    confirmations?: SortOrder
    status?: SortOrder
    detectedAt?: SortOrder
    confirmedAt?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CryptoPaymentAvgOrderByAggregateInput = {
    confirmations?: SortOrder
  }

  export type CryptoPaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    walletId?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    txHash?: SortOrder
    confirmations?: SortOrder
    status?: SortOrder
    detectedAt?: SortOrder
    confirmedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CryptoPaymentMinOrderByAggregateInput = {
    id?: SortOrder
    walletId?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    txHash?: SortOrder
    confirmations?: SortOrder
    status?: SortOrder
    detectedAt?: SortOrder
    confirmedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CryptoPaymentSumOrderByAggregateInput = {
    confirmations?: SortOrder
  }

  export type ExpenseCategoryTenantIdNameCompoundUniqueInput = {
    tenantId: string
    name: string
  }

  export type ExpenseCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExpenseCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExpenseCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumExpenseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ExpenseStatus | EnumExpenseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ExpenseStatus[] | ListEnumExpenseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExpenseStatus[] | ListEnumExpenseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumExpenseStatusFilter<$PrismaModel> | $Enums.ExpenseStatus
  }

  export type ExpenseCategoryScalarRelationFilter = {
    is?: ExpenseCategoryWhereInput
    isNot?: ExpenseCategoryWhereInput
  }

  export type ExpenseCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    categoryId?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    date?: SortOrder
    vendor?: SortOrder
    receiptUrl?: SortOrder
    receiptOcrData?: SortOrder
    taxAmount?: SortOrder
    isTaxDeductible?: SortOrder
    status?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    rejectedReason?: SortOrder
    reimbursedAt?: SortOrder
    reimbursedAmount?: SortOrder
    notes?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExpenseAvgOrderByAggregateInput = {
    amount?: SortOrder
    taxAmount?: SortOrder
    reimbursedAmount?: SortOrder
  }

  export type ExpenseMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    categoryId?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    date?: SortOrder
    vendor?: SortOrder
    receiptUrl?: SortOrder
    taxAmount?: SortOrder
    isTaxDeductible?: SortOrder
    status?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    rejectedReason?: SortOrder
    reimbursedAt?: SortOrder
    reimbursedAmount?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExpenseMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    categoryId?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    date?: SortOrder
    vendor?: SortOrder
    receiptUrl?: SortOrder
    taxAmount?: SortOrder
    isTaxDeductible?: SortOrder
    status?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    rejectedReason?: SortOrder
    reimbursedAt?: SortOrder
    reimbursedAmount?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExpenseSumOrderByAggregateInput = {
    amount?: SortOrder
    taxAmount?: SortOrder
    reimbursedAmount?: SortOrder
  }

  export type EnumExpenseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExpenseStatus | EnumExpenseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ExpenseStatus[] | ListEnumExpenseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExpenseStatus[] | ListEnumExpenseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumExpenseStatusWithAggregatesFilter<$PrismaModel> | $Enums.ExpenseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExpenseStatusFilter<$PrismaModel>
    _max?: NestedEnumExpenseStatusFilter<$PrismaModel>
  }

  export type RecurringInvoiceTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    frequency?: SortOrder
    nextInvoiceDate?: SortOrder
    isActive?: SortOrder
    invoiceTemplate?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecurringInvoiceTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    frequency?: SortOrder
    nextInvoiceDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecurringInvoiceTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    frequency?: SortOrder
    nextInvoiceDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PushSubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    clientId?: SortOrder
    endpoint?: SortOrder
    p256dh?: SortOrder
    auth?: SortOrder
    userAgent?: SortOrder
    deviceName?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PushSubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    clientId?: SortOrder
    endpoint?: SortOrder
    p256dh?: SortOrder
    auth?: SortOrder
    userAgent?: SortOrder
    deviceName?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PushSubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    clientId?: SortOrder
    endpoint?: SortOrder
    p256dh?: SortOrder
    auth?: SortOrder
    userAgent?: SortOrder
    deviceName?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationPreferenceTenantIdUserIdCompoundUniqueInput = {
    tenantId: string
    userId: string
  }

  export type NotificationPreferenceCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    clientId?: SortOrder
    sessionReminders?: SortOrder
    classReminders?: SortOrder
    invoiceNotifications?: SortOrder
    paymentNotifications?: SortOrder
    atRiskAlerts?: SortOrder
    reminderMinutesBefore?: SortOrder
    emailEnabled?: SortOrder
    pushEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationPreferenceAvgOrderByAggregateInput = {
    reminderMinutesBefore?: SortOrder
  }

  export type NotificationPreferenceMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    clientId?: SortOrder
    sessionReminders?: SortOrder
    classReminders?: SortOrder
    invoiceNotifications?: SortOrder
    paymentNotifications?: SortOrder
    atRiskAlerts?: SortOrder
    reminderMinutesBefore?: SortOrder
    emailEnabled?: SortOrder
    pushEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationPreferenceMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    clientId?: SortOrder
    sessionReminders?: SortOrder
    classReminders?: SortOrder
    invoiceNotifications?: SortOrder
    paymentNotifications?: SortOrder
    atRiskAlerts?: SortOrder
    reminderMinutesBefore?: SortOrder
    emailEnabled?: SortOrder
    pushEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationPreferenceSumOrderByAggregateInput = {
    reminderMinutesBefore?: SortOrder
  }

  export type NotificationLogCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    type?: SortOrder
    recipientType?: SortOrder
    recipientId?: SortOrder
    title?: SortOrder
    body?: SortOrder
    data?: SortOrder
    channel?: SortOrder
    status?: SortOrder
    error?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationLogMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    type?: SortOrder
    recipientType?: SortOrder
    recipientId?: SortOrder
    title?: SortOrder
    body?: SortOrder
    channel?: SortOrder
    status?: SortOrder
    error?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationLogMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    type?: SortOrder
    recipientType?: SortOrder
    recipientId?: SortOrder
    title?: SortOrder
    body?: SortOrder
    channel?: SortOrder
    status?: SortOrder
    error?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
  }

  export type CalendarEventSyncListRelationFilter = {
    every?: CalendarEventSyncWhereInput
    some?: CalendarEventSyncWhereInput
    none?: CalendarEventSyncWhereInput
  }

  export type CalendarEventSyncOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CalendarIntegrationTenantIdUserIdProviderCompoundUniqueInput = {
    tenantId: string
    userId: string
    provider: string
  }

  export type CalendarIntegrationCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    tokenExpiry?: SortOrder
    calendarId?: SortOrder
    calendarEmail?: SortOrder
    syncEnabled?: SortOrder
    syncDirection?: SortOrder
    lastSyncAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CalendarIntegrationMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    tokenExpiry?: SortOrder
    calendarId?: SortOrder
    calendarEmail?: SortOrder
    syncEnabled?: SortOrder
    syncDirection?: SortOrder
    lastSyncAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CalendarIntegrationMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    tokenExpiry?: SortOrder
    calendarId?: SortOrder
    calendarEmail?: SortOrder
    syncEnabled?: SortOrder
    syncDirection?: SortOrder
    lastSyncAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CalendarIntegrationScalarRelationFilter = {
    is?: CalendarIntegrationWhereInput
    isNot?: CalendarIntegrationWhereInput
  }

  export type CalendarEventSyncIntegrationIdEntityTypeEntityIdCompoundUniqueInput = {
    integrationId: string
    entityType: string
    entityId: string
  }

  export type CalendarEventSyncCountOrderByAggregateInput = {
    id?: SortOrder
    integrationId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    externalEventId?: SortOrder
    lastSyncedAt?: SortOrder
    syncHash?: SortOrder
  }

  export type CalendarEventSyncMaxOrderByAggregateInput = {
    id?: SortOrder
    integrationId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    externalEventId?: SortOrder
    lastSyncedAt?: SortOrder
    syncHash?: SortOrder
  }

  export type CalendarEventSyncMinOrderByAggregateInput = {
    id?: SortOrder
    integrationId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    externalEventId?: SortOrder
    lastSyncedAt?: SortOrder
    syncHash?: SortOrder
  }

  export type CalendarFeedTokenCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type CalendarFeedTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type CalendarFeedTokenMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type BadgeCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    category?: SortOrder
    criteria?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BadgeMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    category?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BadgeMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    category?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BadgeScalarRelationFilter = {
    is?: BadgeWhereInput
    isNot?: BadgeWhereInput
  }

  export type ClientBadgeClientIdBadgeIdCompoundUniqueInput = {
    clientId: string
    badgeId: string
  }

  export type ClientBadgeCountOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    badgeId?: SortOrder
    earnedAt?: SortOrder
    notified?: SortOrder
  }

  export type ClientBadgeMaxOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    badgeId?: SortOrder
    earnedAt?: SortOrder
    notified?: SortOrder
  }

  export type ClientBadgeMinOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    badgeId?: SortOrder
    earnedAt?: SortOrder
    notified?: SortOrder
  }

  export type WorkoutTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    difficulty?: SortOrder
    duration?: SortOrder
    exercises?: SortOrder
    muscleGroups?: SortOrder
    equipment?: SortOrder
    isPublic?: SortOrder
    usageCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkoutTemplateAvgOrderByAggregateInput = {
    duration?: SortOrder
    usageCount?: SortOrder
  }

  export type WorkoutTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    difficulty?: SortOrder
    duration?: SortOrder
    isPublic?: SortOrder
    usageCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkoutTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    difficulty?: SortOrder
    duration?: SortOrder
    isPublic?: SortOrder
    usageCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkoutTemplateSumOrderByAggregateInput = {
    duration?: SortOrder
    usageCount?: SortOrder
  }

  export type ScheduleTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    slots?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScheduleTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScheduleTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserCreateNestedManyWithoutTenantInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type ClientCreateNestedManyWithoutTenantInput = {
    create?: XOR<ClientCreateWithoutTenantInput, ClientUncheckedCreateWithoutTenantInput> | ClientCreateWithoutTenantInput[] | ClientUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutTenantInput | ClientCreateOrConnectWithoutTenantInput[]
    createMany?: ClientCreateManyTenantInputEnvelope
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutTenantInput = {
    create?: XOR<SessionCreateWithoutTenantInput, SessionUncheckedCreateWithoutTenantInput> | SessionCreateWithoutTenantInput[] | SessionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutTenantInput | SessionCreateOrConnectWithoutTenantInput[]
    createMany?: SessionCreateManyTenantInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type ClassCreateNestedManyWithoutTenantInput = {
    create?: XOR<ClassCreateWithoutTenantInput, ClassUncheckedCreateWithoutTenantInput> | ClassCreateWithoutTenantInput[] | ClassUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutTenantInput | ClassCreateOrConnectWithoutTenantInput[]
    createMany?: ClassCreateManyTenantInputEnvelope
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type PackageCreateNestedManyWithoutTenantInput = {
    create?: XOR<PackageCreateWithoutTenantInput, PackageUncheckedCreateWithoutTenantInput> | PackageCreateWithoutTenantInput[] | PackageUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PackageCreateOrConnectWithoutTenantInput | PackageCreateOrConnectWithoutTenantInput[]
    createMany?: PackageCreateManyTenantInputEnvelope
    connect?: PackageWhereUniqueInput | PackageWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutTenantInput = {
    create?: XOR<OrderCreateWithoutTenantInput, OrderUncheckedCreateWithoutTenantInput> | OrderCreateWithoutTenantInput[] | OrderUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutTenantInput | OrderCreateOrConnectWithoutTenantInput[]
    createMany?: OrderCreateManyTenantInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutTenantInput = {
    create?: XOR<InvoiceCreateWithoutTenantInput, InvoiceUncheckedCreateWithoutTenantInput> | InvoiceCreateWithoutTenantInput[] | InvoiceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutTenantInput | InvoiceCreateOrConnectWithoutTenantInput[]
    createMany?: InvoiceCreateManyTenantInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type AILogCreateNestedManyWithoutTenantInput = {
    create?: XOR<AILogCreateWithoutTenantInput, AILogUncheckedCreateWithoutTenantInput> | AILogCreateWithoutTenantInput[] | AILogUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AILogCreateOrConnectWithoutTenantInput | AILogCreateOrConnectWithoutTenantInput[]
    createMany?: AILogCreateManyTenantInputEnvelope
    connect?: AILogWhereUniqueInput | AILogWhereUniqueInput[]
  }

  export type BankAccountCreateNestedManyWithoutTenantInput = {
    create?: XOR<BankAccountCreateWithoutTenantInput, BankAccountUncheckedCreateWithoutTenantInput> | BankAccountCreateWithoutTenantInput[] | BankAccountUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: BankAccountCreateOrConnectWithoutTenantInput | BankAccountCreateOrConnectWithoutTenantInput[]
    createMany?: BankAccountCreateManyTenantInputEnvelope
    connect?: BankAccountWhereUniqueInput | BankAccountWhereUniqueInput[]
  }

  export type BankTransactionCreateNestedManyWithoutTenantInput = {
    create?: XOR<BankTransactionCreateWithoutTenantInput, BankTransactionUncheckedCreateWithoutTenantInput> | BankTransactionCreateWithoutTenantInput[] | BankTransactionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: BankTransactionCreateOrConnectWithoutTenantInput | BankTransactionCreateOrConnectWithoutTenantInput[]
    createMany?: BankTransactionCreateManyTenantInputEnvelope
    connect?: BankTransactionWhereUniqueInput | BankTransactionWhereUniqueInput[]
  }

  export type InvoicePaymentCreateNestedManyWithoutTenantInput = {
    create?: XOR<InvoicePaymentCreateWithoutTenantInput, InvoicePaymentUncheckedCreateWithoutTenantInput> | InvoicePaymentCreateWithoutTenantInput[] | InvoicePaymentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InvoicePaymentCreateOrConnectWithoutTenantInput | InvoicePaymentCreateOrConnectWithoutTenantInput[]
    createMany?: InvoicePaymentCreateManyTenantInputEnvelope
    connect?: InvoicePaymentWhereUniqueInput | InvoicePaymentWhereUniqueInput[]
  }

  export type PaymentGatewayConfigCreateNestedManyWithoutTenantInput = {
    create?: XOR<PaymentGatewayConfigCreateWithoutTenantInput, PaymentGatewayConfigUncheckedCreateWithoutTenantInput> | PaymentGatewayConfigCreateWithoutTenantInput[] | PaymentGatewayConfigUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PaymentGatewayConfigCreateOrConnectWithoutTenantInput | PaymentGatewayConfigCreateOrConnectWithoutTenantInput[]
    createMany?: PaymentGatewayConfigCreateManyTenantInputEnvelope
    connect?: PaymentGatewayConfigWhereUniqueInput | PaymentGatewayConfigWhereUniqueInput[]
  }

  export type CryptoWalletCreateNestedManyWithoutTenantInput = {
    create?: XOR<CryptoWalletCreateWithoutTenantInput, CryptoWalletUncheckedCreateWithoutTenantInput> | CryptoWalletCreateWithoutTenantInput[] | CryptoWalletUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CryptoWalletCreateOrConnectWithoutTenantInput | CryptoWalletCreateOrConnectWithoutTenantInput[]
    createMany?: CryptoWalletCreateManyTenantInputEnvelope
    connect?: CryptoWalletWhereUniqueInput | CryptoWalletWhereUniqueInput[]
  }

  export type ExpenseCategoryCreateNestedManyWithoutTenantInput = {
    create?: XOR<ExpenseCategoryCreateWithoutTenantInput, ExpenseCategoryUncheckedCreateWithoutTenantInput> | ExpenseCategoryCreateWithoutTenantInput[] | ExpenseCategoryUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ExpenseCategoryCreateOrConnectWithoutTenantInput | ExpenseCategoryCreateOrConnectWithoutTenantInput[]
    createMany?: ExpenseCategoryCreateManyTenantInputEnvelope
    connect?: ExpenseCategoryWhereUniqueInput | ExpenseCategoryWhereUniqueInput[]
  }

  export type ExpenseCreateNestedManyWithoutTenantInput = {
    create?: XOR<ExpenseCreateWithoutTenantInput, ExpenseUncheckedCreateWithoutTenantInput> | ExpenseCreateWithoutTenantInput[] | ExpenseUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutTenantInput | ExpenseCreateOrConnectWithoutTenantInput[]
    createMany?: ExpenseCreateManyTenantInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type RecurringInvoiceTemplateCreateNestedManyWithoutTenantInput = {
    create?: XOR<RecurringInvoiceTemplateCreateWithoutTenantInput, RecurringInvoiceTemplateUncheckedCreateWithoutTenantInput> | RecurringInvoiceTemplateCreateWithoutTenantInput[] | RecurringInvoiceTemplateUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: RecurringInvoiceTemplateCreateOrConnectWithoutTenantInput | RecurringInvoiceTemplateCreateOrConnectWithoutTenantInput[]
    createMany?: RecurringInvoiceTemplateCreateManyTenantInputEnvelope
    connect?: RecurringInvoiceTemplateWhereUniqueInput | RecurringInvoiceTemplateWhereUniqueInput[]
  }

  export type BadgeCreateNestedManyWithoutTenantInput = {
    create?: XOR<BadgeCreateWithoutTenantInput, BadgeUncheckedCreateWithoutTenantInput> | BadgeCreateWithoutTenantInput[] | BadgeUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: BadgeCreateOrConnectWithoutTenantInput | BadgeCreateOrConnectWithoutTenantInput[]
    createMany?: BadgeCreateManyTenantInputEnvelope
    connect?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
  }

  export type WorkoutTemplateCreateNestedManyWithoutTenantInput = {
    create?: XOR<WorkoutTemplateCreateWithoutTenantInput, WorkoutTemplateUncheckedCreateWithoutTenantInput> | WorkoutTemplateCreateWithoutTenantInput[] | WorkoutTemplateUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: WorkoutTemplateCreateOrConnectWithoutTenantInput | WorkoutTemplateCreateOrConnectWithoutTenantInput[]
    createMany?: WorkoutTemplateCreateManyTenantInputEnvelope
    connect?: WorkoutTemplateWhereUniqueInput | WorkoutTemplateWhereUniqueInput[]
  }

  export type ScheduleTemplateCreateNestedManyWithoutTenantInput = {
    create?: XOR<ScheduleTemplateCreateWithoutTenantInput, ScheduleTemplateUncheckedCreateWithoutTenantInput> | ScheduleTemplateCreateWithoutTenantInput[] | ScheduleTemplateUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ScheduleTemplateCreateOrConnectWithoutTenantInput | ScheduleTemplateCreateOrConnectWithoutTenantInput[]
    createMany?: ScheduleTemplateCreateManyTenantInputEnvelope
    connect?: ScheduleTemplateWhereUniqueInput | ScheduleTemplateWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type ClientUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<ClientCreateWithoutTenantInput, ClientUncheckedCreateWithoutTenantInput> | ClientCreateWithoutTenantInput[] | ClientUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutTenantInput | ClientCreateOrConnectWithoutTenantInput[]
    createMany?: ClientCreateManyTenantInputEnvelope
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<SessionCreateWithoutTenantInput, SessionUncheckedCreateWithoutTenantInput> | SessionCreateWithoutTenantInput[] | SessionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutTenantInput | SessionCreateOrConnectWithoutTenantInput[]
    createMany?: SessionCreateManyTenantInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type ClassUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<ClassCreateWithoutTenantInput, ClassUncheckedCreateWithoutTenantInput> | ClassCreateWithoutTenantInput[] | ClassUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutTenantInput | ClassCreateOrConnectWithoutTenantInput[]
    createMany?: ClassCreateManyTenantInputEnvelope
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type PackageUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<PackageCreateWithoutTenantInput, PackageUncheckedCreateWithoutTenantInput> | PackageCreateWithoutTenantInput[] | PackageUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PackageCreateOrConnectWithoutTenantInput | PackageCreateOrConnectWithoutTenantInput[]
    createMany?: PackageCreateManyTenantInputEnvelope
    connect?: PackageWhereUniqueInput | PackageWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<OrderCreateWithoutTenantInput, OrderUncheckedCreateWithoutTenantInput> | OrderCreateWithoutTenantInput[] | OrderUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutTenantInput | OrderCreateOrConnectWithoutTenantInput[]
    createMany?: OrderCreateManyTenantInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<InvoiceCreateWithoutTenantInput, InvoiceUncheckedCreateWithoutTenantInput> | InvoiceCreateWithoutTenantInput[] | InvoiceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutTenantInput | InvoiceCreateOrConnectWithoutTenantInput[]
    createMany?: InvoiceCreateManyTenantInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type AILogUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<AILogCreateWithoutTenantInput, AILogUncheckedCreateWithoutTenantInput> | AILogCreateWithoutTenantInput[] | AILogUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AILogCreateOrConnectWithoutTenantInput | AILogCreateOrConnectWithoutTenantInput[]
    createMany?: AILogCreateManyTenantInputEnvelope
    connect?: AILogWhereUniqueInput | AILogWhereUniqueInput[]
  }

  export type BankAccountUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<BankAccountCreateWithoutTenantInput, BankAccountUncheckedCreateWithoutTenantInput> | BankAccountCreateWithoutTenantInput[] | BankAccountUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: BankAccountCreateOrConnectWithoutTenantInput | BankAccountCreateOrConnectWithoutTenantInput[]
    createMany?: BankAccountCreateManyTenantInputEnvelope
    connect?: BankAccountWhereUniqueInput | BankAccountWhereUniqueInput[]
  }

  export type BankTransactionUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<BankTransactionCreateWithoutTenantInput, BankTransactionUncheckedCreateWithoutTenantInput> | BankTransactionCreateWithoutTenantInput[] | BankTransactionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: BankTransactionCreateOrConnectWithoutTenantInput | BankTransactionCreateOrConnectWithoutTenantInput[]
    createMany?: BankTransactionCreateManyTenantInputEnvelope
    connect?: BankTransactionWhereUniqueInput | BankTransactionWhereUniqueInput[]
  }

  export type InvoicePaymentUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<InvoicePaymentCreateWithoutTenantInput, InvoicePaymentUncheckedCreateWithoutTenantInput> | InvoicePaymentCreateWithoutTenantInput[] | InvoicePaymentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InvoicePaymentCreateOrConnectWithoutTenantInput | InvoicePaymentCreateOrConnectWithoutTenantInput[]
    createMany?: InvoicePaymentCreateManyTenantInputEnvelope
    connect?: InvoicePaymentWhereUniqueInput | InvoicePaymentWhereUniqueInput[]
  }

  export type PaymentGatewayConfigUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<PaymentGatewayConfigCreateWithoutTenantInput, PaymentGatewayConfigUncheckedCreateWithoutTenantInput> | PaymentGatewayConfigCreateWithoutTenantInput[] | PaymentGatewayConfigUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PaymentGatewayConfigCreateOrConnectWithoutTenantInput | PaymentGatewayConfigCreateOrConnectWithoutTenantInput[]
    createMany?: PaymentGatewayConfigCreateManyTenantInputEnvelope
    connect?: PaymentGatewayConfigWhereUniqueInput | PaymentGatewayConfigWhereUniqueInput[]
  }

  export type CryptoWalletUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<CryptoWalletCreateWithoutTenantInput, CryptoWalletUncheckedCreateWithoutTenantInput> | CryptoWalletCreateWithoutTenantInput[] | CryptoWalletUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CryptoWalletCreateOrConnectWithoutTenantInput | CryptoWalletCreateOrConnectWithoutTenantInput[]
    createMany?: CryptoWalletCreateManyTenantInputEnvelope
    connect?: CryptoWalletWhereUniqueInput | CryptoWalletWhereUniqueInput[]
  }

  export type ExpenseCategoryUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<ExpenseCategoryCreateWithoutTenantInput, ExpenseCategoryUncheckedCreateWithoutTenantInput> | ExpenseCategoryCreateWithoutTenantInput[] | ExpenseCategoryUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ExpenseCategoryCreateOrConnectWithoutTenantInput | ExpenseCategoryCreateOrConnectWithoutTenantInput[]
    createMany?: ExpenseCategoryCreateManyTenantInputEnvelope
    connect?: ExpenseCategoryWhereUniqueInput | ExpenseCategoryWhereUniqueInput[]
  }

  export type ExpenseUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<ExpenseCreateWithoutTenantInput, ExpenseUncheckedCreateWithoutTenantInput> | ExpenseCreateWithoutTenantInput[] | ExpenseUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutTenantInput | ExpenseCreateOrConnectWithoutTenantInput[]
    createMany?: ExpenseCreateManyTenantInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type RecurringInvoiceTemplateUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<RecurringInvoiceTemplateCreateWithoutTenantInput, RecurringInvoiceTemplateUncheckedCreateWithoutTenantInput> | RecurringInvoiceTemplateCreateWithoutTenantInput[] | RecurringInvoiceTemplateUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: RecurringInvoiceTemplateCreateOrConnectWithoutTenantInput | RecurringInvoiceTemplateCreateOrConnectWithoutTenantInput[]
    createMany?: RecurringInvoiceTemplateCreateManyTenantInputEnvelope
    connect?: RecurringInvoiceTemplateWhereUniqueInput | RecurringInvoiceTemplateWhereUniqueInput[]
  }

  export type BadgeUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<BadgeCreateWithoutTenantInput, BadgeUncheckedCreateWithoutTenantInput> | BadgeCreateWithoutTenantInput[] | BadgeUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: BadgeCreateOrConnectWithoutTenantInput | BadgeCreateOrConnectWithoutTenantInput[]
    createMany?: BadgeCreateManyTenantInputEnvelope
    connect?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
  }

  export type WorkoutTemplateUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<WorkoutTemplateCreateWithoutTenantInput, WorkoutTemplateUncheckedCreateWithoutTenantInput> | WorkoutTemplateCreateWithoutTenantInput[] | WorkoutTemplateUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: WorkoutTemplateCreateOrConnectWithoutTenantInput | WorkoutTemplateCreateOrConnectWithoutTenantInput[]
    createMany?: WorkoutTemplateCreateManyTenantInputEnvelope
    connect?: WorkoutTemplateWhereUniqueInput | WorkoutTemplateWhereUniqueInput[]
  }

  export type ScheduleTemplateUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<ScheduleTemplateCreateWithoutTenantInput, ScheduleTemplateUncheckedCreateWithoutTenantInput> | ScheduleTemplateCreateWithoutTenantInput[] | ScheduleTemplateUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ScheduleTemplateCreateOrConnectWithoutTenantInput | ScheduleTemplateCreateOrConnectWithoutTenantInput[]
    createMany?: ScheduleTemplateCreateManyTenantInputEnvelope
    connect?: ScheduleTemplateWhereUniqueInput | ScheduleTemplateWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumVerticalFieldUpdateOperationsInput = {
    set?: $Enums.Vertical
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutTenantInput | UserUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutTenantInput | UserUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UserUpdateManyWithWhereWithoutTenantInput | UserUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ClientUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ClientCreateWithoutTenantInput, ClientUncheckedCreateWithoutTenantInput> | ClientCreateWithoutTenantInput[] | ClientUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutTenantInput | ClientCreateOrConnectWithoutTenantInput[]
    upsert?: ClientUpsertWithWhereUniqueWithoutTenantInput | ClientUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ClientCreateManyTenantInputEnvelope
    set?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    disconnect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    delete?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    update?: ClientUpdateWithWhereUniqueWithoutTenantInput | ClientUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ClientUpdateManyWithWhereWithoutTenantInput | ClientUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ClientScalarWhereInput | ClientScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutTenantNestedInput = {
    create?: XOR<SessionCreateWithoutTenantInput, SessionUncheckedCreateWithoutTenantInput> | SessionCreateWithoutTenantInput[] | SessionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutTenantInput | SessionCreateOrConnectWithoutTenantInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutTenantInput | SessionUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: SessionCreateManyTenantInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutTenantInput | SessionUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutTenantInput | SessionUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type ClassUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ClassCreateWithoutTenantInput, ClassUncheckedCreateWithoutTenantInput> | ClassCreateWithoutTenantInput[] | ClassUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutTenantInput | ClassCreateOrConnectWithoutTenantInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutTenantInput | ClassUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ClassCreateManyTenantInputEnvelope
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutTenantInput | ClassUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutTenantInput | ClassUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type PackageUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PackageCreateWithoutTenantInput, PackageUncheckedCreateWithoutTenantInput> | PackageCreateWithoutTenantInput[] | PackageUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PackageCreateOrConnectWithoutTenantInput | PackageCreateOrConnectWithoutTenantInput[]
    upsert?: PackageUpsertWithWhereUniqueWithoutTenantInput | PackageUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PackageCreateManyTenantInputEnvelope
    set?: PackageWhereUniqueInput | PackageWhereUniqueInput[]
    disconnect?: PackageWhereUniqueInput | PackageWhereUniqueInput[]
    delete?: PackageWhereUniqueInput | PackageWhereUniqueInput[]
    connect?: PackageWhereUniqueInput | PackageWhereUniqueInput[]
    update?: PackageUpdateWithWhereUniqueWithoutTenantInput | PackageUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PackageUpdateManyWithWhereWithoutTenantInput | PackageUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PackageScalarWhereInput | PackageScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutTenantNestedInput = {
    create?: XOR<OrderCreateWithoutTenantInput, OrderUncheckedCreateWithoutTenantInput> | OrderCreateWithoutTenantInput[] | OrderUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutTenantInput | OrderCreateOrConnectWithoutTenantInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutTenantInput | OrderUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: OrderCreateManyTenantInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutTenantInput | OrderUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutTenantInput | OrderUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutTenantNestedInput = {
    create?: XOR<InvoiceCreateWithoutTenantInput, InvoiceUncheckedCreateWithoutTenantInput> | InvoiceCreateWithoutTenantInput[] | InvoiceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutTenantInput | InvoiceCreateOrConnectWithoutTenantInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutTenantInput | InvoiceUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: InvoiceCreateManyTenantInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutTenantInput | InvoiceUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutTenantInput | InvoiceUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type AILogUpdateManyWithoutTenantNestedInput = {
    create?: XOR<AILogCreateWithoutTenantInput, AILogUncheckedCreateWithoutTenantInput> | AILogCreateWithoutTenantInput[] | AILogUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AILogCreateOrConnectWithoutTenantInput | AILogCreateOrConnectWithoutTenantInput[]
    upsert?: AILogUpsertWithWhereUniqueWithoutTenantInput | AILogUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: AILogCreateManyTenantInputEnvelope
    set?: AILogWhereUniqueInput | AILogWhereUniqueInput[]
    disconnect?: AILogWhereUniqueInput | AILogWhereUniqueInput[]
    delete?: AILogWhereUniqueInput | AILogWhereUniqueInput[]
    connect?: AILogWhereUniqueInput | AILogWhereUniqueInput[]
    update?: AILogUpdateWithWhereUniqueWithoutTenantInput | AILogUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: AILogUpdateManyWithWhereWithoutTenantInput | AILogUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: AILogScalarWhereInput | AILogScalarWhereInput[]
  }

  export type BankAccountUpdateManyWithoutTenantNestedInput = {
    create?: XOR<BankAccountCreateWithoutTenantInput, BankAccountUncheckedCreateWithoutTenantInput> | BankAccountCreateWithoutTenantInput[] | BankAccountUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: BankAccountCreateOrConnectWithoutTenantInput | BankAccountCreateOrConnectWithoutTenantInput[]
    upsert?: BankAccountUpsertWithWhereUniqueWithoutTenantInput | BankAccountUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: BankAccountCreateManyTenantInputEnvelope
    set?: BankAccountWhereUniqueInput | BankAccountWhereUniqueInput[]
    disconnect?: BankAccountWhereUniqueInput | BankAccountWhereUniqueInput[]
    delete?: BankAccountWhereUniqueInput | BankAccountWhereUniqueInput[]
    connect?: BankAccountWhereUniqueInput | BankAccountWhereUniqueInput[]
    update?: BankAccountUpdateWithWhereUniqueWithoutTenantInput | BankAccountUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: BankAccountUpdateManyWithWhereWithoutTenantInput | BankAccountUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: BankAccountScalarWhereInput | BankAccountScalarWhereInput[]
  }

  export type BankTransactionUpdateManyWithoutTenantNestedInput = {
    create?: XOR<BankTransactionCreateWithoutTenantInput, BankTransactionUncheckedCreateWithoutTenantInput> | BankTransactionCreateWithoutTenantInput[] | BankTransactionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: BankTransactionCreateOrConnectWithoutTenantInput | BankTransactionCreateOrConnectWithoutTenantInput[]
    upsert?: BankTransactionUpsertWithWhereUniqueWithoutTenantInput | BankTransactionUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: BankTransactionCreateManyTenantInputEnvelope
    set?: BankTransactionWhereUniqueInput | BankTransactionWhereUniqueInput[]
    disconnect?: BankTransactionWhereUniqueInput | BankTransactionWhereUniqueInput[]
    delete?: BankTransactionWhereUniqueInput | BankTransactionWhereUniqueInput[]
    connect?: BankTransactionWhereUniqueInput | BankTransactionWhereUniqueInput[]
    update?: BankTransactionUpdateWithWhereUniqueWithoutTenantInput | BankTransactionUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: BankTransactionUpdateManyWithWhereWithoutTenantInput | BankTransactionUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: BankTransactionScalarWhereInput | BankTransactionScalarWhereInput[]
  }

  export type InvoicePaymentUpdateManyWithoutTenantNestedInput = {
    create?: XOR<InvoicePaymentCreateWithoutTenantInput, InvoicePaymentUncheckedCreateWithoutTenantInput> | InvoicePaymentCreateWithoutTenantInput[] | InvoicePaymentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InvoicePaymentCreateOrConnectWithoutTenantInput | InvoicePaymentCreateOrConnectWithoutTenantInput[]
    upsert?: InvoicePaymentUpsertWithWhereUniqueWithoutTenantInput | InvoicePaymentUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: InvoicePaymentCreateManyTenantInputEnvelope
    set?: InvoicePaymentWhereUniqueInput | InvoicePaymentWhereUniqueInput[]
    disconnect?: InvoicePaymentWhereUniqueInput | InvoicePaymentWhereUniqueInput[]
    delete?: InvoicePaymentWhereUniqueInput | InvoicePaymentWhereUniqueInput[]
    connect?: InvoicePaymentWhereUniqueInput | InvoicePaymentWhereUniqueInput[]
    update?: InvoicePaymentUpdateWithWhereUniqueWithoutTenantInput | InvoicePaymentUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: InvoicePaymentUpdateManyWithWhereWithoutTenantInput | InvoicePaymentUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: InvoicePaymentScalarWhereInput | InvoicePaymentScalarWhereInput[]
  }

  export type PaymentGatewayConfigUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PaymentGatewayConfigCreateWithoutTenantInput, PaymentGatewayConfigUncheckedCreateWithoutTenantInput> | PaymentGatewayConfigCreateWithoutTenantInput[] | PaymentGatewayConfigUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PaymentGatewayConfigCreateOrConnectWithoutTenantInput | PaymentGatewayConfigCreateOrConnectWithoutTenantInput[]
    upsert?: PaymentGatewayConfigUpsertWithWhereUniqueWithoutTenantInput | PaymentGatewayConfigUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PaymentGatewayConfigCreateManyTenantInputEnvelope
    set?: PaymentGatewayConfigWhereUniqueInput | PaymentGatewayConfigWhereUniqueInput[]
    disconnect?: PaymentGatewayConfigWhereUniqueInput | PaymentGatewayConfigWhereUniqueInput[]
    delete?: PaymentGatewayConfigWhereUniqueInput | PaymentGatewayConfigWhereUniqueInput[]
    connect?: PaymentGatewayConfigWhereUniqueInput | PaymentGatewayConfigWhereUniqueInput[]
    update?: PaymentGatewayConfigUpdateWithWhereUniqueWithoutTenantInput | PaymentGatewayConfigUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PaymentGatewayConfigUpdateManyWithWhereWithoutTenantInput | PaymentGatewayConfigUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PaymentGatewayConfigScalarWhereInput | PaymentGatewayConfigScalarWhereInput[]
  }

  export type CryptoWalletUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CryptoWalletCreateWithoutTenantInput, CryptoWalletUncheckedCreateWithoutTenantInput> | CryptoWalletCreateWithoutTenantInput[] | CryptoWalletUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CryptoWalletCreateOrConnectWithoutTenantInput | CryptoWalletCreateOrConnectWithoutTenantInput[]
    upsert?: CryptoWalletUpsertWithWhereUniqueWithoutTenantInput | CryptoWalletUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CryptoWalletCreateManyTenantInputEnvelope
    set?: CryptoWalletWhereUniqueInput | CryptoWalletWhereUniqueInput[]
    disconnect?: CryptoWalletWhereUniqueInput | CryptoWalletWhereUniqueInput[]
    delete?: CryptoWalletWhereUniqueInput | CryptoWalletWhereUniqueInput[]
    connect?: CryptoWalletWhereUniqueInput | CryptoWalletWhereUniqueInput[]
    update?: CryptoWalletUpdateWithWhereUniqueWithoutTenantInput | CryptoWalletUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CryptoWalletUpdateManyWithWhereWithoutTenantInput | CryptoWalletUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CryptoWalletScalarWhereInput | CryptoWalletScalarWhereInput[]
  }

  export type ExpenseCategoryUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ExpenseCategoryCreateWithoutTenantInput, ExpenseCategoryUncheckedCreateWithoutTenantInput> | ExpenseCategoryCreateWithoutTenantInput[] | ExpenseCategoryUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ExpenseCategoryCreateOrConnectWithoutTenantInput | ExpenseCategoryCreateOrConnectWithoutTenantInput[]
    upsert?: ExpenseCategoryUpsertWithWhereUniqueWithoutTenantInput | ExpenseCategoryUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ExpenseCategoryCreateManyTenantInputEnvelope
    set?: ExpenseCategoryWhereUniqueInput | ExpenseCategoryWhereUniqueInput[]
    disconnect?: ExpenseCategoryWhereUniqueInput | ExpenseCategoryWhereUniqueInput[]
    delete?: ExpenseCategoryWhereUniqueInput | ExpenseCategoryWhereUniqueInput[]
    connect?: ExpenseCategoryWhereUniqueInput | ExpenseCategoryWhereUniqueInput[]
    update?: ExpenseCategoryUpdateWithWhereUniqueWithoutTenantInput | ExpenseCategoryUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ExpenseCategoryUpdateManyWithWhereWithoutTenantInput | ExpenseCategoryUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ExpenseCategoryScalarWhereInput | ExpenseCategoryScalarWhereInput[]
  }

  export type ExpenseUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ExpenseCreateWithoutTenantInput, ExpenseUncheckedCreateWithoutTenantInput> | ExpenseCreateWithoutTenantInput[] | ExpenseUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutTenantInput | ExpenseCreateOrConnectWithoutTenantInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutTenantInput | ExpenseUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ExpenseCreateManyTenantInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutTenantInput | ExpenseUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutTenantInput | ExpenseUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type RecurringInvoiceTemplateUpdateManyWithoutTenantNestedInput = {
    create?: XOR<RecurringInvoiceTemplateCreateWithoutTenantInput, RecurringInvoiceTemplateUncheckedCreateWithoutTenantInput> | RecurringInvoiceTemplateCreateWithoutTenantInput[] | RecurringInvoiceTemplateUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: RecurringInvoiceTemplateCreateOrConnectWithoutTenantInput | RecurringInvoiceTemplateCreateOrConnectWithoutTenantInput[]
    upsert?: RecurringInvoiceTemplateUpsertWithWhereUniqueWithoutTenantInput | RecurringInvoiceTemplateUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: RecurringInvoiceTemplateCreateManyTenantInputEnvelope
    set?: RecurringInvoiceTemplateWhereUniqueInput | RecurringInvoiceTemplateWhereUniqueInput[]
    disconnect?: RecurringInvoiceTemplateWhereUniqueInput | RecurringInvoiceTemplateWhereUniqueInput[]
    delete?: RecurringInvoiceTemplateWhereUniqueInput | RecurringInvoiceTemplateWhereUniqueInput[]
    connect?: RecurringInvoiceTemplateWhereUniqueInput | RecurringInvoiceTemplateWhereUniqueInput[]
    update?: RecurringInvoiceTemplateUpdateWithWhereUniqueWithoutTenantInput | RecurringInvoiceTemplateUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: RecurringInvoiceTemplateUpdateManyWithWhereWithoutTenantInput | RecurringInvoiceTemplateUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: RecurringInvoiceTemplateScalarWhereInput | RecurringInvoiceTemplateScalarWhereInput[]
  }

  export type BadgeUpdateManyWithoutTenantNestedInput = {
    create?: XOR<BadgeCreateWithoutTenantInput, BadgeUncheckedCreateWithoutTenantInput> | BadgeCreateWithoutTenantInput[] | BadgeUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: BadgeCreateOrConnectWithoutTenantInput | BadgeCreateOrConnectWithoutTenantInput[]
    upsert?: BadgeUpsertWithWhereUniqueWithoutTenantInput | BadgeUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: BadgeCreateManyTenantInputEnvelope
    set?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    disconnect?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    delete?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    connect?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    update?: BadgeUpdateWithWhereUniqueWithoutTenantInput | BadgeUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: BadgeUpdateManyWithWhereWithoutTenantInput | BadgeUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: BadgeScalarWhereInput | BadgeScalarWhereInput[]
  }

  export type WorkoutTemplateUpdateManyWithoutTenantNestedInput = {
    create?: XOR<WorkoutTemplateCreateWithoutTenantInput, WorkoutTemplateUncheckedCreateWithoutTenantInput> | WorkoutTemplateCreateWithoutTenantInput[] | WorkoutTemplateUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: WorkoutTemplateCreateOrConnectWithoutTenantInput | WorkoutTemplateCreateOrConnectWithoutTenantInput[]
    upsert?: WorkoutTemplateUpsertWithWhereUniqueWithoutTenantInput | WorkoutTemplateUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: WorkoutTemplateCreateManyTenantInputEnvelope
    set?: WorkoutTemplateWhereUniqueInput | WorkoutTemplateWhereUniqueInput[]
    disconnect?: WorkoutTemplateWhereUniqueInput | WorkoutTemplateWhereUniqueInput[]
    delete?: WorkoutTemplateWhereUniqueInput | WorkoutTemplateWhereUniqueInput[]
    connect?: WorkoutTemplateWhereUniqueInput | WorkoutTemplateWhereUniqueInput[]
    update?: WorkoutTemplateUpdateWithWhereUniqueWithoutTenantInput | WorkoutTemplateUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: WorkoutTemplateUpdateManyWithWhereWithoutTenantInput | WorkoutTemplateUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: WorkoutTemplateScalarWhereInput | WorkoutTemplateScalarWhereInput[]
  }

  export type ScheduleTemplateUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ScheduleTemplateCreateWithoutTenantInput, ScheduleTemplateUncheckedCreateWithoutTenantInput> | ScheduleTemplateCreateWithoutTenantInput[] | ScheduleTemplateUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ScheduleTemplateCreateOrConnectWithoutTenantInput | ScheduleTemplateCreateOrConnectWithoutTenantInput[]
    upsert?: ScheduleTemplateUpsertWithWhereUniqueWithoutTenantInput | ScheduleTemplateUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ScheduleTemplateCreateManyTenantInputEnvelope
    set?: ScheduleTemplateWhereUniqueInput | ScheduleTemplateWhereUniqueInput[]
    disconnect?: ScheduleTemplateWhereUniqueInput | ScheduleTemplateWhereUniqueInput[]
    delete?: ScheduleTemplateWhereUniqueInput | ScheduleTemplateWhereUniqueInput[]
    connect?: ScheduleTemplateWhereUniqueInput | ScheduleTemplateWhereUniqueInput[]
    update?: ScheduleTemplateUpdateWithWhereUniqueWithoutTenantInput | ScheduleTemplateUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ScheduleTemplateUpdateManyWithWhereWithoutTenantInput | ScheduleTemplateUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ScheduleTemplateScalarWhereInput | ScheduleTemplateScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutTenantInput | UserUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutTenantInput | UserUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UserUpdateManyWithWhereWithoutTenantInput | UserUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ClientUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ClientCreateWithoutTenantInput, ClientUncheckedCreateWithoutTenantInput> | ClientCreateWithoutTenantInput[] | ClientUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutTenantInput | ClientCreateOrConnectWithoutTenantInput[]
    upsert?: ClientUpsertWithWhereUniqueWithoutTenantInput | ClientUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ClientCreateManyTenantInputEnvelope
    set?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    disconnect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    delete?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    update?: ClientUpdateWithWhereUniqueWithoutTenantInput | ClientUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ClientUpdateManyWithWhereWithoutTenantInput | ClientUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ClientScalarWhereInput | ClientScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<SessionCreateWithoutTenantInput, SessionUncheckedCreateWithoutTenantInput> | SessionCreateWithoutTenantInput[] | SessionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutTenantInput | SessionCreateOrConnectWithoutTenantInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutTenantInput | SessionUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: SessionCreateManyTenantInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutTenantInput | SessionUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutTenantInput | SessionUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type ClassUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ClassCreateWithoutTenantInput, ClassUncheckedCreateWithoutTenantInput> | ClassCreateWithoutTenantInput[] | ClassUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutTenantInput | ClassCreateOrConnectWithoutTenantInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutTenantInput | ClassUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ClassCreateManyTenantInputEnvelope
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutTenantInput | ClassUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutTenantInput | ClassUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type PackageUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PackageCreateWithoutTenantInput, PackageUncheckedCreateWithoutTenantInput> | PackageCreateWithoutTenantInput[] | PackageUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PackageCreateOrConnectWithoutTenantInput | PackageCreateOrConnectWithoutTenantInput[]
    upsert?: PackageUpsertWithWhereUniqueWithoutTenantInput | PackageUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PackageCreateManyTenantInputEnvelope
    set?: PackageWhereUniqueInput | PackageWhereUniqueInput[]
    disconnect?: PackageWhereUniqueInput | PackageWhereUniqueInput[]
    delete?: PackageWhereUniqueInput | PackageWhereUniqueInput[]
    connect?: PackageWhereUniqueInput | PackageWhereUniqueInput[]
    update?: PackageUpdateWithWhereUniqueWithoutTenantInput | PackageUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PackageUpdateManyWithWhereWithoutTenantInput | PackageUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PackageScalarWhereInput | PackageScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<OrderCreateWithoutTenantInput, OrderUncheckedCreateWithoutTenantInput> | OrderCreateWithoutTenantInput[] | OrderUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutTenantInput | OrderCreateOrConnectWithoutTenantInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutTenantInput | OrderUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: OrderCreateManyTenantInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutTenantInput | OrderUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutTenantInput | OrderUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<InvoiceCreateWithoutTenantInput, InvoiceUncheckedCreateWithoutTenantInput> | InvoiceCreateWithoutTenantInput[] | InvoiceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutTenantInput | InvoiceCreateOrConnectWithoutTenantInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutTenantInput | InvoiceUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: InvoiceCreateManyTenantInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutTenantInput | InvoiceUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutTenantInput | InvoiceUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type AILogUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<AILogCreateWithoutTenantInput, AILogUncheckedCreateWithoutTenantInput> | AILogCreateWithoutTenantInput[] | AILogUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AILogCreateOrConnectWithoutTenantInput | AILogCreateOrConnectWithoutTenantInput[]
    upsert?: AILogUpsertWithWhereUniqueWithoutTenantInput | AILogUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: AILogCreateManyTenantInputEnvelope
    set?: AILogWhereUniqueInput | AILogWhereUniqueInput[]
    disconnect?: AILogWhereUniqueInput | AILogWhereUniqueInput[]
    delete?: AILogWhereUniqueInput | AILogWhereUniqueInput[]
    connect?: AILogWhereUniqueInput | AILogWhereUniqueInput[]
    update?: AILogUpdateWithWhereUniqueWithoutTenantInput | AILogUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: AILogUpdateManyWithWhereWithoutTenantInput | AILogUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: AILogScalarWhereInput | AILogScalarWhereInput[]
  }

  export type BankAccountUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<BankAccountCreateWithoutTenantInput, BankAccountUncheckedCreateWithoutTenantInput> | BankAccountCreateWithoutTenantInput[] | BankAccountUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: BankAccountCreateOrConnectWithoutTenantInput | BankAccountCreateOrConnectWithoutTenantInput[]
    upsert?: BankAccountUpsertWithWhereUniqueWithoutTenantInput | BankAccountUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: BankAccountCreateManyTenantInputEnvelope
    set?: BankAccountWhereUniqueInput | BankAccountWhereUniqueInput[]
    disconnect?: BankAccountWhereUniqueInput | BankAccountWhereUniqueInput[]
    delete?: BankAccountWhereUniqueInput | BankAccountWhereUniqueInput[]
    connect?: BankAccountWhereUniqueInput | BankAccountWhereUniqueInput[]
    update?: BankAccountUpdateWithWhereUniqueWithoutTenantInput | BankAccountUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: BankAccountUpdateManyWithWhereWithoutTenantInput | BankAccountUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: BankAccountScalarWhereInput | BankAccountScalarWhereInput[]
  }

  export type BankTransactionUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<BankTransactionCreateWithoutTenantInput, BankTransactionUncheckedCreateWithoutTenantInput> | BankTransactionCreateWithoutTenantInput[] | BankTransactionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: BankTransactionCreateOrConnectWithoutTenantInput | BankTransactionCreateOrConnectWithoutTenantInput[]
    upsert?: BankTransactionUpsertWithWhereUniqueWithoutTenantInput | BankTransactionUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: BankTransactionCreateManyTenantInputEnvelope
    set?: BankTransactionWhereUniqueInput | BankTransactionWhereUniqueInput[]
    disconnect?: BankTransactionWhereUniqueInput | BankTransactionWhereUniqueInput[]
    delete?: BankTransactionWhereUniqueInput | BankTransactionWhereUniqueInput[]
    connect?: BankTransactionWhereUniqueInput | BankTransactionWhereUniqueInput[]
    update?: BankTransactionUpdateWithWhereUniqueWithoutTenantInput | BankTransactionUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: BankTransactionUpdateManyWithWhereWithoutTenantInput | BankTransactionUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: BankTransactionScalarWhereInput | BankTransactionScalarWhereInput[]
  }

  export type InvoicePaymentUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<InvoicePaymentCreateWithoutTenantInput, InvoicePaymentUncheckedCreateWithoutTenantInput> | InvoicePaymentCreateWithoutTenantInput[] | InvoicePaymentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InvoicePaymentCreateOrConnectWithoutTenantInput | InvoicePaymentCreateOrConnectWithoutTenantInput[]
    upsert?: InvoicePaymentUpsertWithWhereUniqueWithoutTenantInput | InvoicePaymentUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: InvoicePaymentCreateManyTenantInputEnvelope
    set?: InvoicePaymentWhereUniqueInput | InvoicePaymentWhereUniqueInput[]
    disconnect?: InvoicePaymentWhereUniqueInput | InvoicePaymentWhereUniqueInput[]
    delete?: InvoicePaymentWhereUniqueInput | InvoicePaymentWhereUniqueInput[]
    connect?: InvoicePaymentWhereUniqueInput | InvoicePaymentWhereUniqueInput[]
    update?: InvoicePaymentUpdateWithWhereUniqueWithoutTenantInput | InvoicePaymentUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: InvoicePaymentUpdateManyWithWhereWithoutTenantInput | InvoicePaymentUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: InvoicePaymentScalarWhereInput | InvoicePaymentScalarWhereInput[]
  }

  export type PaymentGatewayConfigUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PaymentGatewayConfigCreateWithoutTenantInput, PaymentGatewayConfigUncheckedCreateWithoutTenantInput> | PaymentGatewayConfigCreateWithoutTenantInput[] | PaymentGatewayConfigUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PaymentGatewayConfigCreateOrConnectWithoutTenantInput | PaymentGatewayConfigCreateOrConnectWithoutTenantInput[]
    upsert?: PaymentGatewayConfigUpsertWithWhereUniqueWithoutTenantInput | PaymentGatewayConfigUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PaymentGatewayConfigCreateManyTenantInputEnvelope
    set?: PaymentGatewayConfigWhereUniqueInput | PaymentGatewayConfigWhereUniqueInput[]
    disconnect?: PaymentGatewayConfigWhereUniqueInput | PaymentGatewayConfigWhereUniqueInput[]
    delete?: PaymentGatewayConfigWhereUniqueInput | PaymentGatewayConfigWhereUniqueInput[]
    connect?: PaymentGatewayConfigWhereUniqueInput | PaymentGatewayConfigWhereUniqueInput[]
    update?: PaymentGatewayConfigUpdateWithWhereUniqueWithoutTenantInput | PaymentGatewayConfigUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PaymentGatewayConfigUpdateManyWithWhereWithoutTenantInput | PaymentGatewayConfigUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PaymentGatewayConfigScalarWhereInput | PaymentGatewayConfigScalarWhereInput[]
  }

  export type CryptoWalletUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CryptoWalletCreateWithoutTenantInput, CryptoWalletUncheckedCreateWithoutTenantInput> | CryptoWalletCreateWithoutTenantInput[] | CryptoWalletUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CryptoWalletCreateOrConnectWithoutTenantInput | CryptoWalletCreateOrConnectWithoutTenantInput[]
    upsert?: CryptoWalletUpsertWithWhereUniqueWithoutTenantInput | CryptoWalletUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CryptoWalletCreateManyTenantInputEnvelope
    set?: CryptoWalletWhereUniqueInput | CryptoWalletWhereUniqueInput[]
    disconnect?: CryptoWalletWhereUniqueInput | CryptoWalletWhereUniqueInput[]
    delete?: CryptoWalletWhereUniqueInput | CryptoWalletWhereUniqueInput[]
    connect?: CryptoWalletWhereUniqueInput | CryptoWalletWhereUniqueInput[]
    update?: CryptoWalletUpdateWithWhereUniqueWithoutTenantInput | CryptoWalletUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CryptoWalletUpdateManyWithWhereWithoutTenantInput | CryptoWalletUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CryptoWalletScalarWhereInput | CryptoWalletScalarWhereInput[]
  }

  export type ExpenseCategoryUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ExpenseCategoryCreateWithoutTenantInput, ExpenseCategoryUncheckedCreateWithoutTenantInput> | ExpenseCategoryCreateWithoutTenantInput[] | ExpenseCategoryUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ExpenseCategoryCreateOrConnectWithoutTenantInput | ExpenseCategoryCreateOrConnectWithoutTenantInput[]
    upsert?: ExpenseCategoryUpsertWithWhereUniqueWithoutTenantInput | ExpenseCategoryUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ExpenseCategoryCreateManyTenantInputEnvelope
    set?: ExpenseCategoryWhereUniqueInput | ExpenseCategoryWhereUniqueInput[]
    disconnect?: ExpenseCategoryWhereUniqueInput | ExpenseCategoryWhereUniqueInput[]
    delete?: ExpenseCategoryWhereUniqueInput | ExpenseCategoryWhereUniqueInput[]
    connect?: ExpenseCategoryWhereUniqueInput | ExpenseCategoryWhereUniqueInput[]
    update?: ExpenseCategoryUpdateWithWhereUniqueWithoutTenantInput | ExpenseCategoryUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ExpenseCategoryUpdateManyWithWhereWithoutTenantInput | ExpenseCategoryUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ExpenseCategoryScalarWhereInput | ExpenseCategoryScalarWhereInput[]
  }

  export type ExpenseUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ExpenseCreateWithoutTenantInput, ExpenseUncheckedCreateWithoutTenantInput> | ExpenseCreateWithoutTenantInput[] | ExpenseUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutTenantInput | ExpenseCreateOrConnectWithoutTenantInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutTenantInput | ExpenseUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ExpenseCreateManyTenantInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutTenantInput | ExpenseUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutTenantInput | ExpenseUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type RecurringInvoiceTemplateUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<RecurringInvoiceTemplateCreateWithoutTenantInput, RecurringInvoiceTemplateUncheckedCreateWithoutTenantInput> | RecurringInvoiceTemplateCreateWithoutTenantInput[] | RecurringInvoiceTemplateUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: RecurringInvoiceTemplateCreateOrConnectWithoutTenantInput | RecurringInvoiceTemplateCreateOrConnectWithoutTenantInput[]
    upsert?: RecurringInvoiceTemplateUpsertWithWhereUniqueWithoutTenantInput | RecurringInvoiceTemplateUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: RecurringInvoiceTemplateCreateManyTenantInputEnvelope
    set?: RecurringInvoiceTemplateWhereUniqueInput | RecurringInvoiceTemplateWhereUniqueInput[]
    disconnect?: RecurringInvoiceTemplateWhereUniqueInput | RecurringInvoiceTemplateWhereUniqueInput[]
    delete?: RecurringInvoiceTemplateWhereUniqueInput | RecurringInvoiceTemplateWhereUniqueInput[]
    connect?: RecurringInvoiceTemplateWhereUniqueInput | RecurringInvoiceTemplateWhereUniqueInput[]
    update?: RecurringInvoiceTemplateUpdateWithWhereUniqueWithoutTenantInput | RecurringInvoiceTemplateUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: RecurringInvoiceTemplateUpdateManyWithWhereWithoutTenantInput | RecurringInvoiceTemplateUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: RecurringInvoiceTemplateScalarWhereInput | RecurringInvoiceTemplateScalarWhereInput[]
  }

  export type BadgeUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<BadgeCreateWithoutTenantInput, BadgeUncheckedCreateWithoutTenantInput> | BadgeCreateWithoutTenantInput[] | BadgeUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: BadgeCreateOrConnectWithoutTenantInput | BadgeCreateOrConnectWithoutTenantInput[]
    upsert?: BadgeUpsertWithWhereUniqueWithoutTenantInput | BadgeUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: BadgeCreateManyTenantInputEnvelope
    set?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    disconnect?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    delete?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    connect?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    update?: BadgeUpdateWithWhereUniqueWithoutTenantInput | BadgeUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: BadgeUpdateManyWithWhereWithoutTenantInput | BadgeUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: BadgeScalarWhereInput | BadgeScalarWhereInput[]
  }

  export type WorkoutTemplateUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<WorkoutTemplateCreateWithoutTenantInput, WorkoutTemplateUncheckedCreateWithoutTenantInput> | WorkoutTemplateCreateWithoutTenantInput[] | WorkoutTemplateUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: WorkoutTemplateCreateOrConnectWithoutTenantInput | WorkoutTemplateCreateOrConnectWithoutTenantInput[]
    upsert?: WorkoutTemplateUpsertWithWhereUniqueWithoutTenantInput | WorkoutTemplateUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: WorkoutTemplateCreateManyTenantInputEnvelope
    set?: WorkoutTemplateWhereUniqueInput | WorkoutTemplateWhereUniqueInput[]
    disconnect?: WorkoutTemplateWhereUniqueInput | WorkoutTemplateWhereUniqueInput[]
    delete?: WorkoutTemplateWhereUniqueInput | WorkoutTemplateWhereUniqueInput[]
    connect?: WorkoutTemplateWhereUniqueInput | WorkoutTemplateWhereUniqueInput[]
    update?: WorkoutTemplateUpdateWithWhereUniqueWithoutTenantInput | WorkoutTemplateUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: WorkoutTemplateUpdateManyWithWhereWithoutTenantInput | WorkoutTemplateUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: WorkoutTemplateScalarWhereInput | WorkoutTemplateScalarWhereInput[]
  }

  export type ScheduleTemplateUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ScheduleTemplateCreateWithoutTenantInput, ScheduleTemplateUncheckedCreateWithoutTenantInput> | ScheduleTemplateCreateWithoutTenantInput[] | ScheduleTemplateUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ScheduleTemplateCreateOrConnectWithoutTenantInput | ScheduleTemplateCreateOrConnectWithoutTenantInput[]
    upsert?: ScheduleTemplateUpsertWithWhereUniqueWithoutTenantInput | ScheduleTemplateUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ScheduleTemplateCreateManyTenantInputEnvelope
    set?: ScheduleTemplateWhereUniqueInput | ScheduleTemplateWhereUniqueInput[]
    disconnect?: ScheduleTemplateWhereUniqueInput | ScheduleTemplateWhereUniqueInput[]
    delete?: ScheduleTemplateWhereUniqueInput | ScheduleTemplateWhereUniqueInput[]
    connect?: ScheduleTemplateWhereUniqueInput | ScheduleTemplateWhereUniqueInput[]
    update?: ScheduleTemplateUpdateWithWhereUniqueWithoutTenantInput | ScheduleTemplateUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ScheduleTemplateUpdateManyWithWhereWithoutTenantInput | ScheduleTemplateUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ScheduleTemplateScalarWhereInput | ScheduleTemplateScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutUsersInput = {
    create?: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutUsersInput
    connect?: TenantWhereUniqueInput
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type UserSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type UserSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type TenantUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutUsersInput
    upsert?: TenantUpsertWithoutUsersInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutUsersInput, TenantUpdateWithoutUsersInput>, TenantUncheckedUpdateWithoutUsersInput>
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type UserSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    upsert?: UserSessionUpsertWithWhereUniqueWithoutUserInput | UserSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    set?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    disconnect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    delete?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    update?: UserSessionUpdateWithWhereUniqueWithoutUserInput | UserSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSessionUpdateManyWithWhereWithoutUserInput | UserSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type UserSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    upsert?: UserSessionUpsertWithWhereUniqueWithoutUserInput | UserSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    set?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    disconnect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    delete?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    update?: UserSessionUpdateWithWhereUniqueWithoutUserInput | UserSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSessionUpdateManyWithWhereWithoutUserInput | UserSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type ClientCreategoalsInput = {
    set: string[]
  }

  export type ClientCreatetagsInput = {
    set: string[]
  }

  export type TenantCreateNestedOneWithoutClientsInput = {
    create?: XOR<TenantCreateWithoutClientsInput, TenantUncheckedCreateWithoutClientsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutClientsInput
    connect?: TenantWhereUniqueInput
  }

  export type SessionCreateNestedManyWithoutClientInput = {
    create?: XOR<SessionCreateWithoutClientInput, SessionUncheckedCreateWithoutClientInput> | SessionCreateWithoutClientInput[] | SessionUncheckedCreateWithoutClientInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutClientInput | SessionCreateOrConnectWithoutClientInput[]
    createMany?: SessionCreateManyClientInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutClientInput = {
    create?: XOR<OrderCreateWithoutClientInput, OrderUncheckedCreateWithoutClientInput> | OrderCreateWithoutClientInput[] | OrderUncheckedCreateWithoutClientInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutClientInput | OrderCreateOrConnectWithoutClientInput[]
    createMany?: OrderCreateManyClientInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutClientInput = {
    create?: XOR<InvoiceCreateWithoutClientInput, InvoiceUncheckedCreateWithoutClientInput> | InvoiceCreateWithoutClientInput[] | InvoiceUncheckedCreateWithoutClientInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutClientInput | InvoiceCreateOrConnectWithoutClientInput[]
    createMany?: InvoiceCreateManyClientInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type ClientMeasurementCreateNestedManyWithoutClientInput = {
    create?: XOR<ClientMeasurementCreateWithoutClientInput, ClientMeasurementUncheckedCreateWithoutClientInput> | ClientMeasurementCreateWithoutClientInput[] | ClientMeasurementUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientMeasurementCreateOrConnectWithoutClientInput | ClientMeasurementCreateOrConnectWithoutClientInput[]
    createMany?: ClientMeasurementCreateManyClientInputEnvelope
    connect?: ClientMeasurementWhereUniqueInput | ClientMeasurementWhereUniqueInput[]
  }

  export type ProgressPhotoCreateNestedManyWithoutClientInput = {
    create?: XOR<ProgressPhotoCreateWithoutClientInput, ProgressPhotoUncheckedCreateWithoutClientInput> | ProgressPhotoCreateWithoutClientInput[] | ProgressPhotoUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ProgressPhotoCreateOrConnectWithoutClientInput | ProgressPhotoCreateOrConnectWithoutClientInput[]
    createMany?: ProgressPhotoCreateManyClientInputEnvelope
    connect?: ProgressPhotoWhereUniqueInput | ProgressPhotoWhereUniqueInput[]
  }

  export type ClientBadgeCreateNestedManyWithoutClientInput = {
    create?: XOR<ClientBadgeCreateWithoutClientInput, ClientBadgeUncheckedCreateWithoutClientInput> | ClientBadgeCreateWithoutClientInput[] | ClientBadgeUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientBadgeCreateOrConnectWithoutClientInput | ClientBadgeCreateOrConnectWithoutClientInput[]
    createMany?: ClientBadgeCreateManyClientInputEnvelope
    connect?: ClientBadgeWhereUniqueInput | ClientBadgeWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<SessionCreateWithoutClientInput, SessionUncheckedCreateWithoutClientInput> | SessionCreateWithoutClientInput[] | SessionUncheckedCreateWithoutClientInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutClientInput | SessionCreateOrConnectWithoutClientInput[]
    createMany?: SessionCreateManyClientInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<OrderCreateWithoutClientInput, OrderUncheckedCreateWithoutClientInput> | OrderCreateWithoutClientInput[] | OrderUncheckedCreateWithoutClientInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutClientInput | OrderCreateOrConnectWithoutClientInput[]
    createMany?: OrderCreateManyClientInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<InvoiceCreateWithoutClientInput, InvoiceUncheckedCreateWithoutClientInput> | InvoiceCreateWithoutClientInput[] | InvoiceUncheckedCreateWithoutClientInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutClientInput | InvoiceCreateOrConnectWithoutClientInput[]
    createMany?: InvoiceCreateManyClientInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type ClientMeasurementUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<ClientMeasurementCreateWithoutClientInput, ClientMeasurementUncheckedCreateWithoutClientInput> | ClientMeasurementCreateWithoutClientInput[] | ClientMeasurementUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientMeasurementCreateOrConnectWithoutClientInput | ClientMeasurementCreateOrConnectWithoutClientInput[]
    createMany?: ClientMeasurementCreateManyClientInputEnvelope
    connect?: ClientMeasurementWhereUniqueInput | ClientMeasurementWhereUniqueInput[]
  }

  export type ProgressPhotoUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<ProgressPhotoCreateWithoutClientInput, ProgressPhotoUncheckedCreateWithoutClientInput> | ProgressPhotoCreateWithoutClientInput[] | ProgressPhotoUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ProgressPhotoCreateOrConnectWithoutClientInput | ProgressPhotoCreateOrConnectWithoutClientInput[]
    createMany?: ProgressPhotoCreateManyClientInputEnvelope
    connect?: ProgressPhotoWhereUniqueInput | ProgressPhotoWhereUniqueInput[]
  }

  export type ClientBadgeUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<ClientBadgeCreateWithoutClientInput, ClientBadgeUncheckedCreateWithoutClientInput> | ClientBadgeCreateWithoutClientInput[] | ClientBadgeUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientBadgeCreateOrConnectWithoutClientInput | ClientBadgeCreateOrConnectWithoutClientInput[]
    createMany?: ClientBadgeCreateManyClientInputEnvelope
    connect?: ClientBadgeWhereUniqueInput | ClientBadgeWhereUniqueInput[]
  }

  export type ClientUpdategoalsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ClientUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TenantUpdateOneRequiredWithoutClientsNestedInput = {
    create?: XOR<TenantCreateWithoutClientsInput, TenantUncheckedCreateWithoutClientsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutClientsInput
    upsert?: TenantUpsertWithoutClientsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutClientsInput, TenantUpdateWithoutClientsInput>, TenantUncheckedUpdateWithoutClientsInput>
  }

  export type SessionUpdateManyWithoutClientNestedInput = {
    create?: XOR<SessionCreateWithoutClientInput, SessionUncheckedCreateWithoutClientInput> | SessionCreateWithoutClientInput[] | SessionUncheckedCreateWithoutClientInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutClientInput | SessionCreateOrConnectWithoutClientInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutClientInput | SessionUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: SessionCreateManyClientInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutClientInput | SessionUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutClientInput | SessionUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutClientNestedInput = {
    create?: XOR<OrderCreateWithoutClientInput, OrderUncheckedCreateWithoutClientInput> | OrderCreateWithoutClientInput[] | OrderUncheckedCreateWithoutClientInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutClientInput | OrderCreateOrConnectWithoutClientInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutClientInput | OrderUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: OrderCreateManyClientInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutClientInput | OrderUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutClientInput | OrderUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutClientNestedInput = {
    create?: XOR<InvoiceCreateWithoutClientInput, InvoiceUncheckedCreateWithoutClientInput> | InvoiceCreateWithoutClientInput[] | InvoiceUncheckedCreateWithoutClientInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutClientInput | InvoiceCreateOrConnectWithoutClientInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutClientInput | InvoiceUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: InvoiceCreateManyClientInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutClientInput | InvoiceUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutClientInput | InvoiceUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type ClientMeasurementUpdateManyWithoutClientNestedInput = {
    create?: XOR<ClientMeasurementCreateWithoutClientInput, ClientMeasurementUncheckedCreateWithoutClientInput> | ClientMeasurementCreateWithoutClientInput[] | ClientMeasurementUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientMeasurementCreateOrConnectWithoutClientInput | ClientMeasurementCreateOrConnectWithoutClientInput[]
    upsert?: ClientMeasurementUpsertWithWhereUniqueWithoutClientInput | ClientMeasurementUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ClientMeasurementCreateManyClientInputEnvelope
    set?: ClientMeasurementWhereUniqueInput | ClientMeasurementWhereUniqueInput[]
    disconnect?: ClientMeasurementWhereUniqueInput | ClientMeasurementWhereUniqueInput[]
    delete?: ClientMeasurementWhereUniqueInput | ClientMeasurementWhereUniqueInput[]
    connect?: ClientMeasurementWhereUniqueInput | ClientMeasurementWhereUniqueInput[]
    update?: ClientMeasurementUpdateWithWhereUniqueWithoutClientInput | ClientMeasurementUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ClientMeasurementUpdateManyWithWhereWithoutClientInput | ClientMeasurementUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ClientMeasurementScalarWhereInput | ClientMeasurementScalarWhereInput[]
  }

  export type ProgressPhotoUpdateManyWithoutClientNestedInput = {
    create?: XOR<ProgressPhotoCreateWithoutClientInput, ProgressPhotoUncheckedCreateWithoutClientInput> | ProgressPhotoCreateWithoutClientInput[] | ProgressPhotoUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ProgressPhotoCreateOrConnectWithoutClientInput | ProgressPhotoCreateOrConnectWithoutClientInput[]
    upsert?: ProgressPhotoUpsertWithWhereUniqueWithoutClientInput | ProgressPhotoUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ProgressPhotoCreateManyClientInputEnvelope
    set?: ProgressPhotoWhereUniqueInput | ProgressPhotoWhereUniqueInput[]
    disconnect?: ProgressPhotoWhereUniqueInput | ProgressPhotoWhereUniqueInput[]
    delete?: ProgressPhotoWhereUniqueInput | ProgressPhotoWhereUniqueInput[]
    connect?: ProgressPhotoWhereUniqueInput | ProgressPhotoWhereUniqueInput[]
    update?: ProgressPhotoUpdateWithWhereUniqueWithoutClientInput | ProgressPhotoUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ProgressPhotoUpdateManyWithWhereWithoutClientInput | ProgressPhotoUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ProgressPhotoScalarWhereInput | ProgressPhotoScalarWhereInput[]
  }

  export type ClientBadgeUpdateManyWithoutClientNestedInput = {
    create?: XOR<ClientBadgeCreateWithoutClientInput, ClientBadgeUncheckedCreateWithoutClientInput> | ClientBadgeCreateWithoutClientInput[] | ClientBadgeUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientBadgeCreateOrConnectWithoutClientInput | ClientBadgeCreateOrConnectWithoutClientInput[]
    upsert?: ClientBadgeUpsertWithWhereUniqueWithoutClientInput | ClientBadgeUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ClientBadgeCreateManyClientInputEnvelope
    set?: ClientBadgeWhereUniqueInput | ClientBadgeWhereUniqueInput[]
    disconnect?: ClientBadgeWhereUniqueInput | ClientBadgeWhereUniqueInput[]
    delete?: ClientBadgeWhereUniqueInput | ClientBadgeWhereUniqueInput[]
    connect?: ClientBadgeWhereUniqueInput | ClientBadgeWhereUniqueInput[]
    update?: ClientBadgeUpdateWithWhereUniqueWithoutClientInput | ClientBadgeUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ClientBadgeUpdateManyWithWhereWithoutClientInput | ClientBadgeUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ClientBadgeScalarWhereInput | ClientBadgeScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<SessionCreateWithoutClientInput, SessionUncheckedCreateWithoutClientInput> | SessionCreateWithoutClientInput[] | SessionUncheckedCreateWithoutClientInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutClientInput | SessionCreateOrConnectWithoutClientInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutClientInput | SessionUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: SessionCreateManyClientInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutClientInput | SessionUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutClientInput | SessionUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<OrderCreateWithoutClientInput, OrderUncheckedCreateWithoutClientInput> | OrderCreateWithoutClientInput[] | OrderUncheckedCreateWithoutClientInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutClientInput | OrderCreateOrConnectWithoutClientInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutClientInput | OrderUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: OrderCreateManyClientInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutClientInput | OrderUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutClientInput | OrderUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<InvoiceCreateWithoutClientInput, InvoiceUncheckedCreateWithoutClientInput> | InvoiceCreateWithoutClientInput[] | InvoiceUncheckedCreateWithoutClientInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutClientInput | InvoiceCreateOrConnectWithoutClientInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutClientInput | InvoiceUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: InvoiceCreateManyClientInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutClientInput | InvoiceUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutClientInput | InvoiceUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type ClientMeasurementUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<ClientMeasurementCreateWithoutClientInput, ClientMeasurementUncheckedCreateWithoutClientInput> | ClientMeasurementCreateWithoutClientInput[] | ClientMeasurementUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientMeasurementCreateOrConnectWithoutClientInput | ClientMeasurementCreateOrConnectWithoutClientInput[]
    upsert?: ClientMeasurementUpsertWithWhereUniqueWithoutClientInput | ClientMeasurementUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ClientMeasurementCreateManyClientInputEnvelope
    set?: ClientMeasurementWhereUniqueInput | ClientMeasurementWhereUniqueInput[]
    disconnect?: ClientMeasurementWhereUniqueInput | ClientMeasurementWhereUniqueInput[]
    delete?: ClientMeasurementWhereUniqueInput | ClientMeasurementWhereUniqueInput[]
    connect?: ClientMeasurementWhereUniqueInput | ClientMeasurementWhereUniqueInput[]
    update?: ClientMeasurementUpdateWithWhereUniqueWithoutClientInput | ClientMeasurementUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ClientMeasurementUpdateManyWithWhereWithoutClientInput | ClientMeasurementUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ClientMeasurementScalarWhereInput | ClientMeasurementScalarWhereInput[]
  }

  export type ProgressPhotoUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<ProgressPhotoCreateWithoutClientInput, ProgressPhotoUncheckedCreateWithoutClientInput> | ProgressPhotoCreateWithoutClientInput[] | ProgressPhotoUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ProgressPhotoCreateOrConnectWithoutClientInput | ProgressPhotoCreateOrConnectWithoutClientInput[]
    upsert?: ProgressPhotoUpsertWithWhereUniqueWithoutClientInput | ProgressPhotoUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ProgressPhotoCreateManyClientInputEnvelope
    set?: ProgressPhotoWhereUniqueInput | ProgressPhotoWhereUniqueInput[]
    disconnect?: ProgressPhotoWhereUniqueInput | ProgressPhotoWhereUniqueInput[]
    delete?: ProgressPhotoWhereUniqueInput | ProgressPhotoWhereUniqueInput[]
    connect?: ProgressPhotoWhereUniqueInput | ProgressPhotoWhereUniqueInput[]
    update?: ProgressPhotoUpdateWithWhereUniqueWithoutClientInput | ProgressPhotoUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ProgressPhotoUpdateManyWithWhereWithoutClientInput | ProgressPhotoUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ProgressPhotoScalarWhereInput | ProgressPhotoScalarWhereInput[]
  }

  export type ClientBadgeUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<ClientBadgeCreateWithoutClientInput, ClientBadgeUncheckedCreateWithoutClientInput> | ClientBadgeCreateWithoutClientInput[] | ClientBadgeUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientBadgeCreateOrConnectWithoutClientInput | ClientBadgeCreateOrConnectWithoutClientInput[]
    upsert?: ClientBadgeUpsertWithWhereUniqueWithoutClientInput | ClientBadgeUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ClientBadgeCreateManyClientInputEnvelope
    set?: ClientBadgeWhereUniqueInput | ClientBadgeWhereUniqueInput[]
    disconnect?: ClientBadgeWhereUniqueInput | ClientBadgeWhereUniqueInput[]
    delete?: ClientBadgeWhereUniqueInput | ClientBadgeWhereUniqueInput[]
    connect?: ClientBadgeWhereUniqueInput | ClientBadgeWhereUniqueInput[]
    update?: ClientBadgeUpdateWithWhereUniqueWithoutClientInput | ClientBadgeUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ClientBadgeUpdateManyWithWhereWithoutClientInput | ClientBadgeUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ClientBadgeScalarWhereInput | ClientBadgeScalarWhereInput[]
  }

  export type ClientCreateNestedOneWithoutMeasurementsInput = {
    create?: XOR<ClientCreateWithoutMeasurementsInput, ClientUncheckedCreateWithoutMeasurementsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutMeasurementsInput
    connect?: ClientWhereUniqueInput
  }

  export type ClientUpdateOneRequiredWithoutMeasurementsNestedInput = {
    create?: XOR<ClientCreateWithoutMeasurementsInput, ClientUncheckedCreateWithoutMeasurementsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutMeasurementsInput
    upsert?: ClientUpsertWithoutMeasurementsInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutMeasurementsInput, ClientUpdateWithoutMeasurementsInput>, ClientUncheckedUpdateWithoutMeasurementsInput>
  }

  export type ClientCreateNestedOneWithoutProgressPhotosInput = {
    create?: XOR<ClientCreateWithoutProgressPhotosInput, ClientUncheckedCreateWithoutProgressPhotosInput>
    connectOrCreate?: ClientCreateOrConnectWithoutProgressPhotosInput
    connect?: ClientWhereUniqueInput
  }

  export type ClientUpdateOneRequiredWithoutProgressPhotosNestedInput = {
    create?: XOR<ClientCreateWithoutProgressPhotosInput, ClientUncheckedCreateWithoutProgressPhotosInput>
    connectOrCreate?: ClientCreateOrConnectWithoutProgressPhotosInput
    upsert?: ClientUpsertWithoutProgressPhotosInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutProgressPhotosInput, ClientUpdateWithoutProgressPhotosInput>, ClientUncheckedUpdateWithoutProgressPhotosInput>
  }

  export type SessionCreateexercisesLoggedInput = {
    set: InputJsonValue[]
  }

  export type SessionCreatemuscleGroupsInput = {
    set: string[]
  }

  export type TenantCreateNestedOneWithoutSessionsInput = {
    create?: XOR<TenantCreateWithoutSessionsInput, TenantUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutSessionsInput
    connect?: TenantWhereUniqueInput
  }

  export type ClientCreateNestedOneWithoutSessionsInput = {
    create?: XOR<ClientCreateWithoutSessionsInput, ClientUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutSessionsInput
    connect?: ClientWhereUniqueInput
  }

  export type SessionUpdateexercisesLoggedInput = {
    set?: InputJsonValue[]
    push?: InputJsonValue | InputJsonValue[]
  }

  export type SessionUpdatemuscleGroupsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type TenantUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<TenantCreateWithoutSessionsInput, TenantUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutSessionsInput
    upsert?: TenantUpsertWithoutSessionsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutSessionsInput, TenantUpdateWithoutSessionsInput>, TenantUncheckedUpdateWithoutSessionsInput>
  }

  export type ClientUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<ClientCreateWithoutSessionsInput, ClientUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutSessionsInput
    upsert?: ClientUpsertWithoutSessionsInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutSessionsInput, ClientUpdateWithoutSessionsInput>, ClientUncheckedUpdateWithoutSessionsInput>
  }

  export type TenantCreateNestedOneWithoutClassesInput = {
    create?: XOR<TenantCreateWithoutClassesInput, TenantUncheckedCreateWithoutClassesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutClassesInput
    connect?: TenantWhereUniqueInput
  }

  export type ClassBookingCreateNestedManyWithoutClassInput = {
    create?: XOR<ClassBookingCreateWithoutClassInput, ClassBookingUncheckedCreateWithoutClassInput> | ClassBookingCreateWithoutClassInput[] | ClassBookingUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ClassBookingCreateOrConnectWithoutClassInput | ClassBookingCreateOrConnectWithoutClassInput[]
    createMany?: ClassBookingCreateManyClassInputEnvelope
    connect?: ClassBookingWhereUniqueInput | ClassBookingWhereUniqueInput[]
  }

  export type ClassBookingUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<ClassBookingCreateWithoutClassInput, ClassBookingUncheckedCreateWithoutClassInput> | ClassBookingCreateWithoutClassInput[] | ClassBookingUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ClassBookingCreateOrConnectWithoutClassInput | ClassBookingCreateOrConnectWithoutClassInput[]
    createMany?: ClassBookingCreateManyClassInputEnvelope
    connect?: ClassBookingWhereUniqueInput | ClassBookingWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TenantUpdateOneRequiredWithoutClassesNestedInput = {
    create?: XOR<TenantCreateWithoutClassesInput, TenantUncheckedCreateWithoutClassesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutClassesInput
    upsert?: TenantUpsertWithoutClassesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutClassesInput, TenantUpdateWithoutClassesInput>, TenantUncheckedUpdateWithoutClassesInput>
  }

  export type ClassBookingUpdateManyWithoutClassNestedInput = {
    create?: XOR<ClassBookingCreateWithoutClassInput, ClassBookingUncheckedCreateWithoutClassInput> | ClassBookingCreateWithoutClassInput[] | ClassBookingUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ClassBookingCreateOrConnectWithoutClassInput | ClassBookingCreateOrConnectWithoutClassInput[]
    upsert?: ClassBookingUpsertWithWhereUniqueWithoutClassInput | ClassBookingUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: ClassBookingCreateManyClassInputEnvelope
    set?: ClassBookingWhereUniqueInput | ClassBookingWhereUniqueInput[]
    disconnect?: ClassBookingWhereUniqueInput | ClassBookingWhereUniqueInput[]
    delete?: ClassBookingWhereUniqueInput | ClassBookingWhereUniqueInput[]
    connect?: ClassBookingWhereUniqueInput | ClassBookingWhereUniqueInput[]
    update?: ClassBookingUpdateWithWhereUniqueWithoutClassInput | ClassBookingUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: ClassBookingUpdateManyWithWhereWithoutClassInput | ClassBookingUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: ClassBookingScalarWhereInput | ClassBookingScalarWhereInput[]
  }

  export type ClassBookingUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<ClassBookingCreateWithoutClassInput, ClassBookingUncheckedCreateWithoutClassInput> | ClassBookingCreateWithoutClassInput[] | ClassBookingUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ClassBookingCreateOrConnectWithoutClassInput | ClassBookingCreateOrConnectWithoutClassInput[]
    upsert?: ClassBookingUpsertWithWhereUniqueWithoutClassInput | ClassBookingUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: ClassBookingCreateManyClassInputEnvelope
    set?: ClassBookingWhereUniqueInput | ClassBookingWhereUniqueInput[]
    disconnect?: ClassBookingWhereUniqueInput | ClassBookingWhereUniqueInput[]
    delete?: ClassBookingWhereUniqueInput | ClassBookingWhereUniqueInput[]
    connect?: ClassBookingWhereUniqueInput | ClassBookingWhereUniqueInput[]
    update?: ClassBookingUpdateWithWhereUniqueWithoutClassInput | ClassBookingUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: ClassBookingUpdateManyWithWhereWithoutClassInput | ClassBookingUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: ClassBookingScalarWhereInput | ClassBookingScalarWhereInput[]
  }

  export type ClassCreateNestedOneWithoutBookingsInput = {
    create?: XOR<ClassCreateWithoutBookingsInput, ClassUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutBookingsInput
    connect?: ClassWhereUniqueInput
  }

  export type ClassUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<ClassCreateWithoutBookingsInput, ClassUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutBookingsInput
    upsert?: ClassUpsertWithoutBookingsInput
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutBookingsInput, ClassUpdateWithoutBookingsInput>, ClassUncheckedUpdateWithoutBookingsInput>
  }

  export type PackageCreatefeaturesInput = {
    set: string[]
  }

  export type TenantCreateNestedOneWithoutPackagesInput = {
    create?: XOR<TenantCreateWithoutPackagesInput, TenantUncheckedCreateWithoutPackagesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPackagesInput
    connect?: TenantWhereUniqueInput
  }

  export type PackageUpdatefeaturesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TenantUpdateOneRequiredWithoutPackagesNestedInput = {
    create?: XOR<TenantCreateWithoutPackagesInput, TenantUncheckedCreateWithoutPackagesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPackagesInput
    upsert?: TenantUpsertWithoutPackagesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutPackagesInput, TenantUpdateWithoutPackagesInput>, TenantUncheckedUpdateWithoutPackagesInput>
  }

  export type OrderCreateitemsInput = {
    set: InputJsonValue[]
  }

  export type TenantCreateNestedOneWithoutOrdersInput = {
    create?: XOR<TenantCreateWithoutOrdersInput, TenantUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutOrdersInput
    connect?: TenantWhereUniqueInput
  }

  export type ClientCreateNestedOneWithoutOrdersInput = {
    create?: XOR<ClientCreateWithoutOrdersInput, ClientUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: ClientCreateOrConnectWithoutOrdersInput
    connect?: ClientWhereUniqueInput
  }

  export type InvoiceCreateNestedManyWithoutOrderInput = {
    create?: XOR<InvoiceCreateWithoutOrderInput, InvoiceUncheckedCreateWithoutOrderInput> | InvoiceCreateWithoutOrderInput[] | InvoiceUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutOrderInput | InvoiceCreateOrConnectWithoutOrderInput[]
    createMany?: InvoiceCreateManyOrderInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<InvoiceCreateWithoutOrderInput, InvoiceUncheckedCreateWithoutOrderInput> | InvoiceCreateWithoutOrderInput[] | InvoiceUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutOrderInput | InvoiceCreateOrConnectWithoutOrderInput[]
    createMany?: InvoiceCreateManyOrderInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type OrderUpdateitemsInput = {
    set?: InputJsonValue[]
    push?: InputJsonValue | InputJsonValue[]
  }

  export type TenantUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<TenantCreateWithoutOrdersInput, TenantUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutOrdersInput
    upsert?: TenantUpsertWithoutOrdersInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutOrdersInput, TenantUpdateWithoutOrdersInput>, TenantUncheckedUpdateWithoutOrdersInput>
  }

  export type ClientUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<ClientCreateWithoutOrdersInput, ClientUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: ClientCreateOrConnectWithoutOrdersInput
    upsert?: ClientUpsertWithoutOrdersInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutOrdersInput, ClientUpdateWithoutOrdersInput>, ClientUncheckedUpdateWithoutOrdersInput>
  }

  export type InvoiceUpdateManyWithoutOrderNestedInput = {
    create?: XOR<InvoiceCreateWithoutOrderInput, InvoiceUncheckedCreateWithoutOrderInput> | InvoiceCreateWithoutOrderInput[] | InvoiceUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutOrderInput | InvoiceCreateOrConnectWithoutOrderInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutOrderInput | InvoiceUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: InvoiceCreateManyOrderInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutOrderInput | InvoiceUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutOrderInput | InvoiceUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<InvoiceCreateWithoutOrderInput, InvoiceUncheckedCreateWithoutOrderInput> | InvoiceCreateWithoutOrderInput[] | InvoiceUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutOrderInput | InvoiceCreateOrConnectWithoutOrderInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutOrderInput | InvoiceUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: InvoiceCreateManyOrderInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutOrderInput | InvoiceUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutOrderInput | InvoiceUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<TenantCreateWithoutInvoicesInput, TenantUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutInvoicesInput
    connect?: TenantWhereUniqueInput
  }

  export type OrderCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<OrderCreateWithoutInvoicesInput, OrderUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: OrderCreateOrConnectWithoutInvoicesInput
    connect?: OrderWhereUniqueInput
  }

  export type ClientCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<ClientCreateWithoutInvoicesInput, ClientUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutInvoicesInput
    connect?: ClientWhereUniqueInput
  }

  export type InvoicePaymentCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<InvoicePaymentCreateWithoutInvoiceInput, InvoicePaymentUncheckedCreateWithoutInvoiceInput> | InvoicePaymentCreateWithoutInvoiceInput[] | InvoicePaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoicePaymentCreateOrConnectWithoutInvoiceInput | InvoicePaymentCreateOrConnectWithoutInvoiceInput[]
    createMany?: InvoicePaymentCreateManyInvoiceInputEnvelope
    connect?: InvoicePaymentWhereUniqueInput | InvoicePaymentWhereUniqueInput[]
  }

  export type BankTransactionCreateNestedManyWithoutMatchedInvoiceInput = {
    create?: XOR<BankTransactionCreateWithoutMatchedInvoiceInput, BankTransactionUncheckedCreateWithoutMatchedInvoiceInput> | BankTransactionCreateWithoutMatchedInvoiceInput[] | BankTransactionUncheckedCreateWithoutMatchedInvoiceInput[]
    connectOrCreate?: BankTransactionCreateOrConnectWithoutMatchedInvoiceInput | BankTransactionCreateOrConnectWithoutMatchedInvoiceInput[]
    createMany?: BankTransactionCreateManyMatchedInvoiceInputEnvelope
    connect?: BankTransactionWhereUniqueInput | BankTransactionWhereUniqueInput[]
  }

  export type CryptoPaymentCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<CryptoPaymentCreateWithoutInvoiceInput, CryptoPaymentUncheckedCreateWithoutInvoiceInput> | CryptoPaymentCreateWithoutInvoiceInput[] | CryptoPaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: CryptoPaymentCreateOrConnectWithoutInvoiceInput | CryptoPaymentCreateOrConnectWithoutInvoiceInput[]
    createMany?: CryptoPaymentCreateManyInvoiceInputEnvelope
    connect?: CryptoPaymentWhereUniqueInput | CryptoPaymentWhereUniqueInput[]
  }

  export type InvoicePaymentUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<InvoicePaymentCreateWithoutInvoiceInput, InvoicePaymentUncheckedCreateWithoutInvoiceInput> | InvoicePaymentCreateWithoutInvoiceInput[] | InvoicePaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoicePaymentCreateOrConnectWithoutInvoiceInput | InvoicePaymentCreateOrConnectWithoutInvoiceInput[]
    createMany?: InvoicePaymentCreateManyInvoiceInputEnvelope
    connect?: InvoicePaymentWhereUniqueInput | InvoicePaymentWhereUniqueInput[]
  }

  export type BankTransactionUncheckedCreateNestedManyWithoutMatchedInvoiceInput = {
    create?: XOR<BankTransactionCreateWithoutMatchedInvoiceInput, BankTransactionUncheckedCreateWithoutMatchedInvoiceInput> | BankTransactionCreateWithoutMatchedInvoiceInput[] | BankTransactionUncheckedCreateWithoutMatchedInvoiceInput[]
    connectOrCreate?: BankTransactionCreateOrConnectWithoutMatchedInvoiceInput | BankTransactionCreateOrConnectWithoutMatchedInvoiceInput[]
    createMany?: BankTransactionCreateManyMatchedInvoiceInputEnvelope
    connect?: BankTransactionWhereUniqueInput | BankTransactionWhereUniqueInput[]
  }

  export type CryptoPaymentUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<CryptoPaymentCreateWithoutInvoiceInput, CryptoPaymentUncheckedCreateWithoutInvoiceInput> | CryptoPaymentCreateWithoutInvoiceInput[] | CryptoPaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: CryptoPaymentCreateOrConnectWithoutInvoiceInput | CryptoPaymentCreateOrConnectWithoutInvoiceInput[]
    createMany?: CryptoPaymentCreateManyInvoiceInputEnvelope
    connect?: CryptoPaymentWhereUniqueInput | CryptoPaymentWhereUniqueInput[]
  }

  export type TenantUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<TenantCreateWithoutInvoicesInput, TenantUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutInvoicesInput
    upsert?: TenantUpsertWithoutInvoicesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutInvoicesInput, TenantUpdateWithoutInvoicesInput>, TenantUncheckedUpdateWithoutInvoicesInput>
  }

  export type OrderUpdateOneWithoutInvoicesNestedInput = {
    create?: XOR<OrderCreateWithoutInvoicesInput, OrderUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: OrderCreateOrConnectWithoutInvoicesInput
    upsert?: OrderUpsertWithoutInvoicesInput
    disconnect?: OrderWhereInput | boolean
    delete?: OrderWhereInput | boolean
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutInvoicesInput, OrderUpdateWithoutInvoicesInput>, OrderUncheckedUpdateWithoutInvoicesInput>
  }

  export type ClientUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<ClientCreateWithoutInvoicesInput, ClientUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutInvoicesInput
    upsert?: ClientUpsertWithoutInvoicesInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutInvoicesInput, ClientUpdateWithoutInvoicesInput>, ClientUncheckedUpdateWithoutInvoicesInput>
  }

  export type InvoicePaymentUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<InvoicePaymentCreateWithoutInvoiceInput, InvoicePaymentUncheckedCreateWithoutInvoiceInput> | InvoicePaymentCreateWithoutInvoiceInput[] | InvoicePaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoicePaymentCreateOrConnectWithoutInvoiceInput | InvoicePaymentCreateOrConnectWithoutInvoiceInput[]
    upsert?: InvoicePaymentUpsertWithWhereUniqueWithoutInvoiceInput | InvoicePaymentUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: InvoicePaymentCreateManyInvoiceInputEnvelope
    set?: InvoicePaymentWhereUniqueInput | InvoicePaymentWhereUniqueInput[]
    disconnect?: InvoicePaymentWhereUniqueInput | InvoicePaymentWhereUniqueInput[]
    delete?: InvoicePaymentWhereUniqueInput | InvoicePaymentWhereUniqueInput[]
    connect?: InvoicePaymentWhereUniqueInput | InvoicePaymentWhereUniqueInput[]
    update?: InvoicePaymentUpdateWithWhereUniqueWithoutInvoiceInput | InvoicePaymentUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: InvoicePaymentUpdateManyWithWhereWithoutInvoiceInput | InvoicePaymentUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: InvoicePaymentScalarWhereInput | InvoicePaymentScalarWhereInput[]
  }

  export type BankTransactionUpdateManyWithoutMatchedInvoiceNestedInput = {
    create?: XOR<BankTransactionCreateWithoutMatchedInvoiceInput, BankTransactionUncheckedCreateWithoutMatchedInvoiceInput> | BankTransactionCreateWithoutMatchedInvoiceInput[] | BankTransactionUncheckedCreateWithoutMatchedInvoiceInput[]
    connectOrCreate?: BankTransactionCreateOrConnectWithoutMatchedInvoiceInput | BankTransactionCreateOrConnectWithoutMatchedInvoiceInput[]
    upsert?: BankTransactionUpsertWithWhereUniqueWithoutMatchedInvoiceInput | BankTransactionUpsertWithWhereUniqueWithoutMatchedInvoiceInput[]
    createMany?: BankTransactionCreateManyMatchedInvoiceInputEnvelope
    set?: BankTransactionWhereUniqueInput | BankTransactionWhereUniqueInput[]
    disconnect?: BankTransactionWhereUniqueInput | BankTransactionWhereUniqueInput[]
    delete?: BankTransactionWhereUniqueInput | BankTransactionWhereUniqueInput[]
    connect?: BankTransactionWhereUniqueInput | BankTransactionWhereUniqueInput[]
    update?: BankTransactionUpdateWithWhereUniqueWithoutMatchedInvoiceInput | BankTransactionUpdateWithWhereUniqueWithoutMatchedInvoiceInput[]
    updateMany?: BankTransactionUpdateManyWithWhereWithoutMatchedInvoiceInput | BankTransactionUpdateManyWithWhereWithoutMatchedInvoiceInput[]
    deleteMany?: BankTransactionScalarWhereInput | BankTransactionScalarWhereInput[]
  }

  export type CryptoPaymentUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<CryptoPaymentCreateWithoutInvoiceInput, CryptoPaymentUncheckedCreateWithoutInvoiceInput> | CryptoPaymentCreateWithoutInvoiceInput[] | CryptoPaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: CryptoPaymentCreateOrConnectWithoutInvoiceInput | CryptoPaymentCreateOrConnectWithoutInvoiceInput[]
    upsert?: CryptoPaymentUpsertWithWhereUniqueWithoutInvoiceInput | CryptoPaymentUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: CryptoPaymentCreateManyInvoiceInputEnvelope
    set?: CryptoPaymentWhereUniqueInput | CryptoPaymentWhereUniqueInput[]
    disconnect?: CryptoPaymentWhereUniqueInput | CryptoPaymentWhereUniqueInput[]
    delete?: CryptoPaymentWhereUniqueInput | CryptoPaymentWhereUniqueInput[]
    connect?: CryptoPaymentWhereUniqueInput | CryptoPaymentWhereUniqueInput[]
    update?: CryptoPaymentUpdateWithWhereUniqueWithoutInvoiceInput | CryptoPaymentUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: CryptoPaymentUpdateManyWithWhereWithoutInvoiceInput | CryptoPaymentUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: CryptoPaymentScalarWhereInput | CryptoPaymentScalarWhereInput[]
  }

  export type InvoicePaymentUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<InvoicePaymentCreateWithoutInvoiceInput, InvoicePaymentUncheckedCreateWithoutInvoiceInput> | InvoicePaymentCreateWithoutInvoiceInput[] | InvoicePaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoicePaymentCreateOrConnectWithoutInvoiceInput | InvoicePaymentCreateOrConnectWithoutInvoiceInput[]
    upsert?: InvoicePaymentUpsertWithWhereUniqueWithoutInvoiceInput | InvoicePaymentUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: InvoicePaymentCreateManyInvoiceInputEnvelope
    set?: InvoicePaymentWhereUniqueInput | InvoicePaymentWhereUniqueInput[]
    disconnect?: InvoicePaymentWhereUniqueInput | InvoicePaymentWhereUniqueInput[]
    delete?: InvoicePaymentWhereUniqueInput | InvoicePaymentWhereUniqueInput[]
    connect?: InvoicePaymentWhereUniqueInput | InvoicePaymentWhereUniqueInput[]
    update?: InvoicePaymentUpdateWithWhereUniqueWithoutInvoiceInput | InvoicePaymentUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: InvoicePaymentUpdateManyWithWhereWithoutInvoiceInput | InvoicePaymentUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: InvoicePaymentScalarWhereInput | InvoicePaymentScalarWhereInput[]
  }

  export type BankTransactionUncheckedUpdateManyWithoutMatchedInvoiceNestedInput = {
    create?: XOR<BankTransactionCreateWithoutMatchedInvoiceInput, BankTransactionUncheckedCreateWithoutMatchedInvoiceInput> | BankTransactionCreateWithoutMatchedInvoiceInput[] | BankTransactionUncheckedCreateWithoutMatchedInvoiceInput[]
    connectOrCreate?: BankTransactionCreateOrConnectWithoutMatchedInvoiceInput | BankTransactionCreateOrConnectWithoutMatchedInvoiceInput[]
    upsert?: BankTransactionUpsertWithWhereUniqueWithoutMatchedInvoiceInput | BankTransactionUpsertWithWhereUniqueWithoutMatchedInvoiceInput[]
    createMany?: BankTransactionCreateManyMatchedInvoiceInputEnvelope
    set?: BankTransactionWhereUniqueInput | BankTransactionWhereUniqueInput[]
    disconnect?: BankTransactionWhereUniqueInput | BankTransactionWhereUniqueInput[]
    delete?: BankTransactionWhereUniqueInput | BankTransactionWhereUniqueInput[]
    connect?: BankTransactionWhereUniqueInput | BankTransactionWhereUniqueInput[]
    update?: BankTransactionUpdateWithWhereUniqueWithoutMatchedInvoiceInput | BankTransactionUpdateWithWhereUniqueWithoutMatchedInvoiceInput[]
    updateMany?: BankTransactionUpdateManyWithWhereWithoutMatchedInvoiceInput | BankTransactionUpdateManyWithWhereWithoutMatchedInvoiceInput[]
    deleteMany?: BankTransactionScalarWhereInput | BankTransactionScalarWhereInput[]
  }

  export type CryptoPaymentUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<CryptoPaymentCreateWithoutInvoiceInput, CryptoPaymentUncheckedCreateWithoutInvoiceInput> | CryptoPaymentCreateWithoutInvoiceInput[] | CryptoPaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: CryptoPaymentCreateOrConnectWithoutInvoiceInput | CryptoPaymentCreateOrConnectWithoutInvoiceInput[]
    upsert?: CryptoPaymentUpsertWithWhereUniqueWithoutInvoiceInput | CryptoPaymentUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: CryptoPaymentCreateManyInvoiceInputEnvelope
    set?: CryptoPaymentWhereUniqueInput | CryptoPaymentWhereUniqueInput[]
    disconnect?: CryptoPaymentWhereUniqueInput | CryptoPaymentWhereUniqueInput[]
    delete?: CryptoPaymentWhereUniqueInput | CryptoPaymentWhereUniqueInput[]
    connect?: CryptoPaymentWhereUniqueInput | CryptoPaymentWhereUniqueInput[]
    update?: CryptoPaymentUpdateWithWhereUniqueWithoutInvoiceInput | CryptoPaymentUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: CryptoPaymentUpdateManyWithWhereWithoutInvoiceInput | CryptoPaymentUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: CryptoPaymentScalarWhereInput | CryptoPaymentScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutAiLogsInput = {
    create?: XOR<TenantCreateWithoutAiLogsInput, TenantUncheckedCreateWithoutAiLogsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAiLogsInput
    connect?: TenantWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutAiLogsNestedInput = {
    create?: XOR<TenantCreateWithoutAiLogsInput, TenantUncheckedCreateWithoutAiLogsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAiLogsInput
    upsert?: TenantUpsertWithoutAiLogsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutAiLogsInput, TenantUpdateWithoutAiLogsInput>, TenantUncheckedUpdateWithoutAiLogsInput>
  }

  export type ExchangeRateCreateNestedManyWithoutFromCurrencyInput = {
    create?: XOR<ExchangeRateCreateWithoutFromCurrencyInput, ExchangeRateUncheckedCreateWithoutFromCurrencyInput> | ExchangeRateCreateWithoutFromCurrencyInput[] | ExchangeRateUncheckedCreateWithoutFromCurrencyInput[]
    connectOrCreate?: ExchangeRateCreateOrConnectWithoutFromCurrencyInput | ExchangeRateCreateOrConnectWithoutFromCurrencyInput[]
    createMany?: ExchangeRateCreateManyFromCurrencyInputEnvelope
    connect?: ExchangeRateWhereUniqueInput | ExchangeRateWhereUniqueInput[]
  }

  export type ExchangeRateCreateNestedManyWithoutToCurrencyInput = {
    create?: XOR<ExchangeRateCreateWithoutToCurrencyInput, ExchangeRateUncheckedCreateWithoutToCurrencyInput> | ExchangeRateCreateWithoutToCurrencyInput[] | ExchangeRateUncheckedCreateWithoutToCurrencyInput[]
    connectOrCreate?: ExchangeRateCreateOrConnectWithoutToCurrencyInput | ExchangeRateCreateOrConnectWithoutToCurrencyInput[]
    createMany?: ExchangeRateCreateManyToCurrencyInputEnvelope
    connect?: ExchangeRateWhereUniqueInput | ExchangeRateWhereUniqueInput[]
  }

  export type ExchangeRateUncheckedCreateNestedManyWithoutFromCurrencyInput = {
    create?: XOR<ExchangeRateCreateWithoutFromCurrencyInput, ExchangeRateUncheckedCreateWithoutFromCurrencyInput> | ExchangeRateCreateWithoutFromCurrencyInput[] | ExchangeRateUncheckedCreateWithoutFromCurrencyInput[]
    connectOrCreate?: ExchangeRateCreateOrConnectWithoutFromCurrencyInput | ExchangeRateCreateOrConnectWithoutFromCurrencyInput[]
    createMany?: ExchangeRateCreateManyFromCurrencyInputEnvelope
    connect?: ExchangeRateWhereUniqueInput | ExchangeRateWhereUniqueInput[]
  }

  export type ExchangeRateUncheckedCreateNestedManyWithoutToCurrencyInput = {
    create?: XOR<ExchangeRateCreateWithoutToCurrencyInput, ExchangeRateUncheckedCreateWithoutToCurrencyInput> | ExchangeRateCreateWithoutToCurrencyInput[] | ExchangeRateUncheckedCreateWithoutToCurrencyInput[]
    connectOrCreate?: ExchangeRateCreateOrConnectWithoutToCurrencyInput | ExchangeRateCreateOrConnectWithoutToCurrencyInput[]
    createMany?: ExchangeRateCreateManyToCurrencyInputEnvelope
    connect?: ExchangeRateWhereUniqueInput | ExchangeRateWhereUniqueInput[]
  }

  export type ExchangeRateUpdateManyWithoutFromCurrencyNestedInput = {
    create?: XOR<ExchangeRateCreateWithoutFromCurrencyInput, ExchangeRateUncheckedCreateWithoutFromCurrencyInput> | ExchangeRateCreateWithoutFromCurrencyInput[] | ExchangeRateUncheckedCreateWithoutFromCurrencyInput[]
    connectOrCreate?: ExchangeRateCreateOrConnectWithoutFromCurrencyInput | ExchangeRateCreateOrConnectWithoutFromCurrencyInput[]
    upsert?: ExchangeRateUpsertWithWhereUniqueWithoutFromCurrencyInput | ExchangeRateUpsertWithWhereUniqueWithoutFromCurrencyInput[]
    createMany?: ExchangeRateCreateManyFromCurrencyInputEnvelope
    set?: ExchangeRateWhereUniqueInput | ExchangeRateWhereUniqueInput[]
    disconnect?: ExchangeRateWhereUniqueInput | ExchangeRateWhereUniqueInput[]
    delete?: ExchangeRateWhereUniqueInput | ExchangeRateWhereUniqueInput[]
    connect?: ExchangeRateWhereUniqueInput | ExchangeRateWhereUniqueInput[]
    update?: ExchangeRateUpdateWithWhereUniqueWithoutFromCurrencyInput | ExchangeRateUpdateWithWhereUniqueWithoutFromCurrencyInput[]
    updateMany?: ExchangeRateUpdateManyWithWhereWithoutFromCurrencyInput | ExchangeRateUpdateManyWithWhereWithoutFromCurrencyInput[]
    deleteMany?: ExchangeRateScalarWhereInput | ExchangeRateScalarWhereInput[]
  }

  export type ExchangeRateUpdateManyWithoutToCurrencyNestedInput = {
    create?: XOR<ExchangeRateCreateWithoutToCurrencyInput, ExchangeRateUncheckedCreateWithoutToCurrencyInput> | ExchangeRateCreateWithoutToCurrencyInput[] | ExchangeRateUncheckedCreateWithoutToCurrencyInput[]
    connectOrCreate?: ExchangeRateCreateOrConnectWithoutToCurrencyInput | ExchangeRateCreateOrConnectWithoutToCurrencyInput[]
    upsert?: ExchangeRateUpsertWithWhereUniqueWithoutToCurrencyInput | ExchangeRateUpsertWithWhereUniqueWithoutToCurrencyInput[]
    createMany?: ExchangeRateCreateManyToCurrencyInputEnvelope
    set?: ExchangeRateWhereUniqueInput | ExchangeRateWhereUniqueInput[]
    disconnect?: ExchangeRateWhereUniqueInput | ExchangeRateWhereUniqueInput[]
    delete?: ExchangeRateWhereUniqueInput | ExchangeRateWhereUniqueInput[]
    connect?: ExchangeRateWhereUniqueInput | ExchangeRateWhereUniqueInput[]
    update?: ExchangeRateUpdateWithWhereUniqueWithoutToCurrencyInput | ExchangeRateUpdateWithWhereUniqueWithoutToCurrencyInput[]
    updateMany?: ExchangeRateUpdateManyWithWhereWithoutToCurrencyInput | ExchangeRateUpdateManyWithWhereWithoutToCurrencyInput[]
    deleteMany?: ExchangeRateScalarWhereInput | ExchangeRateScalarWhereInput[]
  }

  export type ExchangeRateUncheckedUpdateManyWithoutFromCurrencyNestedInput = {
    create?: XOR<ExchangeRateCreateWithoutFromCurrencyInput, ExchangeRateUncheckedCreateWithoutFromCurrencyInput> | ExchangeRateCreateWithoutFromCurrencyInput[] | ExchangeRateUncheckedCreateWithoutFromCurrencyInput[]
    connectOrCreate?: ExchangeRateCreateOrConnectWithoutFromCurrencyInput | ExchangeRateCreateOrConnectWithoutFromCurrencyInput[]
    upsert?: ExchangeRateUpsertWithWhereUniqueWithoutFromCurrencyInput | ExchangeRateUpsertWithWhereUniqueWithoutFromCurrencyInput[]
    createMany?: ExchangeRateCreateManyFromCurrencyInputEnvelope
    set?: ExchangeRateWhereUniqueInput | ExchangeRateWhereUniqueInput[]
    disconnect?: ExchangeRateWhereUniqueInput | ExchangeRateWhereUniqueInput[]
    delete?: ExchangeRateWhereUniqueInput | ExchangeRateWhereUniqueInput[]
    connect?: ExchangeRateWhereUniqueInput | ExchangeRateWhereUniqueInput[]
    update?: ExchangeRateUpdateWithWhereUniqueWithoutFromCurrencyInput | ExchangeRateUpdateWithWhereUniqueWithoutFromCurrencyInput[]
    updateMany?: ExchangeRateUpdateManyWithWhereWithoutFromCurrencyInput | ExchangeRateUpdateManyWithWhereWithoutFromCurrencyInput[]
    deleteMany?: ExchangeRateScalarWhereInput | ExchangeRateScalarWhereInput[]
  }

  export type ExchangeRateUncheckedUpdateManyWithoutToCurrencyNestedInput = {
    create?: XOR<ExchangeRateCreateWithoutToCurrencyInput, ExchangeRateUncheckedCreateWithoutToCurrencyInput> | ExchangeRateCreateWithoutToCurrencyInput[] | ExchangeRateUncheckedCreateWithoutToCurrencyInput[]
    connectOrCreate?: ExchangeRateCreateOrConnectWithoutToCurrencyInput | ExchangeRateCreateOrConnectWithoutToCurrencyInput[]
    upsert?: ExchangeRateUpsertWithWhereUniqueWithoutToCurrencyInput | ExchangeRateUpsertWithWhereUniqueWithoutToCurrencyInput[]
    createMany?: ExchangeRateCreateManyToCurrencyInputEnvelope
    set?: ExchangeRateWhereUniqueInput | ExchangeRateWhereUniqueInput[]
    disconnect?: ExchangeRateWhereUniqueInput | ExchangeRateWhereUniqueInput[]
    delete?: ExchangeRateWhereUniqueInput | ExchangeRateWhereUniqueInput[]
    connect?: ExchangeRateWhereUniqueInput | ExchangeRateWhereUniqueInput[]
    update?: ExchangeRateUpdateWithWhereUniqueWithoutToCurrencyInput | ExchangeRateUpdateWithWhereUniqueWithoutToCurrencyInput[]
    updateMany?: ExchangeRateUpdateManyWithWhereWithoutToCurrencyInput | ExchangeRateUpdateManyWithWhereWithoutToCurrencyInput[]
    deleteMany?: ExchangeRateScalarWhereInput | ExchangeRateScalarWhereInput[]
  }

  export type CurrencyCreateNestedOneWithoutExchangeRatesFromInput = {
    create?: XOR<CurrencyCreateWithoutExchangeRatesFromInput, CurrencyUncheckedCreateWithoutExchangeRatesFromInput>
    connectOrCreate?: CurrencyCreateOrConnectWithoutExchangeRatesFromInput
    connect?: CurrencyWhereUniqueInput
  }

  export type CurrencyCreateNestedOneWithoutExchangeRatesToInput = {
    create?: XOR<CurrencyCreateWithoutExchangeRatesToInput, CurrencyUncheckedCreateWithoutExchangeRatesToInput>
    connectOrCreate?: CurrencyCreateOrConnectWithoutExchangeRatesToInput
    connect?: CurrencyWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type CurrencyUpdateOneRequiredWithoutExchangeRatesFromNestedInput = {
    create?: XOR<CurrencyCreateWithoutExchangeRatesFromInput, CurrencyUncheckedCreateWithoutExchangeRatesFromInput>
    connectOrCreate?: CurrencyCreateOrConnectWithoutExchangeRatesFromInput
    upsert?: CurrencyUpsertWithoutExchangeRatesFromInput
    connect?: CurrencyWhereUniqueInput
    update?: XOR<XOR<CurrencyUpdateToOneWithWhereWithoutExchangeRatesFromInput, CurrencyUpdateWithoutExchangeRatesFromInput>, CurrencyUncheckedUpdateWithoutExchangeRatesFromInput>
  }

  export type CurrencyUpdateOneRequiredWithoutExchangeRatesToNestedInput = {
    create?: XOR<CurrencyCreateWithoutExchangeRatesToInput, CurrencyUncheckedCreateWithoutExchangeRatesToInput>
    connectOrCreate?: CurrencyCreateOrConnectWithoutExchangeRatesToInput
    upsert?: CurrencyUpsertWithoutExchangeRatesToInput
    connect?: CurrencyWhereUniqueInput
    update?: XOR<XOR<CurrencyUpdateToOneWithWhereWithoutExchangeRatesToInput, CurrencyUpdateWithoutExchangeRatesToInput>, CurrencyUncheckedUpdateWithoutExchangeRatesToInput>
  }

  export type TenantCreateNestedOneWithoutBankAccountsInput = {
    create?: XOR<TenantCreateWithoutBankAccountsInput, TenantUncheckedCreateWithoutBankAccountsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutBankAccountsInput
    connect?: TenantWhereUniqueInput
  }

  export type BankTransactionCreateNestedManyWithoutBankAccountInput = {
    create?: XOR<BankTransactionCreateWithoutBankAccountInput, BankTransactionUncheckedCreateWithoutBankAccountInput> | BankTransactionCreateWithoutBankAccountInput[] | BankTransactionUncheckedCreateWithoutBankAccountInput[]
    connectOrCreate?: BankTransactionCreateOrConnectWithoutBankAccountInput | BankTransactionCreateOrConnectWithoutBankAccountInput[]
    createMany?: BankTransactionCreateManyBankAccountInputEnvelope
    connect?: BankTransactionWhereUniqueInput | BankTransactionWhereUniqueInput[]
  }

  export type BankTransactionUncheckedCreateNestedManyWithoutBankAccountInput = {
    create?: XOR<BankTransactionCreateWithoutBankAccountInput, BankTransactionUncheckedCreateWithoutBankAccountInput> | BankTransactionCreateWithoutBankAccountInput[] | BankTransactionUncheckedCreateWithoutBankAccountInput[]
    connectOrCreate?: BankTransactionCreateOrConnectWithoutBankAccountInput | BankTransactionCreateOrConnectWithoutBankAccountInput[]
    createMany?: BankTransactionCreateManyBankAccountInputEnvelope
    connect?: BankTransactionWhereUniqueInput | BankTransactionWhereUniqueInput[]
  }

  export type EnumBankProviderFieldUpdateOperationsInput = {
    set?: $Enums.BankProvider
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type TenantUpdateOneRequiredWithoutBankAccountsNestedInput = {
    create?: XOR<TenantCreateWithoutBankAccountsInput, TenantUncheckedCreateWithoutBankAccountsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutBankAccountsInput
    upsert?: TenantUpsertWithoutBankAccountsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutBankAccountsInput, TenantUpdateWithoutBankAccountsInput>, TenantUncheckedUpdateWithoutBankAccountsInput>
  }

  export type BankTransactionUpdateManyWithoutBankAccountNestedInput = {
    create?: XOR<BankTransactionCreateWithoutBankAccountInput, BankTransactionUncheckedCreateWithoutBankAccountInput> | BankTransactionCreateWithoutBankAccountInput[] | BankTransactionUncheckedCreateWithoutBankAccountInput[]
    connectOrCreate?: BankTransactionCreateOrConnectWithoutBankAccountInput | BankTransactionCreateOrConnectWithoutBankAccountInput[]
    upsert?: BankTransactionUpsertWithWhereUniqueWithoutBankAccountInput | BankTransactionUpsertWithWhereUniqueWithoutBankAccountInput[]
    createMany?: BankTransactionCreateManyBankAccountInputEnvelope
    set?: BankTransactionWhereUniqueInput | BankTransactionWhereUniqueInput[]
    disconnect?: BankTransactionWhereUniqueInput | BankTransactionWhereUniqueInput[]
    delete?: BankTransactionWhereUniqueInput | BankTransactionWhereUniqueInput[]
    connect?: BankTransactionWhereUniqueInput | BankTransactionWhereUniqueInput[]
    update?: BankTransactionUpdateWithWhereUniqueWithoutBankAccountInput | BankTransactionUpdateWithWhereUniqueWithoutBankAccountInput[]
    updateMany?: BankTransactionUpdateManyWithWhereWithoutBankAccountInput | BankTransactionUpdateManyWithWhereWithoutBankAccountInput[]
    deleteMany?: BankTransactionScalarWhereInput | BankTransactionScalarWhereInput[]
  }

  export type BankTransactionUncheckedUpdateManyWithoutBankAccountNestedInput = {
    create?: XOR<BankTransactionCreateWithoutBankAccountInput, BankTransactionUncheckedCreateWithoutBankAccountInput> | BankTransactionCreateWithoutBankAccountInput[] | BankTransactionUncheckedCreateWithoutBankAccountInput[]
    connectOrCreate?: BankTransactionCreateOrConnectWithoutBankAccountInput | BankTransactionCreateOrConnectWithoutBankAccountInput[]
    upsert?: BankTransactionUpsertWithWhereUniqueWithoutBankAccountInput | BankTransactionUpsertWithWhereUniqueWithoutBankAccountInput[]
    createMany?: BankTransactionCreateManyBankAccountInputEnvelope
    set?: BankTransactionWhereUniqueInput | BankTransactionWhereUniqueInput[]
    disconnect?: BankTransactionWhereUniqueInput | BankTransactionWhereUniqueInput[]
    delete?: BankTransactionWhereUniqueInput | BankTransactionWhereUniqueInput[]
    connect?: BankTransactionWhereUniqueInput | BankTransactionWhereUniqueInput[]
    update?: BankTransactionUpdateWithWhereUniqueWithoutBankAccountInput | BankTransactionUpdateWithWhereUniqueWithoutBankAccountInput[]
    updateMany?: BankTransactionUpdateManyWithWhereWithoutBankAccountInput | BankTransactionUpdateManyWithWhereWithoutBankAccountInput[]
    deleteMany?: BankTransactionScalarWhereInput | BankTransactionScalarWhereInput[]
  }

  export type BankAccountCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<BankAccountCreateWithoutTransactionsInput, BankAccountUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: BankAccountCreateOrConnectWithoutTransactionsInput
    connect?: BankAccountWhereUniqueInput
  }

  export type TenantCreateNestedOneWithoutBankTransactionsInput = {
    create?: XOR<TenantCreateWithoutBankTransactionsInput, TenantUncheckedCreateWithoutBankTransactionsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutBankTransactionsInput
    connect?: TenantWhereUniqueInput
  }

  export type InvoiceCreateNestedOneWithoutBankTransactionsInput = {
    create?: XOR<InvoiceCreateWithoutBankTransactionsInput, InvoiceUncheckedCreateWithoutBankTransactionsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutBankTransactionsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type EnumTransactionTypeFieldUpdateOperationsInput = {
    set?: $Enums.TransactionType
  }

  export type BankAccountUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<BankAccountCreateWithoutTransactionsInput, BankAccountUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: BankAccountCreateOrConnectWithoutTransactionsInput
    upsert?: BankAccountUpsertWithoutTransactionsInput
    connect?: BankAccountWhereUniqueInput
    update?: XOR<XOR<BankAccountUpdateToOneWithWhereWithoutTransactionsInput, BankAccountUpdateWithoutTransactionsInput>, BankAccountUncheckedUpdateWithoutTransactionsInput>
  }

  export type TenantUpdateOneRequiredWithoutBankTransactionsNestedInput = {
    create?: XOR<TenantCreateWithoutBankTransactionsInput, TenantUncheckedCreateWithoutBankTransactionsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutBankTransactionsInput
    upsert?: TenantUpsertWithoutBankTransactionsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutBankTransactionsInput, TenantUpdateWithoutBankTransactionsInput>, TenantUncheckedUpdateWithoutBankTransactionsInput>
  }

  export type InvoiceUpdateOneWithoutBankTransactionsNestedInput = {
    create?: XOR<InvoiceCreateWithoutBankTransactionsInput, InvoiceUncheckedCreateWithoutBankTransactionsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutBankTransactionsInput
    upsert?: InvoiceUpsertWithoutBankTransactionsInput
    disconnect?: InvoiceWhereInput | boolean
    delete?: InvoiceWhereInput | boolean
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutBankTransactionsInput, InvoiceUpdateWithoutBankTransactionsInput>, InvoiceUncheckedUpdateWithoutBankTransactionsInput>
  }

  export type TenantCreateNestedOneWithoutInvoicePaymentsInput = {
    create?: XOR<TenantCreateWithoutInvoicePaymentsInput, TenantUncheckedCreateWithoutInvoicePaymentsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutInvoicePaymentsInput
    connect?: TenantWhereUniqueInput
  }

  export type InvoiceCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutPaymentsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type EnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod
  }

  export type TenantUpdateOneRequiredWithoutInvoicePaymentsNestedInput = {
    create?: XOR<TenantCreateWithoutInvoicePaymentsInput, TenantUncheckedCreateWithoutInvoicePaymentsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutInvoicePaymentsInput
    upsert?: TenantUpsertWithoutInvoicePaymentsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutInvoicePaymentsInput, TenantUpdateWithoutInvoicePaymentsInput>, TenantUncheckedUpdateWithoutInvoicePaymentsInput>
  }

  export type InvoiceUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutPaymentsInput
    upsert?: InvoiceUpsertWithoutPaymentsInput
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutPaymentsInput, InvoiceUpdateWithoutPaymentsInput>, InvoiceUncheckedUpdateWithoutPaymentsInput>
  }

  export type TenantCreateNestedOneWithoutPaymentGatewayConfigsInput = {
    create?: XOR<TenantCreateWithoutPaymentGatewayConfigsInput, TenantUncheckedCreateWithoutPaymentGatewayConfigsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPaymentGatewayConfigsInput
    connect?: TenantWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutPaymentGatewayConfigsNestedInput = {
    create?: XOR<TenantCreateWithoutPaymentGatewayConfigsInput, TenantUncheckedCreateWithoutPaymentGatewayConfigsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPaymentGatewayConfigsInput
    upsert?: TenantUpsertWithoutPaymentGatewayConfigsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutPaymentGatewayConfigsInput, TenantUpdateWithoutPaymentGatewayConfigsInput>, TenantUncheckedUpdateWithoutPaymentGatewayConfigsInput>
  }

  export type TenantCreateNestedOneWithoutCryptoWalletsInput = {
    create?: XOR<TenantCreateWithoutCryptoWalletsInput, TenantUncheckedCreateWithoutCryptoWalletsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutCryptoWalletsInput
    connect?: TenantWhereUniqueInput
  }

  export type CryptoPaymentCreateNestedManyWithoutWalletInput = {
    create?: XOR<CryptoPaymentCreateWithoutWalletInput, CryptoPaymentUncheckedCreateWithoutWalletInput> | CryptoPaymentCreateWithoutWalletInput[] | CryptoPaymentUncheckedCreateWithoutWalletInput[]
    connectOrCreate?: CryptoPaymentCreateOrConnectWithoutWalletInput | CryptoPaymentCreateOrConnectWithoutWalletInput[]
    createMany?: CryptoPaymentCreateManyWalletInputEnvelope
    connect?: CryptoPaymentWhereUniqueInput | CryptoPaymentWhereUniqueInput[]
  }

  export type CryptoPaymentUncheckedCreateNestedManyWithoutWalletInput = {
    create?: XOR<CryptoPaymentCreateWithoutWalletInput, CryptoPaymentUncheckedCreateWithoutWalletInput> | CryptoPaymentCreateWithoutWalletInput[] | CryptoPaymentUncheckedCreateWithoutWalletInput[]
    connectOrCreate?: CryptoPaymentCreateOrConnectWithoutWalletInput | CryptoPaymentCreateOrConnectWithoutWalletInput[]
    createMany?: CryptoPaymentCreateManyWalletInputEnvelope
    connect?: CryptoPaymentWhereUniqueInput | CryptoPaymentWhereUniqueInput[]
  }

  export type TenantUpdateOneRequiredWithoutCryptoWalletsNestedInput = {
    create?: XOR<TenantCreateWithoutCryptoWalletsInput, TenantUncheckedCreateWithoutCryptoWalletsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutCryptoWalletsInput
    upsert?: TenantUpsertWithoutCryptoWalletsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutCryptoWalletsInput, TenantUpdateWithoutCryptoWalletsInput>, TenantUncheckedUpdateWithoutCryptoWalletsInput>
  }

  export type CryptoPaymentUpdateManyWithoutWalletNestedInput = {
    create?: XOR<CryptoPaymentCreateWithoutWalletInput, CryptoPaymentUncheckedCreateWithoutWalletInput> | CryptoPaymentCreateWithoutWalletInput[] | CryptoPaymentUncheckedCreateWithoutWalletInput[]
    connectOrCreate?: CryptoPaymentCreateOrConnectWithoutWalletInput | CryptoPaymentCreateOrConnectWithoutWalletInput[]
    upsert?: CryptoPaymentUpsertWithWhereUniqueWithoutWalletInput | CryptoPaymentUpsertWithWhereUniqueWithoutWalletInput[]
    createMany?: CryptoPaymentCreateManyWalletInputEnvelope
    set?: CryptoPaymentWhereUniqueInput | CryptoPaymentWhereUniqueInput[]
    disconnect?: CryptoPaymentWhereUniqueInput | CryptoPaymentWhereUniqueInput[]
    delete?: CryptoPaymentWhereUniqueInput | CryptoPaymentWhereUniqueInput[]
    connect?: CryptoPaymentWhereUniqueInput | CryptoPaymentWhereUniqueInput[]
    update?: CryptoPaymentUpdateWithWhereUniqueWithoutWalletInput | CryptoPaymentUpdateWithWhereUniqueWithoutWalletInput[]
    updateMany?: CryptoPaymentUpdateManyWithWhereWithoutWalletInput | CryptoPaymentUpdateManyWithWhereWithoutWalletInput[]
    deleteMany?: CryptoPaymentScalarWhereInput | CryptoPaymentScalarWhereInput[]
  }

  export type CryptoPaymentUncheckedUpdateManyWithoutWalletNestedInput = {
    create?: XOR<CryptoPaymentCreateWithoutWalletInput, CryptoPaymentUncheckedCreateWithoutWalletInput> | CryptoPaymentCreateWithoutWalletInput[] | CryptoPaymentUncheckedCreateWithoutWalletInput[]
    connectOrCreate?: CryptoPaymentCreateOrConnectWithoutWalletInput | CryptoPaymentCreateOrConnectWithoutWalletInput[]
    upsert?: CryptoPaymentUpsertWithWhereUniqueWithoutWalletInput | CryptoPaymentUpsertWithWhereUniqueWithoutWalletInput[]
    createMany?: CryptoPaymentCreateManyWalletInputEnvelope
    set?: CryptoPaymentWhereUniqueInput | CryptoPaymentWhereUniqueInput[]
    disconnect?: CryptoPaymentWhereUniqueInput | CryptoPaymentWhereUniqueInput[]
    delete?: CryptoPaymentWhereUniqueInput | CryptoPaymentWhereUniqueInput[]
    connect?: CryptoPaymentWhereUniqueInput | CryptoPaymentWhereUniqueInput[]
    update?: CryptoPaymentUpdateWithWhereUniqueWithoutWalletInput | CryptoPaymentUpdateWithWhereUniqueWithoutWalletInput[]
    updateMany?: CryptoPaymentUpdateManyWithWhereWithoutWalletInput | CryptoPaymentUpdateManyWithWhereWithoutWalletInput[]
    deleteMany?: CryptoPaymentScalarWhereInput | CryptoPaymentScalarWhereInput[]
  }

  export type CryptoWalletCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<CryptoWalletCreateWithoutPaymentsInput, CryptoWalletUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: CryptoWalletCreateOrConnectWithoutPaymentsInput
    connect?: CryptoWalletWhereUniqueInput
  }

  export type InvoiceCreateNestedOneWithoutCryptoPaymentsInput = {
    create?: XOR<InvoiceCreateWithoutCryptoPaymentsInput, InvoiceUncheckedCreateWithoutCryptoPaymentsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutCryptoPaymentsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type CryptoWalletUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<CryptoWalletCreateWithoutPaymentsInput, CryptoWalletUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: CryptoWalletCreateOrConnectWithoutPaymentsInput
    upsert?: CryptoWalletUpsertWithoutPaymentsInput
    connect?: CryptoWalletWhereUniqueInput
    update?: XOR<XOR<CryptoWalletUpdateToOneWithWhereWithoutPaymentsInput, CryptoWalletUpdateWithoutPaymentsInput>, CryptoWalletUncheckedUpdateWithoutPaymentsInput>
  }

  export type InvoiceUpdateOneWithoutCryptoPaymentsNestedInput = {
    create?: XOR<InvoiceCreateWithoutCryptoPaymentsInput, InvoiceUncheckedCreateWithoutCryptoPaymentsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutCryptoPaymentsInput
    upsert?: InvoiceUpsertWithoutCryptoPaymentsInput
    disconnect?: InvoiceWhereInput | boolean
    delete?: InvoiceWhereInput | boolean
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutCryptoPaymentsInput, InvoiceUpdateWithoutCryptoPaymentsInput>, InvoiceUncheckedUpdateWithoutCryptoPaymentsInput>
  }

  export type TenantCreateNestedOneWithoutExpenseCategoriesInput = {
    create?: XOR<TenantCreateWithoutExpenseCategoriesInput, TenantUncheckedCreateWithoutExpenseCategoriesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutExpenseCategoriesInput
    connect?: TenantWhereUniqueInput
  }

  export type ExpenseCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ExpenseCreateWithoutCategoryInput, ExpenseUncheckedCreateWithoutCategoryInput> | ExpenseCreateWithoutCategoryInput[] | ExpenseUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutCategoryInput | ExpenseCreateOrConnectWithoutCategoryInput[]
    createMany?: ExpenseCreateManyCategoryInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type ExpenseUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ExpenseCreateWithoutCategoryInput, ExpenseUncheckedCreateWithoutCategoryInput> | ExpenseCreateWithoutCategoryInput[] | ExpenseUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutCategoryInput | ExpenseCreateOrConnectWithoutCategoryInput[]
    createMany?: ExpenseCreateManyCategoryInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type TenantUpdateOneRequiredWithoutExpenseCategoriesNestedInput = {
    create?: XOR<TenantCreateWithoutExpenseCategoriesInput, TenantUncheckedCreateWithoutExpenseCategoriesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutExpenseCategoriesInput
    upsert?: TenantUpsertWithoutExpenseCategoriesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutExpenseCategoriesInput, TenantUpdateWithoutExpenseCategoriesInput>, TenantUncheckedUpdateWithoutExpenseCategoriesInput>
  }

  export type ExpenseUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ExpenseCreateWithoutCategoryInput, ExpenseUncheckedCreateWithoutCategoryInput> | ExpenseCreateWithoutCategoryInput[] | ExpenseUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutCategoryInput | ExpenseCreateOrConnectWithoutCategoryInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutCategoryInput | ExpenseUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ExpenseCreateManyCategoryInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutCategoryInput | ExpenseUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutCategoryInput | ExpenseUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type ExpenseUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ExpenseCreateWithoutCategoryInput, ExpenseUncheckedCreateWithoutCategoryInput> | ExpenseCreateWithoutCategoryInput[] | ExpenseUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutCategoryInput | ExpenseCreateOrConnectWithoutCategoryInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutCategoryInput | ExpenseUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ExpenseCreateManyCategoryInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutCategoryInput | ExpenseUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutCategoryInput | ExpenseUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutExpensesInput = {
    create?: XOR<TenantCreateWithoutExpensesInput, TenantUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutExpensesInput
    connect?: TenantWhereUniqueInput
  }

  export type ExpenseCategoryCreateNestedOneWithoutExpensesInput = {
    create?: XOR<ExpenseCategoryCreateWithoutExpensesInput, ExpenseCategoryUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: ExpenseCategoryCreateOrConnectWithoutExpensesInput
    connect?: ExpenseCategoryWhereUniqueInput
  }

  export type EnumExpenseStatusFieldUpdateOperationsInput = {
    set?: $Enums.ExpenseStatus
  }

  export type TenantUpdateOneRequiredWithoutExpensesNestedInput = {
    create?: XOR<TenantCreateWithoutExpensesInput, TenantUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutExpensesInput
    upsert?: TenantUpsertWithoutExpensesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutExpensesInput, TenantUpdateWithoutExpensesInput>, TenantUncheckedUpdateWithoutExpensesInput>
  }

  export type ExpenseCategoryUpdateOneRequiredWithoutExpensesNestedInput = {
    create?: XOR<ExpenseCategoryCreateWithoutExpensesInput, ExpenseCategoryUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: ExpenseCategoryCreateOrConnectWithoutExpensesInput
    upsert?: ExpenseCategoryUpsertWithoutExpensesInput
    connect?: ExpenseCategoryWhereUniqueInput
    update?: XOR<XOR<ExpenseCategoryUpdateToOneWithWhereWithoutExpensesInput, ExpenseCategoryUpdateWithoutExpensesInput>, ExpenseCategoryUncheckedUpdateWithoutExpensesInput>
  }

  export type TenantCreateNestedOneWithoutRecurringInvoiceTemplatesInput = {
    create?: XOR<TenantCreateWithoutRecurringInvoiceTemplatesInput, TenantUncheckedCreateWithoutRecurringInvoiceTemplatesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutRecurringInvoiceTemplatesInput
    connect?: TenantWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutRecurringInvoiceTemplatesNestedInput = {
    create?: XOR<TenantCreateWithoutRecurringInvoiceTemplatesInput, TenantUncheckedCreateWithoutRecurringInvoiceTemplatesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutRecurringInvoiceTemplatesInput
    upsert?: TenantUpsertWithoutRecurringInvoiceTemplatesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutRecurringInvoiceTemplatesInput, TenantUpdateWithoutRecurringInvoiceTemplatesInput>, TenantUncheckedUpdateWithoutRecurringInvoiceTemplatesInput>
  }

  export type CalendarEventSyncCreateNestedManyWithoutIntegrationInput = {
    create?: XOR<CalendarEventSyncCreateWithoutIntegrationInput, CalendarEventSyncUncheckedCreateWithoutIntegrationInput> | CalendarEventSyncCreateWithoutIntegrationInput[] | CalendarEventSyncUncheckedCreateWithoutIntegrationInput[]
    connectOrCreate?: CalendarEventSyncCreateOrConnectWithoutIntegrationInput | CalendarEventSyncCreateOrConnectWithoutIntegrationInput[]
    createMany?: CalendarEventSyncCreateManyIntegrationInputEnvelope
    connect?: CalendarEventSyncWhereUniqueInput | CalendarEventSyncWhereUniqueInput[]
  }

  export type CalendarEventSyncUncheckedCreateNestedManyWithoutIntegrationInput = {
    create?: XOR<CalendarEventSyncCreateWithoutIntegrationInput, CalendarEventSyncUncheckedCreateWithoutIntegrationInput> | CalendarEventSyncCreateWithoutIntegrationInput[] | CalendarEventSyncUncheckedCreateWithoutIntegrationInput[]
    connectOrCreate?: CalendarEventSyncCreateOrConnectWithoutIntegrationInput | CalendarEventSyncCreateOrConnectWithoutIntegrationInput[]
    createMany?: CalendarEventSyncCreateManyIntegrationInputEnvelope
    connect?: CalendarEventSyncWhereUniqueInput | CalendarEventSyncWhereUniqueInput[]
  }

  export type CalendarEventSyncUpdateManyWithoutIntegrationNestedInput = {
    create?: XOR<CalendarEventSyncCreateWithoutIntegrationInput, CalendarEventSyncUncheckedCreateWithoutIntegrationInput> | CalendarEventSyncCreateWithoutIntegrationInput[] | CalendarEventSyncUncheckedCreateWithoutIntegrationInput[]
    connectOrCreate?: CalendarEventSyncCreateOrConnectWithoutIntegrationInput | CalendarEventSyncCreateOrConnectWithoutIntegrationInput[]
    upsert?: CalendarEventSyncUpsertWithWhereUniqueWithoutIntegrationInput | CalendarEventSyncUpsertWithWhereUniqueWithoutIntegrationInput[]
    createMany?: CalendarEventSyncCreateManyIntegrationInputEnvelope
    set?: CalendarEventSyncWhereUniqueInput | CalendarEventSyncWhereUniqueInput[]
    disconnect?: CalendarEventSyncWhereUniqueInput | CalendarEventSyncWhereUniqueInput[]
    delete?: CalendarEventSyncWhereUniqueInput | CalendarEventSyncWhereUniqueInput[]
    connect?: CalendarEventSyncWhereUniqueInput | CalendarEventSyncWhereUniqueInput[]
    update?: CalendarEventSyncUpdateWithWhereUniqueWithoutIntegrationInput | CalendarEventSyncUpdateWithWhereUniqueWithoutIntegrationInput[]
    updateMany?: CalendarEventSyncUpdateManyWithWhereWithoutIntegrationInput | CalendarEventSyncUpdateManyWithWhereWithoutIntegrationInput[]
    deleteMany?: CalendarEventSyncScalarWhereInput | CalendarEventSyncScalarWhereInput[]
  }

  export type CalendarEventSyncUncheckedUpdateManyWithoutIntegrationNestedInput = {
    create?: XOR<CalendarEventSyncCreateWithoutIntegrationInput, CalendarEventSyncUncheckedCreateWithoutIntegrationInput> | CalendarEventSyncCreateWithoutIntegrationInput[] | CalendarEventSyncUncheckedCreateWithoutIntegrationInput[]
    connectOrCreate?: CalendarEventSyncCreateOrConnectWithoutIntegrationInput | CalendarEventSyncCreateOrConnectWithoutIntegrationInput[]
    upsert?: CalendarEventSyncUpsertWithWhereUniqueWithoutIntegrationInput | CalendarEventSyncUpsertWithWhereUniqueWithoutIntegrationInput[]
    createMany?: CalendarEventSyncCreateManyIntegrationInputEnvelope
    set?: CalendarEventSyncWhereUniqueInput | CalendarEventSyncWhereUniqueInput[]
    disconnect?: CalendarEventSyncWhereUniqueInput | CalendarEventSyncWhereUniqueInput[]
    delete?: CalendarEventSyncWhereUniqueInput | CalendarEventSyncWhereUniqueInput[]
    connect?: CalendarEventSyncWhereUniqueInput | CalendarEventSyncWhereUniqueInput[]
    update?: CalendarEventSyncUpdateWithWhereUniqueWithoutIntegrationInput | CalendarEventSyncUpdateWithWhereUniqueWithoutIntegrationInput[]
    updateMany?: CalendarEventSyncUpdateManyWithWhereWithoutIntegrationInput | CalendarEventSyncUpdateManyWithWhereWithoutIntegrationInput[]
    deleteMany?: CalendarEventSyncScalarWhereInput | CalendarEventSyncScalarWhereInput[]
  }

  export type CalendarIntegrationCreateNestedOneWithoutEventSyncsInput = {
    create?: XOR<CalendarIntegrationCreateWithoutEventSyncsInput, CalendarIntegrationUncheckedCreateWithoutEventSyncsInput>
    connectOrCreate?: CalendarIntegrationCreateOrConnectWithoutEventSyncsInput
    connect?: CalendarIntegrationWhereUniqueInput
  }

  export type CalendarIntegrationUpdateOneRequiredWithoutEventSyncsNestedInput = {
    create?: XOR<CalendarIntegrationCreateWithoutEventSyncsInput, CalendarIntegrationUncheckedCreateWithoutEventSyncsInput>
    connectOrCreate?: CalendarIntegrationCreateOrConnectWithoutEventSyncsInput
    upsert?: CalendarIntegrationUpsertWithoutEventSyncsInput
    connect?: CalendarIntegrationWhereUniqueInput
    update?: XOR<XOR<CalendarIntegrationUpdateToOneWithWhereWithoutEventSyncsInput, CalendarIntegrationUpdateWithoutEventSyncsInput>, CalendarIntegrationUncheckedUpdateWithoutEventSyncsInput>
  }

  export type TenantCreateNestedOneWithoutBadgesInput = {
    create?: XOR<TenantCreateWithoutBadgesInput, TenantUncheckedCreateWithoutBadgesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutBadgesInput
    connect?: TenantWhereUniqueInput
  }

  export type ClientBadgeCreateNestedManyWithoutBadgeInput = {
    create?: XOR<ClientBadgeCreateWithoutBadgeInput, ClientBadgeUncheckedCreateWithoutBadgeInput> | ClientBadgeCreateWithoutBadgeInput[] | ClientBadgeUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: ClientBadgeCreateOrConnectWithoutBadgeInput | ClientBadgeCreateOrConnectWithoutBadgeInput[]
    createMany?: ClientBadgeCreateManyBadgeInputEnvelope
    connect?: ClientBadgeWhereUniqueInput | ClientBadgeWhereUniqueInput[]
  }

  export type ClientBadgeUncheckedCreateNestedManyWithoutBadgeInput = {
    create?: XOR<ClientBadgeCreateWithoutBadgeInput, ClientBadgeUncheckedCreateWithoutBadgeInput> | ClientBadgeCreateWithoutBadgeInput[] | ClientBadgeUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: ClientBadgeCreateOrConnectWithoutBadgeInput | ClientBadgeCreateOrConnectWithoutBadgeInput[]
    createMany?: ClientBadgeCreateManyBadgeInputEnvelope
    connect?: ClientBadgeWhereUniqueInput | ClientBadgeWhereUniqueInput[]
  }

  export type TenantUpdateOneRequiredWithoutBadgesNestedInput = {
    create?: XOR<TenantCreateWithoutBadgesInput, TenantUncheckedCreateWithoutBadgesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutBadgesInput
    upsert?: TenantUpsertWithoutBadgesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutBadgesInput, TenantUpdateWithoutBadgesInput>, TenantUncheckedUpdateWithoutBadgesInput>
  }

  export type ClientBadgeUpdateManyWithoutBadgeNestedInput = {
    create?: XOR<ClientBadgeCreateWithoutBadgeInput, ClientBadgeUncheckedCreateWithoutBadgeInput> | ClientBadgeCreateWithoutBadgeInput[] | ClientBadgeUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: ClientBadgeCreateOrConnectWithoutBadgeInput | ClientBadgeCreateOrConnectWithoutBadgeInput[]
    upsert?: ClientBadgeUpsertWithWhereUniqueWithoutBadgeInput | ClientBadgeUpsertWithWhereUniqueWithoutBadgeInput[]
    createMany?: ClientBadgeCreateManyBadgeInputEnvelope
    set?: ClientBadgeWhereUniqueInput | ClientBadgeWhereUniqueInput[]
    disconnect?: ClientBadgeWhereUniqueInput | ClientBadgeWhereUniqueInput[]
    delete?: ClientBadgeWhereUniqueInput | ClientBadgeWhereUniqueInput[]
    connect?: ClientBadgeWhereUniqueInput | ClientBadgeWhereUniqueInput[]
    update?: ClientBadgeUpdateWithWhereUniqueWithoutBadgeInput | ClientBadgeUpdateWithWhereUniqueWithoutBadgeInput[]
    updateMany?: ClientBadgeUpdateManyWithWhereWithoutBadgeInput | ClientBadgeUpdateManyWithWhereWithoutBadgeInput[]
    deleteMany?: ClientBadgeScalarWhereInput | ClientBadgeScalarWhereInput[]
  }

  export type ClientBadgeUncheckedUpdateManyWithoutBadgeNestedInput = {
    create?: XOR<ClientBadgeCreateWithoutBadgeInput, ClientBadgeUncheckedCreateWithoutBadgeInput> | ClientBadgeCreateWithoutBadgeInput[] | ClientBadgeUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: ClientBadgeCreateOrConnectWithoutBadgeInput | ClientBadgeCreateOrConnectWithoutBadgeInput[]
    upsert?: ClientBadgeUpsertWithWhereUniqueWithoutBadgeInput | ClientBadgeUpsertWithWhereUniqueWithoutBadgeInput[]
    createMany?: ClientBadgeCreateManyBadgeInputEnvelope
    set?: ClientBadgeWhereUniqueInput | ClientBadgeWhereUniqueInput[]
    disconnect?: ClientBadgeWhereUniqueInput | ClientBadgeWhereUniqueInput[]
    delete?: ClientBadgeWhereUniqueInput | ClientBadgeWhereUniqueInput[]
    connect?: ClientBadgeWhereUniqueInput | ClientBadgeWhereUniqueInput[]
    update?: ClientBadgeUpdateWithWhereUniqueWithoutBadgeInput | ClientBadgeUpdateWithWhereUniqueWithoutBadgeInput[]
    updateMany?: ClientBadgeUpdateManyWithWhereWithoutBadgeInput | ClientBadgeUpdateManyWithWhereWithoutBadgeInput[]
    deleteMany?: ClientBadgeScalarWhereInput | ClientBadgeScalarWhereInput[]
  }

  export type ClientCreateNestedOneWithoutBadgesInput = {
    create?: XOR<ClientCreateWithoutBadgesInput, ClientUncheckedCreateWithoutBadgesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutBadgesInput
    connect?: ClientWhereUniqueInput
  }

  export type BadgeCreateNestedOneWithoutClientBadgesInput = {
    create?: XOR<BadgeCreateWithoutClientBadgesInput, BadgeUncheckedCreateWithoutClientBadgesInput>
    connectOrCreate?: BadgeCreateOrConnectWithoutClientBadgesInput
    connect?: BadgeWhereUniqueInput
  }

  export type ClientUpdateOneRequiredWithoutBadgesNestedInput = {
    create?: XOR<ClientCreateWithoutBadgesInput, ClientUncheckedCreateWithoutBadgesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutBadgesInput
    upsert?: ClientUpsertWithoutBadgesInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutBadgesInput, ClientUpdateWithoutBadgesInput>, ClientUncheckedUpdateWithoutBadgesInput>
  }

  export type BadgeUpdateOneRequiredWithoutClientBadgesNestedInput = {
    create?: XOR<BadgeCreateWithoutClientBadgesInput, BadgeUncheckedCreateWithoutClientBadgesInput>
    connectOrCreate?: BadgeCreateOrConnectWithoutClientBadgesInput
    upsert?: BadgeUpsertWithoutClientBadgesInput
    connect?: BadgeWhereUniqueInput
    update?: XOR<XOR<BadgeUpdateToOneWithWhereWithoutClientBadgesInput, BadgeUpdateWithoutClientBadgesInput>, BadgeUncheckedUpdateWithoutClientBadgesInput>
  }

  export type WorkoutTemplateCreateexercisesInput = {
    set: InputJsonValue[]
  }

  export type WorkoutTemplateCreatemuscleGroupsInput = {
    set: string[]
  }

  export type WorkoutTemplateCreateequipmentInput = {
    set: string[]
  }

  export type TenantCreateNestedOneWithoutWorkoutTemplatesInput = {
    create?: XOR<TenantCreateWithoutWorkoutTemplatesInput, TenantUncheckedCreateWithoutWorkoutTemplatesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutWorkoutTemplatesInput
    connect?: TenantWhereUniqueInput
  }

  export type WorkoutTemplateUpdateexercisesInput = {
    set?: InputJsonValue[]
    push?: InputJsonValue | InputJsonValue[]
  }

  export type WorkoutTemplateUpdatemuscleGroupsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type WorkoutTemplateUpdateequipmentInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TenantUpdateOneRequiredWithoutWorkoutTemplatesNestedInput = {
    create?: XOR<TenantCreateWithoutWorkoutTemplatesInput, TenantUncheckedCreateWithoutWorkoutTemplatesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutWorkoutTemplatesInput
    upsert?: TenantUpsertWithoutWorkoutTemplatesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutWorkoutTemplatesInput, TenantUpdateWithoutWorkoutTemplatesInput>, TenantUncheckedUpdateWithoutWorkoutTemplatesInput>
  }

  export type ScheduleTemplateCreateslotsInput = {
    set: InputJsonValue[]
  }

  export type TenantCreateNestedOneWithoutScheduleTemplatesInput = {
    create?: XOR<TenantCreateWithoutScheduleTemplatesInput, TenantUncheckedCreateWithoutScheduleTemplatesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutScheduleTemplatesInput
    connect?: TenantWhereUniqueInput
  }

  export type ScheduleTemplateUpdateslotsInput = {
    set?: InputJsonValue[]
    push?: InputJsonValue | InputJsonValue[]
  }

  export type TenantUpdateOneRequiredWithoutScheduleTemplatesNestedInput = {
    create?: XOR<TenantCreateWithoutScheduleTemplatesInput, TenantUncheckedCreateWithoutScheduleTemplatesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutScheduleTemplatesInput
    upsert?: TenantUpsertWithoutScheduleTemplatesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutScheduleTemplatesInput, TenantUpdateWithoutScheduleTemplatesInput>, TenantUncheckedUpdateWithoutScheduleTemplatesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumVerticalFilter<$PrismaModel = never> = {
    equals?: $Enums.Vertical | EnumVerticalFieldRefInput<$PrismaModel>
    in?: $Enums.Vertical[] | ListEnumVerticalFieldRefInput<$PrismaModel>
    notIn?: $Enums.Vertical[] | ListEnumVerticalFieldRefInput<$PrismaModel>
    not?: NestedEnumVerticalFilter<$PrismaModel> | $Enums.Vertical
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumVerticalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Vertical | EnumVerticalFieldRefInput<$PrismaModel>
    in?: $Enums.Vertical[] | ListEnumVerticalFieldRefInput<$PrismaModel>
    notIn?: $Enums.Vertical[] | ListEnumVerticalFieldRefInput<$PrismaModel>
    not?: NestedEnumVerticalWithAggregatesFilter<$PrismaModel> | $Enums.Vertical
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVerticalFilter<$PrismaModel>
    _max?: NestedEnumVerticalFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumBankProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.BankProvider | EnumBankProviderFieldRefInput<$PrismaModel>
    in?: $Enums.BankProvider[] | ListEnumBankProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.BankProvider[] | ListEnumBankProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumBankProviderFilter<$PrismaModel> | $Enums.BankProvider
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedEnumBankProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BankProvider | EnumBankProviderFieldRefInput<$PrismaModel>
    in?: $Enums.BankProvider[] | ListEnumBankProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.BankProvider[] | ListEnumBankProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumBankProviderWithAggregatesFilter<$PrismaModel> | $Enums.BankProvider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBankProviderFilter<$PrismaModel>
    _max?: NestedEnumBankProviderFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type NestedEnumExpenseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ExpenseStatus | EnumExpenseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ExpenseStatus[] | ListEnumExpenseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExpenseStatus[] | ListEnumExpenseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumExpenseStatusFilter<$PrismaModel> | $Enums.ExpenseStatus
  }

  export type NestedEnumExpenseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExpenseStatus | EnumExpenseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ExpenseStatus[] | ListEnumExpenseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExpenseStatus[] | ListEnumExpenseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumExpenseStatusWithAggregatesFilter<$PrismaModel> | $Enums.ExpenseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExpenseStatusFilter<$PrismaModel>
    _max?: NestedEnumExpenseStatusFilter<$PrismaModel>
  }

  export type UserCreateWithoutTenantInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTenantInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTenantInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput>
  }

  export type UserCreateManyTenantInputEnvelope = {
    data: UserCreateManyTenantInput | UserCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type ClientCreateWithoutTenantInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    avatar?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    goals?: ClientCreategoalsInput | string[]
    currentWeight?: number | null
    targetWeight?: number | null
    height?: number | null
    bodyMeasurements?: NullableJsonNullValueInput | InputJsonValue
    bodyFatPercent?: number | null
    fitnessLevel?: string | null
    injuryHistory?: string | null
    dietaryNotes?: string | null
    medicalNotes?: string | null
    creditsRemaining?: number
    membershipType?: string | null
    membershipExpiry?: Date | string | null
    status?: string
    tags?: ClientCreatetagsInput | string[]
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutClientInput
    orders?: OrderCreateNestedManyWithoutClientInput
    invoices?: InvoiceCreateNestedManyWithoutClientInput
    measurements?: ClientMeasurementCreateNestedManyWithoutClientInput
    progressPhotos?: ProgressPhotoCreateNestedManyWithoutClientInput
    badges?: ClientBadgeCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutTenantInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    avatar?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    goals?: ClientCreategoalsInput | string[]
    currentWeight?: number | null
    targetWeight?: number | null
    height?: number | null
    bodyMeasurements?: NullableJsonNullValueInput | InputJsonValue
    bodyFatPercent?: number | null
    fitnessLevel?: string | null
    injuryHistory?: string | null
    dietaryNotes?: string | null
    medicalNotes?: string | null
    creditsRemaining?: number
    membershipType?: string | null
    membershipExpiry?: Date | string | null
    status?: string
    tags?: ClientCreatetagsInput | string[]
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutClientInput
    orders?: OrderUncheckedCreateNestedManyWithoutClientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutClientInput
    measurements?: ClientMeasurementUncheckedCreateNestedManyWithoutClientInput
    progressPhotos?: ProgressPhotoUncheckedCreateNestedManyWithoutClientInput
    badges?: ClientBadgeUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutTenantInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutTenantInput, ClientUncheckedCreateWithoutTenantInput>
  }

  export type ClientCreateManyTenantInputEnvelope = {
    data: ClientCreateManyTenantInput | ClientCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutTenantInput = {
    id?: string
    scheduledAt: Date | string
    duration?: number
    status?: string
    workoutPlan?: NullableJsonNullValueInput | InputJsonValue
    exercisesLogged?: SessionCreateexercisesLoggedInput | InputJsonValue[]
    caloriesBurned?: number | null
    heartRateAvg?: number | null
    muscleGroups?: SessionCreatemuscleGroupsInput | string[]
    clientFeedback?: string | null
    trainerNotes?: string | null
    intensity?: string | null
    clientRating?: number | null
    price?: number | null
    paid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateWithoutTenantInput = {
    id?: string
    clientId: string
    scheduledAt: Date | string
    duration?: number
    status?: string
    workoutPlan?: NullableJsonNullValueInput | InputJsonValue
    exercisesLogged?: SessionCreateexercisesLoggedInput | InputJsonValue[]
    caloriesBurned?: number | null
    heartRateAvg?: number | null
    muscleGroups?: SessionCreatemuscleGroupsInput | string[]
    clientFeedback?: string | null
    trainerNotes?: string | null
    intensity?: string | null
    clientRating?: number | null
    price?: number | null
    paid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionCreateOrConnectWithoutTenantInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutTenantInput, SessionUncheckedCreateWithoutTenantInput>
  }

  export type SessionCreateManyTenantInputEnvelope = {
    data: SessionCreateManyTenantInput | SessionCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type ClassCreateWithoutTenantInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    scheduledAt: Date | string
    duration: number
    capacity?: number
    instructor?: string | null
    location?: string | null
    price: number
    isRecurring?: boolean
    recurrence?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: ClassBookingCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutTenantInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    scheduledAt: Date | string
    duration: number
    capacity?: number
    instructor?: string | null
    location?: string | null
    price: number
    isRecurring?: boolean
    recurrence?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: ClassBookingUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutTenantInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutTenantInput, ClassUncheckedCreateWithoutTenantInput>
  }

  export type ClassCreateManyTenantInputEnvelope = {
    data: ClassCreateManyTenantInput | ClassCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type PackageCreateWithoutTenantInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    price: number
    credits: number
    validityDays: number
    features?: PackageCreatefeaturesInput | string[]
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PackageUncheckedCreateWithoutTenantInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    price: number
    credits: number
    validityDays: number
    features?: PackageCreatefeaturesInput | string[]
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PackageCreateOrConnectWithoutTenantInput = {
    where: PackageWhereUniqueInput
    create: XOR<PackageCreateWithoutTenantInput, PackageUncheckedCreateWithoutTenantInput>
  }

  export type PackageCreateManyTenantInputEnvelope = {
    data: PackageCreateManyTenantInput | PackageCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutTenantInput = {
    id?: string
    orderNumber: string
    status?: string
    items?: OrderCreateitemsInput | InputJsonValue[]
    subtotal: number
    tax?: number
    discount?: number
    total: number
    paymentMethod?: string | null
    paymentStatus?: string
    paidAmount?: number
    orderDate?: Date | string
    dueDate?: Date | string | null
    paidDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutOrdersInput
    invoices?: InvoiceCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutTenantInput = {
    id?: string
    clientId: string
    orderNumber: string
    status?: string
    items?: OrderCreateitemsInput | InputJsonValue[]
    subtotal: number
    tax?: number
    discount?: number
    total: number
    paymentMethod?: string | null
    paymentStatus?: string
    paidAmount?: number
    orderDate?: Date | string
    dueDate?: Date | string | null
    paidDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutTenantInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutTenantInput, OrderUncheckedCreateWithoutTenantInput>
  }

  export type OrderCreateManyTenantInputEnvelope = {
    data: OrderCreateManyTenantInput | OrderCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutTenantInput = {
    id?: string
    invoiceNumber: string
    status?: string
    issueDate?: Date | string
    dueDate: Date | string
    paidDate?: Date | string | null
    subtotal: number
    tax?: number
    total: number
    paymentMethod?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: OrderCreateNestedOneWithoutInvoicesInput
    client: ClientCreateNestedOneWithoutInvoicesInput
    payments?: InvoicePaymentCreateNestedManyWithoutInvoiceInput
    bankTransactions?: BankTransactionCreateNestedManyWithoutMatchedInvoiceInput
    cryptoPayments?: CryptoPaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutTenantInput = {
    id?: string
    orderId?: string | null
    clientId: string
    invoiceNumber: string
    status?: string
    issueDate?: Date | string
    dueDate: Date | string
    paidDate?: Date | string | null
    subtotal: number
    tax?: number
    total: number
    paymentMethod?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: InvoicePaymentUncheckedCreateNestedManyWithoutInvoiceInput
    bankTransactions?: BankTransactionUncheckedCreateNestedManyWithoutMatchedInvoiceInput
    cryptoPayments?: CryptoPaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutTenantInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutTenantInput, InvoiceUncheckedCreateWithoutTenantInput>
  }

  export type InvoiceCreateManyTenantInputEnvelope = {
    data: InvoiceCreateManyTenantInput | InvoiceCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type AILogCreateWithoutTenantInput = {
    id?: string
    feature: string
    model: string
    promptTokens: number
    completionTokens: number
    totalTokens: number
    estimatedCost: number
    input: JsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    latencyMs?: number | null
    success?: boolean
    error?: string | null
    createdAt?: Date | string
  }

  export type AILogUncheckedCreateWithoutTenantInput = {
    id?: string
    feature: string
    model: string
    promptTokens: number
    completionTokens: number
    totalTokens: number
    estimatedCost: number
    input: JsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    latencyMs?: number | null
    success?: boolean
    error?: string | null
    createdAt?: Date | string
  }

  export type AILogCreateOrConnectWithoutTenantInput = {
    where: AILogWhereUniqueInput
    create: XOR<AILogCreateWithoutTenantInput, AILogUncheckedCreateWithoutTenantInput>
  }

  export type AILogCreateManyTenantInputEnvelope = {
    data: AILogCreateManyTenantInput | AILogCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type BankAccountCreateWithoutTenantInput = {
    id?: string
    accountName: string
    accountNumber: string
    bankCode?: string | null
    iban?: string | null
    swift?: string | null
    provider: $Enums.BankProvider
    providerAccountId?: string | null
    currency?: string
    balance?: Decimal | DecimalJsLike | number | string | null
    balanceUpdatedAt?: Date | string | null
    autoSync?: boolean
    lastSyncAt?: Date | string | null
    syncFrequency?: string
    credentials?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: BankTransactionCreateNestedManyWithoutBankAccountInput
  }

  export type BankAccountUncheckedCreateWithoutTenantInput = {
    id?: string
    accountName: string
    accountNumber: string
    bankCode?: string | null
    iban?: string | null
    swift?: string | null
    provider: $Enums.BankProvider
    providerAccountId?: string | null
    currency?: string
    balance?: Decimal | DecimalJsLike | number | string | null
    balanceUpdatedAt?: Date | string | null
    autoSync?: boolean
    lastSyncAt?: Date | string | null
    syncFrequency?: string
    credentials?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: BankTransactionUncheckedCreateNestedManyWithoutBankAccountInput
  }

  export type BankAccountCreateOrConnectWithoutTenantInput = {
    where: BankAccountWhereUniqueInput
    create: XOR<BankAccountCreateWithoutTenantInput, BankAccountUncheckedCreateWithoutTenantInput>
  }

  export type BankAccountCreateManyTenantInputEnvelope = {
    data: BankAccountCreateManyTenantInput | BankAccountCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type BankTransactionCreateWithoutTenantInput = {
    id?: string
    transactionId: string
    date: Date | string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    type: $Enums.TransactionType
    counterpartyName?: string | null
    counterpartyAccount?: string | null
    counterpartyBankCode?: string | null
    description?: string | null
    note?: string | null
    variableSymbol?: string | null
    constantSymbol?: string | null
    specificSymbol?: string | null
    reference?: string | null
    isMatched?: boolean
    matchedPaymentId?: string | null
    matchConfidence?: Decimal | DecimalJsLike | number | string | null
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    bankAccount: BankAccountCreateNestedOneWithoutTransactionsInput
    matchedInvoice?: InvoiceCreateNestedOneWithoutBankTransactionsInput
  }

  export type BankTransactionUncheckedCreateWithoutTenantInput = {
    id?: string
    bankAccountId: string
    transactionId: string
    date: Date | string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    type: $Enums.TransactionType
    counterpartyName?: string | null
    counterpartyAccount?: string | null
    counterpartyBankCode?: string | null
    description?: string | null
    note?: string | null
    variableSymbol?: string | null
    constantSymbol?: string | null
    specificSymbol?: string | null
    reference?: string | null
    isMatched?: boolean
    matchedInvoiceId?: string | null
    matchedPaymentId?: string | null
    matchConfidence?: Decimal | DecimalJsLike | number | string | null
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankTransactionCreateOrConnectWithoutTenantInput = {
    where: BankTransactionWhereUniqueInput
    create: XOR<BankTransactionCreateWithoutTenantInput, BankTransactionUncheckedCreateWithoutTenantInput>
  }

  export type BankTransactionCreateManyTenantInputEnvelope = {
    data: BankTransactionCreateManyTenantInput | BankTransactionCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type InvoicePaymentCreateWithoutTenantInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    method: $Enums.PaymentMethod
    status?: string
    gatewayProvider?: string | null
    gatewayPaymentId?: string | null
    gatewayFee?: Decimal | DecimalJsLike | number | string | null
    transactionId?: string | null
    reference?: string | null
    processedAt?: Date | string | null
    completedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice: InvoiceCreateNestedOneWithoutPaymentsInput
  }

  export type InvoicePaymentUncheckedCreateWithoutTenantInput = {
    id?: string
    invoiceId: string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    method: $Enums.PaymentMethod
    status?: string
    gatewayProvider?: string | null
    gatewayPaymentId?: string | null
    gatewayFee?: Decimal | DecimalJsLike | number | string | null
    transactionId?: string | null
    reference?: string | null
    processedAt?: Date | string | null
    completedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoicePaymentCreateOrConnectWithoutTenantInput = {
    where: InvoicePaymentWhereUniqueInput
    create: XOR<InvoicePaymentCreateWithoutTenantInput, InvoicePaymentUncheckedCreateWithoutTenantInput>
  }

  export type InvoicePaymentCreateManyTenantInputEnvelope = {
    data: InvoicePaymentCreateManyTenantInput | InvoicePaymentCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type PaymentGatewayConfigCreateWithoutTenantInput = {
    id?: string
    provider: string
    config: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    isTest?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentGatewayConfigUncheckedCreateWithoutTenantInput = {
    id?: string
    provider: string
    config: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    isTest?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentGatewayConfigCreateOrConnectWithoutTenantInput = {
    where: PaymentGatewayConfigWhereUniqueInput
    create: XOR<PaymentGatewayConfigCreateWithoutTenantInput, PaymentGatewayConfigUncheckedCreateWithoutTenantInput>
  }

  export type PaymentGatewayConfigCreateManyTenantInputEnvelope = {
    data: PaymentGatewayConfigCreateManyTenantInput | PaymentGatewayConfigCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type CryptoWalletCreateWithoutTenantInput = {
    id?: string
    currency: string
    address: string
    network?: string | null
    provider: string
    isActive?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: CryptoPaymentCreateNestedManyWithoutWalletInput
  }

  export type CryptoWalletUncheckedCreateWithoutTenantInput = {
    id?: string
    currency: string
    address: string
    network?: string | null
    provider: string
    isActive?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: CryptoPaymentUncheckedCreateNestedManyWithoutWalletInput
  }

  export type CryptoWalletCreateOrConnectWithoutTenantInput = {
    where: CryptoWalletWhereUniqueInput
    create: XOR<CryptoWalletCreateWithoutTenantInput, CryptoWalletUncheckedCreateWithoutTenantInput>
  }

  export type CryptoWalletCreateManyTenantInputEnvelope = {
    data: CryptoWalletCreateManyTenantInput | CryptoWalletCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type ExpenseCategoryCreateWithoutTenantInput = {
    id?: string
    name: string
    description?: string | null
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    expenses?: ExpenseCreateNestedManyWithoutCategoryInput
  }

  export type ExpenseCategoryUncheckedCreateWithoutTenantInput = {
    id?: string
    name: string
    description?: string | null
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ExpenseCategoryCreateOrConnectWithoutTenantInput = {
    where: ExpenseCategoryWhereUniqueInput
    create: XOR<ExpenseCategoryCreateWithoutTenantInput, ExpenseCategoryUncheckedCreateWithoutTenantInput>
  }

  export type ExpenseCategoryCreateManyTenantInputEnvelope = {
    data: ExpenseCategoryCreateManyTenantInput | ExpenseCategoryCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type ExpenseCreateWithoutTenantInput = {
    id?: string
    description: string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    date: Date | string
    vendor?: string | null
    receiptUrl?: string | null
    receiptOcrData?: NullableJsonNullValueInput | InputJsonValue
    taxAmount?: Decimal | DecimalJsLike | number | string | null
    isTaxDeductible?: boolean
    status: $Enums.ExpenseStatus
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectedReason?: string | null
    reimbursedAt?: Date | string | null
    reimbursedAmount?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    category: ExpenseCategoryCreateNestedOneWithoutExpensesInput
  }

  export type ExpenseUncheckedCreateWithoutTenantInput = {
    id?: string
    categoryId: string
    description: string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    date: Date | string
    vendor?: string | null
    receiptUrl?: string | null
    receiptOcrData?: NullableJsonNullValueInput | InputJsonValue
    taxAmount?: Decimal | DecimalJsLike | number | string | null
    isTaxDeductible?: boolean
    status: $Enums.ExpenseStatus
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectedReason?: string | null
    reimbursedAt?: Date | string | null
    reimbursedAmount?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseCreateOrConnectWithoutTenantInput = {
    where: ExpenseWhereUniqueInput
    create: XOR<ExpenseCreateWithoutTenantInput, ExpenseUncheckedCreateWithoutTenantInput>
  }

  export type ExpenseCreateManyTenantInputEnvelope = {
    data: ExpenseCreateManyTenantInput | ExpenseCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type RecurringInvoiceTemplateCreateWithoutTenantInput = {
    id?: string
    frequency: string
    nextInvoiceDate: Date | string
    isActive?: boolean
    invoiceTemplate: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecurringInvoiceTemplateUncheckedCreateWithoutTenantInput = {
    id?: string
    frequency: string
    nextInvoiceDate: Date | string
    isActive?: boolean
    invoiceTemplate: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecurringInvoiceTemplateCreateOrConnectWithoutTenantInput = {
    where: RecurringInvoiceTemplateWhereUniqueInput
    create: XOR<RecurringInvoiceTemplateCreateWithoutTenantInput, RecurringInvoiceTemplateUncheckedCreateWithoutTenantInput>
  }

  export type RecurringInvoiceTemplateCreateManyTenantInputEnvelope = {
    data: RecurringInvoiceTemplateCreateManyTenantInput | RecurringInvoiceTemplateCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type BadgeCreateWithoutTenantInput = {
    id?: string
    name: string
    description: string
    icon: string
    color: string
    category: string
    criteria: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clientBadges?: ClientBadgeCreateNestedManyWithoutBadgeInput
  }

  export type BadgeUncheckedCreateWithoutTenantInput = {
    id?: string
    name: string
    description: string
    icon: string
    color: string
    category: string
    criteria: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clientBadges?: ClientBadgeUncheckedCreateNestedManyWithoutBadgeInput
  }

  export type BadgeCreateOrConnectWithoutTenantInput = {
    where: BadgeWhereUniqueInput
    create: XOR<BadgeCreateWithoutTenantInput, BadgeUncheckedCreateWithoutTenantInput>
  }

  export type BadgeCreateManyTenantInputEnvelope = {
    data: BadgeCreateManyTenantInput | BadgeCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type WorkoutTemplateCreateWithoutTenantInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    difficulty: string
    duration: number
    exercises?: WorkoutTemplateCreateexercisesInput | InputJsonValue[]
    muscleGroups?: WorkoutTemplateCreatemuscleGroupsInput | string[]
    equipment?: WorkoutTemplateCreateequipmentInput | string[]
    isPublic?: boolean
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkoutTemplateUncheckedCreateWithoutTenantInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    difficulty: string
    duration: number
    exercises?: WorkoutTemplateCreateexercisesInput | InputJsonValue[]
    muscleGroups?: WorkoutTemplateCreatemuscleGroupsInput | string[]
    equipment?: WorkoutTemplateCreateequipmentInput | string[]
    isPublic?: boolean
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkoutTemplateCreateOrConnectWithoutTenantInput = {
    where: WorkoutTemplateWhereUniqueInput
    create: XOR<WorkoutTemplateCreateWithoutTenantInput, WorkoutTemplateUncheckedCreateWithoutTenantInput>
  }

  export type WorkoutTemplateCreateManyTenantInputEnvelope = {
    data: WorkoutTemplateCreateManyTenantInput | WorkoutTemplateCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type ScheduleTemplateCreateWithoutTenantInput = {
    id?: string
    name: string
    description?: string | null
    slots?: ScheduleTemplateCreateslotsInput | InputJsonValue[]
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduleTemplateUncheckedCreateWithoutTenantInput = {
    id?: string
    name: string
    description?: string | null
    slots?: ScheduleTemplateCreateslotsInput | InputJsonValue[]
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduleTemplateCreateOrConnectWithoutTenantInput = {
    where: ScheduleTemplateWhereUniqueInput
    create: XOR<ScheduleTemplateCreateWithoutTenantInput, ScheduleTemplateUncheckedCreateWithoutTenantInput>
  }

  export type ScheduleTemplateCreateManyTenantInputEnvelope = {
    data: ScheduleTemplateCreateManyTenantInput | ScheduleTemplateCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutTenantInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutTenantInput, UserUncheckedUpdateWithoutTenantInput>
    create: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput>
  }

  export type UserUpdateWithWhereUniqueWithoutTenantInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutTenantInput, UserUncheckedUpdateWithoutTenantInput>
  }

  export type UserUpdateManyWithWhereWithoutTenantInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutTenantInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    tenantId?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type ClientUpsertWithWhereUniqueWithoutTenantInput = {
    where: ClientWhereUniqueInput
    update: XOR<ClientUpdateWithoutTenantInput, ClientUncheckedUpdateWithoutTenantInput>
    create: XOR<ClientCreateWithoutTenantInput, ClientUncheckedCreateWithoutTenantInput>
  }

  export type ClientUpdateWithWhereUniqueWithoutTenantInput = {
    where: ClientWhereUniqueInput
    data: XOR<ClientUpdateWithoutTenantInput, ClientUncheckedUpdateWithoutTenantInput>
  }

  export type ClientUpdateManyWithWhereWithoutTenantInput = {
    where: ClientScalarWhereInput
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyWithoutTenantInput>
  }

  export type ClientScalarWhereInput = {
    AND?: ClientScalarWhereInput | ClientScalarWhereInput[]
    OR?: ClientScalarWhereInput[]
    NOT?: ClientScalarWhereInput | ClientScalarWhereInput[]
    id?: StringFilter<"Client"> | string
    tenantId?: StringFilter<"Client"> | string
    name?: StringFilter<"Client"> | string
    email?: StringFilter<"Client"> | string
    phone?: StringNullableFilter<"Client"> | string | null
    avatar?: StringNullableFilter<"Client"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"Client"> | Date | string | null
    gender?: StringNullableFilter<"Client"> | string | null
    goals?: StringNullableListFilter<"Client">
    currentWeight?: FloatNullableFilter<"Client"> | number | null
    targetWeight?: FloatNullableFilter<"Client"> | number | null
    height?: FloatNullableFilter<"Client"> | number | null
    bodyMeasurements?: JsonNullableFilter<"Client">
    bodyFatPercent?: FloatNullableFilter<"Client"> | number | null
    fitnessLevel?: StringNullableFilter<"Client"> | string | null
    injuryHistory?: StringNullableFilter<"Client"> | string | null
    dietaryNotes?: StringNullableFilter<"Client"> | string | null
    medicalNotes?: StringNullableFilter<"Client"> | string | null
    creditsRemaining?: IntFilter<"Client"> | number
    membershipType?: StringNullableFilter<"Client"> | string | null
    membershipExpiry?: DateTimeNullableFilter<"Client"> | Date | string | null
    status?: StringFilter<"Client"> | string
    tags?: StringNullableListFilter<"Client">
    notes?: StringNullableFilter<"Client"> | string | null
    createdAt?: DateTimeFilter<"Client"> | Date | string
    updatedAt?: DateTimeFilter<"Client"> | Date | string
  }

  export type SessionUpsertWithWhereUniqueWithoutTenantInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutTenantInput, SessionUncheckedUpdateWithoutTenantInput>
    create: XOR<SessionCreateWithoutTenantInput, SessionUncheckedCreateWithoutTenantInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutTenantInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutTenantInput, SessionUncheckedUpdateWithoutTenantInput>
  }

  export type SessionUpdateManyWithWhereWithoutTenantInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutTenantInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    tenantId?: StringFilter<"Session"> | string
    clientId?: StringFilter<"Session"> | string
    scheduledAt?: DateTimeFilter<"Session"> | Date | string
    duration?: IntFilter<"Session"> | number
    status?: StringFilter<"Session"> | string
    workoutPlan?: JsonNullableFilter<"Session">
    exercisesLogged?: JsonNullableListFilter<"Session">
    caloriesBurned?: IntNullableFilter<"Session"> | number | null
    heartRateAvg?: IntNullableFilter<"Session"> | number | null
    muscleGroups?: StringNullableListFilter<"Session">
    clientFeedback?: StringNullableFilter<"Session"> | string | null
    trainerNotes?: StringNullableFilter<"Session"> | string | null
    intensity?: StringNullableFilter<"Session"> | string | null
    clientRating?: IntNullableFilter<"Session"> | number | null
    price?: FloatNullableFilter<"Session"> | number | null
    paid?: BoolFilter<"Session"> | boolean
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
  }

  export type ClassUpsertWithWhereUniqueWithoutTenantInput = {
    where: ClassWhereUniqueInput
    update: XOR<ClassUpdateWithoutTenantInput, ClassUncheckedUpdateWithoutTenantInput>
    create: XOR<ClassCreateWithoutTenantInput, ClassUncheckedCreateWithoutTenantInput>
  }

  export type ClassUpdateWithWhereUniqueWithoutTenantInput = {
    where: ClassWhereUniqueInput
    data: XOR<ClassUpdateWithoutTenantInput, ClassUncheckedUpdateWithoutTenantInput>
  }

  export type ClassUpdateManyWithWhereWithoutTenantInput = {
    where: ClassScalarWhereInput
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyWithoutTenantInput>
  }

  export type ClassScalarWhereInput = {
    AND?: ClassScalarWhereInput | ClassScalarWhereInput[]
    OR?: ClassScalarWhereInput[]
    NOT?: ClassScalarWhereInput | ClassScalarWhereInput[]
    id?: StringFilter<"Class"> | string
    tenantId?: StringFilter<"Class"> | string
    name?: StringFilter<"Class"> | string
    description?: StringNullableFilter<"Class"> | string | null
    type?: StringFilter<"Class"> | string
    scheduledAt?: DateTimeFilter<"Class"> | Date | string
    duration?: IntFilter<"Class"> | number
    capacity?: IntFilter<"Class"> | number
    instructor?: StringNullableFilter<"Class"> | string | null
    location?: StringNullableFilter<"Class"> | string | null
    price?: FloatFilter<"Class"> | number
    isRecurring?: BoolFilter<"Class"> | boolean
    recurrence?: StringNullableFilter<"Class"> | string | null
    status?: StringFilter<"Class"> | string
    createdAt?: DateTimeFilter<"Class"> | Date | string
    updatedAt?: DateTimeFilter<"Class"> | Date | string
  }

  export type PackageUpsertWithWhereUniqueWithoutTenantInput = {
    where: PackageWhereUniqueInput
    update: XOR<PackageUpdateWithoutTenantInput, PackageUncheckedUpdateWithoutTenantInput>
    create: XOR<PackageCreateWithoutTenantInput, PackageUncheckedCreateWithoutTenantInput>
  }

  export type PackageUpdateWithWhereUniqueWithoutTenantInput = {
    where: PackageWhereUniqueInput
    data: XOR<PackageUpdateWithoutTenantInput, PackageUncheckedUpdateWithoutTenantInput>
  }

  export type PackageUpdateManyWithWhereWithoutTenantInput = {
    where: PackageScalarWhereInput
    data: XOR<PackageUpdateManyMutationInput, PackageUncheckedUpdateManyWithoutTenantInput>
  }

  export type PackageScalarWhereInput = {
    AND?: PackageScalarWhereInput | PackageScalarWhereInput[]
    OR?: PackageScalarWhereInput[]
    NOT?: PackageScalarWhereInput | PackageScalarWhereInput[]
    id?: StringFilter<"Package"> | string
    tenantId?: StringFilter<"Package"> | string
    name?: StringFilter<"Package"> | string
    description?: StringNullableFilter<"Package"> | string | null
    type?: StringFilter<"Package"> | string
    price?: FloatFilter<"Package"> | number
    credits?: IntFilter<"Package"> | number
    validityDays?: IntFilter<"Package"> | number
    features?: StringNullableListFilter<"Package">
    isActive?: BoolFilter<"Package"> | boolean
    createdAt?: DateTimeFilter<"Package"> | Date | string
    updatedAt?: DateTimeFilter<"Package"> | Date | string
  }

  export type OrderUpsertWithWhereUniqueWithoutTenantInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutTenantInput, OrderUncheckedUpdateWithoutTenantInput>
    create: XOR<OrderCreateWithoutTenantInput, OrderUncheckedCreateWithoutTenantInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutTenantInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutTenantInput, OrderUncheckedUpdateWithoutTenantInput>
  }

  export type OrderUpdateManyWithWhereWithoutTenantInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutTenantInput>
  }

  export type OrderScalarWhereInput = {
    AND?: OrderScalarWhereInput | OrderScalarWhereInput[]
    OR?: OrderScalarWhereInput[]
    NOT?: OrderScalarWhereInput | OrderScalarWhereInput[]
    id?: StringFilter<"Order"> | string
    tenantId?: StringFilter<"Order"> | string
    clientId?: StringFilter<"Order"> | string
    orderNumber?: StringFilter<"Order"> | string
    status?: StringFilter<"Order"> | string
    items?: JsonNullableListFilter<"Order">
    subtotal?: FloatFilter<"Order"> | number
    tax?: FloatFilter<"Order"> | number
    discount?: FloatFilter<"Order"> | number
    total?: FloatFilter<"Order"> | number
    paymentMethod?: StringNullableFilter<"Order"> | string | null
    paymentStatus?: StringFilter<"Order"> | string
    paidAmount?: FloatFilter<"Order"> | number
    orderDate?: DateTimeFilter<"Order"> | Date | string
    dueDate?: DateTimeNullableFilter<"Order"> | Date | string | null
    paidDate?: DateTimeNullableFilter<"Order"> | Date | string | null
    notes?: StringNullableFilter<"Order"> | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
  }

  export type InvoiceUpsertWithWhereUniqueWithoutTenantInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutTenantInput, InvoiceUncheckedUpdateWithoutTenantInput>
    create: XOR<InvoiceCreateWithoutTenantInput, InvoiceUncheckedCreateWithoutTenantInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutTenantInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutTenantInput, InvoiceUncheckedUpdateWithoutTenantInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutTenantInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutTenantInput>
  }

  export type InvoiceScalarWhereInput = {
    AND?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    OR?: InvoiceScalarWhereInput[]
    NOT?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    id?: StringFilter<"Invoice"> | string
    tenantId?: StringFilter<"Invoice"> | string
    orderId?: StringNullableFilter<"Invoice"> | string | null
    clientId?: StringFilter<"Invoice"> | string
    invoiceNumber?: StringFilter<"Invoice"> | string
    status?: StringFilter<"Invoice"> | string
    issueDate?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    paidDate?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    subtotal?: FloatFilter<"Invoice"> | number
    tax?: FloatFilter<"Invoice"> | number
    total?: FloatFilter<"Invoice"> | number
    paymentMethod?: StringNullableFilter<"Invoice"> | string | null
    notes?: StringNullableFilter<"Invoice"> | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
  }

  export type AILogUpsertWithWhereUniqueWithoutTenantInput = {
    where: AILogWhereUniqueInput
    update: XOR<AILogUpdateWithoutTenantInput, AILogUncheckedUpdateWithoutTenantInput>
    create: XOR<AILogCreateWithoutTenantInput, AILogUncheckedCreateWithoutTenantInput>
  }

  export type AILogUpdateWithWhereUniqueWithoutTenantInput = {
    where: AILogWhereUniqueInput
    data: XOR<AILogUpdateWithoutTenantInput, AILogUncheckedUpdateWithoutTenantInput>
  }

  export type AILogUpdateManyWithWhereWithoutTenantInput = {
    where: AILogScalarWhereInput
    data: XOR<AILogUpdateManyMutationInput, AILogUncheckedUpdateManyWithoutTenantInput>
  }

  export type AILogScalarWhereInput = {
    AND?: AILogScalarWhereInput | AILogScalarWhereInput[]
    OR?: AILogScalarWhereInput[]
    NOT?: AILogScalarWhereInput | AILogScalarWhereInput[]
    id?: StringFilter<"AILog"> | string
    tenantId?: StringFilter<"AILog"> | string
    feature?: StringFilter<"AILog"> | string
    model?: StringFilter<"AILog"> | string
    promptTokens?: IntFilter<"AILog"> | number
    completionTokens?: IntFilter<"AILog"> | number
    totalTokens?: IntFilter<"AILog"> | number
    estimatedCost?: FloatFilter<"AILog"> | number
    input?: JsonFilter<"AILog">
    output?: JsonNullableFilter<"AILog">
    latencyMs?: IntNullableFilter<"AILog"> | number | null
    success?: BoolFilter<"AILog"> | boolean
    error?: StringNullableFilter<"AILog"> | string | null
    createdAt?: DateTimeFilter<"AILog"> | Date | string
  }

  export type BankAccountUpsertWithWhereUniqueWithoutTenantInput = {
    where: BankAccountWhereUniqueInput
    update: XOR<BankAccountUpdateWithoutTenantInput, BankAccountUncheckedUpdateWithoutTenantInput>
    create: XOR<BankAccountCreateWithoutTenantInput, BankAccountUncheckedCreateWithoutTenantInput>
  }

  export type BankAccountUpdateWithWhereUniqueWithoutTenantInput = {
    where: BankAccountWhereUniqueInput
    data: XOR<BankAccountUpdateWithoutTenantInput, BankAccountUncheckedUpdateWithoutTenantInput>
  }

  export type BankAccountUpdateManyWithWhereWithoutTenantInput = {
    where: BankAccountScalarWhereInput
    data: XOR<BankAccountUpdateManyMutationInput, BankAccountUncheckedUpdateManyWithoutTenantInput>
  }

  export type BankAccountScalarWhereInput = {
    AND?: BankAccountScalarWhereInput | BankAccountScalarWhereInput[]
    OR?: BankAccountScalarWhereInput[]
    NOT?: BankAccountScalarWhereInput | BankAccountScalarWhereInput[]
    id?: StringFilter<"BankAccount"> | string
    tenantId?: StringFilter<"BankAccount"> | string
    accountName?: StringFilter<"BankAccount"> | string
    accountNumber?: StringFilter<"BankAccount"> | string
    bankCode?: StringNullableFilter<"BankAccount"> | string | null
    iban?: StringNullableFilter<"BankAccount"> | string | null
    swift?: StringNullableFilter<"BankAccount"> | string | null
    provider?: EnumBankProviderFilter<"BankAccount"> | $Enums.BankProvider
    providerAccountId?: StringNullableFilter<"BankAccount"> | string | null
    currency?: StringFilter<"BankAccount"> | string
    balance?: DecimalNullableFilter<"BankAccount"> | Decimal | DecimalJsLike | number | string | null
    balanceUpdatedAt?: DateTimeNullableFilter<"BankAccount"> | Date | string | null
    autoSync?: BoolFilter<"BankAccount"> | boolean
    lastSyncAt?: DateTimeNullableFilter<"BankAccount"> | Date | string | null
    syncFrequency?: StringFilter<"BankAccount"> | string
    credentials?: JsonNullableFilter<"BankAccount">
    isActive?: BoolFilter<"BankAccount"> | boolean
    metadata?: JsonNullableFilter<"BankAccount">
    createdAt?: DateTimeFilter<"BankAccount"> | Date | string
    updatedAt?: DateTimeFilter<"BankAccount"> | Date | string
  }

  export type BankTransactionUpsertWithWhereUniqueWithoutTenantInput = {
    where: BankTransactionWhereUniqueInput
    update: XOR<BankTransactionUpdateWithoutTenantInput, BankTransactionUncheckedUpdateWithoutTenantInput>
    create: XOR<BankTransactionCreateWithoutTenantInput, BankTransactionUncheckedCreateWithoutTenantInput>
  }

  export type BankTransactionUpdateWithWhereUniqueWithoutTenantInput = {
    where: BankTransactionWhereUniqueInput
    data: XOR<BankTransactionUpdateWithoutTenantInput, BankTransactionUncheckedUpdateWithoutTenantInput>
  }

  export type BankTransactionUpdateManyWithWhereWithoutTenantInput = {
    where: BankTransactionScalarWhereInput
    data: XOR<BankTransactionUpdateManyMutationInput, BankTransactionUncheckedUpdateManyWithoutTenantInput>
  }

  export type BankTransactionScalarWhereInput = {
    AND?: BankTransactionScalarWhereInput | BankTransactionScalarWhereInput[]
    OR?: BankTransactionScalarWhereInput[]
    NOT?: BankTransactionScalarWhereInput | BankTransactionScalarWhereInput[]
    id?: StringFilter<"BankTransaction"> | string
    bankAccountId?: StringFilter<"BankTransaction"> | string
    tenantId?: StringFilter<"BankTransaction"> | string
    transactionId?: StringFilter<"BankTransaction"> | string
    date?: DateTimeFilter<"BankTransaction"> | Date | string
    amount?: DecimalFilter<"BankTransaction"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"BankTransaction"> | string
    type?: EnumTransactionTypeFilter<"BankTransaction"> | $Enums.TransactionType
    counterpartyName?: StringNullableFilter<"BankTransaction"> | string | null
    counterpartyAccount?: StringNullableFilter<"BankTransaction"> | string | null
    counterpartyBankCode?: StringNullableFilter<"BankTransaction"> | string | null
    description?: StringNullableFilter<"BankTransaction"> | string | null
    note?: StringNullableFilter<"BankTransaction"> | string | null
    variableSymbol?: StringNullableFilter<"BankTransaction"> | string | null
    constantSymbol?: StringNullableFilter<"BankTransaction"> | string | null
    specificSymbol?: StringNullableFilter<"BankTransaction"> | string | null
    reference?: StringNullableFilter<"BankTransaction"> | string | null
    isMatched?: BoolFilter<"BankTransaction"> | boolean
    matchedInvoiceId?: StringNullableFilter<"BankTransaction"> | string | null
    matchedPaymentId?: StringNullableFilter<"BankTransaction"> | string | null
    matchConfidence?: DecimalNullableFilter<"BankTransaction"> | Decimal | DecimalJsLike | number | string | null
    aiSuggestions?: JsonNullableFilter<"BankTransaction">
    metadata?: JsonNullableFilter<"BankTransaction">
    createdAt?: DateTimeFilter<"BankTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"BankTransaction"> | Date | string
  }

  export type InvoicePaymentUpsertWithWhereUniqueWithoutTenantInput = {
    where: InvoicePaymentWhereUniqueInput
    update: XOR<InvoicePaymentUpdateWithoutTenantInput, InvoicePaymentUncheckedUpdateWithoutTenantInput>
    create: XOR<InvoicePaymentCreateWithoutTenantInput, InvoicePaymentUncheckedCreateWithoutTenantInput>
  }

  export type InvoicePaymentUpdateWithWhereUniqueWithoutTenantInput = {
    where: InvoicePaymentWhereUniqueInput
    data: XOR<InvoicePaymentUpdateWithoutTenantInput, InvoicePaymentUncheckedUpdateWithoutTenantInput>
  }

  export type InvoicePaymentUpdateManyWithWhereWithoutTenantInput = {
    where: InvoicePaymentScalarWhereInput
    data: XOR<InvoicePaymentUpdateManyMutationInput, InvoicePaymentUncheckedUpdateManyWithoutTenantInput>
  }

  export type InvoicePaymentScalarWhereInput = {
    AND?: InvoicePaymentScalarWhereInput | InvoicePaymentScalarWhereInput[]
    OR?: InvoicePaymentScalarWhereInput[]
    NOT?: InvoicePaymentScalarWhereInput | InvoicePaymentScalarWhereInput[]
    id?: StringFilter<"InvoicePayment"> | string
    tenantId?: StringFilter<"InvoicePayment"> | string
    invoiceId?: StringFilter<"InvoicePayment"> | string
    amount?: DecimalFilter<"InvoicePayment"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"InvoicePayment"> | string
    method?: EnumPaymentMethodFilter<"InvoicePayment"> | $Enums.PaymentMethod
    status?: StringFilter<"InvoicePayment"> | string
    gatewayProvider?: StringNullableFilter<"InvoicePayment"> | string | null
    gatewayPaymentId?: StringNullableFilter<"InvoicePayment"> | string | null
    gatewayFee?: DecimalNullableFilter<"InvoicePayment"> | Decimal | DecimalJsLike | number | string | null
    transactionId?: StringNullableFilter<"InvoicePayment"> | string | null
    reference?: StringNullableFilter<"InvoicePayment"> | string | null
    processedAt?: DateTimeNullableFilter<"InvoicePayment"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"InvoicePayment"> | Date | string | null
    metadata?: JsonNullableFilter<"InvoicePayment">
    createdAt?: DateTimeFilter<"InvoicePayment"> | Date | string
    updatedAt?: DateTimeFilter<"InvoicePayment"> | Date | string
  }

  export type PaymentGatewayConfigUpsertWithWhereUniqueWithoutTenantInput = {
    where: PaymentGatewayConfigWhereUniqueInput
    update: XOR<PaymentGatewayConfigUpdateWithoutTenantInput, PaymentGatewayConfigUncheckedUpdateWithoutTenantInput>
    create: XOR<PaymentGatewayConfigCreateWithoutTenantInput, PaymentGatewayConfigUncheckedCreateWithoutTenantInput>
  }

  export type PaymentGatewayConfigUpdateWithWhereUniqueWithoutTenantInput = {
    where: PaymentGatewayConfigWhereUniqueInput
    data: XOR<PaymentGatewayConfigUpdateWithoutTenantInput, PaymentGatewayConfigUncheckedUpdateWithoutTenantInput>
  }

  export type PaymentGatewayConfigUpdateManyWithWhereWithoutTenantInput = {
    where: PaymentGatewayConfigScalarWhereInput
    data: XOR<PaymentGatewayConfigUpdateManyMutationInput, PaymentGatewayConfigUncheckedUpdateManyWithoutTenantInput>
  }

  export type PaymentGatewayConfigScalarWhereInput = {
    AND?: PaymentGatewayConfigScalarWhereInput | PaymentGatewayConfigScalarWhereInput[]
    OR?: PaymentGatewayConfigScalarWhereInput[]
    NOT?: PaymentGatewayConfigScalarWhereInput | PaymentGatewayConfigScalarWhereInput[]
    id?: StringFilter<"PaymentGatewayConfig"> | string
    tenantId?: StringFilter<"PaymentGatewayConfig"> | string
    provider?: StringFilter<"PaymentGatewayConfig"> | string
    config?: JsonFilter<"PaymentGatewayConfig">
    isActive?: BoolFilter<"PaymentGatewayConfig"> | boolean
    isTest?: BoolFilter<"PaymentGatewayConfig"> | boolean
    createdAt?: DateTimeFilter<"PaymentGatewayConfig"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentGatewayConfig"> | Date | string
  }

  export type CryptoWalletUpsertWithWhereUniqueWithoutTenantInput = {
    where: CryptoWalletWhereUniqueInput
    update: XOR<CryptoWalletUpdateWithoutTenantInput, CryptoWalletUncheckedUpdateWithoutTenantInput>
    create: XOR<CryptoWalletCreateWithoutTenantInput, CryptoWalletUncheckedCreateWithoutTenantInput>
  }

  export type CryptoWalletUpdateWithWhereUniqueWithoutTenantInput = {
    where: CryptoWalletWhereUniqueInput
    data: XOR<CryptoWalletUpdateWithoutTenantInput, CryptoWalletUncheckedUpdateWithoutTenantInput>
  }

  export type CryptoWalletUpdateManyWithWhereWithoutTenantInput = {
    where: CryptoWalletScalarWhereInput
    data: XOR<CryptoWalletUpdateManyMutationInput, CryptoWalletUncheckedUpdateManyWithoutTenantInput>
  }

  export type CryptoWalletScalarWhereInput = {
    AND?: CryptoWalletScalarWhereInput | CryptoWalletScalarWhereInput[]
    OR?: CryptoWalletScalarWhereInput[]
    NOT?: CryptoWalletScalarWhereInput | CryptoWalletScalarWhereInput[]
    id?: StringFilter<"CryptoWallet"> | string
    tenantId?: StringFilter<"CryptoWallet"> | string
    currency?: StringFilter<"CryptoWallet"> | string
    address?: StringFilter<"CryptoWallet"> | string
    network?: StringNullableFilter<"CryptoWallet"> | string | null
    provider?: StringFilter<"CryptoWallet"> | string
    isActive?: BoolFilter<"CryptoWallet"> | boolean
    metadata?: JsonNullableFilter<"CryptoWallet">
    createdAt?: DateTimeFilter<"CryptoWallet"> | Date | string
    updatedAt?: DateTimeFilter<"CryptoWallet"> | Date | string
  }

  export type ExpenseCategoryUpsertWithWhereUniqueWithoutTenantInput = {
    where: ExpenseCategoryWhereUniqueInput
    update: XOR<ExpenseCategoryUpdateWithoutTenantInput, ExpenseCategoryUncheckedUpdateWithoutTenantInput>
    create: XOR<ExpenseCategoryCreateWithoutTenantInput, ExpenseCategoryUncheckedCreateWithoutTenantInput>
  }

  export type ExpenseCategoryUpdateWithWhereUniqueWithoutTenantInput = {
    where: ExpenseCategoryWhereUniqueInput
    data: XOR<ExpenseCategoryUpdateWithoutTenantInput, ExpenseCategoryUncheckedUpdateWithoutTenantInput>
  }

  export type ExpenseCategoryUpdateManyWithWhereWithoutTenantInput = {
    where: ExpenseCategoryScalarWhereInput
    data: XOR<ExpenseCategoryUpdateManyMutationInput, ExpenseCategoryUncheckedUpdateManyWithoutTenantInput>
  }

  export type ExpenseCategoryScalarWhereInput = {
    AND?: ExpenseCategoryScalarWhereInput | ExpenseCategoryScalarWhereInput[]
    OR?: ExpenseCategoryScalarWhereInput[]
    NOT?: ExpenseCategoryScalarWhereInput | ExpenseCategoryScalarWhereInput[]
    id?: StringFilter<"ExpenseCategory"> | string
    tenantId?: StringFilter<"ExpenseCategory"> | string
    name?: StringFilter<"ExpenseCategory"> | string
    description?: StringNullableFilter<"ExpenseCategory"> | string | null
    isDefault?: BoolFilter<"ExpenseCategory"> | boolean
    createdAt?: DateTimeFilter<"ExpenseCategory"> | Date | string
    updatedAt?: DateTimeFilter<"ExpenseCategory"> | Date | string
  }

  export type ExpenseUpsertWithWhereUniqueWithoutTenantInput = {
    where: ExpenseWhereUniqueInput
    update: XOR<ExpenseUpdateWithoutTenantInput, ExpenseUncheckedUpdateWithoutTenantInput>
    create: XOR<ExpenseCreateWithoutTenantInput, ExpenseUncheckedCreateWithoutTenantInput>
  }

  export type ExpenseUpdateWithWhereUniqueWithoutTenantInput = {
    where: ExpenseWhereUniqueInput
    data: XOR<ExpenseUpdateWithoutTenantInput, ExpenseUncheckedUpdateWithoutTenantInput>
  }

  export type ExpenseUpdateManyWithWhereWithoutTenantInput = {
    where: ExpenseScalarWhereInput
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyWithoutTenantInput>
  }

  export type ExpenseScalarWhereInput = {
    AND?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
    OR?: ExpenseScalarWhereInput[]
    NOT?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
    id?: StringFilter<"Expense"> | string
    tenantId?: StringFilter<"Expense"> | string
    categoryId?: StringFilter<"Expense"> | string
    description?: StringFilter<"Expense"> | string
    amount?: DecimalFilter<"Expense"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Expense"> | string
    date?: DateTimeFilter<"Expense"> | Date | string
    vendor?: StringNullableFilter<"Expense"> | string | null
    receiptUrl?: StringNullableFilter<"Expense"> | string | null
    receiptOcrData?: JsonNullableFilter<"Expense">
    taxAmount?: DecimalNullableFilter<"Expense"> | Decimal | DecimalJsLike | number | string | null
    isTaxDeductible?: BoolFilter<"Expense"> | boolean
    status?: EnumExpenseStatusFilter<"Expense"> | $Enums.ExpenseStatus
    approvedBy?: StringNullableFilter<"Expense"> | string | null
    approvedAt?: DateTimeNullableFilter<"Expense"> | Date | string | null
    rejectedReason?: StringNullableFilter<"Expense"> | string | null
    reimbursedAt?: DateTimeNullableFilter<"Expense"> | Date | string | null
    reimbursedAmount?: DecimalNullableFilter<"Expense"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"Expense"> | string | null
    metadata?: JsonNullableFilter<"Expense">
    createdAt?: DateTimeFilter<"Expense"> | Date | string
    updatedAt?: DateTimeFilter<"Expense"> | Date | string
  }

  export type RecurringInvoiceTemplateUpsertWithWhereUniqueWithoutTenantInput = {
    where: RecurringInvoiceTemplateWhereUniqueInput
    update: XOR<RecurringInvoiceTemplateUpdateWithoutTenantInput, RecurringInvoiceTemplateUncheckedUpdateWithoutTenantInput>
    create: XOR<RecurringInvoiceTemplateCreateWithoutTenantInput, RecurringInvoiceTemplateUncheckedCreateWithoutTenantInput>
  }

  export type RecurringInvoiceTemplateUpdateWithWhereUniqueWithoutTenantInput = {
    where: RecurringInvoiceTemplateWhereUniqueInput
    data: XOR<RecurringInvoiceTemplateUpdateWithoutTenantInput, RecurringInvoiceTemplateUncheckedUpdateWithoutTenantInput>
  }

  export type RecurringInvoiceTemplateUpdateManyWithWhereWithoutTenantInput = {
    where: RecurringInvoiceTemplateScalarWhereInput
    data: XOR<RecurringInvoiceTemplateUpdateManyMutationInput, RecurringInvoiceTemplateUncheckedUpdateManyWithoutTenantInput>
  }

  export type RecurringInvoiceTemplateScalarWhereInput = {
    AND?: RecurringInvoiceTemplateScalarWhereInput | RecurringInvoiceTemplateScalarWhereInput[]
    OR?: RecurringInvoiceTemplateScalarWhereInput[]
    NOT?: RecurringInvoiceTemplateScalarWhereInput | RecurringInvoiceTemplateScalarWhereInput[]
    id?: StringFilter<"RecurringInvoiceTemplate"> | string
    tenantId?: StringFilter<"RecurringInvoiceTemplate"> | string
    frequency?: StringFilter<"RecurringInvoiceTemplate"> | string
    nextInvoiceDate?: DateTimeFilter<"RecurringInvoiceTemplate"> | Date | string
    isActive?: BoolFilter<"RecurringInvoiceTemplate"> | boolean
    invoiceTemplate?: JsonFilter<"RecurringInvoiceTemplate">
    metadata?: JsonNullableFilter<"RecurringInvoiceTemplate">
    createdAt?: DateTimeFilter<"RecurringInvoiceTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"RecurringInvoiceTemplate"> | Date | string
  }

  export type BadgeUpsertWithWhereUniqueWithoutTenantInput = {
    where: BadgeWhereUniqueInput
    update: XOR<BadgeUpdateWithoutTenantInput, BadgeUncheckedUpdateWithoutTenantInput>
    create: XOR<BadgeCreateWithoutTenantInput, BadgeUncheckedCreateWithoutTenantInput>
  }

  export type BadgeUpdateWithWhereUniqueWithoutTenantInput = {
    where: BadgeWhereUniqueInput
    data: XOR<BadgeUpdateWithoutTenantInput, BadgeUncheckedUpdateWithoutTenantInput>
  }

  export type BadgeUpdateManyWithWhereWithoutTenantInput = {
    where: BadgeScalarWhereInput
    data: XOR<BadgeUpdateManyMutationInput, BadgeUncheckedUpdateManyWithoutTenantInput>
  }

  export type BadgeScalarWhereInput = {
    AND?: BadgeScalarWhereInput | BadgeScalarWhereInput[]
    OR?: BadgeScalarWhereInput[]
    NOT?: BadgeScalarWhereInput | BadgeScalarWhereInput[]
    id?: StringFilter<"Badge"> | string
    tenantId?: StringFilter<"Badge"> | string
    name?: StringFilter<"Badge"> | string
    description?: StringFilter<"Badge"> | string
    icon?: StringFilter<"Badge"> | string
    color?: StringFilter<"Badge"> | string
    category?: StringFilter<"Badge"> | string
    criteria?: JsonFilter<"Badge">
    isActive?: BoolFilter<"Badge"> | boolean
    createdAt?: DateTimeFilter<"Badge"> | Date | string
    updatedAt?: DateTimeFilter<"Badge"> | Date | string
  }

  export type WorkoutTemplateUpsertWithWhereUniqueWithoutTenantInput = {
    where: WorkoutTemplateWhereUniqueInput
    update: XOR<WorkoutTemplateUpdateWithoutTenantInput, WorkoutTemplateUncheckedUpdateWithoutTenantInput>
    create: XOR<WorkoutTemplateCreateWithoutTenantInput, WorkoutTemplateUncheckedCreateWithoutTenantInput>
  }

  export type WorkoutTemplateUpdateWithWhereUniqueWithoutTenantInput = {
    where: WorkoutTemplateWhereUniqueInput
    data: XOR<WorkoutTemplateUpdateWithoutTenantInput, WorkoutTemplateUncheckedUpdateWithoutTenantInput>
  }

  export type WorkoutTemplateUpdateManyWithWhereWithoutTenantInput = {
    where: WorkoutTemplateScalarWhereInput
    data: XOR<WorkoutTemplateUpdateManyMutationInput, WorkoutTemplateUncheckedUpdateManyWithoutTenantInput>
  }

  export type WorkoutTemplateScalarWhereInput = {
    AND?: WorkoutTemplateScalarWhereInput | WorkoutTemplateScalarWhereInput[]
    OR?: WorkoutTemplateScalarWhereInput[]
    NOT?: WorkoutTemplateScalarWhereInput | WorkoutTemplateScalarWhereInput[]
    id?: StringFilter<"WorkoutTemplate"> | string
    tenantId?: StringFilter<"WorkoutTemplate"> | string
    name?: StringFilter<"WorkoutTemplate"> | string
    description?: StringNullableFilter<"WorkoutTemplate"> | string | null
    category?: StringFilter<"WorkoutTemplate"> | string
    difficulty?: StringFilter<"WorkoutTemplate"> | string
    duration?: IntFilter<"WorkoutTemplate"> | number
    exercises?: JsonNullableListFilter<"WorkoutTemplate">
    muscleGroups?: StringNullableListFilter<"WorkoutTemplate">
    equipment?: StringNullableListFilter<"WorkoutTemplate">
    isPublic?: BoolFilter<"WorkoutTemplate"> | boolean
    usageCount?: IntFilter<"WorkoutTemplate"> | number
    createdAt?: DateTimeFilter<"WorkoutTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"WorkoutTemplate"> | Date | string
  }

  export type ScheduleTemplateUpsertWithWhereUniqueWithoutTenantInput = {
    where: ScheduleTemplateWhereUniqueInput
    update: XOR<ScheduleTemplateUpdateWithoutTenantInput, ScheduleTemplateUncheckedUpdateWithoutTenantInput>
    create: XOR<ScheduleTemplateCreateWithoutTenantInput, ScheduleTemplateUncheckedCreateWithoutTenantInput>
  }

  export type ScheduleTemplateUpdateWithWhereUniqueWithoutTenantInput = {
    where: ScheduleTemplateWhereUniqueInput
    data: XOR<ScheduleTemplateUpdateWithoutTenantInput, ScheduleTemplateUncheckedUpdateWithoutTenantInput>
  }

  export type ScheduleTemplateUpdateManyWithWhereWithoutTenantInput = {
    where: ScheduleTemplateScalarWhereInput
    data: XOR<ScheduleTemplateUpdateManyMutationInput, ScheduleTemplateUncheckedUpdateManyWithoutTenantInput>
  }

  export type ScheduleTemplateScalarWhereInput = {
    AND?: ScheduleTemplateScalarWhereInput | ScheduleTemplateScalarWhereInput[]
    OR?: ScheduleTemplateScalarWhereInput[]
    NOT?: ScheduleTemplateScalarWhereInput | ScheduleTemplateScalarWhereInput[]
    id?: StringFilter<"ScheduleTemplate"> | string
    tenantId?: StringFilter<"ScheduleTemplate"> | string
    name?: StringFilter<"ScheduleTemplate"> | string
    description?: StringNullableFilter<"ScheduleTemplate"> | string | null
    slots?: JsonNullableListFilter<"ScheduleTemplate">
    isActive?: BoolFilter<"ScheduleTemplate"> | boolean
    createdAt?: DateTimeFilter<"ScheduleTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"ScheduleTemplate"> | Date | string
  }

  export type TenantCreateWithoutUsersInput = {
    id?: string
    vertical: $Enums.Vertical
    name: string
    slug: string
    email?: string | null
    phone?: string | null
    website?: string | null
    logo?: string | null
    subscriptionTier?: string
    aiCredits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    clients?: ClientCreateNestedManyWithoutTenantInput
    sessions?: SessionCreateNestedManyWithoutTenantInput
    classes?: ClassCreateNestedManyWithoutTenantInput
    packages?: PackageCreateNestedManyWithoutTenantInput
    orders?: OrderCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    aiLogs?: AILogCreateNestedManyWithoutTenantInput
    bankAccounts?: BankAccountCreateNestedManyWithoutTenantInput
    bankTransactions?: BankTransactionCreateNestedManyWithoutTenantInput
    invoicePayments?: InvoicePaymentCreateNestedManyWithoutTenantInput
    paymentGatewayConfigs?: PaymentGatewayConfigCreateNestedManyWithoutTenantInput
    cryptoWallets?: CryptoWalletCreateNestedManyWithoutTenantInput
    expenseCategories?: ExpenseCategoryCreateNestedManyWithoutTenantInput
    expenses?: ExpenseCreateNestedManyWithoutTenantInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateCreateNestedManyWithoutTenantInput
    badges?: BadgeCreateNestedManyWithoutTenantInput
    workoutTemplates?: WorkoutTemplateCreateNestedManyWithoutTenantInput
    scheduleTemplates?: ScheduleTemplateCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutUsersInput = {
    id?: string
    vertical: $Enums.Vertical
    name: string
    slug: string
    email?: string | null
    phone?: string | null
    website?: string | null
    logo?: string | null
    subscriptionTier?: string
    aiCredits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    clients?: ClientUncheckedCreateNestedManyWithoutTenantInput
    sessions?: SessionUncheckedCreateNestedManyWithoutTenantInput
    classes?: ClassUncheckedCreateNestedManyWithoutTenantInput
    packages?: PackageUncheckedCreateNestedManyWithoutTenantInput
    orders?: OrderUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    aiLogs?: AILogUncheckedCreateNestedManyWithoutTenantInput
    bankAccounts?: BankAccountUncheckedCreateNestedManyWithoutTenantInput
    bankTransactions?: BankTransactionUncheckedCreateNestedManyWithoutTenantInput
    invoicePayments?: InvoicePaymentUncheckedCreateNestedManyWithoutTenantInput
    paymentGatewayConfigs?: PaymentGatewayConfigUncheckedCreateNestedManyWithoutTenantInput
    cryptoWallets?: CryptoWalletUncheckedCreateNestedManyWithoutTenantInput
    expenseCategories?: ExpenseCategoryUncheckedCreateNestedManyWithoutTenantInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutTenantInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateUncheckedCreateNestedManyWithoutTenantInput
    badges?: BadgeUncheckedCreateNestedManyWithoutTenantInput
    workoutTemplates?: WorkoutTemplateUncheckedCreateNestedManyWithoutTenantInput
    scheduleTemplates?: ScheduleTemplateUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutUsersInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserSessionCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type UserSessionUncheckedCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type UserSessionCreateOrConnectWithoutUserInput = {
    where: UserSessionWhereUniqueInput
    create: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput>
  }

  export type UserSessionCreateManyUserInputEnvelope = {
    data: UserSessionCreateManyUserInput | UserSessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutUsersInput = {
    update: XOR<TenantUpdateWithoutUsersInput, TenantUncheckedUpdateWithoutUsersInput>
    create: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutUsersInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutUsersInput, TenantUncheckedUpdateWithoutUsersInput>
  }

  export type TenantUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    vertical?: EnumVerticalFieldUpdateOperationsInput | $Enums.Vertical
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    aiCredits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clients?: ClientUpdateManyWithoutTenantNestedInput
    sessions?: SessionUpdateManyWithoutTenantNestedInput
    classes?: ClassUpdateManyWithoutTenantNestedInput
    packages?: PackageUpdateManyWithoutTenantNestedInput
    orders?: OrderUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    aiLogs?: AILogUpdateManyWithoutTenantNestedInput
    bankAccounts?: BankAccountUpdateManyWithoutTenantNestedInput
    bankTransactions?: BankTransactionUpdateManyWithoutTenantNestedInput
    invoicePayments?: InvoicePaymentUpdateManyWithoutTenantNestedInput
    paymentGatewayConfigs?: PaymentGatewayConfigUpdateManyWithoutTenantNestedInput
    cryptoWallets?: CryptoWalletUpdateManyWithoutTenantNestedInput
    expenseCategories?: ExpenseCategoryUpdateManyWithoutTenantNestedInput
    expenses?: ExpenseUpdateManyWithoutTenantNestedInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateUpdateManyWithoutTenantNestedInput
    badges?: BadgeUpdateManyWithoutTenantNestedInput
    workoutTemplates?: WorkoutTemplateUpdateManyWithoutTenantNestedInput
    scheduleTemplates?: ScheduleTemplateUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    vertical?: EnumVerticalFieldUpdateOperationsInput | $Enums.Vertical
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    aiCredits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clients?: ClientUncheckedUpdateManyWithoutTenantNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutTenantNestedInput
    classes?: ClassUncheckedUpdateManyWithoutTenantNestedInput
    packages?: PackageUncheckedUpdateManyWithoutTenantNestedInput
    orders?: OrderUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    aiLogs?: AILogUncheckedUpdateManyWithoutTenantNestedInput
    bankAccounts?: BankAccountUncheckedUpdateManyWithoutTenantNestedInput
    bankTransactions?: BankTransactionUncheckedUpdateManyWithoutTenantNestedInput
    invoicePayments?: InvoicePaymentUncheckedUpdateManyWithoutTenantNestedInput
    paymentGatewayConfigs?: PaymentGatewayConfigUncheckedUpdateManyWithoutTenantNestedInput
    cryptoWallets?: CryptoWalletUncheckedUpdateManyWithoutTenantNestedInput
    expenseCategories?: ExpenseCategoryUncheckedUpdateManyWithoutTenantNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutTenantNestedInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateUncheckedUpdateManyWithoutTenantNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutTenantNestedInput
    workoutTemplates?: WorkoutTemplateUncheckedUpdateManyWithoutTenantNestedInput
    scheduleTemplates?: ScheduleTemplateUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
  }

  export type UserSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: UserSessionWhereUniqueInput
    update: XOR<UserSessionUpdateWithoutUserInput, UserSessionUncheckedUpdateWithoutUserInput>
    create: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput>
  }

  export type UserSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: UserSessionWhereUniqueInput
    data: XOR<UserSessionUpdateWithoutUserInput, UserSessionUncheckedUpdateWithoutUserInput>
  }

  export type UserSessionUpdateManyWithWhereWithoutUserInput = {
    where: UserSessionScalarWhereInput
    data: XOR<UserSessionUpdateManyMutationInput, UserSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type UserSessionScalarWhereInput = {
    AND?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
    OR?: UserSessionScalarWhereInput[]
    NOT?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
    id?: StringFilter<"UserSession"> | string
    sessionToken?: StringFilter<"UserSession"> | string
    userId?: StringFilter<"UserSession"> | string
    expires?: DateTimeFilter<"UserSession"> | Date | string
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUsersInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    tenantId: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUsersInput
    accounts?: AccountCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    tenantId: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TenantCreateWithoutClientsInput = {
    id?: string
    vertical: $Enums.Vertical
    name: string
    slug: string
    email?: string | null
    phone?: string | null
    website?: string | null
    logo?: string | null
    subscriptionTier?: string
    aiCredits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    sessions?: SessionCreateNestedManyWithoutTenantInput
    classes?: ClassCreateNestedManyWithoutTenantInput
    packages?: PackageCreateNestedManyWithoutTenantInput
    orders?: OrderCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    aiLogs?: AILogCreateNestedManyWithoutTenantInput
    bankAccounts?: BankAccountCreateNestedManyWithoutTenantInput
    bankTransactions?: BankTransactionCreateNestedManyWithoutTenantInput
    invoicePayments?: InvoicePaymentCreateNestedManyWithoutTenantInput
    paymentGatewayConfigs?: PaymentGatewayConfigCreateNestedManyWithoutTenantInput
    cryptoWallets?: CryptoWalletCreateNestedManyWithoutTenantInput
    expenseCategories?: ExpenseCategoryCreateNestedManyWithoutTenantInput
    expenses?: ExpenseCreateNestedManyWithoutTenantInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateCreateNestedManyWithoutTenantInput
    badges?: BadgeCreateNestedManyWithoutTenantInput
    workoutTemplates?: WorkoutTemplateCreateNestedManyWithoutTenantInput
    scheduleTemplates?: ScheduleTemplateCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutClientsInput = {
    id?: string
    vertical: $Enums.Vertical
    name: string
    slug: string
    email?: string | null
    phone?: string | null
    website?: string | null
    logo?: string | null
    subscriptionTier?: string
    aiCredits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    sessions?: SessionUncheckedCreateNestedManyWithoutTenantInput
    classes?: ClassUncheckedCreateNestedManyWithoutTenantInput
    packages?: PackageUncheckedCreateNestedManyWithoutTenantInput
    orders?: OrderUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    aiLogs?: AILogUncheckedCreateNestedManyWithoutTenantInput
    bankAccounts?: BankAccountUncheckedCreateNestedManyWithoutTenantInput
    bankTransactions?: BankTransactionUncheckedCreateNestedManyWithoutTenantInput
    invoicePayments?: InvoicePaymentUncheckedCreateNestedManyWithoutTenantInput
    paymentGatewayConfigs?: PaymentGatewayConfigUncheckedCreateNestedManyWithoutTenantInput
    cryptoWallets?: CryptoWalletUncheckedCreateNestedManyWithoutTenantInput
    expenseCategories?: ExpenseCategoryUncheckedCreateNestedManyWithoutTenantInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutTenantInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateUncheckedCreateNestedManyWithoutTenantInput
    badges?: BadgeUncheckedCreateNestedManyWithoutTenantInput
    workoutTemplates?: WorkoutTemplateUncheckedCreateNestedManyWithoutTenantInput
    scheduleTemplates?: ScheduleTemplateUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutClientsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutClientsInput, TenantUncheckedCreateWithoutClientsInput>
  }

  export type SessionCreateWithoutClientInput = {
    id?: string
    scheduledAt: Date | string
    duration?: number
    status?: string
    workoutPlan?: NullableJsonNullValueInput | InputJsonValue
    exercisesLogged?: SessionCreateexercisesLoggedInput | InputJsonValue[]
    caloriesBurned?: number | null
    heartRateAvg?: number | null
    muscleGroups?: SessionCreatemuscleGroupsInput | string[]
    clientFeedback?: string | null
    trainerNotes?: string | null
    intensity?: string | null
    clientRating?: number | null
    price?: number | null
    paid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateWithoutClientInput = {
    id?: string
    tenantId: string
    scheduledAt: Date | string
    duration?: number
    status?: string
    workoutPlan?: NullableJsonNullValueInput | InputJsonValue
    exercisesLogged?: SessionCreateexercisesLoggedInput | InputJsonValue[]
    caloriesBurned?: number | null
    heartRateAvg?: number | null
    muscleGroups?: SessionCreatemuscleGroupsInput | string[]
    clientFeedback?: string | null
    trainerNotes?: string | null
    intensity?: string | null
    clientRating?: number | null
    price?: number | null
    paid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionCreateOrConnectWithoutClientInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutClientInput, SessionUncheckedCreateWithoutClientInput>
  }

  export type SessionCreateManyClientInputEnvelope = {
    data: SessionCreateManyClientInput | SessionCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutClientInput = {
    id?: string
    orderNumber: string
    status?: string
    items?: OrderCreateitemsInput | InputJsonValue[]
    subtotal: number
    tax?: number
    discount?: number
    total: number
    paymentMethod?: string | null
    paymentStatus?: string
    paidAmount?: number
    orderDate?: Date | string
    dueDate?: Date | string | null
    paidDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutOrdersInput
    invoices?: InvoiceCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutClientInput = {
    id?: string
    tenantId: string
    orderNumber: string
    status?: string
    items?: OrderCreateitemsInput | InputJsonValue[]
    subtotal: number
    tax?: number
    discount?: number
    total: number
    paymentMethod?: string | null
    paymentStatus?: string
    paidAmount?: number
    orderDate?: Date | string
    dueDate?: Date | string | null
    paidDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutClientInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutClientInput, OrderUncheckedCreateWithoutClientInput>
  }

  export type OrderCreateManyClientInputEnvelope = {
    data: OrderCreateManyClientInput | OrderCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutClientInput = {
    id?: string
    invoiceNumber: string
    status?: string
    issueDate?: Date | string
    dueDate: Date | string
    paidDate?: Date | string | null
    subtotal: number
    tax?: number
    total: number
    paymentMethod?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutInvoicesInput
    order?: OrderCreateNestedOneWithoutInvoicesInput
    payments?: InvoicePaymentCreateNestedManyWithoutInvoiceInput
    bankTransactions?: BankTransactionCreateNestedManyWithoutMatchedInvoiceInput
    cryptoPayments?: CryptoPaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutClientInput = {
    id?: string
    tenantId: string
    orderId?: string | null
    invoiceNumber: string
    status?: string
    issueDate?: Date | string
    dueDate: Date | string
    paidDate?: Date | string | null
    subtotal: number
    tax?: number
    total: number
    paymentMethod?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: InvoicePaymentUncheckedCreateNestedManyWithoutInvoiceInput
    bankTransactions?: BankTransactionUncheckedCreateNestedManyWithoutMatchedInvoiceInput
    cryptoPayments?: CryptoPaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutClientInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutClientInput, InvoiceUncheckedCreateWithoutClientInput>
  }

  export type InvoiceCreateManyClientInputEnvelope = {
    data: InvoiceCreateManyClientInput | InvoiceCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type ClientMeasurementCreateWithoutClientInput = {
    id?: string
    date?: Date | string
    weight?: number | null
    bodyFat?: number | null
    measurements?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdAt?: Date | string
  }

  export type ClientMeasurementUncheckedCreateWithoutClientInput = {
    id?: string
    date?: Date | string
    weight?: number | null
    bodyFat?: number | null
    measurements?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdAt?: Date | string
  }

  export type ClientMeasurementCreateOrConnectWithoutClientInput = {
    where: ClientMeasurementWhereUniqueInput
    create: XOR<ClientMeasurementCreateWithoutClientInput, ClientMeasurementUncheckedCreateWithoutClientInput>
  }

  export type ClientMeasurementCreateManyClientInputEnvelope = {
    data: ClientMeasurementCreateManyClientInput | ClientMeasurementCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type ProgressPhotoCreateWithoutClientInput = {
    id?: string
    url: string
    date?: Date | string
    view: string
    notes?: string | null
    createdAt?: Date | string
  }

  export type ProgressPhotoUncheckedCreateWithoutClientInput = {
    id?: string
    url: string
    date?: Date | string
    view: string
    notes?: string | null
    createdAt?: Date | string
  }

  export type ProgressPhotoCreateOrConnectWithoutClientInput = {
    where: ProgressPhotoWhereUniqueInput
    create: XOR<ProgressPhotoCreateWithoutClientInput, ProgressPhotoUncheckedCreateWithoutClientInput>
  }

  export type ProgressPhotoCreateManyClientInputEnvelope = {
    data: ProgressPhotoCreateManyClientInput | ProgressPhotoCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type ClientBadgeCreateWithoutClientInput = {
    id?: string
    earnedAt?: Date | string
    notified?: boolean
    badge: BadgeCreateNestedOneWithoutClientBadgesInput
  }

  export type ClientBadgeUncheckedCreateWithoutClientInput = {
    id?: string
    badgeId: string
    earnedAt?: Date | string
    notified?: boolean
  }

  export type ClientBadgeCreateOrConnectWithoutClientInput = {
    where: ClientBadgeWhereUniqueInput
    create: XOR<ClientBadgeCreateWithoutClientInput, ClientBadgeUncheckedCreateWithoutClientInput>
  }

  export type ClientBadgeCreateManyClientInputEnvelope = {
    data: ClientBadgeCreateManyClientInput | ClientBadgeCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutClientsInput = {
    update: XOR<TenantUpdateWithoutClientsInput, TenantUncheckedUpdateWithoutClientsInput>
    create: XOR<TenantCreateWithoutClientsInput, TenantUncheckedCreateWithoutClientsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutClientsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutClientsInput, TenantUncheckedUpdateWithoutClientsInput>
  }

  export type TenantUpdateWithoutClientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vertical?: EnumVerticalFieldUpdateOperationsInput | $Enums.Vertical
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    aiCredits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    sessions?: SessionUpdateManyWithoutTenantNestedInput
    classes?: ClassUpdateManyWithoutTenantNestedInput
    packages?: PackageUpdateManyWithoutTenantNestedInput
    orders?: OrderUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    aiLogs?: AILogUpdateManyWithoutTenantNestedInput
    bankAccounts?: BankAccountUpdateManyWithoutTenantNestedInput
    bankTransactions?: BankTransactionUpdateManyWithoutTenantNestedInput
    invoicePayments?: InvoicePaymentUpdateManyWithoutTenantNestedInput
    paymentGatewayConfigs?: PaymentGatewayConfigUpdateManyWithoutTenantNestedInput
    cryptoWallets?: CryptoWalletUpdateManyWithoutTenantNestedInput
    expenseCategories?: ExpenseCategoryUpdateManyWithoutTenantNestedInput
    expenses?: ExpenseUpdateManyWithoutTenantNestedInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateUpdateManyWithoutTenantNestedInput
    badges?: BadgeUpdateManyWithoutTenantNestedInput
    workoutTemplates?: WorkoutTemplateUpdateManyWithoutTenantNestedInput
    scheduleTemplates?: ScheduleTemplateUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutClientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vertical?: EnumVerticalFieldUpdateOperationsInput | $Enums.Vertical
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    aiCredits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutTenantNestedInput
    classes?: ClassUncheckedUpdateManyWithoutTenantNestedInput
    packages?: PackageUncheckedUpdateManyWithoutTenantNestedInput
    orders?: OrderUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    aiLogs?: AILogUncheckedUpdateManyWithoutTenantNestedInput
    bankAccounts?: BankAccountUncheckedUpdateManyWithoutTenantNestedInput
    bankTransactions?: BankTransactionUncheckedUpdateManyWithoutTenantNestedInput
    invoicePayments?: InvoicePaymentUncheckedUpdateManyWithoutTenantNestedInput
    paymentGatewayConfigs?: PaymentGatewayConfigUncheckedUpdateManyWithoutTenantNestedInput
    cryptoWallets?: CryptoWalletUncheckedUpdateManyWithoutTenantNestedInput
    expenseCategories?: ExpenseCategoryUncheckedUpdateManyWithoutTenantNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutTenantNestedInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateUncheckedUpdateManyWithoutTenantNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutTenantNestedInput
    workoutTemplates?: WorkoutTemplateUncheckedUpdateManyWithoutTenantNestedInput
    scheduleTemplates?: ScheduleTemplateUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type SessionUpsertWithWhereUniqueWithoutClientInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutClientInput, SessionUncheckedUpdateWithoutClientInput>
    create: XOR<SessionCreateWithoutClientInput, SessionUncheckedCreateWithoutClientInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutClientInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutClientInput, SessionUncheckedUpdateWithoutClientInput>
  }

  export type SessionUpdateManyWithWhereWithoutClientInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutClientInput>
  }

  export type OrderUpsertWithWhereUniqueWithoutClientInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutClientInput, OrderUncheckedUpdateWithoutClientInput>
    create: XOR<OrderCreateWithoutClientInput, OrderUncheckedCreateWithoutClientInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutClientInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutClientInput, OrderUncheckedUpdateWithoutClientInput>
  }

  export type OrderUpdateManyWithWhereWithoutClientInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutClientInput>
  }

  export type InvoiceUpsertWithWhereUniqueWithoutClientInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutClientInput, InvoiceUncheckedUpdateWithoutClientInput>
    create: XOR<InvoiceCreateWithoutClientInput, InvoiceUncheckedCreateWithoutClientInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutClientInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutClientInput, InvoiceUncheckedUpdateWithoutClientInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutClientInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutClientInput>
  }

  export type ClientMeasurementUpsertWithWhereUniqueWithoutClientInput = {
    where: ClientMeasurementWhereUniqueInput
    update: XOR<ClientMeasurementUpdateWithoutClientInput, ClientMeasurementUncheckedUpdateWithoutClientInput>
    create: XOR<ClientMeasurementCreateWithoutClientInput, ClientMeasurementUncheckedCreateWithoutClientInput>
  }

  export type ClientMeasurementUpdateWithWhereUniqueWithoutClientInput = {
    where: ClientMeasurementWhereUniqueInput
    data: XOR<ClientMeasurementUpdateWithoutClientInput, ClientMeasurementUncheckedUpdateWithoutClientInput>
  }

  export type ClientMeasurementUpdateManyWithWhereWithoutClientInput = {
    where: ClientMeasurementScalarWhereInput
    data: XOR<ClientMeasurementUpdateManyMutationInput, ClientMeasurementUncheckedUpdateManyWithoutClientInput>
  }

  export type ClientMeasurementScalarWhereInput = {
    AND?: ClientMeasurementScalarWhereInput | ClientMeasurementScalarWhereInput[]
    OR?: ClientMeasurementScalarWhereInput[]
    NOT?: ClientMeasurementScalarWhereInput | ClientMeasurementScalarWhereInput[]
    id?: StringFilter<"ClientMeasurement"> | string
    clientId?: StringFilter<"ClientMeasurement"> | string
    date?: DateTimeFilter<"ClientMeasurement"> | Date | string
    weight?: FloatNullableFilter<"ClientMeasurement"> | number | null
    bodyFat?: FloatNullableFilter<"ClientMeasurement"> | number | null
    measurements?: JsonNullableFilter<"ClientMeasurement">
    notes?: StringNullableFilter<"ClientMeasurement"> | string | null
    createdAt?: DateTimeFilter<"ClientMeasurement"> | Date | string
  }

  export type ProgressPhotoUpsertWithWhereUniqueWithoutClientInput = {
    where: ProgressPhotoWhereUniqueInput
    update: XOR<ProgressPhotoUpdateWithoutClientInput, ProgressPhotoUncheckedUpdateWithoutClientInput>
    create: XOR<ProgressPhotoCreateWithoutClientInput, ProgressPhotoUncheckedCreateWithoutClientInput>
  }

  export type ProgressPhotoUpdateWithWhereUniqueWithoutClientInput = {
    where: ProgressPhotoWhereUniqueInput
    data: XOR<ProgressPhotoUpdateWithoutClientInput, ProgressPhotoUncheckedUpdateWithoutClientInput>
  }

  export type ProgressPhotoUpdateManyWithWhereWithoutClientInput = {
    where: ProgressPhotoScalarWhereInput
    data: XOR<ProgressPhotoUpdateManyMutationInput, ProgressPhotoUncheckedUpdateManyWithoutClientInput>
  }

  export type ProgressPhotoScalarWhereInput = {
    AND?: ProgressPhotoScalarWhereInput | ProgressPhotoScalarWhereInput[]
    OR?: ProgressPhotoScalarWhereInput[]
    NOT?: ProgressPhotoScalarWhereInput | ProgressPhotoScalarWhereInput[]
    id?: StringFilter<"ProgressPhoto"> | string
    clientId?: StringFilter<"ProgressPhoto"> | string
    url?: StringFilter<"ProgressPhoto"> | string
    date?: DateTimeFilter<"ProgressPhoto"> | Date | string
    view?: StringFilter<"ProgressPhoto"> | string
    notes?: StringNullableFilter<"ProgressPhoto"> | string | null
    createdAt?: DateTimeFilter<"ProgressPhoto"> | Date | string
  }

  export type ClientBadgeUpsertWithWhereUniqueWithoutClientInput = {
    where: ClientBadgeWhereUniqueInput
    update: XOR<ClientBadgeUpdateWithoutClientInput, ClientBadgeUncheckedUpdateWithoutClientInput>
    create: XOR<ClientBadgeCreateWithoutClientInput, ClientBadgeUncheckedCreateWithoutClientInput>
  }

  export type ClientBadgeUpdateWithWhereUniqueWithoutClientInput = {
    where: ClientBadgeWhereUniqueInput
    data: XOR<ClientBadgeUpdateWithoutClientInput, ClientBadgeUncheckedUpdateWithoutClientInput>
  }

  export type ClientBadgeUpdateManyWithWhereWithoutClientInput = {
    where: ClientBadgeScalarWhereInput
    data: XOR<ClientBadgeUpdateManyMutationInput, ClientBadgeUncheckedUpdateManyWithoutClientInput>
  }

  export type ClientBadgeScalarWhereInput = {
    AND?: ClientBadgeScalarWhereInput | ClientBadgeScalarWhereInput[]
    OR?: ClientBadgeScalarWhereInput[]
    NOT?: ClientBadgeScalarWhereInput | ClientBadgeScalarWhereInput[]
    id?: StringFilter<"ClientBadge"> | string
    clientId?: StringFilter<"ClientBadge"> | string
    badgeId?: StringFilter<"ClientBadge"> | string
    earnedAt?: DateTimeFilter<"ClientBadge"> | Date | string
    notified?: BoolFilter<"ClientBadge"> | boolean
  }

  export type ClientCreateWithoutMeasurementsInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    avatar?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    goals?: ClientCreategoalsInput | string[]
    currentWeight?: number | null
    targetWeight?: number | null
    height?: number | null
    bodyMeasurements?: NullableJsonNullValueInput | InputJsonValue
    bodyFatPercent?: number | null
    fitnessLevel?: string | null
    injuryHistory?: string | null
    dietaryNotes?: string | null
    medicalNotes?: string | null
    creditsRemaining?: number
    membershipType?: string | null
    membershipExpiry?: Date | string | null
    status?: string
    tags?: ClientCreatetagsInput | string[]
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutClientsInput
    sessions?: SessionCreateNestedManyWithoutClientInput
    orders?: OrderCreateNestedManyWithoutClientInput
    invoices?: InvoiceCreateNestedManyWithoutClientInput
    progressPhotos?: ProgressPhotoCreateNestedManyWithoutClientInput
    badges?: ClientBadgeCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutMeasurementsInput = {
    id?: string
    tenantId: string
    name: string
    email: string
    phone?: string | null
    avatar?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    goals?: ClientCreategoalsInput | string[]
    currentWeight?: number | null
    targetWeight?: number | null
    height?: number | null
    bodyMeasurements?: NullableJsonNullValueInput | InputJsonValue
    bodyFatPercent?: number | null
    fitnessLevel?: string | null
    injuryHistory?: string | null
    dietaryNotes?: string | null
    medicalNotes?: string | null
    creditsRemaining?: number
    membershipType?: string | null
    membershipExpiry?: Date | string | null
    status?: string
    tags?: ClientCreatetagsInput | string[]
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutClientInput
    orders?: OrderUncheckedCreateNestedManyWithoutClientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutClientInput
    progressPhotos?: ProgressPhotoUncheckedCreateNestedManyWithoutClientInput
    badges?: ClientBadgeUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutMeasurementsInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutMeasurementsInput, ClientUncheckedCreateWithoutMeasurementsInput>
  }

  export type ClientUpsertWithoutMeasurementsInput = {
    update: XOR<ClientUpdateWithoutMeasurementsInput, ClientUncheckedUpdateWithoutMeasurementsInput>
    create: XOR<ClientCreateWithoutMeasurementsInput, ClientUncheckedCreateWithoutMeasurementsInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutMeasurementsInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutMeasurementsInput, ClientUncheckedUpdateWithoutMeasurementsInput>
  }

  export type ClientUpdateWithoutMeasurementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    goals?: ClientUpdategoalsInput | string[]
    currentWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    targetWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    bodyMeasurements?: NullableJsonNullValueInput | InputJsonValue
    bodyFatPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    fitnessLevel?: NullableStringFieldUpdateOperationsInput | string | null
    injuryHistory?: NullableStringFieldUpdateOperationsInput | string | null
    dietaryNotes?: NullableStringFieldUpdateOperationsInput | string | null
    medicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    creditsRemaining?: IntFieldUpdateOperationsInput | number
    membershipType?: NullableStringFieldUpdateOperationsInput | string | null
    membershipExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    tags?: ClientUpdatetagsInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutClientsNestedInput
    sessions?: SessionUpdateManyWithoutClientNestedInput
    orders?: OrderUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUpdateManyWithoutClientNestedInput
    progressPhotos?: ProgressPhotoUpdateManyWithoutClientNestedInput
    badges?: ClientBadgeUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutMeasurementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    goals?: ClientUpdategoalsInput | string[]
    currentWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    targetWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    bodyMeasurements?: NullableJsonNullValueInput | InputJsonValue
    bodyFatPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    fitnessLevel?: NullableStringFieldUpdateOperationsInput | string | null
    injuryHistory?: NullableStringFieldUpdateOperationsInput | string | null
    dietaryNotes?: NullableStringFieldUpdateOperationsInput | string | null
    medicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    creditsRemaining?: IntFieldUpdateOperationsInput | number
    membershipType?: NullableStringFieldUpdateOperationsInput | string | null
    membershipExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    tags?: ClientUpdatetagsInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutClientNestedInput
    orders?: OrderUncheckedUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutClientNestedInput
    progressPhotos?: ProgressPhotoUncheckedUpdateManyWithoutClientNestedInput
    badges?: ClientBadgeUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientCreateWithoutProgressPhotosInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    avatar?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    goals?: ClientCreategoalsInput | string[]
    currentWeight?: number | null
    targetWeight?: number | null
    height?: number | null
    bodyMeasurements?: NullableJsonNullValueInput | InputJsonValue
    bodyFatPercent?: number | null
    fitnessLevel?: string | null
    injuryHistory?: string | null
    dietaryNotes?: string | null
    medicalNotes?: string | null
    creditsRemaining?: number
    membershipType?: string | null
    membershipExpiry?: Date | string | null
    status?: string
    tags?: ClientCreatetagsInput | string[]
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutClientsInput
    sessions?: SessionCreateNestedManyWithoutClientInput
    orders?: OrderCreateNestedManyWithoutClientInput
    invoices?: InvoiceCreateNestedManyWithoutClientInput
    measurements?: ClientMeasurementCreateNestedManyWithoutClientInput
    badges?: ClientBadgeCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutProgressPhotosInput = {
    id?: string
    tenantId: string
    name: string
    email: string
    phone?: string | null
    avatar?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    goals?: ClientCreategoalsInput | string[]
    currentWeight?: number | null
    targetWeight?: number | null
    height?: number | null
    bodyMeasurements?: NullableJsonNullValueInput | InputJsonValue
    bodyFatPercent?: number | null
    fitnessLevel?: string | null
    injuryHistory?: string | null
    dietaryNotes?: string | null
    medicalNotes?: string | null
    creditsRemaining?: number
    membershipType?: string | null
    membershipExpiry?: Date | string | null
    status?: string
    tags?: ClientCreatetagsInput | string[]
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutClientInput
    orders?: OrderUncheckedCreateNestedManyWithoutClientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutClientInput
    measurements?: ClientMeasurementUncheckedCreateNestedManyWithoutClientInput
    badges?: ClientBadgeUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutProgressPhotosInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutProgressPhotosInput, ClientUncheckedCreateWithoutProgressPhotosInput>
  }

  export type ClientUpsertWithoutProgressPhotosInput = {
    update: XOR<ClientUpdateWithoutProgressPhotosInput, ClientUncheckedUpdateWithoutProgressPhotosInput>
    create: XOR<ClientCreateWithoutProgressPhotosInput, ClientUncheckedCreateWithoutProgressPhotosInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutProgressPhotosInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutProgressPhotosInput, ClientUncheckedUpdateWithoutProgressPhotosInput>
  }

  export type ClientUpdateWithoutProgressPhotosInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    goals?: ClientUpdategoalsInput | string[]
    currentWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    targetWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    bodyMeasurements?: NullableJsonNullValueInput | InputJsonValue
    bodyFatPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    fitnessLevel?: NullableStringFieldUpdateOperationsInput | string | null
    injuryHistory?: NullableStringFieldUpdateOperationsInput | string | null
    dietaryNotes?: NullableStringFieldUpdateOperationsInput | string | null
    medicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    creditsRemaining?: IntFieldUpdateOperationsInput | number
    membershipType?: NullableStringFieldUpdateOperationsInput | string | null
    membershipExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    tags?: ClientUpdatetagsInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutClientsNestedInput
    sessions?: SessionUpdateManyWithoutClientNestedInput
    orders?: OrderUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUpdateManyWithoutClientNestedInput
    measurements?: ClientMeasurementUpdateManyWithoutClientNestedInput
    badges?: ClientBadgeUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutProgressPhotosInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    goals?: ClientUpdategoalsInput | string[]
    currentWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    targetWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    bodyMeasurements?: NullableJsonNullValueInput | InputJsonValue
    bodyFatPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    fitnessLevel?: NullableStringFieldUpdateOperationsInput | string | null
    injuryHistory?: NullableStringFieldUpdateOperationsInput | string | null
    dietaryNotes?: NullableStringFieldUpdateOperationsInput | string | null
    medicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    creditsRemaining?: IntFieldUpdateOperationsInput | number
    membershipType?: NullableStringFieldUpdateOperationsInput | string | null
    membershipExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    tags?: ClientUpdatetagsInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutClientNestedInput
    orders?: OrderUncheckedUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutClientNestedInput
    measurements?: ClientMeasurementUncheckedUpdateManyWithoutClientNestedInput
    badges?: ClientBadgeUncheckedUpdateManyWithoutClientNestedInput
  }

  export type TenantCreateWithoutSessionsInput = {
    id?: string
    vertical: $Enums.Vertical
    name: string
    slug: string
    email?: string | null
    phone?: string | null
    website?: string | null
    logo?: string | null
    subscriptionTier?: string
    aiCredits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    clients?: ClientCreateNestedManyWithoutTenantInput
    classes?: ClassCreateNestedManyWithoutTenantInput
    packages?: PackageCreateNestedManyWithoutTenantInput
    orders?: OrderCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    aiLogs?: AILogCreateNestedManyWithoutTenantInput
    bankAccounts?: BankAccountCreateNestedManyWithoutTenantInput
    bankTransactions?: BankTransactionCreateNestedManyWithoutTenantInput
    invoicePayments?: InvoicePaymentCreateNestedManyWithoutTenantInput
    paymentGatewayConfigs?: PaymentGatewayConfigCreateNestedManyWithoutTenantInput
    cryptoWallets?: CryptoWalletCreateNestedManyWithoutTenantInput
    expenseCategories?: ExpenseCategoryCreateNestedManyWithoutTenantInput
    expenses?: ExpenseCreateNestedManyWithoutTenantInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateCreateNestedManyWithoutTenantInput
    badges?: BadgeCreateNestedManyWithoutTenantInput
    workoutTemplates?: WorkoutTemplateCreateNestedManyWithoutTenantInput
    scheduleTemplates?: ScheduleTemplateCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutSessionsInput = {
    id?: string
    vertical: $Enums.Vertical
    name: string
    slug: string
    email?: string | null
    phone?: string | null
    website?: string | null
    logo?: string | null
    subscriptionTier?: string
    aiCredits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    clients?: ClientUncheckedCreateNestedManyWithoutTenantInput
    classes?: ClassUncheckedCreateNestedManyWithoutTenantInput
    packages?: PackageUncheckedCreateNestedManyWithoutTenantInput
    orders?: OrderUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    aiLogs?: AILogUncheckedCreateNestedManyWithoutTenantInput
    bankAccounts?: BankAccountUncheckedCreateNestedManyWithoutTenantInput
    bankTransactions?: BankTransactionUncheckedCreateNestedManyWithoutTenantInput
    invoicePayments?: InvoicePaymentUncheckedCreateNestedManyWithoutTenantInput
    paymentGatewayConfigs?: PaymentGatewayConfigUncheckedCreateNestedManyWithoutTenantInput
    cryptoWallets?: CryptoWalletUncheckedCreateNestedManyWithoutTenantInput
    expenseCategories?: ExpenseCategoryUncheckedCreateNestedManyWithoutTenantInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutTenantInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateUncheckedCreateNestedManyWithoutTenantInput
    badges?: BadgeUncheckedCreateNestedManyWithoutTenantInput
    workoutTemplates?: WorkoutTemplateUncheckedCreateNestedManyWithoutTenantInput
    scheduleTemplates?: ScheduleTemplateUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutSessionsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutSessionsInput, TenantUncheckedCreateWithoutSessionsInput>
  }

  export type ClientCreateWithoutSessionsInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    avatar?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    goals?: ClientCreategoalsInput | string[]
    currentWeight?: number | null
    targetWeight?: number | null
    height?: number | null
    bodyMeasurements?: NullableJsonNullValueInput | InputJsonValue
    bodyFatPercent?: number | null
    fitnessLevel?: string | null
    injuryHistory?: string | null
    dietaryNotes?: string | null
    medicalNotes?: string | null
    creditsRemaining?: number
    membershipType?: string | null
    membershipExpiry?: Date | string | null
    status?: string
    tags?: ClientCreatetagsInput | string[]
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutClientsInput
    orders?: OrderCreateNestedManyWithoutClientInput
    invoices?: InvoiceCreateNestedManyWithoutClientInput
    measurements?: ClientMeasurementCreateNestedManyWithoutClientInput
    progressPhotos?: ProgressPhotoCreateNestedManyWithoutClientInput
    badges?: ClientBadgeCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutSessionsInput = {
    id?: string
    tenantId: string
    name: string
    email: string
    phone?: string | null
    avatar?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    goals?: ClientCreategoalsInput | string[]
    currentWeight?: number | null
    targetWeight?: number | null
    height?: number | null
    bodyMeasurements?: NullableJsonNullValueInput | InputJsonValue
    bodyFatPercent?: number | null
    fitnessLevel?: string | null
    injuryHistory?: string | null
    dietaryNotes?: string | null
    medicalNotes?: string | null
    creditsRemaining?: number
    membershipType?: string | null
    membershipExpiry?: Date | string | null
    status?: string
    tags?: ClientCreatetagsInput | string[]
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutClientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutClientInput
    measurements?: ClientMeasurementUncheckedCreateNestedManyWithoutClientInput
    progressPhotos?: ProgressPhotoUncheckedCreateNestedManyWithoutClientInput
    badges?: ClientBadgeUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutSessionsInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutSessionsInput, ClientUncheckedCreateWithoutSessionsInput>
  }

  export type TenantUpsertWithoutSessionsInput = {
    update: XOR<TenantUpdateWithoutSessionsInput, TenantUncheckedUpdateWithoutSessionsInput>
    create: XOR<TenantCreateWithoutSessionsInput, TenantUncheckedCreateWithoutSessionsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutSessionsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutSessionsInput, TenantUncheckedUpdateWithoutSessionsInput>
  }

  export type TenantUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vertical?: EnumVerticalFieldUpdateOperationsInput | $Enums.Vertical
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    aiCredits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    clients?: ClientUpdateManyWithoutTenantNestedInput
    classes?: ClassUpdateManyWithoutTenantNestedInput
    packages?: PackageUpdateManyWithoutTenantNestedInput
    orders?: OrderUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    aiLogs?: AILogUpdateManyWithoutTenantNestedInput
    bankAccounts?: BankAccountUpdateManyWithoutTenantNestedInput
    bankTransactions?: BankTransactionUpdateManyWithoutTenantNestedInput
    invoicePayments?: InvoicePaymentUpdateManyWithoutTenantNestedInput
    paymentGatewayConfigs?: PaymentGatewayConfigUpdateManyWithoutTenantNestedInput
    cryptoWallets?: CryptoWalletUpdateManyWithoutTenantNestedInput
    expenseCategories?: ExpenseCategoryUpdateManyWithoutTenantNestedInput
    expenses?: ExpenseUpdateManyWithoutTenantNestedInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateUpdateManyWithoutTenantNestedInput
    badges?: BadgeUpdateManyWithoutTenantNestedInput
    workoutTemplates?: WorkoutTemplateUpdateManyWithoutTenantNestedInput
    scheduleTemplates?: ScheduleTemplateUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vertical?: EnumVerticalFieldUpdateOperationsInput | $Enums.Vertical
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    aiCredits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    clients?: ClientUncheckedUpdateManyWithoutTenantNestedInput
    classes?: ClassUncheckedUpdateManyWithoutTenantNestedInput
    packages?: PackageUncheckedUpdateManyWithoutTenantNestedInput
    orders?: OrderUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    aiLogs?: AILogUncheckedUpdateManyWithoutTenantNestedInput
    bankAccounts?: BankAccountUncheckedUpdateManyWithoutTenantNestedInput
    bankTransactions?: BankTransactionUncheckedUpdateManyWithoutTenantNestedInput
    invoicePayments?: InvoicePaymentUncheckedUpdateManyWithoutTenantNestedInput
    paymentGatewayConfigs?: PaymentGatewayConfigUncheckedUpdateManyWithoutTenantNestedInput
    cryptoWallets?: CryptoWalletUncheckedUpdateManyWithoutTenantNestedInput
    expenseCategories?: ExpenseCategoryUncheckedUpdateManyWithoutTenantNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutTenantNestedInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateUncheckedUpdateManyWithoutTenantNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutTenantNestedInput
    workoutTemplates?: WorkoutTemplateUncheckedUpdateManyWithoutTenantNestedInput
    scheduleTemplates?: ScheduleTemplateUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type ClientUpsertWithoutSessionsInput = {
    update: XOR<ClientUpdateWithoutSessionsInput, ClientUncheckedUpdateWithoutSessionsInput>
    create: XOR<ClientCreateWithoutSessionsInput, ClientUncheckedCreateWithoutSessionsInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutSessionsInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutSessionsInput, ClientUncheckedUpdateWithoutSessionsInput>
  }

  export type ClientUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    goals?: ClientUpdategoalsInput | string[]
    currentWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    targetWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    bodyMeasurements?: NullableJsonNullValueInput | InputJsonValue
    bodyFatPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    fitnessLevel?: NullableStringFieldUpdateOperationsInput | string | null
    injuryHistory?: NullableStringFieldUpdateOperationsInput | string | null
    dietaryNotes?: NullableStringFieldUpdateOperationsInput | string | null
    medicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    creditsRemaining?: IntFieldUpdateOperationsInput | number
    membershipType?: NullableStringFieldUpdateOperationsInput | string | null
    membershipExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    tags?: ClientUpdatetagsInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutClientsNestedInput
    orders?: OrderUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUpdateManyWithoutClientNestedInput
    measurements?: ClientMeasurementUpdateManyWithoutClientNestedInput
    progressPhotos?: ProgressPhotoUpdateManyWithoutClientNestedInput
    badges?: ClientBadgeUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    goals?: ClientUpdategoalsInput | string[]
    currentWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    targetWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    bodyMeasurements?: NullableJsonNullValueInput | InputJsonValue
    bodyFatPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    fitnessLevel?: NullableStringFieldUpdateOperationsInput | string | null
    injuryHistory?: NullableStringFieldUpdateOperationsInput | string | null
    dietaryNotes?: NullableStringFieldUpdateOperationsInput | string | null
    medicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    creditsRemaining?: IntFieldUpdateOperationsInput | number
    membershipType?: NullableStringFieldUpdateOperationsInput | string | null
    membershipExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    tags?: ClientUpdatetagsInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutClientNestedInput
    measurements?: ClientMeasurementUncheckedUpdateManyWithoutClientNestedInput
    progressPhotos?: ProgressPhotoUncheckedUpdateManyWithoutClientNestedInput
    badges?: ClientBadgeUncheckedUpdateManyWithoutClientNestedInput
  }

  export type TenantCreateWithoutClassesInput = {
    id?: string
    vertical: $Enums.Vertical
    name: string
    slug: string
    email?: string | null
    phone?: string | null
    website?: string | null
    logo?: string | null
    subscriptionTier?: string
    aiCredits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    clients?: ClientCreateNestedManyWithoutTenantInput
    sessions?: SessionCreateNestedManyWithoutTenantInput
    packages?: PackageCreateNestedManyWithoutTenantInput
    orders?: OrderCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    aiLogs?: AILogCreateNestedManyWithoutTenantInput
    bankAccounts?: BankAccountCreateNestedManyWithoutTenantInput
    bankTransactions?: BankTransactionCreateNestedManyWithoutTenantInput
    invoicePayments?: InvoicePaymentCreateNestedManyWithoutTenantInput
    paymentGatewayConfigs?: PaymentGatewayConfigCreateNestedManyWithoutTenantInput
    cryptoWallets?: CryptoWalletCreateNestedManyWithoutTenantInput
    expenseCategories?: ExpenseCategoryCreateNestedManyWithoutTenantInput
    expenses?: ExpenseCreateNestedManyWithoutTenantInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateCreateNestedManyWithoutTenantInput
    badges?: BadgeCreateNestedManyWithoutTenantInput
    workoutTemplates?: WorkoutTemplateCreateNestedManyWithoutTenantInput
    scheduleTemplates?: ScheduleTemplateCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutClassesInput = {
    id?: string
    vertical: $Enums.Vertical
    name: string
    slug: string
    email?: string | null
    phone?: string | null
    website?: string | null
    logo?: string | null
    subscriptionTier?: string
    aiCredits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    clients?: ClientUncheckedCreateNestedManyWithoutTenantInput
    sessions?: SessionUncheckedCreateNestedManyWithoutTenantInput
    packages?: PackageUncheckedCreateNestedManyWithoutTenantInput
    orders?: OrderUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    aiLogs?: AILogUncheckedCreateNestedManyWithoutTenantInput
    bankAccounts?: BankAccountUncheckedCreateNestedManyWithoutTenantInput
    bankTransactions?: BankTransactionUncheckedCreateNestedManyWithoutTenantInput
    invoicePayments?: InvoicePaymentUncheckedCreateNestedManyWithoutTenantInput
    paymentGatewayConfigs?: PaymentGatewayConfigUncheckedCreateNestedManyWithoutTenantInput
    cryptoWallets?: CryptoWalletUncheckedCreateNestedManyWithoutTenantInput
    expenseCategories?: ExpenseCategoryUncheckedCreateNestedManyWithoutTenantInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutTenantInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateUncheckedCreateNestedManyWithoutTenantInput
    badges?: BadgeUncheckedCreateNestedManyWithoutTenantInput
    workoutTemplates?: WorkoutTemplateUncheckedCreateNestedManyWithoutTenantInput
    scheduleTemplates?: ScheduleTemplateUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutClassesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutClassesInput, TenantUncheckedCreateWithoutClassesInput>
  }

  export type ClassBookingCreateWithoutClassInput = {
    id?: string
    clientId: string
    status?: string
    checkedIn?: boolean
    paid?: boolean
    createdAt?: Date | string
  }

  export type ClassBookingUncheckedCreateWithoutClassInput = {
    id?: string
    clientId: string
    status?: string
    checkedIn?: boolean
    paid?: boolean
    createdAt?: Date | string
  }

  export type ClassBookingCreateOrConnectWithoutClassInput = {
    where: ClassBookingWhereUniqueInput
    create: XOR<ClassBookingCreateWithoutClassInput, ClassBookingUncheckedCreateWithoutClassInput>
  }

  export type ClassBookingCreateManyClassInputEnvelope = {
    data: ClassBookingCreateManyClassInput | ClassBookingCreateManyClassInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutClassesInput = {
    update: XOR<TenantUpdateWithoutClassesInput, TenantUncheckedUpdateWithoutClassesInput>
    create: XOR<TenantCreateWithoutClassesInput, TenantUncheckedCreateWithoutClassesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutClassesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutClassesInput, TenantUncheckedUpdateWithoutClassesInput>
  }

  export type TenantUpdateWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    vertical?: EnumVerticalFieldUpdateOperationsInput | $Enums.Vertical
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    aiCredits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    clients?: ClientUpdateManyWithoutTenantNestedInput
    sessions?: SessionUpdateManyWithoutTenantNestedInput
    packages?: PackageUpdateManyWithoutTenantNestedInput
    orders?: OrderUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    aiLogs?: AILogUpdateManyWithoutTenantNestedInput
    bankAccounts?: BankAccountUpdateManyWithoutTenantNestedInput
    bankTransactions?: BankTransactionUpdateManyWithoutTenantNestedInput
    invoicePayments?: InvoicePaymentUpdateManyWithoutTenantNestedInput
    paymentGatewayConfigs?: PaymentGatewayConfigUpdateManyWithoutTenantNestedInput
    cryptoWallets?: CryptoWalletUpdateManyWithoutTenantNestedInput
    expenseCategories?: ExpenseCategoryUpdateManyWithoutTenantNestedInput
    expenses?: ExpenseUpdateManyWithoutTenantNestedInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateUpdateManyWithoutTenantNestedInput
    badges?: BadgeUpdateManyWithoutTenantNestedInput
    workoutTemplates?: WorkoutTemplateUpdateManyWithoutTenantNestedInput
    scheduleTemplates?: ScheduleTemplateUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    vertical?: EnumVerticalFieldUpdateOperationsInput | $Enums.Vertical
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    aiCredits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    clients?: ClientUncheckedUpdateManyWithoutTenantNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutTenantNestedInput
    packages?: PackageUncheckedUpdateManyWithoutTenantNestedInput
    orders?: OrderUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    aiLogs?: AILogUncheckedUpdateManyWithoutTenantNestedInput
    bankAccounts?: BankAccountUncheckedUpdateManyWithoutTenantNestedInput
    bankTransactions?: BankTransactionUncheckedUpdateManyWithoutTenantNestedInput
    invoicePayments?: InvoicePaymentUncheckedUpdateManyWithoutTenantNestedInput
    paymentGatewayConfigs?: PaymentGatewayConfigUncheckedUpdateManyWithoutTenantNestedInput
    cryptoWallets?: CryptoWalletUncheckedUpdateManyWithoutTenantNestedInput
    expenseCategories?: ExpenseCategoryUncheckedUpdateManyWithoutTenantNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutTenantNestedInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateUncheckedUpdateManyWithoutTenantNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutTenantNestedInput
    workoutTemplates?: WorkoutTemplateUncheckedUpdateManyWithoutTenantNestedInput
    scheduleTemplates?: ScheduleTemplateUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type ClassBookingUpsertWithWhereUniqueWithoutClassInput = {
    where: ClassBookingWhereUniqueInput
    update: XOR<ClassBookingUpdateWithoutClassInput, ClassBookingUncheckedUpdateWithoutClassInput>
    create: XOR<ClassBookingCreateWithoutClassInput, ClassBookingUncheckedCreateWithoutClassInput>
  }

  export type ClassBookingUpdateWithWhereUniqueWithoutClassInput = {
    where: ClassBookingWhereUniqueInput
    data: XOR<ClassBookingUpdateWithoutClassInput, ClassBookingUncheckedUpdateWithoutClassInput>
  }

  export type ClassBookingUpdateManyWithWhereWithoutClassInput = {
    where: ClassBookingScalarWhereInput
    data: XOR<ClassBookingUpdateManyMutationInput, ClassBookingUncheckedUpdateManyWithoutClassInput>
  }

  export type ClassBookingScalarWhereInput = {
    AND?: ClassBookingScalarWhereInput | ClassBookingScalarWhereInput[]
    OR?: ClassBookingScalarWhereInput[]
    NOT?: ClassBookingScalarWhereInput | ClassBookingScalarWhereInput[]
    id?: StringFilter<"ClassBooking"> | string
    classId?: StringFilter<"ClassBooking"> | string
    clientId?: StringFilter<"ClassBooking"> | string
    status?: StringFilter<"ClassBooking"> | string
    checkedIn?: BoolFilter<"ClassBooking"> | boolean
    paid?: BoolFilter<"ClassBooking"> | boolean
    createdAt?: DateTimeFilter<"ClassBooking"> | Date | string
  }

  export type ClassCreateWithoutBookingsInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    scheduledAt: Date | string
    duration: number
    capacity?: number
    instructor?: string | null
    location?: string | null
    price: number
    isRecurring?: boolean
    recurrence?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutClassesInput
  }

  export type ClassUncheckedCreateWithoutBookingsInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    type: string
    scheduledAt: Date | string
    duration: number
    capacity?: number
    instructor?: string | null
    location?: string | null
    price: number
    isRecurring?: boolean
    recurrence?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassCreateOrConnectWithoutBookingsInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutBookingsInput, ClassUncheckedCreateWithoutBookingsInput>
  }

  export type ClassUpsertWithoutBookingsInput = {
    update: XOR<ClassUpdateWithoutBookingsInput, ClassUncheckedUpdateWithoutBookingsInput>
    create: XOR<ClassCreateWithoutBookingsInput, ClassUncheckedCreateWithoutBookingsInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutBookingsInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutBookingsInput, ClassUncheckedUpdateWithoutBookingsInput>
  }

  export type ClassUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    instructor?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurrence?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutClassesNestedInput
  }

  export type ClassUncheckedUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    instructor?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurrence?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantCreateWithoutPackagesInput = {
    id?: string
    vertical: $Enums.Vertical
    name: string
    slug: string
    email?: string | null
    phone?: string | null
    website?: string | null
    logo?: string | null
    subscriptionTier?: string
    aiCredits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    clients?: ClientCreateNestedManyWithoutTenantInput
    sessions?: SessionCreateNestedManyWithoutTenantInput
    classes?: ClassCreateNestedManyWithoutTenantInput
    orders?: OrderCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    aiLogs?: AILogCreateNestedManyWithoutTenantInput
    bankAccounts?: BankAccountCreateNestedManyWithoutTenantInput
    bankTransactions?: BankTransactionCreateNestedManyWithoutTenantInput
    invoicePayments?: InvoicePaymentCreateNestedManyWithoutTenantInput
    paymentGatewayConfigs?: PaymentGatewayConfigCreateNestedManyWithoutTenantInput
    cryptoWallets?: CryptoWalletCreateNestedManyWithoutTenantInput
    expenseCategories?: ExpenseCategoryCreateNestedManyWithoutTenantInput
    expenses?: ExpenseCreateNestedManyWithoutTenantInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateCreateNestedManyWithoutTenantInput
    badges?: BadgeCreateNestedManyWithoutTenantInput
    workoutTemplates?: WorkoutTemplateCreateNestedManyWithoutTenantInput
    scheduleTemplates?: ScheduleTemplateCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutPackagesInput = {
    id?: string
    vertical: $Enums.Vertical
    name: string
    slug: string
    email?: string | null
    phone?: string | null
    website?: string | null
    logo?: string | null
    subscriptionTier?: string
    aiCredits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    clients?: ClientUncheckedCreateNestedManyWithoutTenantInput
    sessions?: SessionUncheckedCreateNestedManyWithoutTenantInput
    classes?: ClassUncheckedCreateNestedManyWithoutTenantInput
    orders?: OrderUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    aiLogs?: AILogUncheckedCreateNestedManyWithoutTenantInput
    bankAccounts?: BankAccountUncheckedCreateNestedManyWithoutTenantInput
    bankTransactions?: BankTransactionUncheckedCreateNestedManyWithoutTenantInput
    invoicePayments?: InvoicePaymentUncheckedCreateNestedManyWithoutTenantInput
    paymentGatewayConfigs?: PaymentGatewayConfigUncheckedCreateNestedManyWithoutTenantInput
    cryptoWallets?: CryptoWalletUncheckedCreateNestedManyWithoutTenantInput
    expenseCategories?: ExpenseCategoryUncheckedCreateNestedManyWithoutTenantInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutTenantInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateUncheckedCreateNestedManyWithoutTenantInput
    badges?: BadgeUncheckedCreateNestedManyWithoutTenantInput
    workoutTemplates?: WorkoutTemplateUncheckedCreateNestedManyWithoutTenantInput
    scheduleTemplates?: ScheduleTemplateUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutPackagesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutPackagesInput, TenantUncheckedCreateWithoutPackagesInput>
  }

  export type TenantUpsertWithoutPackagesInput = {
    update: XOR<TenantUpdateWithoutPackagesInput, TenantUncheckedUpdateWithoutPackagesInput>
    create: XOR<TenantCreateWithoutPackagesInput, TenantUncheckedCreateWithoutPackagesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutPackagesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutPackagesInput, TenantUncheckedUpdateWithoutPackagesInput>
  }

  export type TenantUpdateWithoutPackagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    vertical?: EnumVerticalFieldUpdateOperationsInput | $Enums.Vertical
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    aiCredits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    clients?: ClientUpdateManyWithoutTenantNestedInput
    sessions?: SessionUpdateManyWithoutTenantNestedInput
    classes?: ClassUpdateManyWithoutTenantNestedInput
    orders?: OrderUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    aiLogs?: AILogUpdateManyWithoutTenantNestedInput
    bankAccounts?: BankAccountUpdateManyWithoutTenantNestedInput
    bankTransactions?: BankTransactionUpdateManyWithoutTenantNestedInput
    invoicePayments?: InvoicePaymentUpdateManyWithoutTenantNestedInput
    paymentGatewayConfigs?: PaymentGatewayConfigUpdateManyWithoutTenantNestedInput
    cryptoWallets?: CryptoWalletUpdateManyWithoutTenantNestedInput
    expenseCategories?: ExpenseCategoryUpdateManyWithoutTenantNestedInput
    expenses?: ExpenseUpdateManyWithoutTenantNestedInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateUpdateManyWithoutTenantNestedInput
    badges?: BadgeUpdateManyWithoutTenantNestedInput
    workoutTemplates?: WorkoutTemplateUpdateManyWithoutTenantNestedInput
    scheduleTemplates?: ScheduleTemplateUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutPackagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    vertical?: EnumVerticalFieldUpdateOperationsInput | $Enums.Vertical
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    aiCredits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    clients?: ClientUncheckedUpdateManyWithoutTenantNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutTenantNestedInput
    classes?: ClassUncheckedUpdateManyWithoutTenantNestedInput
    orders?: OrderUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    aiLogs?: AILogUncheckedUpdateManyWithoutTenantNestedInput
    bankAccounts?: BankAccountUncheckedUpdateManyWithoutTenantNestedInput
    bankTransactions?: BankTransactionUncheckedUpdateManyWithoutTenantNestedInput
    invoicePayments?: InvoicePaymentUncheckedUpdateManyWithoutTenantNestedInput
    paymentGatewayConfigs?: PaymentGatewayConfigUncheckedUpdateManyWithoutTenantNestedInput
    cryptoWallets?: CryptoWalletUncheckedUpdateManyWithoutTenantNestedInput
    expenseCategories?: ExpenseCategoryUncheckedUpdateManyWithoutTenantNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutTenantNestedInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateUncheckedUpdateManyWithoutTenantNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutTenantNestedInput
    workoutTemplates?: WorkoutTemplateUncheckedUpdateManyWithoutTenantNestedInput
    scheduleTemplates?: ScheduleTemplateUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateWithoutOrdersInput = {
    id?: string
    vertical: $Enums.Vertical
    name: string
    slug: string
    email?: string | null
    phone?: string | null
    website?: string | null
    logo?: string | null
    subscriptionTier?: string
    aiCredits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    clients?: ClientCreateNestedManyWithoutTenantInput
    sessions?: SessionCreateNestedManyWithoutTenantInput
    classes?: ClassCreateNestedManyWithoutTenantInput
    packages?: PackageCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    aiLogs?: AILogCreateNestedManyWithoutTenantInput
    bankAccounts?: BankAccountCreateNestedManyWithoutTenantInput
    bankTransactions?: BankTransactionCreateNestedManyWithoutTenantInput
    invoicePayments?: InvoicePaymentCreateNestedManyWithoutTenantInput
    paymentGatewayConfigs?: PaymentGatewayConfigCreateNestedManyWithoutTenantInput
    cryptoWallets?: CryptoWalletCreateNestedManyWithoutTenantInput
    expenseCategories?: ExpenseCategoryCreateNestedManyWithoutTenantInput
    expenses?: ExpenseCreateNestedManyWithoutTenantInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateCreateNestedManyWithoutTenantInput
    badges?: BadgeCreateNestedManyWithoutTenantInput
    workoutTemplates?: WorkoutTemplateCreateNestedManyWithoutTenantInput
    scheduleTemplates?: ScheduleTemplateCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutOrdersInput = {
    id?: string
    vertical: $Enums.Vertical
    name: string
    slug: string
    email?: string | null
    phone?: string | null
    website?: string | null
    logo?: string | null
    subscriptionTier?: string
    aiCredits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    clients?: ClientUncheckedCreateNestedManyWithoutTenantInput
    sessions?: SessionUncheckedCreateNestedManyWithoutTenantInput
    classes?: ClassUncheckedCreateNestedManyWithoutTenantInput
    packages?: PackageUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    aiLogs?: AILogUncheckedCreateNestedManyWithoutTenantInput
    bankAccounts?: BankAccountUncheckedCreateNestedManyWithoutTenantInput
    bankTransactions?: BankTransactionUncheckedCreateNestedManyWithoutTenantInput
    invoicePayments?: InvoicePaymentUncheckedCreateNestedManyWithoutTenantInput
    paymentGatewayConfigs?: PaymentGatewayConfigUncheckedCreateNestedManyWithoutTenantInput
    cryptoWallets?: CryptoWalletUncheckedCreateNestedManyWithoutTenantInput
    expenseCategories?: ExpenseCategoryUncheckedCreateNestedManyWithoutTenantInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutTenantInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateUncheckedCreateNestedManyWithoutTenantInput
    badges?: BadgeUncheckedCreateNestedManyWithoutTenantInput
    workoutTemplates?: WorkoutTemplateUncheckedCreateNestedManyWithoutTenantInput
    scheduleTemplates?: ScheduleTemplateUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutOrdersInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutOrdersInput, TenantUncheckedCreateWithoutOrdersInput>
  }

  export type ClientCreateWithoutOrdersInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    avatar?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    goals?: ClientCreategoalsInput | string[]
    currentWeight?: number | null
    targetWeight?: number | null
    height?: number | null
    bodyMeasurements?: NullableJsonNullValueInput | InputJsonValue
    bodyFatPercent?: number | null
    fitnessLevel?: string | null
    injuryHistory?: string | null
    dietaryNotes?: string | null
    medicalNotes?: string | null
    creditsRemaining?: number
    membershipType?: string | null
    membershipExpiry?: Date | string | null
    status?: string
    tags?: ClientCreatetagsInput | string[]
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutClientsInput
    sessions?: SessionCreateNestedManyWithoutClientInput
    invoices?: InvoiceCreateNestedManyWithoutClientInput
    measurements?: ClientMeasurementCreateNestedManyWithoutClientInput
    progressPhotos?: ProgressPhotoCreateNestedManyWithoutClientInput
    badges?: ClientBadgeCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutOrdersInput = {
    id?: string
    tenantId: string
    name: string
    email: string
    phone?: string | null
    avatar?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    goals?: ClientCreategoalsInput | string[]
    currentWeight?: number | null
    targetWeight?: number | null
    height?: number | null
    bodyMeasurements?: NullableJsonNullValueInput | InputJsonValue
    bodyFatPercent?: number | null
    fitnessLevel?: string | null
    injuryHistory?: string | null
    dietaryNotes?: string | null
    medicalNotes?: string | null
    creditsRemaining?: number
    membershipType?: string | null
    membershipExpiry?: Date | string | null
    status?: string
    tags?: ClientCreatetagsInput | string[]
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutClientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutClientInput
    measurements?: ClientMeasurementUncheckedCreateNestedManyWithoutClientInput
    progressPhotos?: ProgressPhotoUncheckedCreateNestedManyWithoutClientInput
    badges?: ClientBadgeUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutOrdersInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutOrdersInput, ClientUncheckedCreateWithoutOrdersInput>
  }

  export type InvoiceCreateWithoutOrderInput = {
    id?: string
    invoiceNumber: string
    status?: string
    issueDate?: Date | string
    dueDate: Date | string
    paidDate?: Date | string | null
    subtotal: number
    tax?: number
    total: number
    paymentMethod?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutInvoicesInput
    client: ClientCreateNestedOneWithoutInvoicesInput
    payments?: InvoicePaymentCreateNestedManyWithoutInvoiceInput
    bankTransactions?: BankTransactionCreateNestedManyWithoutMatchedInvoiceInput
    cryptoPayments?: CryptoPaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutOrderInput = {
    id?: string
    tenantId: string
    clientId: string
    invoiceNumber: string
    status?: string
    issueDate?: Date | string
    dueDate: Date | string
    paidDate?: Date | string | null
    subtotal: number
    tax?: number
    total: number
    paymentMethod?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: InvoicePaymentUncheckedCreateNestedManyWithoutInvoiceInput
    bankTransactions?: BankTransactionUncheckedCreateNestedManyWithoutMatchedInvoiceInput
    cryptoPayments?: CryptoPaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutOrderInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutOrderInput, InvoiceUncheckedCreateWithoutOrderInput>
  }

  export type InvoiceCreateManyOrderInputEnvelope = {
    data: InvoiceCreateManyOrderInput | InvoiceCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutOrdersInput = {
    update: XOR<TenantUpdateWithoutOrdersInput, TenantUncheckedUpdateWithoutOrdersInput>
    create: XOR<TenantCreateWithoutOrdersInput, TenantUncheckedCreateWithoutOrdersInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutOrdersInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutOrdersInput, TenantUncheckedUpdateWithoutOrdersInput>
  }

  export type TenantUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    vertical?: EnumVerticalFieldUpdateOperationsInput | $Enums.Vertical
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    aiCredits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    clients?: ClientUpdateManyWithoutTenantNestedInput
    sessions?: SessionUpdateManyWithoutTenantNestedInput
    classes?: ClassUpdateManyWithoutTenantNestedInput
    packages?: PackageUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    aiLogs?: AILogUpdateManyWithoutTenantNestedInput
    bankAccounts?: BankAccountUpdateManyWithoutTenantNestedInput
    bankTransactions?: BankTransactionUpdateManyWithoutTenantNestedInput
    invoicePayments?: InvoicePaymentUpdateManyWithoutTenantNestedInput
    paymentGatewayConfigs?: PaymentGatewayConfigUpdateManyWithoutTenantNestedInput
    cryptoWallets?: CryptoWalletUpdateManyWithoutTenantNestedInput
    expenseCategories?: ExpenseCategoryUpdateManyWithoutTenantNestedInput
    expenses?: ExpenseUpdateManyWithoutTenantNestedInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateUpdateManyWithoutTenantNestedInput
    badges?: BadgeUpdateManyWithoutTenantNestedInput
    workoutTemplates?: WorkoutTemplateUpdateManyWithoutTenantNestedInput
    scheduleTemplates?: ScheduleTemplateUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    vertical?: EnumVerticalFieldUpdateOperationsInput | $Enums.Vertical
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    aiCredits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    clients?: ClientUncheckedUpdateManyWithoutTenantNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutTenantNestedInput
    classes?: ClassUncheckedUpdateManyWithoutTenantNestedInput
    packages?: PackageUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    aiLogs?: AILogUncheckedUpdateManyWithoutTenantNestedInput
    bankAccounts?: BankAccountUncheckedUpdateManyWithoutTenantNestedInput
    bankTransactions?: BankTransactionUncheckedUpdateManyWithoutTenantNestedInput
    invoicePayments?: InvoicePaymentUncheckedUpdateManyWithoutTenantNestedInput
    paymentGatewayConfigs?: PaymentGatewayConfigUncheckedUpdateManyWithoutTenantNestedInput
    cryptoWallets?: CryptoWalletUncheckedUpdateManyWithoutTenantNestedInput
    expenseCategories?: ExpenseCategoryUncheckedUpdateManyWithoutTenantNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutTenantNestedInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateUncheckedUpdateManyWithoutTenantNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutTenantNestedInput
    workoutTemplates?: WorkoutTemplateUncheckedUpdateManyWithoutTenantNestedInput
    scheduleTemplates?: ScheduleTemplateUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type ClientUpsertWithoutOrdersInput = {
    update: XOR<ClientUpdateWithoutOrdersInput, ClientUncheckedUpdateWithoutOrdersInput>
    create: XOR<ClientCreateWithoutOrdersInput, ClientUncheckedCreateWithoutOrdersInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutOrdersInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutOrdersInput, ClientUncheckedUpdateWithoutOrdersInput>
  }

  export type ClientUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    goals?: ClientUpdategoalsInput | string[]
    currentWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    targetWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    bodyMeasurements?: NullableJsonNullValueInput | InputJsonValue
    bodyFatPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    fitnessLevel?: NullableStringFieldUpdateOperationsInput | string | null
    injuryHistory?: NullableStringFieldUpdateOperationsInput | string | null
    dietaryNotes?: NullableStringFieldUpdateOperationsInput | string | null
    medicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    creditsRemaining?: IntFieldUpdateOperationsInput | number
    membershipType?: NullableStringFieldUpdateOperationsInput | string | null
    membershipExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    tags?: ClientUpdatetagsInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutClientsNestedInput
    sessions?: SessionUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUpdateManyWithoutClientNestedInput
    measurements?: ClientMeasurementUpdateManyWithoutClientNestedInput
    progressPhotos?: ProgressPhotoUpdateManyWithoutClientNestedInput
    badges?: ClientBadgeUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    goals?: ClientUpdategoalsInput | string[]
    currentWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    targetWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    bodyMeasurements?: NullableJsonNullValueInput | InputJsonValue
    bodyFatPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    fitnessLevel?: NullableStringFieldUpdateOperationsInput | string | null
    injuryHistory?: NullableStringFieldUpdateOperationsInput | string | null
    dietaryNotes?: NullableStringFieldUpdateOperationsInput | string | null
    medicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    creditsRemaining?: IntFieldUpdateOperationsInput | number
    membershipType?: NullableStringFieldUpdateOperationsInput | string | null
    membershipExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    tags?: ClientUpdatetagsInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutClientNestedInput
    measurements?: ClientMeasurementUncheckedUpdateManyWithoutClientNestedInput
    progressPhotos?: ProgressPhotoUncheckedUpdateManyWithoutClientNestedInput
    badges?: ClientBadgeUncheckedUpdateManyWithoutClientNestedInput
  }

  export type InvoiceUpsertWithWhereUniqueWithoutOrderInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutOrderInput, InvoiceUncheckedUpdateWithoutOrderInput>
    create: XOR<InvoiceCreateWithoutOrderInput, InvoiceUncheckedCreateWithoutOrderInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutOrderInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutOrderInput, InvoiceUncheckedUpdateWithoutOrderInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutOrderInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutOrderInput>
  }

  export type TenantCreateWithoutInvoicesInput = {
    id?: string
    vertical: $Enums.Vertical
    name: string
    slug: string
    email?: string | null
    phone?: string | null
    website?: string | null
    logo?: string | null
    subscriptionTier?: string
    aiCredits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    clients?: ClientCreateNestedManyWithoutTenantInput
    sessions?: SessionCreateNestedManyWithoutTenantInput
    classes?: ClassCreateNestedManyWithoutTenantInput
    packages?: PackageCreateNestedManyWithoutTenantInput
    orders?: OrderCreateNestedManyWithoutTenantInput
    aiLogs?: AILogCreateNestedManyWithoutTenantInput
    bankAccounts?: BankAccountCreateNestedManyWithoutTenantInput
    bankTransactions?: BankTransactionCreateNestedManyWithoutTenantInput
    invoicePayments?: InvoicePaymentCreateNestedManyWithoutTenantInput
    paymentGatewayConfigs?: PaymentGatewayConfigCreateNestedManyWithoutTenantInput
    cryptoWallets?: CryptoWalletCreateNestedManyWithoutTenantInput
    expenseCategories?: ExpenseCategoryCreateNestedManyWithoutTenantInput
    expenses?: ExpenseCreateNestedManyWithoutTenantInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateCreateNestedManyWithoutTenantInput
    badges?: BadgeCreateNestedManyWithoutTenantInput
    workoutTemplates?: WorkoutTemplateCreateNestedManyWithoutTenantInput
    scheduleTemplates?: ScheduleTemplateCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutInvoicesInput = {
    id?: string
    vertical: $Enums.Vertical
    name: string
    slug: string
    email?: string | null
    phone?: string | null
    website?: string | null
    logo?: string | null
    subscriptionTier?: string
    aiCredits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    clients?: ClientUncheckedCreateNestedManyWithoutTenantInput
    sessions?: SessionUncheckedCreateNestedManyWithoutTenantInput
    classes?: ClassUncheckedCreateNestedManyWithoutTenantInput
    packages?: PackageUncheckedCreateNestedManyWithoutTenantInput
    orders?: OrderUncheckedCreateNestedManyWithoutTenantInput
    aiLogs?: AILogUncheckedCreateNestedManyWithoutTenantInput
    bankAccounts?: BankAccountUncheckedCreateNestedManyWithoutTenantInput
    bankTransactions?: BankTransactionUncheckedCreateNestedManyWithoutTenantInput
    invoicePayments?: InvoicePaymentUncheckedCreateNestedManyWithoutTenantInput
    paymentGatewayConfigs?: PaymentGatewayConfigUncheckedCreateNestedManyWithoutTenantInput
    cryptoWallets?: CryptoWalletUncheckedCreateNestedManyWithoutTenantInput
    expenseCategories?: ExpenseCategoryUncheckedCreateNestedManyWithoutTenantInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutTenantInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateUncheckedCreateNestedManyWithoutTenantInput
    badges?: BadgeUncheckedCreateNestedManyWithoutTenantInput
    workoutTemplates?: WorkoutTemplateUncheckedCreateNestedManyWithoutTenantInput
    scheduleTemplates?: ScheduleTemplateUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutInvoicesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutInvoicesInput, TenantUncheckedCreateWithoutInvoicesInput>
  }

  export type OrderCreateWithoutInvoicesInput = {
    id?: string
    orderNumber: string
    status?: string
    items?: OrderCreateitemsInput | InputJsonValue[]
    subtotal: number
    tax?: number
    discount?: number
    total: number
    paymentMethod?: string | null
    paymentStatus?: string
    paidAmount?: number
    orderDate?: Date | string
    dueDate?: Date | string | null
    paidDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutOrdersInput
    client: ClientCreateNestedOneWithoutOrdersInput
  }

  export type OrderUncheckedCreateWithoutInvoicesInput = {
    id?: string
    tenantId: string
    clientId: string
    orderNumber: string
    status?: string
    items?: OrderCreateitemsInput | InputJsonValue[]
    subtotal: number
    tax?: number
    discount?: number
    total: number
    paymentMethod?: string | null
    paymentStatus?: string
    paidAmount?: number
    orderDate?: Date | string
    dueDate?: Date | string | null
    paidDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderCreateOrConnectWithoutInvoicesInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutInvoicesInput, OrderUncheckedCreateWithoutInvoicesInput>
  }

  export type ClientCreateWithoutInvoicesInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    avatar?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    goals?: ClientCreategoalsInput | string[]
    currentWeight?: number | null
    targetWeight?: number | null
    height?: number | null
    bodyMeasurements?: NullableJsonNullValueInput | InputJsonValue
    bodyFatPercent?: number | null
    fitnessLevel?: string | null
    injuryHistory?: string | null
    dietaryNotes?: string | null
    medicalNotes?: string | null
    creditsRemaining?: number
    membershipType?: string | null
    membershipExpiry?: Date | string | null
    status?: string
    tags?: ClientCreatetagsInput | string[]
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutClientsInput
    sessions?: SessionCreateNestedManyWithoutClientInput
    orders?: OrderCreateNestedManyWithoutClientInput
    measurements?: ClientMeasurementCreateNestedManyWithoutClientInput
    progressPhotos?: ProgressPhotoCreateNestedManyWithoutClientInput
    badges?: ClientBadgeCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutInvoicesInput = {
    id?: string
    tenantId: string
    name: string
    email: string
    phone?: string | null
    avatar?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    goals?: ClientCreategoalsInput | string[]
    currentWeight?: number | null
    targetWeight?: number | null
    height?: number | null
    bodyMeasurements?: NullableJsonNullValueInput | InputJsonValue
    bodyFatPercent?: number | null
    fitnessLevel?: string | null
    injuryHistory?: string | null
    dietaryNotes?: string | null
    medicalNotes?: string | null
    creditsRemaining?: number
    membershipType?: string | null
    membershipExpiry?: Date | string | null
    status?: string
    tags?: ClientCreatetagsInput | string[]
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutClientInput
    orders?: OrderUncheckedCreateNestedManyWithoutClientInput
    measurements?: ClientMeasurementUncheckedCreateNestedManyWithoutClientInput
    progressPhotos?: ProgressPhotoUncheckedCreateNestedManyWithoutClientInput
    badges?: ClientBadgeUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutInvoicesInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutInvoicesInput, ClientUncheckedCreateWithoutInvoicesInput>
  }

  export type InvoicePaymentCreateWithoutInvoiceInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    method: $Enums.PaymentMethod
    status?: string
    gatewayProvider?: string | null
    gatewayPaymentId?: string | null
    gatewayFee?: Decimal | DecimalJsLike | number | string | null
    transactionId?: string | null
    reference?: string | null
    processedAt?: Date | string | null
    completedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutInvoicePaymentsInput
  }

  export type InvoicePaymentUncheckedCreateWithoutInvoiceInput = {
    id?: string
    tenantId: string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    method: $Enums.PaymentMethod
    status?: string
    gatewayProvider?: string | null
    gatewayPaymentId?: string | null
    gatewayFee?: Decimal | DecimalJsLike | number | string | null
    transactionId?: string | null
    reference?: string | null
    processedAt?: Date | string | null
    completedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoicePaymentCreateOrConnectWithoutInvoiceInput = {
    where: InvoicePaymentWhereUniqueInput
    create: XOR<InvoicePaymentCreateWithoutInvoiceInput, InvoicePaymentUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoicePaymentCreateManyInvoiceInputEnvelope = {
    data: InvoicePaymentCreateManyInvoiceInput | InvoicePaymentCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type BankTransactionCreateWithoutMatchedInvoiceInput = {
    id?: string
    transactionId: string
    date: Date | string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    type: $Enums.TransactionType
    counterpartyName?: string | null
    counterpartyAccount?: string | null
    counterpartyBankCode?: string | null
    description?: string | null
    note?: string | null
    variableSymbol?: string | null
    constantSymbol?: string | null
    specificSymbol?: string | null
    reference?: string | null
    isMatched?: boolean
    matchedPaymentId?: string | null
    matchConfidence?: Decimal | DecimalJsLike | number | string | null
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    bankAccount: BankAccountCreateNestedOneWithoutTransactionsInput
    tenant: TenantCreateNestedOneWithoutBankTransactionsInput
  }

  export type BankTransactionUncheckedCreateWithoutMatchedInvoiceInput = {
    id?: string
    bankAccountId: string
    tenantId: string
    transactionId: string
    date: Date | string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    type: $Enums.TransactionType
    counterpartyName?: string | null
    counterpartyAccount?: string | null
    counterpartyBankCode?: string | null
    description?: string | null
    note?: string | null
    variableSymbol?: string | null
    constantSymbol?: string | null
    specificSymbol?: string | null
    reference?: string | null
    isMatched?: boolean
    matchedPaymentId?: string | null
    matchConfidence?: Decimal | DecimalJsLike | number | string | null
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankTransactionCreateOrConnectWithoutMatchedInvoiceInput = {
    where: BankTransactionWhereUniqueInput
    create: XOR<BankTransactionCreateWithoutMatchedInvoiceInput, BankTransactionUncheckedCreateWithoutMatchedInvoiceInput>
  }

  export type BankTransactionCreateManyMatchedInvoiceInputEnvelope = {
    data: BankTransactionCreateManyMatchedInvoiceInput | BankTransactionCreateManyMatchedInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type CryptoPaymentCreateWithoutInvoiceInput = {
    id?: string
    amount: string
    currency: string
    txHash?: string | null
    confirmations?: number
    status?: string
    detectedAt?: Date | string | null
    confirmedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    wallet: CryptoWalletCreateNestedOneWithoutPaymentsInput
  }

  export type CryptoPaymentUncheckedCreateWithoutInvoiceInput = {
    id?: string
    walletId: string
    amount: string
    currency: string
    txHash?: string | null
    confirmations?: number
    status?: string
    detectedAt?: Date | string | null
    confirmedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CryptoPaymentCreateOrConnectWithoutInvoiceInput = {
    where: CryptoPaymentWhereUniqueInput
    create: XOR<CryptoPaymentCreateWithoutInvoiceInput, CryptoPaymentUncheckedCreateWithoutInvoiceInput>
  }

  export type CryptoPaymentCreateManyInvoiceInputEnvelope = {
    data: CryptoPaymentCreateManyInvoiceInput | CryptoPaymentCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutInvoicesInput = {
    update: XOR<TenantUpdateWithoutInvoicesInput, TenantUncheckedUpdateWithoutInvoicesInput>
    create: XOR<TenantCreateWithoutInvoicesInput, TenantUncheckedCreateWithoutInvoicesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutInvoicesInput, TenantUncheckedUpdateWithoutInvoicesInput>
  }

  export type TenantUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    vertical?: EnumVerticalFieldUpdateOperationsInput | $Enums.Vertical
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    aiCredits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    clients?: ClientUpdateManyWithoutTenantNestedInput
    sessions?: SessionUpdateManyWithoutTenantNestedInput
    classes?: ClassUpdateManyWithoutTenantNestedInput
    packages?: PackageUpdateManyWithoutTenantNestedInput
    orders?: OrderUpdateManyWithoutTenantNestedInput
    aiLogs?: AILogUpdateManyWithoutTenantNestedInput
    bankAccounts?: BankAccountUpdateManyWithoutTenantNestedInput
    bankTransactions?: BankTransactionUpdateManyWithoutTenantNestedInput
    invoicePayments?: InvoicePaymentUpdateManyWithoutTenantNestedInput
    paymentGatewayConfigs?: PaymentGatewayConfigUpdateManyWithoutTenantNestedInput
    cryptoWallets?: CryptoWalletUpdateManyWithoutTenantNestedInput
    expenseCategories?: ExpenseCategoryUpdateManyWithoutTenantNestedInput
    expenses?: ExpenseUpdateManyWithoutTenantNestedInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateUpdateManyWithoutTenantNestedInput
    badges?: BadgeUpdateManyWithoutTenantNestedInput
    workoutTemplates?: WorkoutTemplateUpdateManyWithoutTenantNestedInput
    scheduleTemplates?: ScheduleTemplateUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    vertical?: EnumVerticalFieldUpdateOperationsInput | $Enums.Vertical
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    aiCredits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    clients?: ClientUncheckedUpdateManyWithoutTenantNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutTenantNestedInput
    classes?: ClassUncheckedUpdateManyWithoutTenantNestedInput
    packages?: PackageUncheckedUpdateManyWithoutTenantNestedInput
    orders?: OrderUncheckedUpdateManyWithoutTenantNestedInput
    aiLogs?: AILogUncheckedUpdateManyWithoutTenantNestedInput
    bankAccounts?: BankAccountUncheckedUpdateManyWithoutTenantNestedInput
    bankTransactions?: BankTransactionUncheckedUpdateManyWithoutTenantNestedInput
    invoicePayments?: InvoicePaymentUncheckedUpdateManyWithoutTenantNestedInput
    paymentGatewayConfigs?: PaymentGatewayConfigUncheckedUpdateManyWithoutTenantNestedInput
    cryptoWallets?: CryptoWalletUncheckedUpdateManyWithoutTenantNestedInput
    expenseCategories?: ExpenseCategoryUncheckedUpdateManyWithoutTenantNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutTenantNestedInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateUncheckedUpdateManyWithoutTenantNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutTenantNestedInput
    workoutTemplates?: WorkoutTemplateUncheckedUpdateManyWithoutTenantNestedInput
    scheduleTemplates?: ScheduleTemplateUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type OrderUpsertWithoutInvoicesInput = {
    update: XOR<OrderUpdateWithoutInvoicesInput, OrderUncheckedUpdateWithoutInvoicesInput>
    create: XOR<OrderCreateWithoutInvoicesInput, OrderUncheckedCreateWithoutInvoicesInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutInvoicesInput, OrderUncheckedUpdateWithoutInvoicesInput>
  }

  export type OrderUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    items?: OrderUpdateitemsInput | InputJsonValue[]
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    paidAmount?: FloatFieldUpdateOperationsInput | number
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutOrdersNestedInput
    client?: ClientUpdateOneRequiredWithoutOrdersNestedInput
  }

  export type OrderUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    items?: OrderUpdateitemsInput | InputJsonValue[]
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    paidAmount?: FloatFieldUpdateOperationsInput | number
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientUpsertWithoutInvoicesInput = {
    update: XOR<ClientUpdateWithoutInvoicesInput, ClientUncheckedUpdateWithoutInvoicesInput>
    create: XOR<ClientCreateWithoutInvoicesInput, ClientUncheckedCreateWithoutInvoicesInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutInvoicesInput, ClientUncheckedUpdateWithoutInvoicesInput>
  }

  export type ClientUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    goals?: ClientUpdategoalsInput | string[]
    currentWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    targetWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    bodyMeasurements?: NullableJsonNullValueInput | InputJsonValue
    bodyFatPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    fitnessLevel?: NullableStringFieldUpdateOperationsInput | string | null
    injuryHistory?: NullableStringFieldUpdateOperationsInput | string | null
    dietaryNotes?: NullableStringFieldUpdateOperationsInput | string | null
    medicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    creditsRemaining?: IntFieldUpdateOperationsInput | number
    membershipType?: NullableStringFieldUpdateOperationsInput | string | null
    membershipExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    tags?: ClientUpdatetagsInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutClientsNestedInput
    sessions?: SessionUpdateManyWithoutClientNestedInput
    orders?: OrderUpdateManyWithoutClientNestedInput
    measurements?: ClientMeasurementUpdateManyWithoutClientNestedInput
    progressPhotos?: ProgressPhotoUpdateManyWithoutClientNestedInput
    badges?: ClientBadgeUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    goals?: ClientUpdategoalsInput | string[]
    currentWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    targetWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    bodyMeasurements?: NullableJsonNullValueInput | InputJsonValue
    bodyFatPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    fitnessLevel?: NullableStringFieldUpdateOperationsInput | string | null
    injuryHistory?: NullableStringFieldUpdateOperationsInput | string | null
    dietaryNotes?: NullableStringFieldUpdateOperationsInput | string | null
    medicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    creditsRemaining?: IntFieldUpdateOperationsInput | number
    membershipType?: NullableStringFieldUpdateOperationsInput | string | null
    membershipExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    tags?: ClientUpdatetagsInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutClientNestedInput
    orders?: OrderUncheckedUpdateManyWithoutClientNestedInput
    measurements?: ClientMeasurementUncheckedUpdateManyWithoutClientNestedInput
    progressPhotos?: ProgressPhotoUncheckedUpdateManyWithoutClientNestedInput
    badges?: ClientBadgeUncheckedUpdateManyWithoutClientNestedInput
  }

  export type InvoicePaymentUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: InvoicePaymentWhereUniqueInput
    update: XOR<InvoicePaymentUpdateWithoutInvoiceInput, InvoicePaymentUncheckedUpdateWithoutInvoiceInput>
    create: XOR<InvoicePaymentCreateWithoutInvoiceInput, InvoicePaymentUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoicePaymentUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: InvoicePaymentWhereUniqueInput
    data: XOR<InvoicePaymentUpdateWithoutInvoiceInput, InvoicePaymentUncheckedUpdateWithoutInvoiceInput>
  }

  export type InvoicePaymentUpdateManyWithWhereWithoutInvoiceInput = {
    where: InvoicePaymentScalarWhereInput
    data: XOR<InvoicePaymentUpdateManyMutationInput, InvoicePaymentUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type BankTransactionUpsertWithWhereUniqueWithoutMatchedInvoiceInput = {
    where: BankTransactionWhereUniqueInput
    update: XOR<BankTransactionUpdateWithoutMatchedInvoiceInput, BankTransactionUncheckedUpdateWithoutMatchedInvoiceInput>
    create: XOR<BankTransactionCreateWithoutMatchedInvoiceInput, BankTransactionUncheckedCreateWithoutMatchedInvoiceInput>
  }

  export type BankTransactionUpdateWithWhereUniqueWithoutMatchedInvoiceInput = {
    where: BankTransactionWhereUniqueInput
    data: XOR<BankTransactionUpdateWithoutMatchedInvoiceInput, BankTransactionUncheckedUpdateWithoutMatchedInvoiceInput>
  }

  export type BankTransactionUpdateManyWithWhereWithoutMatchedInvoiceInput = {
    where: BankTransactionScalarWhereInput
    data: XOR<BankTransactionUpdateManyMutationInput, BankTransactionUncheckedUpdateManyWithoutMatchedInvoiceInput>
  }

  export type CryptoPaymentUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: CryptoPaymentWhereUniqueInput
    update: XOR<CryptoPaymentUpdateWithoutInvoiceInput, CryptoPaymentUncheckedUpdateWithoutInvoiceInput>
    create: XOR<CryptoPaymentCreateWithoutInvoiceInput, CryptoPaymentUncheckedCreateWithoutInvoiceInput>
  }

  export type CryptoPaymentUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: CryptoPaymentWhereUniqueInput
    data: XOR<CryptoPaymentUpdateWithoutInvoiceInput, CryptoPaymentUncheckedUpdateWithoutInvoiceInput>
  }

  export type CryptoPaymentUpdateManyWithWhereWithoutInvoiceInput = {
    where: CryptoPaymentScalarWhereInput
    data: XOR<CryptoPaymentUpdateManyMutationInput, CryptoPaymentUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type CryptoPaymentScalarWhereInput = {
    AND?: CryptoPaymentScalarWhereInput | CryptoPaymentScalarWhereInput[]
    OR?: CryptoPaymentScalarWhereInput[]
    NOT?: CryptoPaymentScalarWhereInput | CryptoPaymentScalarWhereInput[]
    id?: StringFilter<"CryptoPayment"> | string
    walletId?: StringFilter<"CryptoPayment"> | string
    invoiceId?: StringNullableFilter<"CryptoPayment"> | string | null
    amount?: StringFilter<"CryptoPayment"> | string
    currency?: StringFilter<"CryptoPayment"> | string
    txHash?: StringNullableFilter<"CryptoPayment"> | string | null
    confirmations?: IntFilter<"CryptoPayment"> | number
    status?: StringFilter<"CryptoPayment"> | string
    detectedAt?: DateTimeNullableFilter<"CryptoPayment"> | Date | string | null
    confirmedAt?: DateTimeNullableFilter<"CryptoPayment"> | Date | string | null
    metadata?: JsonNullableFilter<"CryptoPayment">
    createdAt?: DateTimeFilter<"CryptoPayment"> | Date | string
    updatedAt?: DateTimeFilter<"CryptoPayment"> | Date | string
  }

  export type TenantCreateWithoutAiLogsInput = {
    id?: string
    vertical: $Enums.Vertical
    name: string
    slug: string
    email?: string | null
    phone?: string | null
    website?: string | null
    logo?: string | null
    subscriptionTier?: string
    aiCredits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    clients?: ClientCreateNestedManyWithoutTenantInput
    sessions?: SessionCreateNestedManyWithoutTenantInput
    classes?: ClassCreateNestedManyWithoutTenantInput
    packages?: PackageCreateNestedManyWithoutTenantInput
    orders?: OrderCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    bankAccounts?: BankAccountCreateNestedManyWithoutTenantInput
    bankTransactions?: BankTransactionCreateNestedManyWithoutTenantInput
    invoicePayments?: InvoicePaymentCreateNestedManyWithoutTenantInput
    paymentGatewayConfigs?: PaymentGatewayConfigCreateNestedManyWithoutTenantInput
    cryptoWallets?: CryptoWalletCreateNestedManyWithoutTenantInput
    expenseCategories?: ExpenseCategoryCreateNestedManyWithoutTenantInput
    expenses?: ExpenseCreateNestedManyWithoutTenantInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateCreateNestedManyWithoutTenantInput
    badges?: BadgeCreateNestedManyWithoutTenantInput
    workoutTemplates?: WorkoutTemplateCreateNestedManyWithoutTenantInput
    scheduleTemplates?: ScheduleTemplateCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutAiLogsInput = {
    id?: string
    vertical: $Enums.Vertical
    name: string
    slug: string
    email?: string | null
    phone?: string | null
    website?: string | null
    logo?: string | null
    subscriptionTier?: string
    aiCredits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    clients?: ClientUncheckedCreateNestedManyWithoutTenantInput
    sessions?: SessionUncheckedCreateNestedManyWithoutTenantInput
    classes?: ClassUncheckedCreateNestedManyWithoutTenantInput
    packages?: PackageUncheckedCreateNestedManyWithoutTenantInput
    orders?: OrderUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    bankAccounts?: BankAccountUncheckedCreateNestedManyWithoutTenantInput
    bankTransactions?: BankTransactionUncheckedCreateNestedManyWithoutTenantInput
    invoicePayments?: InvoicePaymentUncheckedCreateNestedManyWithoutTenantInput
    paymentGatewayConfigs?: PaymentGatewayConfigUncheckedCreateNestedManyWithoutTenantInput
    cryptoWallets?: CryptoWalletUncheckedCreateNestedManyWithoutTenantInput
    expenseCategories?: ExpenseCategoryUncheckedCreateNestedManyWithoutTenantInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutTenantInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateUncheckedCreateNestedManyWithoutTenantInput
    badges?: BadgeUncheckedCreateNestedManyWithoutTenantInput
    workoutTemplates?: WorkoutTemplateUncheckedCreateNestedManyWithoutTenantInput
    scheduleTemplates?: ScheduleTemplateUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutAiLogsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutAiLogsInput, TenantUncheckedCreateWithoutAiLogsInput>
  }

  export type TenantUpsertWithoutAiLogsInput = {
    update: XOR<TenantUpdateWithoutAiLogsInput, TenantUncheckedUpdateWithoutAiLogsInput>
    create: XOR<TenantCreateWithoutAiLogsInput, TenantUncheckedCreateWithoutAiLogsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutAiLogsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutAiLogsInput, TenantUncheckedUpdateWithoutAiLogsInput>
  }

  export type TenantUpdateWithoutAiLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vertical?: EnumVerticalFieldUpdateOperationsInput | $Enums.Vertical
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    aiCredits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    clients?: ClientUpdateManyWithoutTenantNestedInput
    sessions?: SessionUpdateManyWithoutTenantNestedInput
    classes?: ClassUpdateManyWithoutTenantNestedInput
    packages?: PackageUpdateManyWithoutTenantNestedInput
    orders?: OrderUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    bankAccounts?: BankAccountUpdateManyWithoutTenantNestedInput
    bankTransactions?: BankTransactionUpdateManyWithoutTenantNestedInput
    invoicePayments?: InvoicePaymentUpdateManyWithoutTenantNestedInput
    paymentGatewayConfigs?: PaymentGatewayConfigUpdateManyWithoutTenantNestedInput
    cryptoWallets?: CryptoWalletUpdateManyWithoutTenantNestedInput
    expenseCategories?: ExpenseCategoryUpdateManyWithoutTenantNestedInput
    expenses?: ExpenseUpdateManyWithoutTenantNestedInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateUpdateManyWithoutTenantNestedInput
    badges?: BadgeUpdateManyWithoutTenantNestedInput
    workoutTemplates?: WorkoutTemplateUpdateManyWithoutTenantNestedInput
    scheduleTemplates?: ScheduleTemplateUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutAiLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vertical?: EnumVerticalFieldUpdateOperationsInput | $Enums.Vertical
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    aiCredits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    clients?: ClientUncheckedUpdateManyWithoutTenantNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutTenantNestedInput
    classes?: ClassUncheckedUpdateManyWithoutTenantNestedInput
    packages?: PackageUncheckedUpdateManyWithoutTenantNestedInput
    orders?: OrderUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    bankAccounts?: BankAccountUncheckedUpdateManyWithoutTenantNestedInput
    bankTransactions?: BankTransactionUncheckedUpdateManyWithoutTenantNestedInput
    invoicePayments?: InvoicePaymentUncheckedUpdateManyWithoutTenantNestedInput
    paymentGatewayConfigs?: PaymentGatewayConfigUncheckedUpdateManyWithoutTenantNestedInput
    cryptoWallets?: CryptoWalletUncheckedUpdateManyWithoutTenantNestedInput
    expenseCategories?: ExpenseCategoryUncheckedUpdateManyWithoutTenantNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutTenantNestedInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateUncheckedUpdateManyWithoutTenantNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutTenantNestedInput
    workoutTemplates?: WorkoutTemplateUncheckedUpdateManyWithoutTenantNestedInput
    scheduleTemplates?: ScheduleTemplateUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type ExchangeRateCreateWithoutFromCurrencyInput = {
    id?: string
    rate: Decimal | DecimalJsLike | number | string
    source: string
    timestamp: Date | string
    toCurrency: CurrencyCreateNestedOneWithoutExchangeRatesToInput
  }

  export type ExchangeRateUncheckedCreateWithoutFromCurrencyInput = {
    id?: string
    toCurrencyId: string
    rate: Decimal | DecimalJsLike | number | string
    source: string
    timestamp: Date | string
  }

  export type ExchangeRateCreateOrConnectWithoutFromCurrencyInput = {
    where: ExchangeRateWhereUniqueInput
    create: XOR<ExchangeRateCreateWithoutFromCurrencyInput, ExchangeRateUncheckedCreateWithoutFromCurrencyInput>
  }

  export type ExchangeRateCreateManyFromCurrencyInputEnvelope = {
    data: ExchangeRateCreateManyFromCurrencyInput | ExchangeRateCreateManyFromCurrencyInput[]
    skipDuplicates?: boolean
  }

  export type ExchangeRateCreateWithoutToCurrencyInput = {
    id?: string
    rate: Decimal | DecimalJsLike | number | string
    source: string
    timestamp: Date | string
    fromCurrency: CurrencyCreateNestedOneWithoutExchangeRatesFromInput
  }

  export type ExchangeRateUncheckedCreateWithoutToCurrencyInput = {
    id?: string
    fromCurrencyId: string
    rate: Decimal | DecimalJsLike | number | string
    source: string
    timestamp: Date | string
  }

  export type ExchangeRateCreateOrConnectWithoutToCurrencyInput = {
    where: ExchangeRateWhereUniqueInput
    create: XOR<ExchangeRateCreateWithoutToCurrencyInput, ExchangeRateUncheckedCreateWithoutToCurrencyInput>
  }

  export type ExchangeRateCreateManyToCurrencyInputEnvelope = {
    data: ExchangeRateCreateManyToCurrencyInput | ExchangeRateCreateManyToCurrencyInput[]
    skipDuplicates?: boolean
  }

  export type ExchangeRateUpsertWithWhereUniqueWithoutFromCurrencyInput = {
    where: ExchangeRateWhereUniqueInput
    update: XOR<ExchangeRateUpdateWithoutFromCurrencyInput, ExchangeRateUncheckedUpdateWithoutFromCurrencyInput>
    create: XOR<ExchangeRateCreateWithoutFromCurrencyInput, ExchangeRateUncheckedCreateWithoutFromCurrencyInput>
  }

  export type ExchangeRateUpdateWithWhereUniqueWithoutFromCurrencyInput = {
    where: ExchangeRateWhereUniqueInput
    data: XOR<ExchangeRateUpdateWithoutFromCurrencyInput, ExchangeRateUncheckedUpdateWithoutFromCurrencyInput>
  }

  export type ExchangeRateUpdateManyWithWhereWithoutFromCurrencyInput = {
    where: ExchangeRateScalarWhereInput
    data: XOR<ExchangeRateUpdateManyMutationInput, ExchangeRateUncheckedUpdateManyWithoutFromCurrencyInput>
  }

  export type ExchangeRateScalarWhereInput = {
    AND?: ExchangeRateScalarWhereInput | ExchangeRateScalarWhereInput[]
    OR?: ExchangeRateScalarWhereInput[]
    NOT?: ExchangeRateScalarWhereInput | ExchangeRateScalarWhereInput[]
    id?: StringFilter<"ExchangeRate"> | string
    fromCurrencyId?: StringFilter<"ExchangeRate"> | string
    toCurrencyId?: StringFilter<"ExchangeRate"> | string
    rate?: DecimalFilter<"ExchangeRate"> | Decimal | DecimalJsLike | number | string
    source?: StringFilter<"ExchangeRate"> | string
    timestamp?: DateTimeFilter<"ExchangeRate"> | Date | string
  }

  export type ExchangeRateUpsertWithWhereUniqueWithoutToCurrencyInput = {
    where: ExchangeRateWhereUniqueInput
    update: XOR<ExchangeRateUpdateWithoutToCurrencyInput, ExchangeRateUncheckedUpdateWithoutToCurrencyInput>
    create: XOR<ExchangeRateCreateWithoutToCurrencyInput, ExchangeRateUncheckedCreateWithoutToCurrencyInput>
  }

  export type ExchangeRateUpdateWithWhereUniqueWithoutToCurrencyInput = {
    where: ExchangeRateWhereUniqueInput
    data: XOR<ExchangeRateUpdateWithoutToCurrencyInput, ExchangeRateUncheckedUpdateWithoutToCurrencyInput>
  }

  export type ExchangeRateUpdateManyWithWhereWithoutToCurrencyInput = {
    where: ExchangeRateScalarWhereInput
    data: XOR<ExchangeRateUpdateManyMutationInput, ExchangeRateUncheckedUpdateManyWithoutToCurrencyInput>
  }

  export type CurrencyCreateWithoutExchangeRatesFromInput = {
    id?: string
    code: string
    name: string
    symbol: string
    decimals?: number
    isCrypto?: boolean
    isStablecoin?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    exchangeRatesTo?: ExchangeRateCreateNestedManyWithoutToCurrencyInput
  }

  export type CurrencyUncheckedCreateWithoutExchangeRatesFromInput = {
    id?: string
    code: string
    name: string
    symbol: string
    decimals?: number
    isCrypto?: boolean
    isStablecoin?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    exchangeRatesTo?: ExchangeRateUncheckedCreateNestedManyWithoutToCurrencyInput
  }

  export type CurrencyCreateOrConnectWithoutExchangeRatesFromInput = {
    where: CurrencyWhereUniqueInput
    create: XOR<CurrencyCreateWithoutExchangeRatesFromInput, CurrencyUncheckedCreateWithoutExchangeRatesFromInput>
  }

  export type CurrencyCreateWithoutExchangeRatesToInput = {
    id?: string
    code: string
    name: string
    symbol: string
    decimals?: number
    isCrypto?: boolean
    isStablecoin?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    exchangeRatesFrom?: ExchangeRateCreateNestedManyWithoutFromCurrencyInput
  }

  export type CurrencyUncheckedCreateWithoutExchangeRatesToInput = {
    id?: string
    code: string
    name: string
    symbol: string
    decimals?: number
    isCrypto?: boolean
    isStablecoin?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    exchangeRatesFrom?: ExchangeRateUncheckedCreateNestedManyWithoutFromCurrencyInput
  }

  export type CurrencyCreateOrConnectWithoutExchangeRatesToInput = {
    where: CurrencyWhereUniqueInput
    create: XOR<CurrencyCreateWithoutExchangeRatesToInput, CurrencyUncheckedCreateWithoutExchangeRatesToInput>
  }

  export type CurrencyUpsertWithoutExchangeRatesFromInput = {
    update: XOR<CurrencyUpdateWithoutExchangeRatesFromInput, CurrencyUncheckedUpdateWithoutExchangeRatesFromInput>
    create: XOR<CurrencyCreateWithoutExchangeRatesFromInput, CurrencyUncheckedCreateWithoutExchangeRatesFromInput>
    where?: CurrencyWhereInput
  }

  export type CurrencyUpdateToOneWithWhereWithoutExchangeRatesFromInput = {
    where?: CurrencyWhereInput
    data: XOR<CurrencyUpdateWithoutExchangeRatesFromInput, CurrencyUncheckedUpdateWithoutExchangeRatesFromInput>
  }

  export type CurrencyUpdateWithoutExchangeRatesFromInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    isCrypto?: BoolFieldUpdateOperationsInput | boolean
    isStablecoin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exchangeRatesTo?: ExchangeRateUpdateManyWithoutToCurrencyNestedInput
  }

  export type CurrencyUncheckedUpdateWithoutExchangeRatesFromInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    isCrypto?: BoolFieldUpdateOperationsInput | boolean
    isStablecoin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exchangeRatesTo?: ExchangeRateUncheckedUpdateManyWithoutToCurrencyNestedInput
  }

  export type CurrencyUpsertWithoutExchangeRatesToInput = {
    update: XOR<CurrencyUpdateWithoutExchangeRatesToInput, CurrencyUncheckedUpdateWithoutExchangeRatesToInput>
    create: XOR<CurrencyCreateWithoutExchangeRatesToInput, CurrencyUncheckedCreateWithoutExchangeRatesToInput>
    where?: CurrencyWhereInput
  }

  export type CurrencyUpdateToOneWithWhereWithoutExchangeRatesToInput = {
    where?: CurrencyWhereInput
    data: XOR<CurrencyUpdateWithoutExchangeRatesToInput, CurrencyUncheckedUpdateWithoutExchangeRatesToInput>
  }

  export type CurrencyUpdateWithoutExchangeRatesToInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    isCrypto?: BoolFieldUpdateOperationsInput | boolean
    isStablecoin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exchangeRatesFrom?: ExchangeRateUpdateManyWithoutFromCurrencyNestedInput
  }

  export type CurrencyUncheckedUpdateWithoutExchangeRatesToInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    isCrypto?: BoolFieldUpdateOperationsInput | boolean
    isStablecoin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exchangeRatesFrom?: ExchangeRateUncheckedUpdateManyWithoutFromCurrencyNestedInput
  }

  export type TenantCreateWithoutBankAccountsInput = {
    id?: string
    vertical: $Enums.Vertical
    name: string
    slug: string
    email?: string | null
    phone?: string | null
    website?: string | null
    logo?: string | null
    subscriptionTier?: string
    aiCredits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    clients?: ClientCreateNestedManyWithoutTenantInput
    sessions?: SessionCreateNestedManyWithoutTenantInput
    classes?: ClassCreateNestedManyWithoutTenantInput
    packages?: PackageCreateNestedManyWithoutTenantInput
    orders?: OrderCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    aiLogs?: AILogCreateNestedManyWithoutTenantInput
    bankTransactions?: BankTransactionCreateNestedManyWithoutTenantInput
    invoicePayments?: InvoicePaymentCreateNestedManyWithoutTenantInput
    paymentGatewayConfigs?: PaymentGatewayConfigCreateNestedManyWithoutTenantInput
    cryptoWallets?: CryptoWalletCreateNestedManyWithoutTenantInput
    expenseCategories?: ExpenseCategoryCreateNestedManyWithoutTenantInput
    expenses?: ExpenseCreateNestedManyWithoutTenantInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateCreateNestedManyWithoutTenantInput
    badges?: BadgeCreateNestedManyWithoutTenantInput
    workoutTemplates?: WorkoutTemplateCreateNestedManyWithoutTenantInput
    scheduleTemplates?: ScheduleTemplateCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutBankAccountsInput = {
    id?: string
    vertical: $Enums.Vertical
    name: string
    slug: string
    email?: string | null
    phone?: string | null
    website?: string | null
    logo?: string | null
    subscriptionTier?: string
    aiCredits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    clients?: ClientUncheckedCreateNestedManyWithoutTenantInput
    sessions?: SessionUncheckedCreateNestedManyWithoutTenantInput
    classes?: ClassUncheckedCreateNestedManyWithoutTenantInput
    packages?: PackageUncheckedCreateNestedManyWithoutTenantInput
    orders?: OrderUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    aiLogs?: AILogUncheckedCreateNestedManyWithoutTenantInput
    bankTransactions?: BankTransactionUncheckedCreateNestedManyWithoutTenantInput
    invoicePayments?: InvoicePaymentUncheckedCreateNestedManyWithoutTenantInput
    paymentGatewayConfigs?: PaymentGatewayConfigUncheckedCreateNestedManyWithoutTenantInput
    cryptoWallets?: CryptoWalletUncheckedCreateNestedManyWithoutTenantInput
    expenseCategories?: ExpenseCategoryUncheckedCreateNestedManyWithoutTenantInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutTenantInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateUncheckedCreateNestedManyWithoutTenantInput
    badges?: BadgeUncheckedCreateNestedManyWithoutTenantInput
    workoutTemplates?: WorkoutTemplateUncheckedCreateNestedManyWithoutTenantInput
    scheduleTemplates?: ScheduleTemplateUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutBankAccountsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutBankAccountsInput, TenantUncheckedCreateWithoutBankAccountsInput>
  }

  export type BankTransactionCreateWithoutBankAccountInput = {
    id?: string
    transactionId: string
    date: Date | string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    type: $Enums.TransactionType
    counterpartyName?: string | null
    counterpartyAccount?: string | null
    counterpartyBankCode?: string | null
    description?: string | null
    note?: string | null
    variableSymbol?: string | null
    constantSymbol?: string | null
    specificSymbol?: string | null
    reference?: string | null
    isMatched?: boolean
    matchedPaymentId?: string | null
    matchConfidence?: Decimal | DecimalJsLike | number | string | null
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutBankTransactionsInput
    matchedInvoice?: InvoiceCreateNestedOneWithoutBankTransactionsInput
  }

  export type BankTransactionUncheckedCreateWithoutBankAccountInput = {
    id?: string
    tenantId: string
    transactionId: string
    date: Date | string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    type: $Enums.TransactionType
    counterpartyName?: string | null
    counterpartyAccount?: string | null
    counterpartyBankCode?: string | null
    description?: string | null
    note?: string | null
    variableSymbol?: string | null
    constantSymbol?: string | null
    specificSymbol?: string | null
    reference?: string | null
    isMatched?: boolean
    matchedInvoiceId?: string | null
    matchedPaymentId?: string | null
    matchConfidence?: Decimal | DecimalJsLike | number | string | null
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankTransactionCreateOrConnectWithoutBankAccountInput = {
    where: BankTransactionWhereUniqueInput
    create: XOR<BankTransactionCreateWithoutBankAccountInput, BankTransactionUncheckedCreateWithoutBankAccountInput>
  }

  export type BankTransactionCreateManyBankAccountInputEnvelope = {
    data: BankTransactionCreateManyBankAccountInput | BankTransactionCreateManyBankAccountInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutBankAccountsInput = {
    update: XOR<TenantUpdateWithoutBankAccountsInput, TenantUncheckedUpdateWithoutBankAccountsInput>
    create: XOR<TenantCreateWithoutBankAccountsInput, TenantUncheckedCreateWithoutBankAccountsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutBankAccountsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutBankAccountsInput, TenantUncheckedUpdateWithoutBankAccountsInput>
  }

  export type TenantUpdateWithoutBankAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vertical?: EnumVerticalFieldUpdateOperationsInput | $Enums.Vertical
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    aiCredits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    clients?: ClientUpdateManyWithoutTenantNestedInput
    sessions?: SessionUpdateManyWithoutTenantNestedInput
    classes?: ClassUpdateManyWithoutTenantNestedInput
    packages?: PackageUpdateManyWithoutTenantNestedInput
    orders?: OrderUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    aiLogs?: AILogUpdateManyWithoutTenantNestedInput
    bankTransactions?: BankTransactionUpdateManyWithoutTenantNestedInput
    invoicePayments?: InvoicePaymentUpdateManyWithoutTenantNestedInput
    paymentGatewayConfigs?: PaymentGatewayConfigUpdateManyWithoutTenantNestedInput
    cryptoWallets?: CryptoWalletUpdateManyWithoutTenantNestedInput
    expenseCategories?: ExpenseCategoryUpdateManyWithoutTenantNestedInput
    expenses?: ExpenseUpdateManyWithoutTenantNestedInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateUpdateManyWithoutTenantNestedInput
    badges?: BadgeUpdateManyWithoutTenantNestedInput
    workoutTemplates?: WorkoutTemplateUpdateManyWithoutTenantNestedInput
    scheduleTemplates?: ScheduleTemplateUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutBankAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vertical?: EnumVerticalFieldUpdateOperationsInput | $Enums.Vertical
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    aiCredits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    clients?: ClientUncheckedUpdateManyWithoutTenantNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutTenantNestedInput
    classes?: ClassUncheckedUpdateManyWithoutTenantNestedInput
    packages?: PackageUncheckedUpdateManyWithoutTenantNestedInput
    orders?: OrderUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    aiLogs?: AILogUncheckedUpdateManyWithoutTenantNestedInput
    bankTransactions?: BankTransactionUncheckedUpdateManyWithoutTenantNestedInput
    invoicePayments?: InvoicePaymentUncheckedUpdateManyWithoutTenantNestedInput
    paymentGatewayConfigs?: PaymentGatewayConfigUncheckedUpdateManyWithoutTenantNestedInput
    cryptoWallets?: CryptoWalletUncheckedUpdateManyWithoutTenantNestedInput
    expenseCategories?: ExpenseCategoryUncheckedUpdateManyWithoutTenantNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutTenantNestedInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateUncheckedUpdateManyWithoutTenantNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutTenantNestedInput
    workoutTemplates?: WorkoutTemplateUncheckedUpdateManyWithoutTenantNestedInput
    scheduleTemplates?: ScheduleTemplateUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type BankTransactionUpsertWithWhereUniqueWithoutBankAccountInput = {
    where: BankTransactionWhereUniqueInput
    update: XOR<BankTransactionUpdateWithoutBankAccountInput, BankTransactionUncheckedUpdateWithoutBankAccountInput>
    create: XOR<BankTransactionCreateWithoutBankAccountInput, BankTransactionUncheckedCreateWithoutBankAccountInput>
  }

  export type BankTransactionUpdateWithWhereUniqueWithoutBankAccountInput = {
    where: BankTransactionWhereUniqueInput
    data: XOR<BankTransactionUpdateWithoutBankAccountInput, BankTransactionUncheckedUpdateWithoutBankAccountInput>
  }

  export type BankTransactionUpdateManyWithWhereWithoutBankAccountInput = {
    where: BankTransactionScalarWhereInput
    data: XOR<BankTransactionUpdateManyMutationInput, BankTransactionUncheckedUpdateManyWithoutBankAccountInput>
  }

  export type BankAccountCreateWithoutTransactionsInput = {
    id?: string
    accountName: string
    accountNumber: string
    bankCode?: string | null
    iban?: string | null
    swift?: string | null
    provider: $Enums.BankProvider
    providerAccountId?: string | null
    currency?: string
    balance?: Decimal | DecimalJsLike | number | string | null
    balanceUpdatedAt?: Date | string | null
    autoSync?: boolean
    lastSyncAt?: Date | string | null
    syncFrequency?: string
    credentials?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutBankAccountsInput
  }

  export type BankAccountUncheckedCreateWithoutTransactionsInput = {
    id?: string
    tenantId: string
    accountName: string
    accountNumber: string
    bankCode?: string | null
    iban?: string | null
    swift?: string | null
    provider: $Enums.BankProvider
    providerAccountId?: string | null
    currency?: string
    balance?: Decimal | DecimalJsLike | number | string | null
    balanceUpdatedAt?: Date | string | null
    autoSync?: boolean
    lastSyncAt?: Date | string | null
    syncFrequency?: string
    credentials?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankAccountCreateOrConnectWithoutTransactionsInput = {
    where: BankAccountWhereUniqueInput
    create: XOR<BankAccountCreateWithoutTransactionsInput, BankAccountUncheckedCreateWithoutTransactionsInput>
  }

  export type TenantCreateWithoutBankTransactionsInput = {
    id?: string
    vertical: $Enums.Vertical
    name: string
    slug: string
    email?: string | null
    phone?: string | null
    website?: string | null
    logo?: string | null
    subscriptionTier?: string
    aiCredits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    clients?: ClientCreateNestedManyWithoutTenantInput
    sessions?: SessionCreateNestedManyWithoutTenantInput
    classes?: ClassCreateNestedManyWithoutTenantInput
    packages?: PackageCreateNestedManyWithoutTenantInput
    orders?: OrderCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    aiLogs?: AILogCreateNestedManyWithoutTenantInput
    bankAccounts?: BankAccountCreateNestedManyWithoutTenantInput
    invoicePayments?: InvoicePaymentCreateNestedManyWithoutTenantInput
    paymentGatewayConfigs?: PaymentGatewayConfigCreateNestedManyWithoutTenantInput
    cryptoWallets?: CryptoWalletCreateNestedManyWithoutTenantInput
    expenseCategories?: ExpenseCategoryCreateNestedManyWithoutTenantInput
    expenses?: ExpenseCreateNestedManyWithoutTenantInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateCreateNestedManyWithoutTenantInput
    badges?: BadgeCreateNestedManyWithoutTenantInput
    workoutTemplates?: WorkoutTemplateCreateNestedManyWithoutTenantInput
    scheduleTemplates?: ScheduleTemplateCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutBankTransactionsInput = {
    id?: string
    vertical: $Enums.Vertical
    name: string
    slug: string
    email?: string | null
    phone?: string | null
    website?: string | null
    logo?: string | null
    subscriptionTier?: string
    aiCredits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    clients?: ClientUncheckedCreateNestedManyWithoutTenantInput
    sessions?: SessionUncheckedCreateNestedManyWithoutTenantInput
    classes?: ClassUncheckedCreateNestedManyWithoutTenantInput
    packages?: PackageUncheckedCreateNestedManyWithoutTenantInput
    orders?: OrderUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    aiLogs?: AILogUncheckedCreateNestedManyWithoutTenantInput
    bankAccounts?: BankAccountUncheckedCreateNestedManyWithoutTenantInput
    invoicePayments?: InvoicePaymentUncheckedCreateNestedManyWithoutTenantInput
    paymentGatewayConfigs?: PaymentGatewayConfigUncheckedCreateNestedManyWithoutTenantInput
    cryptoWallets?: CryptoWalletUncheckedCreateNestedManyWithoutTenantInput
    expenseCategories?: ExpenseCategoryUncheckedCreateNestedManyWithoutTenantInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutTenantInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateUncheckedCreateNestedManyWithoutTenantInput
    badges?: BadgeUncheckedCreateNestedManyWithoutTenantInput
    workoutTemplates?: WorkoutTemplateUncheckedCreateNestedManyWithoutTenantInput
    scheduleTemplates?: ScheduleTemplateUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutBankTransactionsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutBankTransactionsInput, TenantUncheckedCreateWithoutBankTransactionsInput>
  }

  export type InvoiceCreateWithoutBankTransactionsInput = {
    id?: string
    invoiceNumber: string
    status?: string
    issueDate?: Date | string
    dueDate: Date | string
    paidDate?: Date | string | null
    subtotal: number
    tax?: number
    total: number
    paymentMethod?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutInvoicesInput
    order?: OrderCreateNestedOneWithoutInvoicesInput
    client: ClientCreateNestedOneWithoutInvoicesInput
    payments?: InvoicePaymentCreateNestedManyWithoutInvoiceInput
    cryptoPayments?: CryptoPaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutBankTransactionsInput = {
    id?: string
    tenantId: string
    orderId?: string | null
    clientId: string
    invoiceNumber: string
    status?: string
    issueDate?: Date | string
    dueDate: Date | string
    paidDate?: Date | string | null
    subtotal: number
    tax?: number
    total: number
    paymentMethod?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: InvoicePaymentUncheckedCreateNestedManyWithoutInvoiceInput
    cryptoPayments?: CryptoPaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutBankTransactionsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutBankTransactionsInput, InvoiceUncheckedCreateWithoutBankTransactionsInput>
  }

  export type BankAccountUpsertWithoutTransactionsInput = {
    update: XOR<BankAccountUpdateWithoutTransactionsInput, BankAccountUncheckedUpdateWithoutTransactionsInput>
    create: XOR<BankAccountCreateWithoutTransactionsInput, BankAccountUncheckedCreateWithoutTransactionsInput>
    where?: BankAccountWhereInput
  }

  export type BankAccountUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: BankAccountWhereInput
    data: XOR<BankAccountUpdateWithoutTransactionsInput, BankAccountUncheckedUpdateWithoutTransactionsInput>
  }

  export type BankAccountUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    bankCode?: NullableStringFieldUpdateOperationsInput | string | null
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    swift?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: EnumBankProviderFieldUpdateOperationsInput | $Enums.BankProvider
    providerAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balanceUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoSync?: BoolFieldUpdateOperationsInput | boolean
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncFrequency?: StringFieldUpdateOperationsInput | string
    credentials?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutBankAccountsNestedInput
  }

  export type BankAccountUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    bankCode?: NullableStringFieldUpdateOperationsInput | string | null
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    swift?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: EnumBankProviderFieldUpdateOperationsInput | $Enums.BankProvider
    providerAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balanceUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoSync?: BoolFieldUpdateOperationsInput | boolean
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncFrequency?: StringFieldUpdateOperationsInput | string
    credentials?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantUpsertWithoutBankTransactionsInput = {
    update: XOR<TenantUpdateWithoutBankTransactionsInput, TenantUncheckedUpdateWithoutBankTransactionsInput>
    create: XOR<TenantCreateWithoutBankTransactionsInput, TenantUncheckedCreateWithoutBankTransactionsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutBankTransactionsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutBankTransactionsInput, TenantUncheckedUpdateWithoutBankTransactionsInput>
  }

  export type TenantUpdateWithoutBankTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vertical?: EnumVerticalFieldUpdateOperationsInput | $Enums.Vertical
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    aiCredits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    clients?: ClientUpdateManyWithoutTenantNestedInput
    sessions?: SessionUpdateManyWithoutTenantNestedInput
    classes?: ClassUpdateManyWithoutTenantNestedInput
    packages?: PackageUpdateManyWithoutTenantNestedInput
    orders?: OrderUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    aiLogs?: AILogUpdateManyWithoutTenantNestedInput
    bankAccounts?: BankAccountUpdateManyWithoutTenantNestedInput
    invoicePayments?: InvoicePaymentUpdateManyWithoutTenantNestedInput
    paymentGatewayConfigs?: PaymentGatewayConfigUpdateManyWithoutTenantNestedInput
    cryptoWallets?: CryptoWalletUpdateManyWithoutTenantNestedInput
    expenseCategories?: ExpenseCategoryUpdateManyWithoutTenantNestedInput
    expenses?: ExpenseUpdateManyWithoutTenantNestedInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateUpdateManyWithoutTenantNestedInput
    badges?: BadgeUpdateManyWithoutTenantNestedInput
    workoutTemplates?: WorkoutTemplateUpdateManyWithoutTenantNestedInput
    scheduleTemplates?: ScheduleTemplateUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutBankTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vertical?: EnumVerticalFieldUpdateOperationsInput | $Enums.Vertical
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    aiCredits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    clients?: ClientUncheckedUpdateManyWithoutTenantNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutTenantNestedInput
    classes?: ClassUncheckedUpdateManyWithoutTenantNestedInput
    packages?: PackageUncheckedUpdateManyWithoutTenantNestedInput
    orders?: OrderUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    aiLogs?: AILogUncheckedUpdateManyWithoutTenantNestedInput
    bankAccounts?: BankAccountUncheckedUpdateManyWithoutTenantNestedInput
    invoicePayments?: InvoicePaymentUncheckedUpdateManyWithoutTenantNestedInput
    paymentGatewayConfigs?: PaymentGatewayConfigUncheckedUpdateManyWithoutTenantNestedInput
    cryptoWallets?: CryptoWalletUncheckedUpdateManyWithoutTenantNestedInput
    expenseCategories?: ExpenseCategoryUncheckedUpdateManyWithoutTenantNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutTenantNestedInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateUncheckedUpdateManyWithoutTenantNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutTenantNestedInput
    workoutTemplates?: WorkoutTemplateUncheckedUpdateManyWithoutTenantNestedInput
    scheduleTemplates?: ScheduleTemplateUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type InvoiceUpsertWithoutBankTransactionsInput = {
    update: XOR<InvoiceUpdateWithoutBankTransactionsInput, InvoiceUncheckedUpdateWithoutBankTransactionsInput>
    create: XOR<InvoiceCreateWithoutBankTransactionsInput, InvoiceUncheckedCreateWithoutBankTransactionsInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutBankTransactionsInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutBankTransactionsInput, InvoiceUncheckedUpdateWithoutBankTransactionsInput>
  }

  export type InvoiceUpdateWithoutBankTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutInvoicesNestedInput
    order?: OrderUpdateOneWithoutInvoicesNestedInput
    client?: ClientUpdateOneRequiredWithoutInvoicesNestedInput
    payments?: InvoicePaymentUpdateManyWithoutInvoiceNestedInput
    cryptoPayments?: CryptoPaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutBankTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: InvoicePaymentUncheckedUpdateManyWithoutInvoiceNestedInput
    cryptoPayments?: CryptoPaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type TenantCreateWithoutInvoicePaymentsInput = {
    id?: string
    vertical: $Enums.Vertical
    name: string
    slug: string
    email?: string | null
    phone?: string | null
    website?: string | null
    logo?: string | null
    subscriptionTier?: string
    aiCredits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    clients?: ClientCreateNestedManyWithoutTenantInput
    sessions?: SessionCreateNestedManyWithoutTenantInput
    classes?: ClassCreateNestedManyWithoutTenantInput
    packages?: PackageCreateNestedManyWithoutTenantInput
    orders?: OrderCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    aiLogs?: AILogCreateNestedManyWithoutTenantInput
    bankAccounts?: BankAccountCreateNestedManyWithoutTenantInput
    bankTransactions?: BankTransactionCreateNestedManyWithoutTenantInput
    paymentGatewayConfigs?: PaymentGatewayConfigCreateNestedManyWithoutTenantInput
    cryptoWallets?: CryptoWalletCreateNestedManyWithoutTenantInput
    expenseCategories?: ExpenseCategoryCreateNestedManyWithoutTenantInput
    expenses?: ExpenseCreateNestedManyWithoutTenantInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateCreateNestedManyWithoutTenantInput
    badges?: BadgeCreateNestedManyWithoutTenantInput
    workoutTemplates?: WorkoutTemplateCreateNestedManyWithoutTenantInput
    scheduleTemplates?: ScheduleTemplateCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutInvoicePaymentsInput = {
    id?: string
    vertical: $Enums.Vertical
    name: string
    slug: string
    email?: string | null
    phone?: string | null
    website?: string | null
    logo?: string | null
    subscriptionTier?: string
    aiCredits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    clients?: ClientUncheckedCreateNestedManyWithoutTenantInput
    sessions?: SessionUncheckedCreateNestedManyWithoutTenantInput
    classes?: ClassUncheckedCreateNestedManyWithoutTenantInput
    packages?: PackageUncheckedCreateNestedManyWithoutTenantInput
    orders?: OrderUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    aiLogs?: AILogUncheckedCreateNestedManyWithoutTenantInput
    bankAccounts?: BankAccountUncheckedCreateNestedManyWithoutTenantInput
    bankTransactions?: BankTransactionUncheckedCreateNestedManyWithoutTenantInput
    paymentGatewayConfigs?: PaymentGatewayConfigUncheckedCreateNestedManyWithoutTenantInput
    cryptoWallets?: CryptoWalletUncheckedCreateNestedManyWithoutTenantInput
    expenseCategories?: ExpenseCategoryUncheckedCreateNestedManyWithoutTenantInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutTenantInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateUncheckedCreateNestedManyWithoutTenantInput
    badges?: BadgeUncheckedCreateNestedManyWithoutTenantInput
    workoutTemplates?: WorkoutTemplateUncheckedCreateNestedManyWithoutTenantInput
    scheduleTemplates?: ScheduleTemplateUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutInvoicePaymentsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutInvoicePaymentsInput, TenantUncheckedCreateWithoutInvoicePaymentsInput>
  }

  export type InvoiceCreateWithoutPaymentsInput = {
    id?: string
    invoiceNumber: string
    status?: string
    issueDate?: Date | string
    dueDate: Date | string
    paidDate?: Date | string | null
    subtotal: number
    tax?: number
    total: number
    paymentMethod?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutInvoicesInput
    order?: OrderCreateNestedOneWithoutInvoicesInput
    client: ClientCreateNestedOneWithoutInvoicesInput
    bankTransactions?: BankTransactionCreateNestedManyWithoutMatchedInvoiceInput
    cryptoPayments?: CryptoPaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutPaymentsInput = {
    id?: string
    tenantId: string
    orderId?: string | null
    clientId: string
    invoiceNumber: string
    status?: string
    issueDate?: Date | string
    dueDate: Date | string
    paidDate?: Date | string | null
    subtotal: number
    tax?: number
    total: number
    paymentMethod?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bankTransactions?: BankTransactionUncheckedCreateNestedManyWithoutMatchedInvoiceInput
    cryptoPayments?: CryptoPaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutPaymentsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
  }

  export type TenantUpsertWithoutInvoicePaymentsInput = {
    update: XOR<TenantUpdateWithoutInvoicePaymentsInput, TenantUncheckedUpdateWithoutInvoicePaymentsInput>
    create: XOR<TenantCreateWithoutInvoicePaymentsInput, TenantUncheckedCreateWithoutInvoicePaymentsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutInvoicePaymentsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutInvoicePaymentsInput, TenantUncheckedUpdateWithoutInvoicePaymentsInput>
  }

  export type TenantUpdateWithoutInvoicePaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vertical?: EnumVerticalFieldUpdateOperationsInput | $Enums.Vertical
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    aiCredits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    clients?: ClientUpdateManyWithoutTenantNestedInput
    sessions?: SessionUpdateManyWithoutTenantNestedInput
    classes?: ClassUpdateManyWithoutTenantNestedInput
    packages?: PackageUpdateManyWithoutTenantNestedInput
    orders?: OrderUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    aiLogs?: AILogUpdateManyWithoutTenantNestedInput
    bankAccounts?: BankAccountUpdateManyWithoutTenantNestedInput
    bankTransactions?: BankTransactionUpdateManyWithoutTenantNestedInput
    paymentGatewayConfigs?: PaymentGatewayConfigUpdateManyWithoutTenantNestedInput
    cryptoWallets?: CryptoWalletUpdateManyWithoutTenantNestedInput
    expenseCategories?: ExpenseCategoryUpdateManyWithoutTenantNestedInput
    expenses?: ExpenseUpdateManyWithoutTenantNestedInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateUpdateManyWithoutTenantNestedInput
    badges?: BadgeUpdateManyWithoutTenantNestedInput
    workoutTemplates?: WorkoutTemplateUpdateManyWithoutTenantNestedInput
    scheduleTemplates?: ScheduleTemplateUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutInvoicePaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vertical?: EnumVerticalFieldUpdateOperationsInput | $Enums.Vertical
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    aiCredits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    clients?: ClientUncheckedUpdateManyWithoutTenantNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutTenantNestedInput
    classes?: ClassUncheckedUpdateManyWithoutTenantNestedInput
    packages?: PackageUncheckedUpdateManyWithoutTenantNestedInput
    orders?: OrderUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    aiLogs?: AILogUncheckedUpdateManyWithoutTenantNestedInput
    bankAccounts?: BankAccountUncheckedUpdateManyWithoutTenantNestedInput
    bankTransactions?: BankTransactionUncheckedUpdateManyWithoutTenantNestedInput
    paymentGatewayConfigs?: PaymentGatewayConfigUncheckedUpdateManyWithoutTenantNestedInput
    cryptoWallets?: CryptoWalletUncheckedUpdateManyWithoutTenantNestedInput
    expenseCategories?: ExpenseCategoryUncheckedUpdateManyWithoutTenantNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutTenantNestedInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateUncheckedUpdateManyWithoutTenantNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutTenantNestedInput
    workoutTemplates?: WorkoutTemplateUncheckedUpdateManyWithoutTenantNestedInput
    scheduleTemplates?: ScheduleTemplateUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type InvoiceUpsertWithoutPaymentsInput = {
    update: XOR<InvoiceUpdateWithoutPaymentsInput, InvoiceUncheckedUpdateWithoutPaymentsInput>
    create: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutPaymentsInput, InvoiceUncheckedUpdateWithoutPaymentsInput>
  }

  export type InvoiceUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutInvoicesNestedInput
    order?: OrderUpdateOneWithoutInvoicesNestedInput
    client?: ClientUpdateOneRequiredWithoutInvoicesNestedInput
    bankTransactions?: BankTransactionUpdateManyWithoutMatchedInvoiceNestedInput
    cryptoPayments?: CryptoPaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankTransactions?: BankTransactionUncheckedUpdateManyWithoutMatchedInvoiceNestedInput
    cryptoPayments?: CryptoPaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type TenantCreateWithoutPaymentGatewayConfigsInput = {
    id?: string
    vertical: $Enums.Vertical
    name: string
    slug: string
    email?: string | null
    phone?: string | null
    website?: string | null
    logo?: string | null
    subscriptionTier?: string
    aiCredits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    clients?: ClientCreateNestedManyWithoutTenantInput
    sessions?: SessionCreateNestedManyWithoutTenantInput
    classes?: ClassCreateNestedManyWithoutTenantInput
    packages?: PackageCreateNestedManyWithoutTenantInput
    orders?: OrderCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    aiLogs?: AILogCreateNestedManyWithoutTenantInput
    bankAccounts?: BankAccountCreateNestedManyWithoutTenantInput
    bankTransactions?: BankTransactionCreateNestedManyWithoutTenantInput
    invoicePayments?: InvoicePaymentCreateNestedManyWithoutTenantInput
    cryptoWallets?: CryptoWalletCreateNestedManyWithoutTenantInput
    expenseCategories?: ExpenseCategoryCreateNestedManyWithoutTenantInput
    expenses?: ExpenseCreateNestedManyWithoutTenantInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateCreateNestedManyWithoutTenantInput
    badges?: BadgeCreateNestedManyWithoutTenantInput
    workoutTemplates?: WorkoutTemplateCreateNestedManyWithoutTenantInput
    scheduleTemplates?: ScheduleTemplateCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutPaymentGatewayConfigsInput = {
    id?: string
    vertical: $Enums.Vertical
    name: string
    slug: string
    email?: string | null
    phone?: string | null
    website?: string | null
    logo?: string | null
    subscriptionTier?: string
    aiCredits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    clients?: ClientUncheckedCreateNestedManyWithoutTenantInput
    sessions?: SessionUncheckedCreateNestedManyWithoutTenantInput
    classes?: ClassUncheckedCreateNestedManyWithoutTenantInput
    packages?: PackageUncheckedCreateNestedManyWithoutTenantInput
    orders?: OrderUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    aiLogs?: AILogUncheckedCreateNestedManyWithoutTenantInput
    bankAccounts?: BankAccountUncheckedCreateNestedManyWithoutTenantInput
    bankTransactions?: BankTransactionUncheckedCreateNestedManyWithoutTenantInput
    invoicePayments?: InvoicePaymentUncheckedCreateNestedManyWithoutTenantInput
    cryptoWallets?: CryptoWalletUncheckedCreateNestedManyWithoutTenantInput
    expenseCategories?: ExpenseCategoryUncheckedCreateNestedManyWithoutTenantInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutTenantInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateUncheckedCreateNestedManyWithoutTenantInput
    badges?: BadgeUncheckedCreateNestedManyWithoutTenantInput
    workoutTemplates?: WorkoutTemplateUncheckedCreateNestedManyWithoutTenantInput
    scheduleTemplates?: ScheduleTemplateUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutPaymentGatewayConfigsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutPaymentGatewayConfigsInput, TenantUncheckedCreateWithoutPaymentGatewayConfigsInput>
  }

  export type TenantUpsertWithoutPaymentGatewayConfigsInput = {
    update: XOR<TenantUpdateWithoutPaymentGatewayConfigsInput, TenantUncheckedUpdateWithoutPaymentGatewayConfigsInput>
    create: XOR<TenantCreateWithoutPaymentGatewayConfigsInput, TenantUncheckedCreateWithoutPaymentGatewayConfigsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutPaymentGatewayConfigsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutPaymentGatewayConfigsInput, TenantUncheckedUpdateWithoutPaymentGatewayConfigsInput>
  }

  export type TenantUpdateWithoutPaymentGatewayConfigsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vertical?: EnumVerticalFieldUpdateOperationsInput | $Enums.Vertical
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    aiCredits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    clients?: ClientUpdateManyWithoutTenantNestedInput
    sessions?: SessionUpdateManyWithoutTenantNestedInput
    classes?: ClassUpdateManyWithoutTenantNestedInput
    packages?: PackageUpdateManyWithoutTenantNestedInput
    orders?: OrderUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    aiLogs?: AILogUpdateManyWithoutTenantNestedInput
    bankAccounts?: BankAccountUpdateManyWithoutTenantNestedInput
    bankTransactions?: BankTransactionUpdateManyWithoutTenantNestedInput
    invoicePayments?: InvoicePaymentUpdateManyWithoutTenantNestedInput
    cryptoWallets?: CryptoWalletUpdateManyWithoutTenantNestedInput
    expenseCategories?: ExpenseCategoryUpdateManyWithoutTenantNestedInput
    expenses?: ExpenseUpdateManyWithoutTenantNestedInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateUpdateManyWithoutTenantNestedInput
    badges?: BadgeUpdateManyWithoutTenantNestedInput
    workoutTemplates?: WorkoutTemplateUpdateManyWithoutTenantNestedInput
    scheduleTemplates?: ScheduleTemplateUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutPaymentGatewayConfigsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vertical?: EnumVerticalFieldUpdateOperationsInput | $Enums.Vertical
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    aiCredits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    clients?: ClientUncheckedUpdateManyWithoutTenantNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutTenantNestedInput
    classes?: ClassUncheckedUpdateManyWithoutTenantNestedInput
    packages?: PackageUncheckedUpdateManyWithoutTenantNestedInput
    orders?: OrderUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    aiLogs?: AILogUncheckedUpdateManyWithoutTenantNestedInput
    bankAccounts?: BankAccountUncheckedUpdateManyWithoutTenantNestedInput
    bankTransactions?: BankTransactionUncheckedUpdateManyWithoutTenantNestedInput
    invoicePayments?: InvoicePaymentUncheckedUpdateManyWithoutTenantNestedInput
    cryptoWallets?: CryptoWalletUncheckedUpdateManyWithoutTenantNestedInput
    expenseCategories?: ExpenseCategoryUncheckedUpdateManyWithoutTenantNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutTenantNestedInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateUncheckedUpdateManyWithoutTenantNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutTenantNestedInput
    workoutTemplates?: WorkoutTemplateUncheckedUpdateManyWithoutTenantNestedInput
    scheduleTemplates?: ScheduleTemplateUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateWithoutCryptoWalletsInput = {
    id?: string
    vertical: $Enums.Vertical
    name: string
    slug: string
    email?: string | null
    phone?: string | null
    website?: string | null
    logo?: string | null
    subscriptionTier?: string
    aiCredits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    clients?: ClientCreateNestedManyWithoutTenantInput
    sessions?: SessionCreateNestedManyWithoutTenantInput
    classes?: ClassCreateNestedManyWithoutTenantInput
    packages?: PackageCreateNestedManyWithoutTenantInput
    orders?: OrderCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    aiLogs?: AILogCreateNestedManyWithoutTenantInput
    bankAccounts?: BankAccountCreateNestedManyWithoutTenantInput
    bankTransactions?: BankTransactionCreateNestedManyWithoutTenantInput
    invoicePayments?: InvoicePaymentCreateNestedManyWithoutTenantInput
    paymentGatewayConfigs?: PaymentGatewayConfigCreateNestedManyWithoutTenantInput
    expenseCategories?: ExpenseCategoryCreateNestedManyWithoutTenantInput
    expenses?: ExpenseCreateNestedManyWithoutTenantInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateCreateNestedManyWithoutTenantInput
    badges?: BadgeCreateNestedManyWithoutTenantInput
    workoutTemplates?: WorkoutTemplateCreateNestedManyWithoutTenantInput
    scheduleTemplates?: ScheduleTemplateCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutCryptoWalletsInput = {
    id?: string
    vertical: $Enums.Vertical
    name: string
    slug: string
    email?: string | null
    phone?: string | null
    website?: string | null
    logo?: string | null
    subscriptionTier?: string
    aiCredits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    clients?: ClientUncheckedCreateNestedManyWithoutTenantInput
    sessions?: SessionUncheckedCreateNestedManyWithoutTenantInput
    classes?: ClassUncheckedCreateNestedManyWithoutTenantInput
    packages?: PackageUncheckedCreateNestedManyWithoutTenantInput
    orders?: OrderUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    aiLogs?: AILogUncheckedCreateNestedManyWithoutTenantInput
    bankAccounts?: BankAccountUncheckedCreateNestedManyWithoutTenantInput
    bankTransactions?: BankTransactionUncheckedCreateNestedManyWithoutTenantInput
    invoicePayments?: InvoicePaymentUncheckedCreateNestedManyWithoutTenantInput
    paymentGatewayConfigs?: PaymentGatewayConfigUncheckedCreateNestedManyWithoutTenantInput
    expenseCategories?: ExpenseCategoryUncheckedCreateNestedManyWithoutTenantInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutTenantInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateUncheckedCreateNestedManyWithoutTenantInput
    badges?: BadgeUncheckedCreateNestedManyWithoutTenantInput
    workoutTemplates?: WorkoutTemplateUncheckedCreateNestedManyWithoutTenantInput
    scheduleTemplates?: ScheduleTemplateUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutCryptoWalletsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutCryptoWalletsInput, TenantUncheckedCreateWithoutCryptoWalletsInput>
  }

  export type CryptoPaymentCreateWithoutWalletInput = {
    id?: string
    amount: string
    currency: string
    txHash?: string | null
    confirmations?: number
    status?: string
    detectedAt?: Date | string | null
    confirmedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice?: InvoiceCreateNestedOneWithoutCryptoPaymentsInput
  }

  export type CryptoPaymentUncheckedCreateWithoutWalletInput = {
    id?: string
    invoiceId?: string | null
    amount: string
    currency: string
    txHash?: string | null
    confirmations?: number
    status?: string
    detectedAt?: Date | string | null
    confirmedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CryptoPaymentCreateOrConnectWithoutWalletInput = {
    where: CryptoPaymentWhereUniqueInput
    create: XOR<CryptoPaymentCreateWithoutWalletInput, CryptoPaymentUncheckedCreateWithoutWalletInput>
  }

  export type CryptoPaymentCreateManyWalletInputEnvelope = {
    data: CryptoPaymentCreateManyWalletInput | CryptoPaymentCreateManyWalletInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutCryptoWalletsInput = {
    update: XOR<TenantUpdateWithoutCryptoWalletsInput, TenantUncheckedUpdateWithoutCryptoWalletsInput>
    create: XOR<TenantCreateWithoutCryptoWalletsInput, TenantUncheckedCreateWithoutCryptoWalletsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutCryptoWalletsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutCryptoWalletsInput, TenantUncheckedUpdateWithoutCryptoWalletsInput>
  }

  export type TenantUpdateWithoutCryptoWalletsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vertical?: EnumVerticalFieldUpdateOperationsInput | $Enums.Vertical
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    aiCredits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    clients?: ClientUpdateManyWithoutTenantNestedInput
    sessions?: SessionUpdateManyWithoutTenantNestedInput
    classes?: ClassUpdateManyWithoutTenantNestedInput
    packages?: PackageUpdateManyWithoutTenantNestedInput
    orders?: OrderUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    aiLogs?: AILogUpdateManyWithoutTenantNestedInput
    bankAccounts?: BankAccountUpdateManyWithoutTenantNestedInput
    bankTransactions?: BankTransactionUpdateManyWithoutTenantNestedInput
    invoicePayments?: InvoicePaymentUpdateManyWithoutTenantNestedInput
    paymentGatewayConfigs?: PaymentGatewayConfigUpdateManyWithoutTenantNestedInput
    expenseCategories?: ExpenseCategoryUpdateManyWithoutTenantNestedInput
    expenses?: ExpenseUpdateManyWithoutTenantNestedInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateUpdateManyWithoutTenantNestedInput
    badges?: BadgeUpdateManyWithoutTenantNestedInput
    workoutTemplates?: WorkoutTemplateUpdateManyWithoutTenantNestedInput
    scheduleTemplates?: ScheduleTemplateUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutCryptoWalletsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vertical?: EnumVerticalFieldUpdateOperationsInput | $Enums.Vertical
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    aiCredits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    clients?: ClientUncheckedUpdateManyWithoutTenantNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutTenantNestedInput
    classes?: ClassUncheckedUpdateManyWithoutTenantNestedInput
    packages?: PackageUncheckedUpdateManyWithoutTenantNestedInput
    orders?: OrderUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    aiLogs?: AILogUncheckedUpdateManyWithoutTenantNestedInput
    bankAccounts?: BankAccountUncheckedUpdateManyWithoutTenantNestedInput
    bankTransactions?: BankTransactionUncheckedUpdateManyWithoutTenantNestedInput
    invoicePayments?: InvoicePaymentUncheckedUpdateManyWithoutTenantNestedInput
    paymentGatewayConfigs?: PaymentGatewayConfigUncheckedUpdateManyWithoutTenantNestedInput
    expenseCategories?: ExpenseCategoryUncheckedUpdateManyWithoutTenantNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutTenantNestedInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateUncheckedUpdateManyWithoutTenantNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutTenantNestedInput
    workoutTemplates?: WorkoutTemplateUncheckedUpdateManyWithoutTenantNestedInput
    scheduleTemplates?: ScheduleTemplateUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type CryptoPaymentUpsertWithWhereUniqueWithoutWalletInput = {
    where: CryptoPaymentWhereUniqueInput
    update: XOR<CryptoPaymentUpdateWithoutWalletInput, CryptoPaymentUncheckedUpdateWithoutWalletInput>
    create: XOR<CryptoPaymentCreateWithoutWalletInput, CryptoPaymentUncheckedCreateWithoutWalletInput>
  }

  export type CryptoPaymentUpdateWithWhereUniqueWithoutWalletInput = {
    where: CryptoPaymentWhereUniqueInput
    data: XOR<CryptoPaymentUpdateWithoutWalletInput, CryptoPaymentUncheckedUpdateWithoutWalletInput>
  }

  export type CryptoPaymentUpdateManyWithWhereWithoutWalletInput = {
    where: CryptoPaymentScalarWhereInput
    data: XOR<CryptoPaymentUpdateManyMutationInput, CryptoPaymentUncheckedUpdateManyWithoutWalletInput>
  }

  export type CryptoWalletCreateWithoutPaymentsInput = {
    id?: string
    currency: string
    address: string
    network?: string | null
    provider: string
    isActive?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutCryptoWalletsInput
  }

  export type CryptoWalletUncheckedCreateWithoutPaymentsInput = {
    id?: string
    tenantId: string
    currency: string
    address: string
    network?: string | null
    provider: string
    isActive?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CryptoWalletCreateOrConnectWithoutPaymentsInput = {
    where: CryptoWalletWhereUniqueInput
    create: XOR<CryptoWalletCreateWithoutPaymentsInput, CryptoWalletUncheckedCreateWithoutPaymentsInput>
  }

  export type InvoiceCreateWithoutCryptoPaymentsInput = {
    id?: string
    invoiceNumber: string
    status?: string
    issueDate?: Date | string
    dueDate: Date | string
    paidDate?: Date | string | null
    subtotal: number
    tax?: number
    total: number
    paymentMethod?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutInvoicesInput
    order?: OrderCreateNestedOneWithoutInvoicesInput
    client: ClientCreateNestedOneWithoutInvoicesInput
    payments?: InvoicePaymentCreateNestedManyWithoutInvoiceInput
    bankTransactions?: BankTransactionCreateNestedManyWithoutMatchedInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutCryptoPaymentsInput = {
    id?: string
    tenantId: string
    orderId?: string | null
    clientId: string
    invoiceNumber: string
    status?: string
    issueDate?: Date | string
    dueDate: Date | string
    paidDate?: Date | string | null
    subtotal: number
    tax?: number
    total: number
    paymentMethod?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: InvoicePaymentUncheckedCreateNestedManyWithoutInvoiceInput
    bankTransactions?: BankTransactionUncheckedCreateNestedManyWithoutMatchedInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutCryptoPaymentsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutCryptoPaymentsInput, InvoiceUncheckedCreateWithoutCryptoPaymentsInput>
  }

  export type CryptoWalletUpsertWithoutPaymentsInput = {
    update: XOR<CryptoWalletUpdateWithoutPaymentsInput, CryptoWalletUncheckedUpdateWithoutPaymentsInput>
    create: XOR<CryptoWalletCreateWithoutPaymentsInput, CryptoWalletUncheckedCreateWithoutPaymentsInput>
    where?: CryptoWalletWhereInput
  }

  export type CryptoWalletUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: CryptoWalletWhereInput
    data: XOR<CryptoWalletUpdateWithoutPaymentsInput, CryptoWalletUncheckedUpdateWithoutPaymentsInput>
  }

  export type CryptoWalletUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    network?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutCryptoWalletsNestedInput
  }

  export type CryptoWalletUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    network?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpsertWithoutCryptoPaymentsInput = {
    update: XOR<InvoiceUpdateWithoutCryptoPaymentsInput, InvoiceUncheckedUpdateWithoutCryptoPaymentsInput>
    create: XOR<InvoiceCreateWithoutCryptoPaymentsInput, InvoiceUncheckedCreateWithoutCryptoPaymentsInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutCryptoPaymentsInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutCryptoPaymentsInput, InvoiceUncheckedUpdateWithoutCryptoPaymentsInput>
  }

  export type InvoiceUpdateWithoutCryptoPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutInvoicesNestedInput
    order?: OrderUpdateOneWithoutInvoicesNestedInput
    client?: ClientUpdateOneRequiredWithoutInvoicesNestedInput
    payments?: InvoicePaymentUpdateManyWithoutInvoiceNestedInput
    bankTransactions?: BankTransactionUpdateManyWithoutMatchedInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutCryptoPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: InvoicePaymentUncheckedUpdateManyWithoutInvoiceNestedInput
    bankTransactions?: BankTransactionUncheckedUpdateManyWithoutMatchedInvoiceNestedInput
  }

  export type TenantCreateWithoutExpenseCategoriesInput = {
    id?: string
    vertical: $Enums.Vertical
    name: string
    slug: string
    email?: string | null
    phone?: string | null
    website?: string | null
    logo?: string | null
    subscriptionTier?: string
    aiCredits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    clients?: ClientCreateNestedManyWithoutTenantInput
    sessions?: SessionCreateNestedManyWithoutTenantInput
    classes?: ClassCreateNestedManyWithoutTenantInput
    packages?: PackageCreateNestedManyWithoutTenantInput
    orders?: OrderCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    aiLogs?: AILogCreateNestedManyWithoutTenantInput
    bankAccounts?: BankAccountCreateNestedManyWithoutTenantInput
    bankTransactions?: BankTransactionCreateNestedManyWithoutTenantInput
    invoicePayments?: InvoicePaymentCreateNestedManyWithoutTenantInput
    paymentGatewayConfigs?: PaymentGatewayConfigCreateNestedManyWithoutTenantInput
    cryptoWallets?: CryptoWalletCreateNestedManyWithoutTenantInput
    expenses?: ExpenseCreateNestedManyWithoutTenantInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateCreateNestedManyWithoutTenantInput
    badges?: BadgeCreateNestedManyWithoutTenantInput
    workoutTemplates?: WorkoutTemplateCreateNestedManyWithoutTenantInput
    scheduleTemplates?: ScheduleTemplateCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutExpenseCategoriesInput = {
    id?: string
    vertical: $Enums.Vertical
    name: string
    slug: string
    email?: string | null
    phone?: string | null
    website?: string | null
    logo?: string | null
    subscriptionTier?: string
    aiCredits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    clients?: ClientUncheckedCreateNestedManyWithoutTenantInput
    sessions?: SessionUncheckedCreateNestedManyWithoutTenantInput
    classes?: ClassUncheckedCreateNestedManyWithoutTenantInput
    packages?: PackageUncheckedCreateNestedManyWithoutTenantInput
    orders?: OrderUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    aiLogs?: AILogUncheckedCreateNestedManyWithoutTenantInput
    bankAccounts?: BankAccountUncheckedCreateNestedManyWithoutTenantInput
    bankTransactions?: BankTransactionUncheckedCreateNestedManyWithoutTenantInput
    invoicePayments?: InvoicePaymentUncheckedCreateNestedManyWithoutTenantInput
    paymentGatewayConfigs?: PaymentGatewayConfigUncheckedCreateNestedManyWithoutTenantInput
    cryptoWallets?: CryptoWalletUncheckedCreateNestedManyWithoutTenantInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutTenantInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateUncheckedCreateNestedManyWithoutTenantInput
    badges?: BadgeUncheckedCreateNestedManyWithoutTenantInput
    workoutTemplates?: WorkoutTemplateUncheckedCreateNestedManyWithoutTenantInput
    scheduleTemplates?: ScheduleTemplateUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutExpenseCategoriesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutExpenseCategoriesInput, TenantUncheckedCreateWithoutExpenseCategoriesInput>
  }

  export type ExpenseCreateWithoutCategoryInput = {
    id?: string
    description: string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    date: Date | string
    vendor?: string | null
    receiptUrl?: string | null
    receiptOcrData?: NullableJsonNullValueInput | InputJsonValue
    taxAmount?: Decimal | DecimalJsLike | number | string | null
    isTaxDeductible?: boolean
    status: $Enums.ExpenseStatus
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectedReason?: string | null
    reimbursedAt?: Date | string | null
    reimbursedAmount?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutExpensesInput
  }

  export type ExpenseUncheckedCreateWithoutCategoryInput = {
    id?: string
    tenantId: string
    description: string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    date: Date | string
    vendor?: string | null
    receiptUrl?: string | null
    receiptOcrData?: NullableJsonNullValueInput | InputJsonValue
    taxAmount?: Decimal | DecimalJsLike | number | string | null
    isTaxDeductible?: boolean
    status: $Enums.ExpenseStatus
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectedReason?: string | null
    reimbursedAt?: Date | string | null
    reimbursedAmount?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseCreateOrConnectWithoutCategoryInput = {
    where: ExpenseWhereUniqueInput
    create: XOR<ExpenseCreateWithoutCategoryInput, ExpenseUncheckedCreateWithoutCategoryInput>
  }

  export type ExpenseCreateManyCategoryInputEnvelope = {
    data: ExpenseCreateManyCategoryInput | ExpenseCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutExpenseCategoriesInput = {
    update: XOR<TenantUpdateWithoutExpenseCategoriesInput, TenantUncheckedUpdateWithoutExpenseCategoriesInput>
    create: XOR<TenantCreateWithoutExpenseCategoriesInput, TenantUncheckedCreateWithoutExpenseCategoriesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutExpenseCategoriesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutExpenseCategoriesInput, TenantUncheckedUpdateWithoutExpenseCategoriesInput>
  }

  export type TenantUpdateWithoutExpenseCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    vertical?: EnumVerticalFieldUpdateOperationsInput | $Enums.Vertical
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    aiCredits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    clients?: ClientUpdateManyWithoutTenantNestedInput
    sessions?: SessionUpdateManyWithoutTenantNestedInput
    classes?: ClassUpdateManyWithoutTenantNestedInput
    packages?: PackageUpdateManyWithoutTenantNestedInput
    orders?: OrderUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    aiLogs?: AILogUpdateManyWithoutTenantNestedInput
    bankAccounts?: BankAccountUpdateManyWithoutTenantNestedInput
    bankTransactions?: BankTransactionUpdateManyWithoutTenantNestedInput
    invoicePayments?: InvoicePaymentUpdateManyWithoutTenantNestedInput
    paymentGatewayConfigs?: PaymentGatewayConfigUpdateManyWithoutTenantNestedInput
    cryptoWallets?: CryptoWalletUpdateManyWithoutTenantNestedInput
    expenses?: ExpenseUpdateManyWithoutTenantNestedInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateUpdateManyWithoutTenantNestedInput
    badges?: BadgeUpdateManyWithoutTenantNestedInput
    workoutTemplates?: WorkoutTemplateUpdateManyWithoutTenantNestedInput
    scheduleTemplates?: ScheduleTemplateUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutExpenseCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    vertical?: EnumVerticalFieldUpdateOperationsInput | $Enums.Vertical
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    aiCredits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    clients?: ClientUncheckedUpdateManyWithoutTenantNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutTenantNestedInput
    classes?: ClassUncheckedUpdateManyWithoutTenantNestedInput
    packages?: PackageUncheckedUpdateManyWithoutTenantNestedInput
    orders?: OrderUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    aiLogs?: AILogUncheckedUpdateManyWithoutTenantNestedInput
    bankAccounts?: BankAccountUncheckedUpdateManyWithoutTenantNestedInput
    bankTransactions?: BankTransactionUncheckedUpdateManyWithoutTenantNestedInput
    invoicePayments?: InvoicePaymentUncheckedUpdateManyWithoutTenantNestedInput
    paymentGatewayConfigs?: PaymentGatewayConfigUncheckedUpdateManyWithoutTenantNestedInput
    cryptoWallets?: CryptoWalletUncheckedUpdateManyWithoutTenantNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutTenantNestedInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateUncheckedUpdateManyWithoutTenantNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutTenantNestedInput
    workoutTemplates?: WorkoutTemplateUncheckedUpdateManyWithoutTenantNestedInput
    scheduleTemplates?: ScheduleTemplateUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type ExpenseUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ExpenseWhereUniqueInput
    update: XOR<ExpenseUpdateWithoutCategoryInput, ExpenseUncheckedUpdateWithoutCategoryInput>
    create: XOR<ExpenseCreateWithoutCategoryInput, ExpenseUncheckedCreateWithoutCategoryInput>
  }

  export type ExpenseUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ExpenseWhereUniqueInput
    data: XOR<ExpenseUpdateWithoutCategoryInput, ExpenseUncheckedUpdateWithoutCategoryInput>
  }

  export type ExpenseUpdateManyWithWhereWithoutCategoryInput = {
    where: ExpenseScalarWhereInput
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyWithoutCategoryInput>
  }

  export type TenantCreateWithoutExpensesInput = {
    id?: string
    vertical: $Enums.Vertical
    name: string
    slug: string
    email?: string | null
    phone?: string | null
    website?: string | null
    logo?: string | null
    subscriptionTier?: string
    aiCredits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    clients?: ClientCreateNestedManyWithoutTenantInput
    sessions?: SessionCreateNestedManyWithoutTenantInput
    classes?: ClassCreateNestedManyWithoutTenantInput
    packages?: PackageCreateNestedManyWithoutTenantInput
    orders?: OrderCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    aiLogs?: AILogCreateNestedManyWithoutTenantInput
    bankAccounts?: BankAccountCreateNestedManyWithoutTenantInput
    bankTransactions?: BankTransactionCreateNestedManyWithoutTenantInput
    invoicePayments?: InvoicePaymentCreateNestedManyWithoutTenantInput
    paymentGatewayConfigs?: PaymentGatewayConfigCreateNestedManyWithoutTenantInput
    cryptoWallets?: CryptoWalletCreateNestedManyWithoutTenantInput
    expenseCategories?: ExpenseCategoryCreateNestedManyWithoutTenantInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateCreateNestedManyWithoutTenantInput
    badges?: BadgeCreateNestedManyWithoutTenantInput
    workoutTemplates?: WorkoutTemplateCreateNestedManyWithoutTenantInput
    scheduleTemplates?: ScheduleTemplateCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutExpensesInput = {
    id?: string
    vertical: $Enums.Vertical
    name: string
    slug: string
    email?: string | null
    phone?: string | null
    website?: string | null
    logo?: string | null
    subscriptionTier?: string
    aiCredits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    clients?: ClientUncheckedCreateNestedManyWithoutTenantInput
    sessions?: SessionUncheckedCreateNestedManyWithoutTenantInput
    classes?: ClassUncheckedCreateNestedManyWithoutTenantInput
    packages?: PackageUncheckedCreateNestedManyWithoutTenantInput
    orders?: OrderUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    aiLogs?: AILogUncheckedCreateNestedManyWithoutTenantInput
    bankAccounts?: BankAccountUncheckedCreateNestedManyWithoutTenantInput
    bankTransactions?: BankTransactionUncheckedCreateNestedManyWithoutTenantInput
    invoicePayments?: InvoicePaymentUncheckedCreateNestedManyWithoutTenantInput
    paymentGatewayConfigs?: PaymentGatewayConfigUncheckedCreateNestedManyWithoutTenantInput
    cryptoWallets?: CryptoWalletUncheckedCreateNestedManyWithoutTenantInput
    expenseCategories?: ExpenseCategoryUncheckedCreateNestedManyWithoutTenantInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateUncheckedCreateNestedManyWithoutTenantInput
    badges?: BadgeUncheckedCreateNestedManyWithoutTenantInput
    workoutTemplates?: WorkoutTemplateUncheckedCreateNestedManyWithoutTenantInput
    scheduleTemplates?: ScheduleTemplateUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutExpensesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutExpensesInput, TenantUncheckedCreateWithoutExpensesInput>
  }

  export type ExpenseCategoryCreateWithoutExpensesInput = {
    id?: string
    name: string
    description?: string | null
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutExpenseCategoriesInput
  }

  export type ExpenseCategoryUncheckedCreateWithoutExpensesInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseCategoryCreateOrConnectWithoutExpensesInput = {
    where: ExpenseCategoryWhereUniqueInput
    create: XOR<ExpenseCategoryCreateWithoutExpensesInput, ExpenseCategoryUncheckedCreateWithoutExpensesInput>
  }

  export type TenantUpsertWithoutExpensesInput = {
    update: XOR<TenantUpdateWithoutExpensesInput, TenantUncheckedUpdateWithoutExpensesInput>
    create: XOR<TenantCreateWithoutExpensesInput, TenantUncheckedCreateWithoutExpensesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutExpensesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutExpensesInput, TenantUncheckedUpdateWithoutExpensesInput>
  }

  export type TenantUpdateWithoutExpensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    vertical?: EnumVerticalFieldUpdateOperationsInput | $Enums.Vertical
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    aiCredits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    clients?: ClientUpdateManyWithoutTenantNestedInput
    sessions?: SessionUpdateManyWithoutTenantNestedInput
    classes?: ClassUpdateManyWithoutTenantNestedInput
    packages?: PackageUpdateManyWithoutTenantNestedInput
    orders?: OrderUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    aiLogs?: AILogUpdateManyWithoutTenantNestedInput
    bankAccounts?: BankAccountUpdateManyWithoutTenantNestedInput
    bankTransactions?: BankTransactionUpdateManyWithoutTenantNestedInput
    invoicePayments?: InvoicePaymentUpdateManyWithoutTenantNestedInput
    paymentGatewayConfigs?: PaymentGatewayConfigUpdateManyWithoutTenantNestedInput
    cryptoWallets?: CryptoWalletUpdateManyWithoutTenantNestedInput
    expenseCategories?: ExpenseCategoryUpdateManyWithoutTenantNestedInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateUpdateManyWithoutTenantNestedInput
    badges?: BadgeUpdateManyWithoutTenantNestedInput
    workoutTemplates?: WorkoutTemplateUpdateManyWithoutTenantNestedInput
    scheduleTemplates?: ScheduleTemplateUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutExpensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    vertical?: EnumVerticalFieldUpdateOperationsInput | $Enums.Vertical
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    aiCredits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    clients?: ClientUncheckedUpdateManyWithoutTenantNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutTenantNestedInput
    classes?: ClassUncheckedUpdateManyWithoutTenantNestedInput
    packages?: PackageUncheckedUpdateManyWithoutTenantNestedInput
    orders?: OrderUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    aiLogs?: AILogUncheckedUpdateManyWithoutTenantNestedInput
    bankAccounts?: BankAccountUncheckedUpdateManyWithoutTenantNestedInput
    bankTransactions?: BankTransactionUncheckedUpdateManyWithoutTenantNestedInput
    invoicePayments?: InvoicePaymentUncheckedUpdateManyWithoutTenantNestedInput
    paymentGatewayConfigs?: PaymentGatewayConfigUncheckedUpdateManyWithoutTenantNestedInput
    cryptoWallets?: CryptoWalletUncheckedUpdateManyWithoutTenantNestedInput
    expenseCategories?: ExpenseCategoryUncheckedUpdateManyWithoutTenantNestedInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateUncheckedUpdateManyWithoutTenantNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutTenantNestedInput
    workoutTemplates?: WorkoutTemplateUncheckedUpdateManyWithoutTenantNestedInput
    scheduleTemplates?: ScheduleTemplateUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type ExpenseCategoryUpsertWithoutExpensesInput = {
    update: XOR<ExpenseCategoryUpdateWithoutExpensesInput, ExpenseCategoryUncheckedUpdateWithoutExpensesInput>
    create: XOR<ExpenseCategoryCreateWithoutExpensesInput, ExpenseCategoryUncheckedCreateWithoutExpensesInput>
    where?: ExpenseCategoryWhereInput
  }

  export type ExpenseCategoryUpdateToOneWithWhereWithoutExpensesInput = {
    where?: ExpenseCategoryWhereInput
    data: XOR<ExpenseCategoryUpdateWithoutExpensesInput, ExpenseCategoryUncheckedUpdateWithoutExpensesInput>
  }

  export type ExpenseCategoryUpdateWithoutExpensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutExpenseCategoriesNestedInput
  }

  export type ExpenseCategoryUncheckedUpdateWithoutExpensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantCreateWithoutRecurringInvoiceTemplatesInput = {
    id?: string
    vertical: $Enums.Vertical
    name: string
    slug: string
    email?: string | null
    phone?: string | null
    website?: string | null
    logo?: string | null
    subscriptionTier?: string
    aiCredits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    clients?: ClientCreateNestedManyWithoutTenantInput
    sessions?: SessionCreateNestedManyWithoutTenantInput
    classes?: ClassCreateNestedManyWithoutTenantInput
    packages?: PackageCreateNestedManyWithoutTenantInput
    orders?: OrderCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    aiLogs?: AILogCreateNestedManyWithoutTenantInput
    bankAccounts?: BankAccountCreateNestedManyWithoutTenantInput
    bankTransactions?: BankTransactionCreateNestedManyWithoutTenantInput
    invoicePayments?: InvoicePaymentCreateNestedManyWithoutTenantInput
    paymentGatewayConfigs?: PaymentGatewayConfigCreateNestedManyWithoutTenantInput
    cryptoWallets?: CryptoWalletCreateNestedManyWithoutTenantInput
    expenseCategories?: ExpenseCategoryCreateNestedManyWithoutTenantInput
    expenses?: ExpenseCreateNestedManyWithoutTenantInput
    badges?: BadgeCreateNestedManyWithoutTenantInput
    workoutTemplates?: WorkoutTemplateCreateNestedManyWithoutTenantInput
    scheduleTemplates?: ScheduleTemplateCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutRecurringInvoiceTemplatesInput = {
    id?: string
    vertical: $Enums.Vertical
    name: string
    slug: string
    email?: string | null
    phone?: string | null
    website?: string | null
    logo?: string | null
    subscriptionTier?: string
    aiCredits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    clients?: ClientUncheckedCreateNestedManyWithoutTenantInput
    sessions?: SessionUncheckedCreateNestedManyWithoutTenantInput
    classes?: ClassUncheckedCreateNestedManyWithoutTenantInput
    packages?: PackageUncheckedCreateNestedManyWithoutTenantInput
    orders?: OrderUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    aiLogs?: AILogUncheckedCreateNestedManyWithoutTenantInput
    bankAccounts?: BankAccountUncheckedCreateNestedManyWithoutTenantInput
    bankTransactions?: BankTransactionUncheckedCreateNestedManyWithoutTenantInput
    invoicePayments?: InvoicePaymentUncheckedCreateNestedManyWithoutTenantInput
    paymentGatewayConfigs?: PaymentGatewayConfigUncheckedCreateNestedManyWithoutTenantInput
    cryptoWallets?: CryptoWalletUncheckedCreateNestedManyWithoutTenantInput
    expenseCategories?: ExpenseCategoryUncheckedCreateNestedManyWithoutTenantInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutTenantInput
    badges?: BadgeUncheckedCreateNestedManyWithoutTenantInput
    workoutTemplates?: WorkoutTemplateUncheckedCreateNestedManyWithoutTenantInput
    scheduleTemplates?: ScheduleTemplateUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutRecurringInvoiceTemplatesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutRecurringInvoiceTemplatesInput, TenantUncheckedCreateWithoutRecurringInvoiceTemplatesInput>
  }

  export type TenantUpsertWithoutRecurringInvoiceTemplatesInput = {
    update: XOR<TenantUpdateWithoutRecurringInvoiceTemplatesInput, TenantUncheckedUpdateWithoutRecurringInvoiceTemplatesInput>
    create: XOR<TenantCreateWithoutRecurringInvoiceTemplatesInput, TenantUncheckedCreateWithoutRecurringInvoiceTemplatesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutRecurringInvoiceTemplatesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutRecurringInvoiceTemplatesInput, TenantUncheckedUpdateWithoutRecurringInvoiceTemplatesInput>
  }

  export type TenantUpdateWithoutRecurringInvoiceTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    vertical?: EnumVerticalFieldUpdateOperationsInput | $Enums.Vertical
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    aiCredits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    clients?: ClientUpdateManyWithoutTenantNestedInput
    sessions?: SessionUpdateManyWithoutTenantNestedInput
    classes?: ClassUpdateManyWithoutTenantNestedInput
    packages?: PackageUpdateManyWithoutTenantNestedInput
    orders?: OrderUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    aiLogs?: AILogUpdateManyWithoutTenantNestedInput
    bankAccounts?: BankAccountUpdateManyWithoutTenantNestedInput
    bankTransactions?: BankTransactionUpdateManyWithoutTenantNestedInput
    invoicePayments?: InvoicePaymentUpdateManyWithoutTenantNestedInput
    paymentGatewayConfigs?: PaymentGatewayConfigUpdateManyWithoutTenantNestedInput
    cryptoWallets?: CryptoWalletUpdateManyWithoutTenantNestedInput
    expenseCategories?: ExpenseCategoryUpdateManyWithoutTenantNestedInput
    expenses?: ExpenseUpdateManyWithoutTenantNestedInput
    badges?: BadgeUpdateManyWithoutTenantNestedInput
    workoutTemplates?: WorkoutTemplateUpdateManyWithoutTenantNestedInput
    scheduleTemplates?: ScheduleTemplateUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutRecurringInvoiceTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    vertical?: EnumVerticalFieldUpdateOperationsInput | $Enums.Vertical
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    aiCredits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    clients?: ClientUncheckedUpdateManyWithoutTenantNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutTenantNestedInput
    classes?: ClassUncheckedUpdateManyWithoutTenantNestedInput
    packages?: PackageUncheckedUpdateManyWithoutTenantNestedInput
    orders?: OrderUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    aiLogs?: AILogUncheckedUpdateManyWithoutTenantNestedInput
    bankAccounts?: BankAccountUncheckedUpdateManyWithoutTenantNestedInput
    bankTransactions?: BankTransactionUncheckedUpdateManyWithoutTenantNestedInput
    invoicePayments?: InvoicePaymentUncheckedUpdateManyWithoutTenantNestedInput
    paymentGatewayConfigs?: PaymentGatewayConfigUncheckedUpdateManyWithoutTenantNestedInput
    cryptoWallets?: CryptoWalletUncheckedUpdateManyWithoutTenantNestedInput
    expenseCategories?: ExpenseCategoryUncheckedUpdateManyWithoutTenantNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutTenantNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutTenantNestedInput
    workoutTemplates?: WorkoutTemplateUncheckedUpdateManyWithoutTenantNestedInput
    scheduleTemplates?: ScheduleTemplateUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type CalendarEventSyncCreateWithoutIntegrationInput = {
    id?: string
    entityType: string
    entityId: string
    externalEventId: string
    lastSyncedAt: Date | string
    syncHash: string
  }

  export type CalendarEventSyncUncheckedCreateWithoutIntegrationInput = {
    id?: string
    entityType: string
    entityId: string
    externalEventId: string
    lastSyncedAt: Date | string
    syncHash: string
  }

  export type CalendarEventSyncCreateOrConnectWithoutIntegrationInput = {
    where: CalendarEventSyncWhereUniqueInput
    create: XOR<CalendarEventSyncCreateWithoutIntegrationInput, CalendarEventSyncUncheckedCreateWithoutIntegrationInput>
  }

  export type CalendarEventSyncCreateManyIntegrationInputEnvelope = {
    data: CalendarEventSyncCreateManyIntegrationInput | CalendarEventSyncCreateManyIntegrationInput[]
    skipDuplicates?: boolean
  }

  export type CalendarEventSyncUpsertWithWhereUniqueWithoutIntegrationInput = {
    where: CalendarEventSyncWhereUniqueInput
    update: XOR<CalendarEventSyncUpdateWithoutIntegrationInput, CalendarEventSyncUncheckedUpdateWithoutIntegrationInput>
    create: XOR<CalendarEventSyncCreateWithoutIntegrationInput, CalendarEventSyncUncheckedCreateWithoutIntegrationInput>
  }

  export type CalendarEventSyncUpdateWithWhereUniqueWithoutIntegrationInput = {
    where: CalendarEventSyncWhereUniqueInput
    data: XOR<CalendarEventSyncUpdateWithoutIntegrationInput, CalendarEventSyncUncheckedUpdateWithoutIntegrationInput>
  }

  export type CalendarEventSyncUpdateManyWithWhereWithoutIntegrationInput = {
    where: CalendarEventSyncScalarWhereInput
    data: XOR<CalendarEventSyncUpdateManyMutationInput, CalendarEventSyncUncheckedUpdateManyWithoutIntegrationInput>
  }

  export type CalendarEventSyncScalarWhereInput = {
    AND?: CalendarEventSyncScalarWhereInput | CalendarEventSyncScalarWhereInput[]
    OR?: CalendarEventSyncScalarWhereInput[]
    NOT?: CalendarEventSyncScalarWhereInput | CalendarEventSyncScalarWhereInput[]
    id?: StringFilter<"CalendarEventSync"> | string
    integrationId?: StringFilter<"CalendarEventSync"> | string
    entityType?: StringFilter<"CalendarEventSync"> | string
    entityId?: StringFilter<"CalendarEventSync"> | string
    externalEventId?: StringFilter<"CalendarEventSync"> | string
    lastSyncedAt?: DateTimeFilter<"CalendarEventSync"> | Date | string
    syncHash?: StringFilter<"CalendarEventSync"> | string
  }

  export type CalendarIntegrationCreateWithoutEventSyncsInput = {
    id?: string
    tenantId: string
    userId: string
    provider: string
    accessToken?: string | null
    refreshToken?: string | null
    tokenExpiry?: Date | string | null
    calendarId?: string | null
    calendarEmail?: string | null
    syncEnabled?: boolean
    syncDirection?: string
    lastSyncAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CalendarIntegrationUncheckedCreateWithoutEventSyncsInput = {
    id?: string
    tenantId: string
    userId: string
    provider: string
    accessToken?: string | null
    refreshToken?: string | null
    tokenExpiry?: Date | string | null
    calendarId?: string | null
    calendarEmail?: string | null
    syncEnabled?: boolean
    syncDirection?: string
    lastSyncAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CalendarIntegrationCreateOrConnectWithoutEventSyncsInput = {
    where: CalendarIntegrationWhereUniqueInput
    create: XOR<CalendarIntegrationCreateWithoutEventSyncsInput, CalendarIntegrationUncheckedCreateWithoutEventSyncsInput>
  }

  export type CalendarIntegrationUpsertWithoutEventSyncsInput = {
    update: XOR<CalendarIntegrationUpdateWithoutEventSyncsInput, CalendarIntegrationUncheckedUpdateWithoutEventSyncsInput>
    create: XOR<CalendarIntegrationCreateWithoutEventSyncsInput, CalendarIntegrationUncheckedCreateWithoutEventSyncsInput>
    where?: CalendarIntegrationWhereInput
  }

  export type CalendarIntegrationUpdateToOneWithWhereWithoutEventSyncsInput = {
    where?: CalendarIntegrationWhereInput
    data: XOR<CalendarIntegrationUpdateWithoutEventSyncsInput, CalendarIntegrationUncheckedUpdateWithoutEventSyncsInput>
  }

  export type CalendarIntegrationUpdateWithoutEventSyncsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    calendarId?: NullableStringFieldUpdateOperationsInput | string | null
    calendarEmail?: NullableStringFieldUpdateOperationsInput | string | null
    syncEnabled?: BoolFieldUpdateOperationsInput | boolean
    syncDirection?: StringFieldUpdateOperationsInput | string
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarIntegrationUncheckedUpdateWithoutEventSyncsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    calendarId?: NullableStringFieldUpdateOperationsInput | string | null
    calendarEmail?: NullableStringFieldUpdateOperationsInput | string | null
    syncEnabled?: BoolFieldUpdateOperationsInput | boolean
    syncDirection?: StringFieldUpdateOperationsInput | string
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantCreateWithoutBadgesInput = {
    id?: string
    vertical: $Enums.Vertical
    name: string
    slug: string
    email?: string | null
    phone?: string | null
    website?: string | null
    logo?: string | null
    subscriptionTier?: string
    aiCredits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    clients?: ClientCreateNestedManyWithoutTenantInput
    sessions?: SessionCreateNestedManyWithoutTenantInput
    classes?: ClassCreateNestedManyWithoutTenantInput
    packages?: PackageCreateNestedManyWithoutTenantInput
    orders?: OrderCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    aiLogs?: AILogCreateNestedManyWithoutTenantInput
    bankAccounts?: BankAccountCreateNestedManyWithoutTenantInput
    bankTransactions?: BankTransactionCreateNestedManyWithoutTenantInput
    invoicePayments?: InvoicePaymentCreateNestedManyWithoutTenantInput
    paymentGatewayConfigs?: PaymentGatewayConfigCreateNestedManyWithoutTenantInput
    cryptoWallets?: CryptoWalletCreateNestedManyWithoutTenantInput
    expenseCategories?: ExpenseCategoryCreateNestedManyWithoutTenantInput
    expenses?: ExpenseCreateNestedManyWithoutTenantInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateCreateNestedManyWithoutTenantInput
    workoutTemplates?: WorkoutTemplateCreateNestedManyWithoutTenantInput
    scheduleTemplates?: ScheduleTemplateCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutBadgesInput = {
    id?: string
    vertical: $Enums.Vertical
    name: string
    slug: string
    email?: string | null
    phone?: string | null
    website?: string | null
    logo?: string | null
    subscriptionTier?: string
    aiCredits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    clients?: ClientUncheckedCreateNestedManyWithoutTenantInput
    sessions?: SessionUncheckedCreateNestedManyWithoutTenantInput
    classes?: ClassUncheckedCreateNestedManyWithoutTenantInput
    packages?: PackageUncheckedCreateNestedManyWithoutTenantInput
    orders?: OrderUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    aiLogs?: AILogUncheckedCreateNestedManyWithoutTenantInput
    bankAccounts?: BankAccountUncheckedCreateNestedManyWithoutTenantInput
    bankTransactions?: BankTransactionUncheckedCreateNestedManyWithoutTenantInput
    invoicePayments?: InvoicePaymentUncheckedCreateNestedManyWithoutTenantInput
    paymentGatewayConfigs?: PaymentGatewayConfigUncheckedCreateNestedManyWithoutTenantInput
    cryptoWallets?: CryptoWalletUncheckedCreateNestedManyWithoutTenantInput
    expenseCategories?: ExpenseCategoryUncheckedCreateNestedManyWithoutTenantInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutTenantInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateUncheckedCreateNestedManyWithoutTenantInput
    workoutTemplates?: WorkoutTemplateUncheckedCreateNestedManyWithoutTenantInput
    scheduleTemplates?: ScheduleTemplateUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutBadgesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutBadgesInput, TenantUncheckedCreateWithoutBadgesInput>
  }

  export type ClientBadgeCreateWithoutBadgeInput = {
    id?: string
    earnedAt?: Date | string
    notified?: boolean
    client: ClientCreateNestedOneWithoutBadgesInput
  }

  export type ClientBadgeUncheckedCreateWithoutBadgeInput = {
    id?: string
    clientId: string
    earnedAt?: Date | string
    notified?: boolean
  }

  export type ClientBadgeCreateOrConnectWithoutBadgeInput = {
    where: ClientBadgeWhereUniqueInput
    create: XOR<ClientBadgeCreateWithoutBadgeInput, ClientBadgeUncheckedCreateWithoutBadgeInput>
  }

  export type ClientBadgeCreateManyBadgeInputEnvelope = {
    data: ClientBadgeCreateManyBadgeInput | ClientBadgeCreateManyBadgeInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutBadgesInput = {
    update: XOR<TenantUpdateWithoutBadgesInput, TenantUncheckedUpdateWithoutBadgesInput>
    create: XOR<TenantCreateWithoutBadgesInput, TenantUncheckedCreateWithoutBadgesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutBadgesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutBadgesInput, TenantUncheckedUpdateWithoutBadgesInput>
  }

  export type TenantUpdateWithoutBadgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    vertical?: EnumVerticalFieldUpdateOperationsInput | $Enums.Vertical
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    aiCredits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    clients?: ClientUpdateManyWithoutTenantNestedInput
    sessions?: SessionUpdateManyWithoutTenantNestedInput
    classes?: ClassUpdateManyWithoutTenantNestedInput
    packages?: PackageUpdateManyWithoutTenantNestedInput
    orders?: OrderUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    aiLogs?: AILogUpdateManyWithoutTenantNestedInput
    bankAccounts?: BankAccountUpdateManyWithoutTenantNestedInput
    bankTransactions?: BankTransactionUpdateManyWithoutTenantNestedInput
    invoicePayments?: InvoicePaymentUpdateManyWithoutTenantNestedInput
    paymentGatewayConfigs?: PaymentGatewayConfigUpdateManyWithoutTenantNestedInput
    cryptoWallets?: CryptoWalletUpdateManyWithoutTenantNestedInput
    expenseCategories?: ExpenseCategoryUpdateManyWithoutTenantNestedInput
    expenses?: ExpenseUpdateManyWithoutTenantNestedInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateUpdateManyWithoutTenantNestedInput
    workoutTemplates?: WorkoutTemplateUpdateManyWithoutTenantNestedInput
    scheduleTemplates?: ScheduleTemplateUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutBadgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    vertical?: EnumVerticalFieldUpdateOperationsInput | $Enums.Vertical
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    aiCredits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    clients?: ClientUncheckedUpdateManyWithoutTenantNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutTenantNestedInput
    classes?: ClassUncheckedUpdateManyWithoutTenantNestedInput
    packages?: PackageUncheckedUpdateManyWithoutTenantNestedInput
    orders?: OrderUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    aiLogs?: AILogUncheckedUpdateManyWithoutTenantNestedInput
    bankAccounts?: BankAccountUncheckedUpdateManyWithoutTenantNestedInput
    bankTransactions?: BankTransactionUncheckedUpdateManyWithoutTenantNestedInput
    invoicePayments?: InvoicePaymentUncheckedUpdateManyWithoutTenantNestedInput
    paymentGatewayConfigs?: PaymentGatewayConfigUncheckedUpdateManyWithoutTenantNestedInput
    cryptoWallets?: CryptoWalletUncheckedUpdateManyWithoutTenantNestedInput
    expenseCategories?: ExpenseCategoryUncheckedUpdateManyWithoutTenantNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutTenantNestedInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateUncheckedUpdateManyWithoutTenantNestedInput
    workoutTemplates?: WorkoutTemplateUncheckedUpdateManyWithoutTenantNestedInput
    scheduleTemplates?: ScheduleTemplateUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type ClientBadgeUpsertWithWhereUniqueWithoutBadgeInput = {
    where: ClientBadgeWhereUniqueInput
    update: XOR<ClientBadgeUpdateWithoutBadgeInput, ClientBadgeUncheckedUpdateWithoutBadgeInput>
    create: XOR<ClientBadgeCreateWithoutBadgeInput, ClientBadgeUncheckedCreateWithoutBadgeInput>
  }

  export type ClientBadgeUpdateWithWhereUniqueWithoutBadgeInput = {
    where: ClientBadgeWhereUniqueInput
    data: XOR<ClientBadgeUpdateWithoutBadgeInput, ClientBadgeUncheckedUpdateWithoutBadgeInput>
  }

  export type ClientBadgeUpdateManyWithWhereWithoutBadgeInput = {
    where: ClientBadgeScalarWhereInput
    data: XOR<ClientBadgeUpdateManyMutationInput, ClientBadgeUncheckedUpdateManyWithoutBadgeInput>
  }

  export type ClientCreateWithoutBadgesInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    avatar?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    goals?: ClientCreategoalsInput | string[]
    currentWeight?: number | null
    targetWeight?: number | null
    height?: number | null
    bodyMeasurements?: NullableJsonNullValueInput | InputJsonValue
    bodyFatPercent?: number | null
    fitnessLevel?: string | null
    injuryHistory?: string | null
    dietaryNotes?: string | null
    medicalNotes?: string | null
    creditsRemaining?: number
    membershipType?: string | null
    membershipExpiry?: Date | string | null
    status?: string
    tags?: ClientCreatetagsInput | string[]
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutClientsInput
    sessions?: SessionCreateNestedManyWithoutClientInput
    orders?: OrderCreateNestedManyWithoutClientInput
    invoices?: InvoiceCreateNestedManyWithoutClientInput
    measurements?: ClientMeasurementCreateNestedManyWithoutClientInput
    progressPhotos?: ProgressPhotoCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutBadgesInput = {
    id?: string
    tenantId: string
    name: string
    email: string
    phone?: string | null
    avatar?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    goals?: ClientCreategoalsInput | string[]
    currentWeight?: number | null
    targetWeight?: number | null
    height?: number | null
    bodyMeasurements?: NullableJsonNullValueInput | InputJsonValue
    bodyFatPercent?: number | null
    fitnessLevel?: string | null
    injuryHistory?: string | null
    dietaryNotes?: string | null
    medicalNotes?: string | null
    creditsRemaining?: number
    membershipType?: string | null
    membershipExpiry?: Date | string | null
    status?: string
    tags?: ClientCreatetagsInput | string[]
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutClientInput
    orders?: OrderUncheckedCreateNestedManyWithoutClientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutClientInput
    measurements?: ClientMeasurementUncheckedCreateNestedManyWithoutClientInput
    progressPhotos?: ProgressPhotoUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutBadgesInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutBadgesInput, ClientUncheckedCreateWithoutBadgesInput>
  }

  export type BadgeCreateWithoutClientBadgesInput = {
    id?: string
    name: string
    description: string
    icon: string
    color: string
    category: string
    criteria: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutBadgesInput
  }

  export type BadgeUncheckedCreateWithoutClientBadgesInput = {
    id?: string
    tenantId: string
    name: string
    description: string
    icon: string
    color: string
    category: string
    criteria: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BadgeCreateOrConnectWithoutClientBadgesInput = {
    where: BadgeWhereUniqueInput
    create: XOR<BadgeCreateWithoutClientBadgesInput, BadgeUncheckedCreateWithoutClientBadgesInput>
  }

  export type ClientUpsertWithoutBadgesInput = {
    update: XOR<ClientUpdateWithoutBadgesInput, ClientUncheckedUpdateWithoutBadgesInput>
    create: XOR<ClientCreateWithoutBadgesInput, ClientUncheckedCreateWithoutBadgesInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutBadgesInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutBadgesInput, ClientUncheckedUpdateWithoutBadgesInput>
  }

  export type ClientUpdateWithoutBadgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    goals?: ClientUpdategoalsInput | string[]
    currentWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    targetWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    bodyMeasurements?: NullableJsonNullValueInput | InputJsonValue
    bodyFatPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    fitnessLevel?: NullableStringFieldUpdateOperationsInput | string | null
    injuryHistory?: NullableStringFieldUpdateOperationsInput | string | null
    dietaryNotes?: NullableStringFieldUpdateOperationsInput | string | null
    medicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    creditsRemaining?: IntFieldUpdateOperationsInput | number
    membershipType?: NullableStringFieldUpdateOperationsInput | string | null
    membershipExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    tags?: ClientUpdatetagsInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutClientsNestedInput
    sessions?: SessionUpdateManyWithoutClientNestedInput
    orders?: OrderUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUpdateManyWithoutClientNestedInput
    measurements?: ClientMeasurementUpdateManyWithoutClientNestedInput
    progressPhotos?: ProgressPhotoUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutBadgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    goals?: ClientUpdategoalsInput | string[]
    currentWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    targetWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    bodyMeasurements?: NullableJsonNullValueInput | InputJsonValue
    bodyFatPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    fitnessLevel?: NullableStringFieldUpdateOperationsInput | string | null
    injuryHistory?: NullableStringFieldUpdateOperationsInput | string | null
    dietaryNotes?: NullableStringFieldUpdateOperationsInput | string | null
    medicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    creditsRemaining?: IntFieldUpdateOperationsInput | number
    membershipType?: NullableStringFieldUpdateOperationsInput | string | null
    membershipExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    tags?: ClientUpdatetagsInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutClientNestedInput
    orders?: OrderUncheckedUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutClientNestedInput
    measurements?: ClientMeasurementUncheckedUpdateManyWithoutClientNestedInput
    progressPhotos?: ProgressPhotoUncheckedUpdateManyWithoutClientNestedInput
  }

  export type BadgeUpsertWithoutClientBadgesInput = {
    update: XOR<BadgeUpdateWithoutClientBadgesInput, BadgeUncheckedUpdateWithoutClientBadgesInput>
    create: XOR<BadgeCreateWithoutClientBadgesInput, BadgeUncheckedCreateWithoutClientBadgesInput>
    where?: BadgeWhereInput
  }

  export type BadgeUpdateToOneWithWhereWithoutClientBadgesInput = {
    where?: BadgeWhereInput
    data: XOR<BadgeUpdateWithoutClientBadgesInput, BadgeUncheckedUpdateWithoutClientBadgesInput>
  }

  export type BadgeUpdateWithoutClientBadgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    criteria?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutBadgesNestedInput
  }

  export type BadgeUncheckedUpdateWithoutClientBadgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    criteria?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantCreateWithoutWorkoutTemplatesInput = {
    id?: string
    vertical: $Enums.Vertical
    name: string
    slug: string
    email?: string | null
    phone?: string | null
    website?: string | null
    logo?: string | null
    subscriptionTier?: string
    aiCredits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    clients?: ClientCreateNestedManyWithoutTenantInput
    sessions?: SessionCreateNestedManyWithoutTenantInput
    classes?: ClassCreateNestedManyWithoutTenantInput
    packages?: PackageCreateNestedManyWithoutTenantInput
    orders?: OrderCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    aiLogs?: AILogCreateNestedManyWithoutTenantInput
    bankAccounts?: BankAccountCreateNestedManyWithoutTenantInput
    bankTransactions?: BankTransactionCreateNestedManyWithoutTenantInput
    invoicePayments?: InvoicePaymentCreateNestedManyWithoutTenantInput
    paymentGatewayConfigs?: PaymentGatewayConfigCreateNestedManyWithoutTenantInput
    cryptoWallets?: CryptoWalletCreateNestedManyWithoutTenantInput
    expenseCategories?: ExpenseCategoryCreateNestedManyWithoutTenantInput
    expenses?: ExpenseCreateNestedManyWithoutTenantInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateCreateNestedManyWithoutTenantInput
    badges?: BadgeCreateNestedManyWithoutTenantInput
    scheduleTemplates?: ScheduleTemplateCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutWorkoutTemplatesInput = {
    id?: string
    vertical: $Enums.Vertical
    name: string
    slug: string
    email?: string | null
    phone?: string | null
    website?: string | null
    logo?: string | null
    subscriptionTier?: string
    aiCredits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    clients?: ClientUncheckedCreateNestedManyWithoutTenantInput
    sessions?: SessionUncheckedCreateNestedManyWithoutTenantInput
    classes?: ClassUncheckedCreateNestedManyWithoutTenantInput
    packages?: PackageUncheckedCreateNestedManyWithoutTenantInput
    orders?: OrderUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    aiLogs?: AILogUncheckedCreateNestedManyWithoutTenantInput
    bankAccounts?: BankAccountUncheckedCreateNestedManyWithoutTenantInput
    bankTransactions?: BankTransactionUncheckedCreateNestedManyWithoutTenantInput
    invoicePayments?: InvoicePaymentUncheckedCreateNestedManyWithoutTenantInput
    paymentGatewayConfigs?: PaymentGatewayConfigUncheckedCreateNestedManyWithoutTenantInput
    cryptoWallets?: CryptoWalletUncheckedCreateNestedManyWithoutTenantInput
    expenseCategories?: ExpenseCategoryUncheckedCreateNestedManyWithoutTenantInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutTenantInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateUncheckedCreateNestedManyWithoutTenantInput
    badges?: BadgeUncheckedCreateNestedManyWithoutTenantInput
    scheduleTemplates?: ScheduleTemplateUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutWorkoutTemplatesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutWorkoutTemplatesInput, TenantUncheckedCreateWithoutWorkoutTemplatesInput>
  }

  export type TenantUpsertWithoutWorkoutTemplatesInput = {
    update: XOR<TenantUpdateWithoutWorkoutTemplatesInput, TenantUncheckedUpdateWithoutWorkoutTemplatesInput>
    create: XOR<TenantCreateWithoutWorkoutTemplatesInput, TenantUncheckedCreateWithoutWorkoutTemplatesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutWorkoutTemplatesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutWorkoutTemplatesInput, TenantUncheckedUpdateWithoutWorkoutTemplatesInput>
  }

  export type TenantUpdateWithoutWorkoutTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    vertical?: EnumVerticalFieldUpdateOperationsInput | $Enums.Vertical
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    aiCredits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    clients?: ClientUpdateManyWithoutTenantNestedInput
    sessions?: SessionUpdateManyWithoutTenantNestedInput
    classes?: ClassUpdateManyWithoutTenantNestedInput
    packages?: PackageUpdateManyWithoutTenantNestedInput
    orders?: OrderUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    aiLogs?: AILogUpdateManyWithoutTenantNestedInput
    bankAccounts?: BankAccountUpdateManyWithoutTenantNestedInput
    bankTransactions?: BankTransactionUpdateManyWithoutTenantNestedInput
    invoicePayments?: InvoicePaymentUpdateManyWithoutTenantNestedInput
    paymentGatewayConfigs?: PaymentGatewayConfigUpdateManyWithoutTenantNestedInput
    cryptoWallets?: CryptoWalletUpdateManyWithoutTenantNestedInput
    expenseCategories?: ExpenseCategoryUpdateManyWithoutTenantNestedInput
    expenses?: ExpenseUpdateManyWithoutTenantNestedInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateUpdateManyWithoutTenantNestedInput
    badges?: BadgeUpdateManyWithoutTenantNestedInput
    scheduleTemplates?: ScheduleTemplateUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutWorkoutTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    vertical?: EnumVerticalFieldUpdateOperationsInput | $Enums.Vertical
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    aiCredits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    clients?: ClientUncheckedUpdateManyWithoutTenantNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutTenantNestedInput
    classes?: ClassUncheckedUpdateManyWithoutTenantNestedInput
    packages?: PackageUncheckedUpdateManyWithoutTenantNestedInput
    orders?: OrderUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    aiLogs?: AILogUncheckedUpdateManyWithoutTenantNestedInput
    bankAccounts?: BankAccountUncheckedUpdateManyWithoutTenantNestedInput
    bankTransactions?: BankTransactionUncheckedUpdateManyWithoutTenantNestedInput
    invoicePayments?: InvoicePaymentUncheckedUpdateManyWithoutTenantNestedInput
    paymentGatewayConfigs?: PaymentGatewayConfigUncheckedUpdateManyWithoutTenantNestedInput
    cryptoWallets?: CryptoWalletUncheckedUpdateManyWithoutTenantNestedInput
    expenseCategories?: ExpenseCategoryUncheckedUpdateManyWithoutTenantNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutTenantNestedInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateUncheckedUpdateManyWithoutTenantNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutTenantNestedInput
    scheduleTemplates?: ScheduleTemplateUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateWithoutScheduleTemplatesInput = {
    id?: string
    vertical: $Enums.Vertical
    name: string
    slug: string
    email?: string | null
    phone?: string | null
    website?: string | null
    logo?: string | null
    subscriptionTier?: string
    aiCredits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    clients?: ClientCreateNestedManyWithoutTenantInput
    sessions?: SessionCreateNestedManyWithoutTenantInput
    classes?: ClassCreateNestedManyWithoutTenantInput
    packages?: PackageCreateNestedManyWithoutTenantInput
    orders?: OrderCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    aiLogs?: AILogCreateNestedManyWithoutTenantInput
    bankAccounts?: BankAccountCreateNestedManyWithoutTenantInput
    bankTransactions?: BankTransactionCreateNestedManyWithoutTenantInput
    invoicePayments?: InvoicePaymentCreateNestedManyWithoutTenantInput
    paymentGatewayConfigs?: PaymentGatewayConfigCreateNestedManyWithoutTenantInput
    cryptoWallets?: CryptoWalletCreateNestedManyWithoutTenantInput
    expenseCategories?: ExpenseCategoryCreateNestedManyWithoutTenantInput
    expenses?: ExpenseCreateNestedManyWithoutTenantInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateCreateNestedManyWithoutTenantInput
    badges?: BadgeCreateNestedManyWithoutTenantInput
    workoutTemplates?: WorkoutTemplateCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutScheduleTemplatesInput = {
    id?: string
    vertical: $Enums.Vertical
    name: string
    slug: string
    email?: string | null
    phone?: string | null
    website?: string | null
    logo?: string | null
    subscriptionTier?: string
    aiCredits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    clients?: ClientUncheckedCreateNestedManyWithoutTenantInput
    sessions?: SessionUncheckedCreateNestedManyWithoutTenantInput
    classes?: ClassUncheckedCreateNestedManyWithoutTenantInput
    packages?: PackageUncheckedCreateNestedManyWithoutTenantInput
    orders?: OrderUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    aiLogs?: AILogUncheckedCreateNestedManyWithoutTenantInput
    bankAccounts?: BankAccountUncheckedCreateNestedManyWithoutTenantInput
    bankTransactions?: BankTransactionUncheckedCreateNestedManyWithoutTenantInput
    invoicePayments?: InvoicePaymentUncheckedCreateNestedManyWithoutTenantInput
    paymentGatewayConfigs?: PaymentGatewayConfigUncheckedCreateNestedManyWithoutTenantInput
    cryptoWallets?: CryptoWalletUncheckedCreateNestedManyWithoutTenantInput
    expenseCategories?: ExpenseCategoryUncheckedCreateNestedManyWithoutTenantInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutTenantInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateUncheckedCreateNestedManyWithoutTenantInput
    badges?: BadgeUncheckedCreateNestedManyWithoutTenantInput
    workoutTemplates?: WorkoutTemplateUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutScheduleTemplatesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutScheduleTemplatesInput, TenantUncheckedCreateWithoutScheduleTemplatesInput>
  }

  export type TenantUpsertWithoutScheduleTemplatesInput = {
    update: XOR<TenantUpdateWithoutScheduleTemplatesInput, TenantUncheckedUpdateWithoutScheduleTemplatesInput>
    create: XOR<TenantCreateWithoutScheduleTemplatesInput, TenantUncheckedCreateWithoutScheduleTemplatesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutScheduleTemplatesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutScheduleTemplatesInput, TenantUncheckedUpdateWithoutScheduleTemplatesInput>
  }

  export type TenantUpdateWithoutScheduleTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    vertical?: EnumVerticalFieldUpdateOperationsInput | $Enums.Vertical
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    aiCredits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    clients?: ClientUpdateManyWithoutTenantNestedInput
    sessions?: SessionUpdateManyWithoutTenantNestedInput
    classes?: ClassUpdateManyWithoutTenantNestedInput
    packages?: PackageUpdateManyWithoutTenantNestedInput
    orders?: OrderUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    aiLogs?: AILogUpdateManyWithoutTenantNestedInput
    bankAccounts?: BankAccountUpdateManyWithoutTenantNestedInput
    bankTransactions?: BankTransactionUpdateManyWithoutTenantNestedInput
    invoicePayments?: InvoicePaymentUpdateManyWithoutTenantNestedInput
    paymentGatewayConfigs?: PaymentGatewayConfigUpdateManyWithoutTenantNestedInput
    cryptoWallets?: CryptoWalletUpdateManyWithoutTenantNestedInput
    expenseCategories?: ExpenseCategoryUpdateManyWithoutTenantNestedInput
    expenses?: ExpenseUpdateManyWithoutTenantNestedInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateUpdateManyWithoutTenantNestedInput
    badges?: BadgeUpdateManyWithoutTenantNestedInput
    workoutTemplates?: WorkoutTemplateUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutScheduleTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    vertical?: EnumVerticalFieldUpdateOperationsInput | $Enums.Vertical
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    aiCredits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    clients?: ClientUncheckedUpdateManyWithoutTenantNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutTenantNestedInput
    classes?: ClassUncheckedUpdateManyWithoutTenantNestedInput
    packages?: PackageUncheckedUpdateManyWithoutTenantNestedInput
    orders?: OrderUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    aiLogs?: AILogUncheckedUpdateManyWithoutTenantNestedInput
    bankAccounts?: BankAccountUncheckedUpdateManyWithoutTenantNestedInput
    bankTransactions?: BankTransactionUncheckedUpdateManyWithoutTenantNestedInput
    invoicePayments?: InvoicePaymentUncheckedUpdateManyWithoutTenantNestedInput
    paymentGatewayConfigs?: PaymentGatewayConfigUncheckedUpdateManyWithoutTenantNestedInput
    cryptoWallets?: CryptoWalletUncheckedUpdateManyWithoutTenantNestedInput
    expenseCategories?: ExpenseCategoryUncheckedUpdateManyWithoutTenantNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutTenantNestedInput
    recurringInvoiceTemplates?: RecurringInvoiceTemplateUncheckedUpdateManyWithoutTenantNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutTenantNestedInput
    workoutTemplates?: WorkoutTemplateUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserCreateManyTenantInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientCreateManyTenantInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    avatar?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    goals?: ClientCreategoalsInput | string[]
    currentWeight?: number | null
    targetWeight?: number | null
    height?: number | null
    bodyMeasurements?: NullableJsonNullValueInput | InputJsonValue
    bodyFatPercent?: number | null
    fitnessLevel?: string | null
    injuryHistory?: string | null
    dietaryNotes?: string | null
    medicalNotes?: string | null
    creditsRemaining?: number
    membershipType?: string | null
    membershipExpiry?: Date | string | null
    status?: string
    tags?: ClientCreatetagsInput | string[]
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionCreateManyTenantInput = {
    id?: string
    clientId: string
    scheduledAt: Date | string
    duration?: number
    status?: string
    workoutPlan?: NullableJsonNullValueInput | InputJsonValue
    exercisesLogged?: SessionCreateexercisesLoggedInput | InputJsonValue[]
    caloriesBurned?: number | null
    heartRateAvg?: number | null
    muscleGroups?: SessionCreatemuscleGroupsInput | string[]
    clientFeedback?: string | null
    trainerNotes?: string | null
    intensity?: string | null
    clientRating?: number | null
    price?: number | null
    paid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassCreateManyTenantInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    scheduledAt: Date | string
    duration: number
    capacity?: number
    instructor?: string | null
    location?: string | null
    price: number
    isRecurring?: boolean
    recurrence?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PackageCreateManyTenantInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    price: number
    credits: number
    validityDays: number
    features?: PackageCreatefeaturesInput | string[]
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderCreateManyTenantInput = {
    id?: string
    clientId: string
    orderNumber: string
    status?: string
    items?: OrderCreateitemsInput | InputJsonValue[]
    subtotal: number
    tax?: number
    discount?: number
    total: number
    paymentMethod?: string | null
    paymentStatus?: string
    paidAmount?: number
    orderDate?: Date | string
    dueDate?: Date | string | null
    paidDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceCreateManyTenantInput = {
    id?: string
    orderId?: string | null
    clientId: string
    invoiceNumber: string
    status?: string
    issueDate?: Date | string
    dueDate: Date | string
    paidDate?: Date | string | null
    subtotal: number
    tax?: number
    total: number
    paymentMethod?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AILogCreateManyTenantInput = {
    id?: string
    feature: string
    model: string
    promptTokens: number
    completionTokens: number
    totalTokens: number
    estimatedCost: number
    input: JsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    latencyMs?: number | null
    success?: boolean
    error?: string | null
    createdAt?: Date | string
  }

  export type BankAccountCreateManyTenantInput = {
    id?: string
    accountName: string
    accountNumber: string
    bankCode?: string | null
    iban?: string | null
    swift?: string | null
    provider: $Enums.BankProvider
    providerAccountId?: string | null
    currency?: string
    balance?: Decimal | DecimalJsLike | number | string | null
    balanceUpdatedAt?: Date | string | null
    autoSync?: boolean
    lastSyncAt?: Date | string | null
    syncFrequency?: string
    credentials?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankTransactionCreateManyTenantInput = {
    id?: string
    bankAccountId: string
    transactionId: string
    date: Date | string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    type: $Enums.TransactionType
    counterpartyName?: string | null
    counterpartyAccount?: string | null
    counterpartyBankCode?: string | null
    description?: string | null
    note?: string | null
    variableSymbol?: string | null
    constantSymbol?: string | null
    specificSymbol?: string | null
    reference?: string | null
    isMatched?: boolean
    matchedInvoiceId?: string | null
    matchedPaymentId?: string | null
    matchConfidence?: Decimal | DecimalJsLike | number | string | null
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoicePaymentCreateManyTenantInput = {
    id?: string
    invoiceId: string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    method: $Enums.PaymentMethod
    status?: string
    gatewayProvider?: string | null
    gatewayPaymentId?: string | null
    gatewayFee?: Decimal | DecimalJsLike | number | string | null
    transactionId?: string | null
    reference?: string | null
    processedAt?: Date | string | null
    completedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentGatewayConfigCreateManyTenantInput = {
    id?: string
    provider: string
    config: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    isTest?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CryptoWalletCreateManyTenantInput = {
    id?: string
    currency: string
    address: string
    network?: string | null
    provider: string
    isActive?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseCategoryCreateManyTenantInput = {
    id?: string
    name: string
    description?: string | null
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseCreateManyTenantInput = {
    id?: string
    categoryId: string
    description: string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    date: Date | string
    vendor?: string | null
    receiptUrl?: string | null
    receiptOcrData?: NullableJsonNullValueInput | InputJsonValue
    taxAmount?: Decimal | DecimalJsLike | number | string | null
    isTaxDeductible?: boolean
    status: $Enums.ExpenseStatus
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectedReason?: string | null
    reimbursedAt?: Date | string | null
    reimbursedAmount?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecurringInvoiceTemplateCreateManyTenantInput = {
    id?: string
    frequency: string
    nextInvoiceDate: Date | string
    isActive?: boolean
    invoiceTemplate: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BadgeCreateManyTenantInput = {
    id?: string
    name: string
    description: string
    icon: string
    color: string
    category: string
    criteria: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkoutTemplateCreateManyTenantInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    difficulty: string
    duration: number
    exercises?: WorkoutTemplateCreateexercisesInput | InputJsonValue[]
    muscleGroups?: WorkoutTemplateCreatemuscleGroupsInput | string[]
    equipment?: WorkoutTemplateCreateequipmentInput | string[]
    isPublic?: boolean
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduleTemplateCreateManyTenantInput = {
    id?: string
    name: string
    description?: string | null
    slots?: ScheduleTemplateCreateslotsInput | InputJsonValue[]
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    goals?: ClientUpdategoalsInput | string[]
    currentWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    targetWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    bodyMeasurements?: NullableJsonNullValueInput | InputJsonValue
    bodyFatPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    fitnessLevel?: NullableStringFieldUpdateOperationsInput | string | null
    injuryHistory?: NullableStringFieldUpdateOperationsInput | string | null
    dietaryNotes?: NullableStringFieldUpdateOperationsInput | string | null
    medicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    creditsRemaining?: IntFieldUpdateOperationsInput | number
    membershipType?: NullableStringFieldUpdateOperationsInput | string | null
    membershipExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    tags?: ClientUpdatetagsInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutClientNestedInput
    orders?: OrderUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUpdateManyWithoutClientNestedInput
    measurements?: ClientMeasurementUpdateManyWithoutClientNestedInput
    progressPhotos?: ProgressPhotoUpdateManyWithoutClientNestedInput
    badges?: ClientBadgeUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    goals?: ClientUpdategoalsInput | string[]
    currentWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    targetWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    bodyMeasurements?: NullableJsonNullValueInput | InputJsonValue
    bodyFatPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    fitnessLevel?: NullableStringFieldUpdateOperationsInput | string | null
    injuryHistory?: NullableStringFieldUpdateOperationsInput | string | null
    dietaryNotes?: NullableStringFieldUpdateOperationsInput | string | null
    medicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    creditsRemaining?: IntFieldUpdateOperationsInput | number
    membershipType?: NullableStringFieldUpdateOperationsInput | string | null
    membershipExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    tags?: ClientUpdatetagsInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutClientNestedInput
    orders?: OrderUncheckedUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutClientNestedInput
    measurements?: ClientMeasurementUncheckedUpdateManyWithoutClientNestedInput
    progressPhotos?: ProgressPhotoUncheckedUpdateManyWithoutClientNestedInput
    badges?: ClientBadgeUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    goals?: ClientUpdategoalsInput | string[]
    currentWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    targetWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    bodyMeasurements?: NullableJsonNullValueInput | InputJsonValue
    bodyFatPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    fitnessLevel?: NullableStringFieldUpdateOperationsInput | string | null
    injuryHistory?: NullableStringFieldUpdateOperationsInput | string | null
    dietaryNotes?: NullableStringFieldUpdateOperationsInput | string | null
    medicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    creditsRemaining?: IntFieldUpdateOperationsInput | number
    membershipType?: NullableStringFieldUpdateOperationsInput | string | null
    membershipExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    tags?: ClientUpdatetagsInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    workoutPlan?: NullableJsonNullValueInput | InputJsonValue
    exercisesLogged?: SessionUpdateexercisesLoggedInput | InputJsonValue[]
    caloriesBurned?: NullableIntFieldUpdateOperationsInput | number | null
    heartRateAvg?: NullableIntFieldUpdateOperationsInput | number | null
    muscleGroups?: SessionUpdatemuscleGroupsInput | string[]
    clientFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    trainerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    intensity?: NullableStringFieldUpdateOperationsInput | string | null
    clientRating?: NullableIntFieldUpdateOperationsInput | number | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    paid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    workoutPlan?: NullableJsonNullValueInput | InputJsonValue
    exercisesLogged?: SessionUpdateexercisesLoggedInput | InputJsonValue[]
    caloriesBurned?: NullableIntFieldUpdateOperationsInput | number | null
    heartRateAvg?: NullableIntFieldUpdateOperationsInput | number | null
    muscleGroups?: SessionUpdatemuscleGroupsInput | string[]
    clientFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    trainerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    intensity?: NullableStringFieldUpdateOperationsInput | string | null
    clientRating?: NullableIntFieldUpdateOperationsInput | number | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    paid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    workoutPlan?: NullableJsonNullValueInput | InputJsonValue
    exercisesLogged?: SessionUpdateexercisesLoggedInput | InputJsonValue[]
    caloriesBurned?: NullableIntFieldUpdateOperationsInput | number | null
    heartRateAvg?: NullableIntFieldUpdateOperationsInput | number | null
    muscleGroups?: SessionUpdatemuscleGroupsInput | string[]
    clientFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    trainerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    intensity?: NullableStringFieldUpdateOperationsInput | string | null
    clientRating?: NullableIntFieldUpdateOperationsInput | number | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    paid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    instructor?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurrence?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: ClassBookingUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    instructor?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurrence?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: ClassBookingUncheckedUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    instructor?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurrence?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PackageUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    credits?: IntFieldUpdateOperationsInput | number
    validityDays?: IntFieldUpdateOperationsInput | number
    features?: PackageUpdatefeaturesInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PackageUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    credits?: IntFieldUpdateOperationsInput | number
    validityDays?: IntFieldUpdateOperationsInput | number
    features?: PackageUpdatefeaturesInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PackageUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    credits?: IntFieldUpdateOperationsInput | number
    validityDays?: IntFieldUpdateOperationsInput | number
    features?: PackageUpdatefeaturesInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    items?: OrderUpdateitemsInput | InputJsonValue[]
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    paidAmount?: FloatFieldUpdateOperationsInput | number
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutOrdersNestedInput
    invoices?: InvoiceUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    items?: OrderUpdateitemsInput | InputJsonValue[]
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    paidAmount?: FloatFieldUpdateOperationsInput | number
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    items?: OrderUpdateitemsInput | InputJsonValue[]
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    paidAmount?: FloatFieldUpdateOperationsInput | number
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneWithoutInvoicesNestedInput
    client?: ClientUpdateOneRequiredWithoutInvoicesNestedInput
    payments?: InvoicePaymentUpdateManyWithoutInvoiceNestedInput
    bankTransactions?: BankTransactionUpdateManyWithoutMatchedInvoiceNestedInput
    cryptoPayments?: CryptoPaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: InvoicePaymentUncheckedUpdateManyWithoutInvoiceNestedInput
    bankTransactions?: BankTransactionUncheckedUpdateManyWithoutMatchedInvoiceNestedInput
    cryptoPayments?: CryptoPaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AILogUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    feature?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    promptTokens?: IntFieldUpdateOperationsInput | number
    completionTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    estimatedCost?: FloatFieldUpdateOperationsInput | number
    input?: JsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    latencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    success?: BoolFieldUpdateOperationsInput | boolean
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AILogUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    feature?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    promptTokens?: IntFieldUpdateOperationsInput | number
    completionTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    estimatedCost?: FloatFieldUpdateOperationsInput | number
    input?: JsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    latencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    success?: BoolFieldUpdateOperationsInput | boolean
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AILogUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    feature?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    promptTokens?: IntFieldUpdateOperationsInput | number
    completionTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    estimatedCost?: FloatFieldUpdateOperationsInput | number
    input?: JsonNullValueInput | InputJsonValue
    output?: NullableJsonNullValueInput | InputJsonValue
    latencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    success?: BoolFieldUpdateOperationsInput | boolean
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankAccountUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    bankCode?: NullableStringFieldUpdateOperationsInput | string | null
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    swift?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: EnumBankProviderFieldUpdateOperationsInput | $Enums.BankProvider
    providerAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balanceUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoSync?: BoolFieldUpdateOperationsInput | boolean
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncFrequency?: StringFieldUpdateOperationsInput | string
    credentials?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: BankTransactionUpdateManyWithoutBankAccountNestedInput
  }

  export type BankAccountUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    bankCode?: NullableStringFieldUpdateOperationsInput | string | null
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    swift?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: EnumBankProviderFieldUpdateOperationsInput | $Enums.BankProvider
    providerAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balanceUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoSync?: BoolFieldUpdateOperationsInput | boolean
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncFrequency?: StringFieldUpdateOperationsInput | string
    credentials?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: BankTransactionUncheckedUpdateManyWithoutBankAccountNestedInput
  }

  export type BankAccountUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    bankCode?: NullableStringFieldUpdateOperationsInput | string | null
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    swift?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: EnumBankProviderFieldUpdateOperationsInput | $Enums.BankProvider
    providerAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balanceUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoSync?: BoolFieldUpdateOperationsInput | boolean
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncFrequency?: StringFieldUpdateOperationsInput | string
    credentials?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankTransactionUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    counterpartyName?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyAccount?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyBankCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    variableSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    constantSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    specificSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    isMatched?: BoolFieldUpdateOperationsInput | boolean
    matchedPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    matchConfidence?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankAccount?: BankAccountUpdateOneRequiredWithoutTransactionsNestedInput
    matchedInvoice?: InvoiceUpdateOneWithoutBankTransactionsNestedInput
  }

  export type BankTransactionUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    bankAccountId?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    counterpartyName?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyAccount?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyBankCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    variableSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    constantSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    specificSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    isMatched?: BoolFieldUpdateOperationsInput | boolean
    matchedInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    matchedPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    matchConfidence?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankTransactionUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    bankAccountId?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    counterpartyName?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyAccount?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyBankCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    variableSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    constantSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    specificSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    isMatched?: BoolFieldUpdateOperationsInput | boolean
    matchedInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    matchedPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    matchConfidence?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoicePaymentUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: StringFieldUpdateOperationsInput | string
    gatewayProvider?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type InvoicePaymentUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: StringFieldUpdateOperationsInput | string
    gatewayProvider?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoicePaymentUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: StringFieldUpdateOperationsInput | string
    gatewayProvider?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentGatewayConfigUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isTest?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentGatewayConfigUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isTest?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentGatewayConfigUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isTest?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CryptoWalletUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    network?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: CryptoPaymentUpdateManyWithoutWalletNestedInput
  }

  export type CryptoWalletUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    network?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: CryptoPaymentUncheckedUpdateManyWithoutWalletNestedInput
  }

  export type CryptoWalletUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    network?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseCategoryUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expenses?: ExpenseUpdateManyWithoutCategoryNestedInput
  }

  export type ExpenseCategoryUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expenses?: ExpenseUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ExpenseCategoryUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    receiptOcrData?: NullableJsonNullValueInput | InputJsonValue
    taxAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isTaxDeductible?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumExpenseStatusFieldUpdateOperationsInput | $Enums.ExpenseStatus
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedReason?: NullableStringFieldUpdateOperationsInput | string | null
    reimbursedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reimbursedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: ExpenseCategoryUpdateOneRequiredWithoutExpensesNestedInput
  }

  export type ExpenseUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    receiptOcrData?: NullableJsonNullValueInput | InputJsonValue
    taxAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isTaxDeductible?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumExpenseStatusFieldUpdateOperationsInput | $Enums.ExpenseStatus
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedReason?: NullableStringFieldUpdateOperationsInput | string | null
    reimbursedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reimbursedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    receiptOcrData?: NullableJsonNullValueInput | InputJsonValue
    taxAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isTaxDeductible?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumExpenseStatusFieldUpdateOperationsInput | $Enums.ExpenseStatus
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedReason?: NullableStringFieldUpdateOperationsInput | string | null
    reimbursedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reimbursedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecurringInvoiceTemplateUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    nextInvoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    invoiceTemplate?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecurringInvoiceTemplateUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    nextInvoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    invoiceTemplate?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecurringInvoiceTemplateUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    nextInvoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    invoiceTemplate?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BadgeUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    criteria?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientBadges?: ClientBadgeUpdateManyWithoutBadgeNestedInput
  }

  export type BadgeUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    criteria?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientBadges?: ClientBadgeUncheckedUpdateManyWithoutBadgeNestedInput
  }

  export type BadgeUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    criteria?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkoutTemplateUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    exercises?: WorkoutTemplateUpdateexercisesInput | InputJsonValue[]
    muscleGroups?: WorkoutTemplateUpdatemuscleGroupsInput | string[]
    equipment?: WorkoutTemplateUpdateequipmentInput | string[]
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkoutTemplateUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    exercises?: WorkoutTemplateUpdateexercisesInput | InputJsonValue[]
    muscleGroups?: WorkoutTemplateUpdatemuscleGroupsInput | string[]
    equipment?: WorkoutTemplateUpdateequipmentInput | string[]
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkoutTemplateUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    exercises?: WorkoutTemplateUpdateexercisesInput | InputJsonValue[]
    muscleGroups?: WorkoutTemplateUpdatemuscleGroupsInput | string[]
    equipment?: WorkoutTemplateUpdateequipmentInput | string[]
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleTemplateUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slots?: ScheduleTemplateUpdateslotsInput | InputJsonValue[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleTemplateUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slots?: ScheduleTemplateUpdateslotsInput | InputJsonValue[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleTemplateUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slots?: ScheduleTemplateUpdateslotsInput | InputJsonValue[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateManyUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type UserSessionCreateManyUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserSessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyClientInput = {
    id?: string
    tenantId: string
    scheduledAt: Date | string
    duration?: number
    status?: string
    workoutPlan?: NullableJsonNullValueInput | InputJsonValue
    exercisesLogged?: SessionCreateexercisesLoggedInput | InputJsonValue[]
    caloriesBurned?: number | null
    heartRateAvg?: number | null
    muscleGroups?: SessionCreatemuscleGroupsInput | string[]
    clientFeedback?: string | null
    trainerNotes?: string | null
    intensity?: string | null
    clientRating?: number | null
    price?: number | null
    paid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderCreateManyClientInput = {
    id?: string
    tenantId: string
    orderNumber: string
    status?: string
    items?: OrderCreateitemsInput | InputJsonValue[]
    subtotal: number
    tax?: number
    discount?: number
    total: number
    paymentMethod?: string | null
    paymentStatus?: string
    paidAmount?: number
    orderDate?: Date | string
    dueDate?: Date | string | null
    paidDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceCreateManyClientInput = {
    id?: string
    tenantId: string
    orderId?: string | null
    invoiceNumber: string
    status?: string
    issueDate?: Date | string
    dueDate: Date | string
    paidDate?: Date | string | null
    subtotal: number
    tax?: number
    total: number
    paymentMethod?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientMeasurementCreateManyClientInput = {
    id?: string
    date?: Date | string
    weight?: number | null
    bodyFat?: number | null
    measurements?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    createdAt?: Date | string
  }

  export type ProgressPhotoCreateManyClientInput = {
    id?: string
    url: string
    date?: Date | string
    view: string
    notes?: string | null
    createdAt?: Date | string
  }

  export type ClientBadgeCreateManyClientInput = {
    id?: string
    badgeId: string
    earnedAt?: Date | string
    notified?: boolean
  }

  export type SessionUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    workoutPlan?: NullableJsonNullValueInput | InputJsonValue
    exercisesLogged?: SessionUpdateexercisesLoggedInput | InputJsonValue[]
    caloriesBurned?: NullableIntFieldUpdateOperationsInput | number | null
    heartRateAvg?: NullableIntFieldUpdateOperationsInput | number | null
    muscleGroups?: SessionUpdatemuscleGroupsInput | string[]
    clientFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    trainerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    intensity?: NullableStringFieldUpdateOperationsInput | string | null
    clientRating?: NullableIntFieldUpdateOperationsInput | number | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    paid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    workoutPlan?: NullableJsonNullValueInput | InputJsonValue
    exercisesLogged?: SessionUpdateexercisesLoggedInput | InputJsonValue[]
    caloriesBurned?: NullableIntFieldUpdateOperationsInput | number | null
    heartRateAvg?: NullableIntFieldUpdateOperationsInput | number | null
    muscleGroups?: SessionUpdatemuscleGroupsInput | string[]
    clientFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    trainerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    intensity?: NullableStringFieldUpdateOperationsInput | string | null
    clientRating?: NullableIntFieldUpdateOperationsInput | number | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    paid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    workoutPlan?: NullableJsonNullValueInput | InputJsonValue
    exercisesLogged?: SessionUpdateexercisesLoggedInput | InputJsonValue[]
    caloriesBurned?: NullableIntFieldUpdateOperationsInput | number | null
    heartRateAvg?: NullableIntFieldUpdateOperationsInput | number | null
    muscleGroups?: SessionUpdatemuscleGroupsInput | string[]
    clientFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    trainerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    intensity?: NullableStringFieldUpdateOperationsInput | string | null
    clientRating?: NullableIntFieldUpdateOperationsInput | number | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    paid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    items?: OrderUpdateitemsInput | InputJsonValue[]
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    paidAmount?: FloatFieldUpdateOperationsInput | number
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutOrdersNestedInput
    invoices?: InvoiceUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    items?: OrderUpdateitemsInput | InputJsonValue[]
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    paidAmount?: FloatFieldUpdateOperationsInput | number
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    items?: OrderUpdateitemsInput | InputJsonValue[]
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    paidAmount?: FloatFieldUpdateOperationsInput | number
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutInvoicesNestedInput
    order?: OrderUpdateOneWithoutInvoicesNestedInput
    payments?: InvoicePaymentUpdateManyWithoutInvoiceNestedInput
    bankTransactions?: BankTransactionUpdateManyWithoutMatchedInvoiceNestedInput
    cryptoPayments?: CryptoPaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: InvoicePaymentUncheckedUpdateManyWithoutInvoiceNestedInput
    bankTransactions?: BankTransactionUncheckedUpdateManyWithoutMatchedInvoiceNestedInput
    cryptoPayments?: CryptoPaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientMeasurementUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    bodyFat?: NullableFloatFieldUpdateOperationsInput | number | null
    measurements?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientMeasurementUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    bodyFat?: NullableFloatFieldUpdateOperationsInput | number | null
    measurements?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientMeasurementUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    bodyFat?: NullableFloatFieldUpdateOperationsInput | number | null
    measurements?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgressPhotoUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    view?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgressPhotoUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    view?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgressPhotoUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    view?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientBadgeUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notified?: BoolFieldUpdateOperationsInput | boolean
    badge?: BadgeUpdateOneRequiredWithoutClientBadgesNestedInput
  }

  export type ClientBadgeUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    badgeId?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ClientBadgeUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    badgeId?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ClassBookingCreateManyClassInput = {
    id?: string
    clientId: string
    status?: string
    checkedIn?: boolean
    paid?: boolean
    createdAt?: Date | string
  }

  export type ClassBookingUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    checkedIn?: BoolFieldUpdateOperationsInput | boolean
    paid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassBookingUncheckedUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    checkedIn?: BoolFieldUpdateOperationsInput | boolean
    paid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassBookingUncheckedUpdateManyWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    checkedIn?: BoolFieldUpdateOperationsInput | boolean
    paid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateManyOrderInput = {
    id?: string
    tenantId: string
    clientId: string
    invoiceNumber: string
    status?: string
    issueDate?: Date | string
    dueDate: Date | string
    paidDate?: Date | string | null
    subtotal: number
    tax?: number
    total: number
    paymentMethod?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutInvoicesNestedInput
    client?: ClientUpdateOneRequiredWithoutInvoicesNestedInput
    payments?: InvoicePaymentUpdateManyWithoutInvoiceNestedInput
    bankTransactions?: BankTransactionUpdateManyWithoutMatchedInvoiceNestedInput
    cryptoPayments?: CryptoPaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: InvoicePaymentUncheckedUpdateManyWithoutInvoiceNestedInput
    bankTransactions?: BankTransactionUncheckedUpdateManyWithoutMatchedInvoiceNestedInput
    cryptoPayments?: CryptoPaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoicePaymentCreateManyInvoiceInput = {
    id?: string
    tenantId: string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    method: $Enums.PaymentMethod
    status?: string
    gatewayProvider?: string | null
    gatewayPaymentId?: string | null
    gatewayFee?: Decimal | DecimalJsLike | number | string | null
    transactionId?: string | null
    reference?: string | null
    processedAt?: Date | string | null
    completedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankTransactionCreateManyMatchedInvoiceInput = {
    id?: string
    bankAccountId: string
    tenantId: string
    transactionId: string
    date: Date | string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    type: $Enums.TransactionType
    counterpartyName?: string | null
    counterpartyAccount?: string | null
    counterpartyBankCode?: string | null
    description?: string | null
    note?: string | null
    variableSymbol?: string | null
    constantSymbol?: string | null
    specificSymbol?: string | null
    reference?: string | null
    isMatched?: boolean
    matchedPaymentId?: string | null
    matchConfidence?: Decimal | DecimalJsLike | number | string | null
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CryptoPaymentCreateManyInvoiceInput = {
    id?: string
    walletId: string
    amount: string
    currency: string
    txHash?: string | null
    confirmations?: number
    status?: string
    detectedAt?: Date | string | null
    confirmedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoicePaymentUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: StringFieldUpdateOperationsInput | string
    gatewayProvider?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutInvoicePaymentsNestedInput
  }

  export type InvoicePaymentUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: StringFieldUpdateOperationsInput | string
    gatewayProvider?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoicePaymentUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: StringFieldUpdateOperationsInput | string
    gatewayProvider?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankTransactionUpdateWithoutMatchedInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    counterpartyName?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyAccount?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyBankCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    variableSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    constantSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    specificSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    isMatched?: BoolFieldUpdateOperationsInput | boolean
    matchedPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    matchConfidence?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankAccount?: BankAccountUpdateOneRequiredWithoutTransactionsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutBankTransactionsNestedInput
  }

  export type BankTransactionUncheckedUpdateWithoutMatchedInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    bankAccountId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    counterpartyName?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyAccount?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyBankCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    variableSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    constantSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    specificSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    isMatched?: BoolFieldUpdateOperationsInput | boolean
    matchedPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    matchConfidence?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankTransactionUncheckedUpdateManyWithoutMatchedInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    bankAccountId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    counterpartyName?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyAccount?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyBankCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    variableSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    constantSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    specificSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    isMatched?: BoolFieldUpdateOperationsInput | boolean
    matchedPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    matchConfidence?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CryptoPaymentUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    confirmations?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    detectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wallet?: CryptoWalletUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type CryptoPaymentUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletId?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    confirmations?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    detectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CryptoPaymentUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletId?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    confirmations?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    detectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExchangeRateCreateManyFromCurrencyInput = {
    id?: string
    toCurrencyId: string
    rate: Decimal | DecimalJsLike | number | string
    source: string
    timestamp: Date | string
  }

  export type ExchangeRateCreateManyToCurrencyInput = {
    id?: string
    fromCurrencyId: string
    rate: Decimal | DecimalJsLike | number | string
    source: string
    timestamp: Date | string
  }

  export type ExchangeRateUpdateWithoutFromCurrencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    source?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    toCurrency?: CurrencyUpdateOneRequiredWithoutExchangeRatesToNestedInput
  }

  export type ExchangeRateUncheckedUpdateWithoutFromCurrencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    toCurrencyId?: StringFieldUpdateOperationsInput | string
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    source?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExchangeRateUncheckedUpdateManyWithoutFromCurrencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    toCurrencyId?: StringFieldUpdateOperationsInput | string
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    source?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExchangeRateUpdateWithoutToCurrencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    source?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    fromCurrency?: CurrencyUpdateOneRequiredWithoutExchangeRatesFromNestedInput
  }

  export type ExchangeRateUncheckedUpdateWithoutToCurrencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromCurrencyId?: StringFieldUpdateOperationsInput | string
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    source?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExchangeRateUncheckedUpdateManyWithoutToCurrencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromCurrencyId?: StringFieldUpdateOperationsInput | string
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    source?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankTransactionCreateManyBankAccountInput = {
    id?: string
    tenantId: string
    transactionId: string
    date: Date | string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    type: $Enums.TransactionType
    counterpartyName?: string | null
    counterpartyAccount?: string | null
    counterpartyBankCode?: string | null
    description?: string | null
    note?: string | null
    variableSymbol?: string | null
    constantSymbol?: string | null
    specificSymbol?: string | null
    reference?: string | null
    isMatched?: boolean
    matchedInvoiceId?: string | null
    matchedPaymentId?: string | null
    matchConfidence?: Decimal | DecimalJsLike | number | string | null
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankTransactionUpdateWithoutBankAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    counterpartyName?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyAccount?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyBankCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    variableSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    constantSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    specificSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    isMatched?: BoolFieldUpdateOperationsInput | boolean
    matchedPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    matchConfidence?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutBankTransactionsNestedInput
    matchedInvoice?: InvoiceUpdateOneWithoutBankTransactionsNestedInput
  }

  export type BankTransactionUncheckedUpdateWithoutBankAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    counterpartyName?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyAccount?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyBankCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    variableSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    constantSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    specificSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    isMatched?: BoolFieldUpdateOperationsInput | boolean
    matchedInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    matchedPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    matchConfidence?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankTransactionUncheckedUpdateManyWithoutBankAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    counterpartyName?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyAccount?: NullableStringFieldUpdateOperationsInput | string | null
    counterpartyBankCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    variableSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    constantSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    specificSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    isMatched?: BoolFieldUpdateOperationsInput | boolean
    matchedInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    matchedPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    matchConfidence?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CryptoPaymentCreateManyWalletInput = {
    id?: string
    invoiceId?: string | null
    amount: string
    currency: string
    txHash?: string | null
    confirmations?: number
    status?: string
    detectedAt?: Date | string | null
    confirmedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CryptoPaymentUpdateWithoutWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    confirmations?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    detectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneWithoutCryptoPaymentsNestedInput
  }

  export type CryptoPaymentUncheckedUpdateWithoutWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    confirmations?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    detectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CryptoPaymentUncheckedUpdateManyWithoutWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    confirmations?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    detectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseCreateManyCategoryInput = {
    id?: string
    tenantId: string
    description: string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    date: Date | string
    vendor?: string | null
    receiptUrl?: string | null
    receiptOcrData?: NullableJsonNullValueInput | InputJsonValue
    taxAmount?: Decimal | DecimalJsLike | number | string | null
    isTaxDeductible?: boolean
    status: $Enums.ExpenseStatus
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectedReason?: string | null
    reimbursedAt?: Date | string | null
    reimbursedAmount?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    receiptOcrData?: NullableJsonNullValueInput | InputJsonValue
    taxAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isTaxDeductible?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumExpenseStatusFieldUpdateOperationsInput | $Enums.ExpenseStatus
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedReason?: NullableStringFieldUpdateOperationsInput | string | null
    reimbursedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reimbursedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutExpensesNestedInput
  }

  export type ExpenseUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    receiptOcrData?: NullableJsonNullValueInput | InputJsonValue
    taxAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isTaxDeductible?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumExpenseStatusFieldUpdateOperationsInput | $Enums.ExpenseStatus
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedReason?: NullableStringFieldUpdateOperationsInput | string | null
    reimbursedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reimbursedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    receiptOcrData?: NullableJsonNullValueInput | InputJsonValue
    taxAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isTaxDeductible?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumExpenseStatusFieldUpdateOperationsInput | $Enums.ExpenseStatus
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedReason?: NullableStringFieldUpdateOperationsInput | string | null
    reimbursedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reimbursedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarEventSyncCreateManyIntegrationInput = {
    id?: string
    entityType: string
    entityId: string
    externalEventId: string
    lastSyncedAt: Date | string
    syncHash: string
  }

  export type CalendarEventSyncUpdateWithoutIntegrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    externalEventId?: StringFieldUpdateOperationsInput | string
    lastSyncedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncHash?: StringFieldUpdateOperationsInput | string
  }

  export type CalendarEventSyncUncheckedUpdateWithoutIntegrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    externalEventId?: StringFieldUpdateOperationsInput | string
    lastSyncedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncHash?: StringFieldUpdateOperationsInput | string
  }

  export type CalendarEventSyncUncheckedUpdateManyWithoutIntegrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    externalEventId?: StringFieldUpdateOperationsInput | string
    lastSyncedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncHash?: StringFieldUpdateOperationsInput | string
  }

  export type ClientBadgeCreateManyBadgeInput = {
    id?: string
    clientId: string
    earnedAt?: Date | string
    notified?: boolean
  }

  export type ClientBadgeUpdateWithoutBadgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notified?: BoolFieldUpdateOperationsInput | boolean
    client?: ClientUpdateOneRequiredWithoutBadgesNestedInput
  }

  export type ClientBadgeUncheckedUpdateWithoutBadgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ClientBadgeUncheckedUpdateManyWithoutBadgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notified?: BoolFieldUpdateOperationsInput | boolean
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}