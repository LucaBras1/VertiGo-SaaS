
/**
 * Client
**/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Program
 * 
 */
export type Program = $Result.DefaultSelection<Prisma.$ProgramPayload>
/**
 * Model Activity
 * 
 */
export type Activity = $Result.DefaultSelection<Prisma.$ActivityPayload>
/**
 * Model ProgramActivity
 * 
 */
export type ProgramActivity = $Result.DefaultSelection<Prisma.$ProgramActivityPayload>
/**
 * Model Extra
 * 
 */
export type Extra = $Result.DefaultSelection<Prisma.$ExtraPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Customer
 * 
 */
export type Customer = $Result.DefaultSelection<Prisma.$CustomerPayload>
/**
 * Model Order
 * 
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>
/**
 * Model OrderItem
 * 
 */
export type OrderItem = $Result.DefaultSelection<Prisma.$OrderItemPayload>
/**
 * Model Invoice
 * 
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model UserSession
 * 
 */
export type UserSession = $Result.DefaultSelection<Prisma.$UserSessionPayload>
/**
 * Model VerificationToken
 * 
 */
export type VerificationToken = $Result.DefaultSelection<Prisma.$VerificationTokenPayload>
/**
 * Model Settings
 * 
 */
export type Settings = $Result.DefaultSelection<Prisma.$SettingsPayload>
/**
 * Model AIUsage
 * 
 */
export type AIUsage = $Result.DefaultSelection<Prisma.$AIUsagePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const ObjectiveType: {
  COMMUNICATION: 'COMMUNICATION',
  TRUST: 'TRUST',
  LEADERSHIP: 'LEADERSHIP',
  PROBLEM_SOLVING: 'PROBLEM_SOLVING',
  CREATIVITY: 'CREATIVITY',
  COLLABORATION: 'COLLABORATION',
  CONFLICT: 'CONFLICT',
  MOTIVATION: 'MOTIVATION'
};

export type ObjectiveType = (typeof ObjectiveType)[keyof typeof ObjectiveType]


export const PhysicalLevel: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH'
};

export type PhysicalLevel = (typeof PhysicalLevel)[keyof typeof PhysicalLevel]


export const IndoorOutdoor: {
  INDOOR: 'INDOOR',
  OUTDOOR: 'OUTDOOR',
  BOTH: 'BOTH',
  FLEXIBLE: 'FLEXIBLE'
};

export type IndoorOutdoor = (typeof IndoorOutdoor)[keyof typeof IndoorOutdoor]


export const IndustryType: {
  TECHNOLOGY: 'TECHNOLOGY',
  FINANCE: 'FINANCE',
  HEALTHCARE: 'HEALTHCARE',
  EDUCATION: 'EDUCATION',
  MANUFACTURING: 'MANUFACTURING',
  RETAIL: 'RETAIL',
  HOSPITALITY: 'HOSPITALITY',
  CONSULTING: 'CONSULTING',
  GOVERNMENT: 'GOVERNMENT',
  NONPROFIT: 'NONPROFIT',
  OTHER: 'OTHER'
};

export type IndustryType = (typeof IndustryType)[keyof typeof IndustryType]

}

export type ObjectiveType = $Enums.ObjectiveType

export const ObjectiveType: typeof $Enums.ObjectiveType

export type PhysicalLevel = $Enums.PhysicalLevel

export const PhysicalLevel: typeof $Enums.PhysicalLevel

export type IndoorOutdoor = $Enums.IndoorOutdoor

export const IndoorOutdoor: typeof $Enums.IndoorOutdoor

export type IndustryType = $Enums.IndustryType

export const IndustryType: typeof $Enums.IndustryType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Programs
 * const programs = await prisma.program.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Programs
   * const programs = await prisma.program.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.program`: Exposes CRUD operations for the **Program** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Programs
    * const programs = await prisma.program.findMany()
    * ```
    */
  get program(): Prisma.ProgramDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.activity`: Exposes CRUD operations for the **Activity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Activities
    * const activities = await prisma.activity.findMany()
    * ```
    */
  get activity(): Prisma.ActivityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.programActivity`: Exposes CRUD operations for the **ProgramActivity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProgramActivities
    * const programActivities = await prisma.programActivity.findMany()
    * ```
    */
  get programActivity(): Prisma.ProgramActivityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.extra`: Exposes CRUD operations for the **Extra** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Extras
    * const extras = await prisma.extra.findMany()
    * ```
    */
  get extra(): Prisma.ExtraDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orderItem`: Exposes CRUD operations for the **OrderItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderItems
    * const orderItems = await prisma.orderItem.findMany()
    * ```
    */
  get orderItem(): Prisma.OrderItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userSession`: Exposes CRUD operations for the **UserSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSessions
    * const userSessions = await prisma.userSession.findMany()
    * ```
    */
  get userSession(): Prisma.UserSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationTokens
    * const verificationTokens = await prisma.verificationToken.findMany()
    * ```
    */
  get verificationToken(): Prisma.VerificationTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.settings`: Exposes CRUD operations for the **Settings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Settings
    * const settings = await prisma.settings.findMany()
    * ```
    */
  get settings(): Prisma.SettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aIUsage`: Exposes CRUD operations for the **AIUsage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AIUsages
    * const aIUsages = await prisma.aIUsage.findMany()
    * ```
    */
  get aIUsage(): Prisma.AIUsageDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.3.0
   * Query Engine version: 9d6ad21cbbceab97458517b147a6a09ff43aa735
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Program: 'Program',
    Activity: 'Activity',
    ProgramActivity: 'ProgramActivity',
    Extra: 'Extra',
    Session: 'Session',
    Customer: 'Customer',
    Order: 'Order',
    OrderItem: 'OrderItem',
    Invoice: 'Invoice',
    User: 'User',
    Account: 'Account',
    UserSession: 'UserSession',
    VerificationToken: 'VerificationToken',
    Settings: 'Settings',
    AIUsage: 'AIUsage'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "program" | "activity" | "programActivity" | "extra" | "session" | "customer" | "order" | "orderItem" | "invoice" | "user" | "account" | "userSession" | "verificationToken" | "settings" | "aIUsage"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Program: {
        payload: Prisma.$ProgramPayload<ExtArgs>
        fields: Prisma.ProgramFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProgramFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProgramFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          findFirst: {
            args: Prisma.ProgramFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProgramFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          findMany: {
            args: Prisma.ProgramFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>[]
          }
          create: {
            args: Prisma.ProgramCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          createMany: {
            args: Prisma.ProgramCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProgramCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>[]
          }
          delete: {
            args: Prisma.ProgramDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          update: {
            args: Prisma.ProgramUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          deleteMany: {
            args: Prisma.ProgramDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProgramUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProgramUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>[]
          }
          upsert: {
            args: Prisma.ProgramUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          aggregate: {
            args: Prisma.ProgramAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProgram>
          }
          groupBy: {
            args: Prisma.ProgramGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProgramGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProgramCountArgs<ExtArgs>
            result: $Utils.Optional<ProgramCountAggregateOutputType> | number
          }
        }
      }
      Activity: {
        payload: Prisma.$ActivityPayload<ExtArgs>
        fields: Prisma.ActivityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          findFirst: {
            args: Prisma.ActivityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          findMany: {
            args: Prisma.ActivityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          create: {
            args: Prisma.ActivityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          createMany: {
            args: Prisma.ActivityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          delete: {
            args: Prisma.ActivityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          update: {
            args: Prisma.ActivityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          deleteMany: {
            args: Prisma.ActivityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ActivityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          upsert: {
            args: Prisma.ActivityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          aggregate: {
            args: Prisma.ActivityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivity>
          }
          groupBy: {
            args: Prisma.ActivityGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityCountAggregateOutputType> | number
          }
        }
      }
      ProgramActivity: {
        payload: Prisma.$ProgramActivityPayload<ExtArgs>
        fields: Prisma.ProgramActivityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProgramActivityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramActivityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProgramActivityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramActivityPayload>
          }
          findFirst: {
            args: Prisma.ProgramActivityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramActivityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProgramActivityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramActivityPayload>
          }
          findMany: {
            args: Prisma.ProgramActivityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramActivityPayload>[]
          }
          create: {
            args: Prisma.ProgramActivityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramActivityPayload>
          }
          createMany: {
            args: Prisma.ProgramActivityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProgramActivityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramActivityPayload>[]
          }
          delete: {
            args: Prisma.ProgramActivityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramActivityPayload>
          }
          update: {
            args: Prisma.ProgramActivityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramActivityPayload>
          }
          deleteMany: {
            args: Prisma.ProgramActivityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProgramActivityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProgramActivityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramActivityPayload>[]
          }
          upsert: {
            args: Prisma.ProgramActivityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramActivityPayload>
          }
          aggregate: {
            args: Prisma.ProgramActivityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProgramActivity>
          }
          groupBy: {
            args: Prisma.ProgramActivityGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProgramActivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProgramActivityCountArgs<ExtArgs>
            result: $Utils.Optional<ProgramActivityCountAggregateOutputType> | number
          }
        }
      }
      Extra: {
        payload: Prisma.$ExtraPayload<ExtArgs>
        fields: Prisma.ExtraFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExtraFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExtraPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExtraFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExtraPayload>
          }
          findFirst: {
            args: Prisma.ExtraFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExtraPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExtraFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExtraPayload>
          }
          findMany: {
            args: Prisma.ExtraFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExtraPayload>[]
          }
          create: {
            args: Prisma.ExtraCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExtraPayload>
          }
          createMany: {
            args: Prisma.ExtraCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExtraCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExtraPayload>[]
          }
          delete: {
            args: Prisma.ExtraDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExtraPayload>
          }
          update: {
            args: Prisma.ExtraUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExtraPayload>
          }
          deleteMany: {
            args: Prisma.ExtraDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExtraUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExtraUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExtraPayload>[]
          }
          upsert: {
            args: Prisma.ExtraUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExtraPayload>
          }
          aggregate: {
            args: Prisma.ExtraAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExtra>
          }
          groupBy: {
            args: Prisma.ExtraGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExtraGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExtraCountArgs<ExtArgs>
            result: $Utils.Optional<ExtraCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Customer: {
        payload: Prisma.$CustomerPayload<ExtArgs>
        fields: Prisma.CustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findFirst: {
            args: Prisma.CustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findMany: {
            args: Prisma.CustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          create: {
            args: Prisma.CustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          createMany: {
            args: Prisma.CustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          delete: {
            args: Prisma.CustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          update: {
            args: Prisma.CustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          upsert: {
            args: Prisma.CustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.CustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>
        fields: Prisma.OrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      OrderItem: {
        payload: Prisma.$OrderItemPayload<ExtArgs>
        fields: Prisma.OrderItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findFirst: {
            args: Prisma.OrderItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findMany: {
            args: Prisma.OrderItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          create: {
            args: Prisma.OrderItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          createMany: {
            args: Prisma.OrderItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          delete: {
            args: Prisma.OrderItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          update: {
            args: Prisma.OrderItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          deleteMany: {
            args: Prisma.OrderItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          upsert: {
            args: Prisma.OrderItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          aggregate: {
            args: Prisma.OrderItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderItem>
          }
          groupBy: {
            args: Prisma.OrderItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderItemCountArgs<ExtArgs>
            result: $Utils.Optional<OrderItemCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: Prisma.$InvoicePayload<ExtArgs>
        fields: Prisma.InvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvoiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      UserSession: {
        payload: Prisma.$UserSessionPayload<ExtArgs>
        fields: Prisma.UserSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          findFirst: {
            args: Prisma.UserSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          findMany: {
            args: Prisma.UserSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>[]
          }
          create: {
            args: Prisma.UserSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          createMany: {
            args: Prisma.UserSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>[]
          }
          delete: {
            args: Prisma.UserSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          update: {
            args: Prisma.UserSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          deleteMany: {
            args: Prisma.UserSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>[]
          }
          upsert: {
            args: Prisma.UserSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          aggregate: {
            args: Prisma.UserSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSession>
          }
          groupBy: {
            args: Prisma.UserSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSessionCountArgs<ExtArgs>
            result: $Utils.Optional<UserSessionCountAggregateOutputType> | number
          }
        }
      }
      VerificationToken: {
        payload: Prisma.$VerificationTokenPayload<ExtArgs>
        fields: Prisma.VerificationTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findFirst: {
            args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findMany: {
            args: Prisma.VerificationTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          create: {
            args: Prisma.VerificationTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          createMany: {
            args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          delete: {
            args: Prisma.VerificationTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          update: {
            args: Prisma.VerificationTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          deleteMany: {
            args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          upsert: {
            args: Prisma.VerificationTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          aggregate: {
            args: Prisma.VerificationTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerificationToken>
          }
          groupBy: {
            args: Prisma.VerificationTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationTokenCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenCountAggregateOutputType> | number
          }
        }
      }
      Settings: {
        payload: Prisma.$SettingsPayload<ExtArgs>
        fields: Prisma.SettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          findFirst: {
            args: Prisma.SettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          findMany: {
            args: Prisma.SettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>[]
          }
          create: {
            args: Prisma.SettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          createMany: {
            args: Prisma.SettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>[]
          }
          delete: {
            args: Prisma.SettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          update: {
            args: Prisma.SettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          deleteMany: {
            args: Prisma.SettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>[]
          }
          upsert: {
            args: Prisma.SettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          aggregate: {
            args: Prisma.SettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSettings>
          }
          groupBy: {
            args: Prisma.SettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SettingsCountArgs<ExtArgs>
            result: $Utils.Optional<SettingsCountAggregateOutputType> | number
          }
        }
      }
      AIUsage: {
        payload: Prisma.$AIUsagePayload<ExtArgs>
        fields: Prisma.AIUsageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AIUsageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AIUsageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsagePayload>
          }
          findFirst: {
            args: Prisma.AIUsageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AIUsageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsagePayload>
          }
          findMany: {
            args: Prisma.AIUsageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsagePayload>[]
          }
          create: {
            args: Prisma.AIUsageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsagePayload>
          }
          createMany: {
            args: Prisma.AIUsageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AIUsageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsagePayload>[]
          }
          delete: {
            args: Prisma.AIUsageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsagePayload>
          }
          update: {
            args: Prisma.AIUsageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsagePayload>
          }
          deleteMany: {
            args: Prisma.AIUsageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AIUsageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AIUsageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsagePayload>[]
          }
          upsert: {
            args: Prisma.AIUsageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsagePayload>
          }
          aggregate: {
            args: Prisma.AIUsageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAIUsage>
          }
          groupBy: {
            args: Prisma.AIUsageGroupByArgs<ExtArgs>
            result: $Utils.Optional<AIUsageGroupByOutputType>[]
          }
          count: {
            args: Prisma.AIUsageCountArgs<ExtArgs>
            result: $Utils.Optional<AIUsageCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://pris.ly/d/logging).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
    /**
     * SQL commenter plugins that add metadata to SQL queries as comments.
     * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   adapter,
     *   comments: [
     *     traceContext(),
     *     queryInsights(),
     *   ],
     * })
     * ```
     */
    comments?: runtime.SqlCommenterPlugin[]
  }
  export type GlobalOmitConfig = {
    program?: ProgramOmit
    activity?: ActivityOmit
    programActivity?: ProgramActivityOmit
    extra?: ExtraOmit
    session?: SessionOmit
    customer?: CustomerOmit
    order?: OrderOmit
    orderItem?: OrderItemOmit
    invoice?: InvoiceOmit
    user?: UserOmit
    account?: AccountOmit
    userSession?: UserSessionOmit
    verificationToken?: VerificationTokenOmit
    settings?: SettingsOmit
    aIUsage?: AIUsageOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ProgramCountOutputType
   */

  export type ProgramCountOutputType = {
    sessions: number
    activityLinks: number
    orderItems: number
  }

  export type ProgramCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | ProgramCountOutputTypeCountSessionsArgs
    activityLinks?: boolean | ProgramCountOutputTypeCountActivityLinksArgs
    orderItems?: boolean | ProgramCountOutputTypeCountOrderItemsArgs
  }

  // Custom InputTypes
  /**
   * ProgramCountOutputType without action
   */
  export type ProgramCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramCountOutputType
     */
    select?: ProgramCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProgramCountOutputType without action
   */
  export type ProgramCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * ProgramCountOutputType without action
   */
  export type ProgramCountOutputTypeCountActivityLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramActivityWhereInput
  }

  /**
   * ProgramCountOutputType without action
   */
  export type ProgramCountOutputTypeCountOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }


  /**
   * Count Type ActivityCountOutputType
   */

  export type ActivityCountOutputType = {
    programLinks: number
    orderItems: number
  }

  export type ActivityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    programLinks?: boolean | ActivityCountOutputTypeCountProgramLinksArgs
    orderItems?: boolean | ActivityCountOutputTypeCountOrderItemsArgs
  }

  // Custom InputTypes
  /**
   * ActivityCountOutputType without action
   */
  export type ActivityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityCountOutputType
     */
    select?: ActivityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ActivityCountOutputType without action
   */
  export type ActivityCountOutputTypeCountProgramLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramActivityWhereInput
  }

  /**
   * ActivityCountOutputType without action
   */
  export type ActivityCountOutputTypeCountOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }


  /**
   * Count Type ExtraCountOutputType
   */

  export type ExtraCountOutputType = {
    orderItems: number
  }

  export type ExtraCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderItems?: boolean | ExtraCountOutputTypeCountOrderItemsArgs
  }

  // Custom InputTypes
  /**
   * ExtraCountOutputType without action
   */
  export type ExtraCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtraCountOutputType
     */
    select?: ExtraCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExtraCountOutputType without action
   */
  export type ExtraCountOutputTypeCountOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }


  /**
   * Count Type SessionCountOutputType
   */

  export type SessionCountOutputType = {
    orders: number
  }

  export type SessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | SessionCountOutputTypeCountOrdersArgs
  }

  // Custom InputTypes
  /**
   * SessionCountOutputType without action
   */
  export type SessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionCountOutputType
     */
    select?: SessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SessionCountOutputType without action
   */
  export type SessionCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }


  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    orders: number
    invoices: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | CustomerCountOutputTypeCountOrdersArgs
    invoices?: boolean | CustomerCountOutputTypeCountInvoicesArgs
  }

  // Custom InputTypes
  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }


  /**
   * Count Type OrderCountOutputType
   */

  export type OrderCountOutputType = {
    items: number
    invoices: number
  }

  export type OrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | OrderCountOutputTypeCountItemsArgs
    invoices?: boolean | OrderCountOutputTypeCountInvoicesArgs
  }

  // Custom InputTypes
  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     */
    select?: OrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    accounts: number
    sessions: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSessionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Program
   */

  export type AggregateProgram = {
    _count: ProgramCountAggregateOutputType | null
    _avg: ProgramAvgAggregateOutputType | null
    _sum: ProgramSumAggregateOutputType | null
    _min: ProgramMinAggregateOutputType | null
    _max: ProgramMaxAggregateOutputType | null
  }

  export type ProgramAvgAggregateOutputType = {
    order: number | null
    teamSize: number | null
    minTeamSize: number | null
    maxTeamSize: number | null
    duration: number | null
    price: number | null
    pricePerPerson: number | null
  }

  export type ProgramSumAggregateOutputType = {
    order: number | null
    teamSize: number | null
    minTeamSize: number | null
    maxTeamSize: number | null
    duration: number | null
    price: number | null
    pricePerPerson: number | null
  }

  export type ProgramMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    title: string | null
    slug: string | null
    category: string | null
    status: string | null
    featured: boolean | null
    order: number | null
    subtitle: string | null
    excerpt: string | null
    teamSize: number | null
    minTeamSize: number | null
    maxTeamSize: number | null
    industryType: string | null
    physicalLevel: string | null
    indoorOutdoor: string | null
    duration: number | null
    includesCatering: boolean | null
    debriefIncluded: boolean | null
    facilitationRequired: boolean | null
    price: number | null
    pricePerPerson: number | null
    pricingNotes: string | null
    featuredImageUrl: string | null
    featuredImageAlt: string | null
    videoUrl: string | null
  }

  export type ProgramMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    title: string | null
    slug: string | null
    category: string | null
    status: string | null
    featured: boolean | null
    order: number | null
    subtitle: string | null
    excerpt: string | null
    teamSize: number | null
    minTeamSize: number | null
    maxTeamSize: number | null
    industryType: string | null
    physicalLevel: string | null
    indoorOutdoor: string | null
    duration: number | null
    includesCatering: boolean | null
    debriefIncluded: boolean | null
    facilitationRequired: boolean | null
    price: number | null
    pricePerPerson: number | null
    pricingNotes: string | null
    featuredImageUrl: string | null
    featuredImageAlt: string | null
    videoUrl: string | null
  }

  export type ProgramCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    title: number
    slug: number
    category: number
    status: number
    featured: number
    order: number
    subtitle: number
    excerpt: number
    description: number
    teamSize: number
    minTeamSize: number
    maxTeamSize: number
    objectives: number
    industryType: number
    physicalLevel: number
    indoorOutdoor: number
    duration: number
    includesCatering: number
    debriefIncluded: number
    facilitationRequired: number
    technicalRequirements: number
    materialsIncluded: number
    venueRequirements: number
    price: number
    pricePerPerson: number
    pricingNotes: number
    featuredImageUrl: number
    featuredImageAlt: number
    galleryImages: number
    videoUrl: number
    seo: number
    _all: number
  }


  export type ProgramAvgAggregateInputType = {
    order?: true
    teamSize?: true
    minTeamSize?: true
    maxTeamSize?: true
    duration?: true
    price?: true
    pricePerPerson?: true
  }

  export type ProgramSumAggregateInputType = {
    order?: true
    teamSize?: true
    minTeamSize?: true
    maxTeamSize?: true
    duration?: true
    price?: true
    pricePerPerson?: true
  }

  export type ProgramMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    title?: true
    slug?: true
    category?: true
    status?: true
    featured?: true
    order?: true
    subtitle?: true
    excerpt?: true
    teamSize?: true
    minTeamSize?: true
    maxTeamSize?: true
    industryType?: true
    physicalLevel?: true
    indoorOutdoor?: true
    duration?: true
    includesCatering?: true
    debriefIncluded?: true
    facilitationRequired?: true
    price?: true
    pricePerPerson?: true
    pricingNotes?: true
    featuredImageUrl?: true
    featuredImageAlt?: true
    videoUrl?: true
  }

  export type ProgramMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    title?: true
    slug?: true
    category?: true
    status?: true
    featured?: true
    order?: true
    subtitle?: true
    excerpt?: true
    teamSize?: true
    minTeamSize?: true
    maxTeamSize?: true
    industryType?: true
    physicalLevel?: true
    indoorOutdoor?: true
    duration?: true
    includesCatering?: true
    debriefIncluded?: true
    facilitationRequired?: true
    price?: true
    pricePerPerson?: true
    pricingNotes?: true
    featuredImageUrl?: true
    featuredImageAlt?: true
    videoUrl?: true
  }

  export type ProgramCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    title?: true
    slug?: true
    category?: true
    status?: true
    featured?: true
    order?: true
    subtitle?: true
    excerpt?: true
    description?: true
    teamSize?: true
    minTeamSize?: true
    maxTeamSize?: true
    objectives?: true
    industryType?: true
    physicalLevel?: true
    indoorOutdoor?: true
    duration?: true
    includesCatering?: true
    debriefIncluded?: true
    facilitationRequired?: true
    technicalRequirements?: true
    materialsIncluded?: true
    venueRequirements?: true
    price?: true
    pricePerPerson?: true
    pricingNotes?: true
    featuredImageUrl?: true
    featuredImageAlt?: true
    galleryImages?: true
    videoUrl?: true
    seo?: true
    _all?: true
  }

  export type ProgramAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Program to aggregate.
     */
    where?: ProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programs to fetch.
     */
    orderBy?: ProgramOrderByWithRelationInput | ProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Programs
    **/
    _count?: true | ProgramCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProgramAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProgramSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProgramMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProgramMaxAggregateInputType
  }

  export type GetProgramAggregateType<T extends ProgramAggregateArgs> = {
        [P in keyof T & keyof AggregateProgram]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProgram[P]>
      : GetScalarType<T[P], AggregateProgram[P]>
  }




  export type ProgramGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramWhereInput
    orderBy?: ProgramOrderByWithAggregationInput | ProgramOrderByWithAggregationInput[]
    by: ProgramScalarFieldEnum[] | ProgramScalarFieldEnum
    having?: ProgramScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProgramCountAggregateInputType | true
    _avg?: ProgramAvgAggregateInputType
    _sum?: ProgramSumAggregateInputType
    _min?: ProgramMinAggregateInputType
    _max?: ProgramMaxAggregateInputType
  }

  export type ProgramGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    title: string
    slug: string
    category: string
    status: string
    featured: boolean
    order: number
    subtitle: string | null
    excerpt: string | null
    description: JsonValue | null
    teamSize: number | null
    minTeamSize: number | null
    maxTeamSize: number | null
    objectives: JsonValue | null
    industryType: string | null
    physicalLevel: string | null
    indoorOutdoor: string | null
    duration: number
    includesCatering: boolean
    debriefIncluded: boolean
    facilitationRequired: boolean
    technicalRequirements: JsonValue | null
    materialsIncluded: JsonValue | null
    venueRequirements: JsonValue | null
    price: number | null
    pricePerPerson: number | null
    pricingNotes: string | null
    featuredImageUrl: string | null
    featuredImageAlt: string | null
    galleryImages: JsonValue | null
    videoUrl: string | null
    seo: JsonValue | null
    _count: ProgramCountAggregateOutputType | null
    _avg: ProgramAvgAggregateOutputType | null
    _sum: ProgramSumAggregateOutputType | null
    _min: ProgramMinAggregateOutputType | null
    _max: ProgramMaxAggregateOutputType | null
  }

  type GetProgramGroupByPayload<T extends ProgramGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProgramGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProgramGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProgramGroupByOutputType[P]>
            : GetScalarType<T[P], ProgramGroupByOutputType[P]>
        }
      >
    >


  export type ProgramSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    title?: boolean
    slug?: boolean
    category?: boolean
    status?: boolean
    featured?: boolean
    order?: boolean
    subtitle?: boolean
    excerpt?: boolean
    description?: boolean
    teamSize?: boolean
    minTeamSize?: boolean
    maxTeamSize?: boolean
    objectives?: boolean
    industryType?: boolean
    physicalLevel?: boolean
    indoorOutdoor?: boolean
    duration?: boolean
    includesCatering?: boolean
    debriefIncluded?: boolean
    facilitationRequired?: boolean
    technicalRequirements?: boolean
    materialsIncluded?: boolean
    venueRequirements?: boolean
    price?: boolean
    pricePerPerson?: boolean
    pricingNotes?: boolean
    featuredImageUrl?: boolean
    featuredImageAlt?: boolean
    galleryImages?: boolean
    videoUrl?: boolean
    seo?: boolean
    sessions?: boolean | Program$sessionsArgs<ExtArgs>
    activityLinks?: boolean | Program$activityLinksArgs<ExtArgs>
    orderItems?: boolean | Program$orderItemsArgs<ExtArgs>
    _count?: boolean | ProgramCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["program"]>

  export type ProgramSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    title?: boolean
    slug?: boolean
    category?: boolean
    status?: boolean
    featured?: boolean
    order?: boolean
    subtitle?: boolean
    excerpt?: boolean
    description?: boolean
    teamSize?: boolean
    minTeamSize?: boolean
    maxTeamSize?: boolean
    objectives?: boolean
    industryType?: boolean
    physicalLevel?: boolean
    indoorOutdoor?: boolean
    duration?: boolean
    includesCatering?: boolean
    debriefIncluded?: boolean
    facilitationRequired?: boolean
    technicalRequirements?: boolean
    materialsIncluded?: boolean
    venueRequirements?: boolean
    price?: boolean
    pricePerPerson?: boolean
    pricingNotes?: boolean
    featuredImageUrl?: boolean
    featuredImageAlt?: boolean
    galleryImages?: boolean
    videoUrl?: boolean
    seo?: boolean
  }, ExtArgs["result"]["program"]>

  export type ProgramSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    title?: boolean
    slug?: boolean
    category?: boolean
    status?: boolean
    featured?: boolean
    order?: boolean
    subtitle?: boolean
    excerpt?: boolean
    description?: boolean
    teamSize?: boolean
    minTeamSize?: boolean
    maxTeamSize?: boolean
    objectives?: boolean
    industryType?: boolean
    physicalLevel?: boolean
    indoorOutdoor?: boolean
    duration?: boolean
    includesCatering?: boolean
    debriefIncluded?: boolean
    facilitationRequired?: boolean
    technicalRequirements?: boolean
    materialsIncluded?: boolean
    venueRequirements?: boolean
    price?: boolean
    pricePerPerson?: boolean
    pricingNotes?: boolean
    featuredImageUrl?: boolean
    featuredImageAlt?: boolean
    galleryImages?: boolean
    videoUrl?: boolean
    seo?: boolean
  }, ExtArgs["result"]["program"]>

  export type ProgramSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    title?: boolean
    slug?: boolean
    category?: boolean
    status?: boolean
    featured?: boolean
    order?: boolean
    subtitle?: boolean
    excerpt?: boolean
    description?: boolean
    teamSize?: boolean
    minTeamSize?: boolean
    maxTeamSize?: boolean
    objectives?: boolean
    industryType?: boolean
    physicalLevel?: boolean
    indoorOutdoor?: boolean
    duration?: boolean
    includesCatering?: boolean
    debriefIncluded?: boolean
    facilitationRequired?: boolean
    technicalRequirements?: boolean
    materialsIncluded?: boolean
    venueRequirements?: boolean
    price?: boolean
    pricePerPerson?: boolean
    pricingNotes?: boolean
    featuredImageUrl?: boolean
    featuredImageAlt?: boolean
    galleryImages?: boolean
    videoUrl?: boolean
    seo?: boolean
  }

  export type ProgramOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "title" | "slug" | "category" | "status" | "featured" | "order" | "subtitle" | "excerpt" | "description" | "teamSize" | "minTeamSize" | "maxTeamSize" | "objectives" | "industryType" | "physicalLevel" | "indoorOutdoor" | "duration" | "includesCatering" | "debriefIncluded" | "facilitationRequired" | "technicalRequirements" | "materialsIncluded" | "venueRequirements" | "price" | "pricePerPerson" | "pricingNotes" | "featuredImageUrl" | "featuredImageAlt" | "galleryImages" | "videoUrl" | "seo", ExtArgs["result"]["program"]>
  export type ProgramInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | Program$sessionsArgs<ExtArgs>
    activityLinks?: boolean | Program$activityLinksArgs<ExtArgs>
    orderItems?: boolean | Program$orderItemsArgs<ExtArgs>
    _count?: boolean | ProgramCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProgramIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ProgramIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProgramPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Program"
    objects: {
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      activityLinks: Prisma.$ProgramActivityPayload<ExtArgs>[]
      orderItems: Prisma.$OrderItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      title: string
      slug: string
      category: string
      status: string
      featured: boolean
      order: number
      subtitle: string | null
      excerpt: string | null
      description: Prisma.JsonValue | null
      teamSize: number | null
      minTeamSize: number | null
      maxTeamSize: number | null
      objectives: Prisma.JsonValue | null
      industryType: string | null
      physicalLevel: string | null
      indoorOutdoor: string | null
      duration: number
      includesCatering: boolean
      debriefIncluded: boolean
      facilitationRequired: boolean
      technicalRequirements: Prisma.JsonValue | null
      materialsIncluded: Prisma.JsonValue | null
      venueRequirements: Prisma.JsonValue | null
      price: number | null
      pricePerPerson: number | null
      pricingNotes: string | null
      featuredImageUrl: string | null
      featuredImageAlt: string | null
      galleryImages: Prisma.JsonValue | null
      videoUrl: string | null
      seo: Prisma.JsonValue | null
    }, ExtArgs["result"]["program"]>
    composites: {}
  }

  type ProgramGetPayload<S extends boolean | null | undefined | ProgramDefaultArgs> = $Result.GetResult<Prisma.$ProgramPayload, S>

  type ProgramCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProgramFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProgramCountAggregateInputType | true
    }

  export interface ProgramDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Program'], meta: { name: 'Program' } }
    /**
     * Find zero or one Program that matches the filter.
     * @param {ProgramFindUniqueArgs} args - Arguments to find a Program
     * @example
     * // Get one Program
     * const program = await prisma.program.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProgramFindUniqueArgs>(args: SelectSubset<T, ProgramFindUniqueArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Program that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProgramFindUniqueOrThrowArgs} args - Arguments to find a Program
     * @example
     * // Get one Program
     * const program = await prisma.program.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProgramFindUniqueOrThrowArgs>(args: SelectSubset<T, ProgramFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Program that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramFindFirstArgs} args - Arguments to find a Program
     * @example
     * // Get one Program
     * const program = await prisma.program.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProgramFindFirstArgs>(args?: SelectSubset<T, ProgramFindFirstArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Program that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramFindFirstOrThrowArgs} args - Arguments to find a Program
     * @example
     * // Get one Program
     * const program = await prisma.program.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProgramFindFirstOrThrowArgs>(args?: SelectSubset<T, ProgramFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Programs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Programs
     * const programs = await prisma.program.findMany()
     * 
     * // Get first 10 Programs
     * const programs = await prisma.program.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const programWithIdOnly = await prisma.program.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProgramFindManyArgs>(args?: SelectSubset<T, ProgramFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Program.
     * @param {ProgramCreateArgs} args - Arguments to create a Program.
     * @example
     * // Create one Program
     * const Program = await prisma.program.create({
     *   data: {
     *     // ... data to create a Program
     *   }
     * })
     * 
     */
    create<T extends ProgramCreateArgs>(args: SelectSubset<T, ProgramCreateArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Programs.
     * @param {ProgramCreateManyArgs} args - Arguments to create many Programs.
     * @example
     * // Create many Programs
     * const program = await prisma.program.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProgramCreateManyArgs>(args?: SelectSubset<T, ProgramCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Programs and returns the data saved in the database.
     * @param {ProgramCreateManyAndReturnArgs} args - Arguments to create many Programs.
     * @example
     * // Create many Programs
     * const program = await prisma.program.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Programs and only return the `id`
     * const programWithIdOnly = await prisma.program.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProgramCreateManyAndReturnArgs>(args?: SelectSubset<T, ProgramCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Program.
     * @param {ProgramDeleteArgs} args - Arguments to delete one Program.
     * @example
     * // Delete one Program
     * const Program = await prisma.program.delete({
     *   where: {
     *     // ... filter to delete one Program
     *   }
     * })
     * 
     */
    delete<T extends ProgramDeleteArgs>(args: SelectSubset<T, ProgramDeleteArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Program.
     * @param {ProgramUpdateArgs} args - Arguments to update one Program.
     * @example
     * // Update one Program
     * const program = await prisma.program.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProgramUpdateArgs>(args: SelectSubset<T, ProgramUpdateArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Programs.
     * @param {ProgramDeleteManyArgs} args - Arguments to filter Programs to delete.
     * @example
     * // Delete a few Programs
     * const { count } = await prisma.program.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProgramDeleteManyArgs>(args?: SelectSubset<T, ProgramDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Programs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Programs
     * const program = await prisma.program.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProgramUpdateManyArgs>(args: SelectSubset<T, ProgramUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Programs and returns the data updated in the database.
     * @param {ProgramUpdateManyAndReturnArgs} args - Arguments to update many Programs.
     * @example
     * // Update many Programs
     * const program = await prisma.program.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Programs and only return the `id`
     * const programWithIdOnly = await prisma.program.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProgramUpdateManyAndReturnArgs>(args: SelectSubset<T, ProgramUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Program.
     * @param {ProgramUpsertArgs} args - Arguments to update or create a Program.
     * @example
     * // Update or create a Program
     * const program = await prisma.program.upsert({
     *   create: {
     *     // ... data to create a Program
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Program we want to update
     *   }
     * })
     */
    upsert<T extends ProgramUpsertArgs>(args: SelectSubset<T, ProgramUpsertArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Programs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramCountArgs} args - Arguments to filter Programs to count.
     * @example
     * // Count the number of Programs
     * const count = await prisma.program.count({
     *   where: {
     *     // ... the filter for the Programs we want to count
     *   }
     * })
    **/
    count<T extends ProgramCountArgs>(
      args?: Subset<T, ProgramCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProgramCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Program.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProgramAggregateArgs>(args: Subset<T, ProgramAggregateArgs>): Prisma.PrismaPromise<GetProgramAggregateType<T>>

    /**
     * Group by Program.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProgramGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProgramGroupByArgs['orderBy'] }
        : { orderBy?: ProgramGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProgramGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProgramGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Program model
   */
  readonly fields: ProgramFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Program.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProgramClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessions<T extends Program$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, Program$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    activityLinks<T extends Program$activityLinksArgs<ExtArgs> = {}>(args?: Subset<T, Program$activityLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orderItems<T extends Program$orderItemsArgs<ExtArgs> = {}>(args?: Subset<T, Program$orderItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Program model
   */
  interface ProgramFieldRefs {
    readonly id: FieldRef<"Program", 'String'>
    readonly createdAt: FieldRef<"Program", 'DateTime'>
    readonly updatedAt: FieldRef<"Program", 'DateTime'>
    readonly title: FieldRef<"Program", 'String'>
    readonly slug: FieldRef<"Program", 'String'>
    readonly category: FieldRef<"Program", 'String'>
    readonly status: FieldRef<"Program", 'String'>
    readonly featured: FieldRef<"Program", 'Boolean'>
    readonly order: FieldRef<"Program", 'Int'>
    readonly subtitle: FieldRef<"Program", 'String'>
    readonly excerpt: FieldRef<"Program", 'String'>
    readonly description: FieldRef<"Program", 'Json'>
    readonly teamSize: FieldRef<"Program", 'Int'>
    readonly minTeamSize: FieldRef<"Program", 'Int'>
    readonly maxTeamSize: FieldRef<"Program", 'Int'>
    readonly objectives: FieldRef<"Program", 'Json'>
    readonly industryType: FieldRef<"Program", 'String'>
    readonly physicalLevel: FieldRef<"Program", 'String'>
    readonly indoorOutdoor: FieldRef<"Program", 'String'>
    readonly duration: FieldRef<"Program", 'Int'>
    readonly includesCatering: FieldRef<"Program", 'Boolean'>
    readonly debriefIncluded: FieldRef<"Program", 'Boolean'>
    readonly facilitationRequired: FieldRef<"Program", 'Boolean'>
    readonly technicalRequirements: FieldRef<"Program", 'Json'>
    readonly materialsIncluded: FieldRef<"Program", 'Json'>
    readonly venueRequirements: FieldRef<"Program", 'Json'>
    readonly price: FieldRef<"Program", 'Int'>
    readonly pricePerPerson: FieldRef<"Program", 'Int'>
    readonly pricingNotes: FieldRef<"Program", 'String'>
    readonly featuredImageUrl: FieldRef<"Program", 'String'>
    readonly featuredImageAlt: FieldRef<"Program", 'String'>
    readonly galleryImages: FieldRef<"Program", 'Json'>
    readonly videoUrl: FieldRef<"Program", 'String'>
    readonly seo: FieldRef<"Program", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Program findUnique
   */
  export type ProgramFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter, which Program to fetch.
     */
    where: ProgramWhereUniqueInput
  }

  /**
   * Program findUniqueOrThrow
   */
  export type ProgramFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter, which Program to fetch.
     */
    where: ProgramWhereUniqueInput
  }

  /**
   * Program findFirst
   */
  export type ProgramFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter, which Program to fetch.
     */
    where?: ProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programs to fetch.
     */
    orderBy?: ProgramOrderByWithRelationInput | ProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Programs.
     */
    cursor?: ProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Programs.
     */
    distinct?: ProgramScalarFieldEnum | ProgramScalarFieldEnum[]
  }

  /**
   * Program findFirstOrThrow
   */
  export type ProgramFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter, which Program to fetch.
     */
    where?: ProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programs to fetch.
     */
    orderBy?: ProgramOrderByWithRelationInput | ProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Programs.
     */
    cursor?: ProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Programs.
     */
    distinct?: ProgramScalarFieldEnum | ProgramScalarFieldEnum[]
  }

  /**
   * Program findMany
   */
  export type ProgramFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter, which Programs to fetch.
     */
    where?: ProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programs to fetch.
     */
    orderBy?: ProgramOrderByWithRelationInput | ProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Programs.
     */
    cursor?: ProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programs.
     */
    skip?: number
    distinct?: ProgramScalarFieldEnum | ProgramScalarFieldEnum[]
  }

  /**
   * Program create
   */
  export type ProgramCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * The data needed to create a Program.
     */
    data: XOR<ProgramCreateInput, ProgramUncheckedCreateInput>
  }

  /**
   * Program createMany
   */
  export type ProgramCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Programs.
     */
    data: ProgramCreateManyInput | ProgramCreateManyInput[]
  }

  /**
   * Program createManyAndReturn
   */
  export type ProgramCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * The data used to create many Programs.
     */
    data: ProgramCreateManyInput | ProgramCreateManyInput[]
  }

  /**
   * Program update
   */
  export type ProgramUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * The data needed to update a Program.
     */
    data: XOR<ProgramUpdateInput, ProgramUncheckedUpdateInput>
    /**
     * Choose, which Program to update.
     */
    where: ProgramWhereUniqueInput
  }

  /**
   * Program updateMany
   */
  export type ProgramUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Programs.
     */
    data: XOR<ProgramUpdateManyMutationInput, ProgramUncheckedUpdateManyInput>
    /**
     * Filter which Programs to update
     */
    where?: ProgramWhereInput
    /**
     * Limit how many Programs to update.
     */
    limit?: number
  }

  /**
   * Program updateManyAndReturn
   */
  export type ProgramUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * The data used to update Programs.
     */
    data: XOR<ProgramUpdateManyMutationInput, ProgramUncheckedUpdateManyInput>
    /**
     * Filter which Programs to update
     */
    where?: ProgramWhereInput
    /**
     * Limit how many Programs to update.
     */
    limit?: number
  }

  /**
   * Program upsert
   */
  export type ProgramUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * The filter to search for the Program to update in case it exists.
     */
    where: ProgramWhereUniqueInput
    /**
     * In case the Program found by the `where` argument doesn't exist, create a new Program with this data.
     */
    create: XOR<ProgramCreateInput, ProgramUncheckedCreateInput>
    /**
     * In case the Program was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProgramUpdateInput, ProgramUncheckedUpdateInput>
  }

  /**
   * Program delete
   */
  export type ProgramDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter which Program to delete.
     */
    where: ProgramWhereUniqueInput
  }

  /**
   * Program deleteMany
   */
  export type ProgramDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Programs to delete
     */
    where?: ProgramWhereInput
    /**
     * Limit how many Programs to delete.
     */
    limit?: number
  }

  /**
   * Program.sessions
   */
  export type Program$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Program.activityLinks
   */
  export type Program$activityLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramActivity
     */
    select?: ProgramActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramActivity
     */
    omit?: ProgramActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramActivityInclude<ExtArgs> | null
    where?: ProgramActivityWhereInput
    orderBy?: ProgramActivityOrderByWithRelationInput | ProgramActivityOrderByWithRelationInput[]
    cursor?: ProgramActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProgramActivityScalarFieldEnum | ProgramActivityScalarFieldEnum[]
  }

  /**
   * Program.orderItems
   */
  export type Program$orderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * Program without action
   */
  export type ProgramDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
  }


  /**
   * Model Activity
   */

  export type AggregateActivity = {
    _count: ActivityCountAggregateOutputType | null
    _avg: ActivityAvgAggregateOutputType | null
    _sum: ActivitySumAggregateOutputType | null
    _min: ActivityMinAggregateOutputType | null
    _max: ActivityMaxAggregateOutputType | null
  }

  export type ActivityAvgAggregateOutputType = {
    order: number | null
    minParticipants: number | null
    maxParticipants: number | null
    idealGroupSize: number | null
    duration: number | null
    setupTime: number | null
    price: number | null
  }

  export type ActivitySumAggregateOutputType = {
    order: number | null
    minParticipants: number | null
    maxParticipants: number | null
    idealGroupSize: number | null
    duration: number | null
    setupTime: number | null
    price: number | null
  }

  export type ActivityMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    title: string | null
    slug: string | null
    category: string | null
    status: string | null
    featured: boolean | null
    order: number | null
    subtitle: string | null
    excerpt: string | null
    minParticipants: number | null
    maxParticipants: number | null
    idealGroupSize: number | null
    physicalDemand: string | null
    indoorOutdoor: string | null
    duration: number | null
    setupTime: number | null
    difficultyLevel: string | null
    scalable: boolean | null
    canCombine: boolean | null
    price: number | null
    featuredImageUrl: string | null
    featuredImageAlt: string | null
    videoUrl: string | null
    instructionPdfUrl: string | null
  }

  export type ActivityMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    title: string | null
    slug: string | null
    category: string | null
    status: string | null
    featured: boolean | null
    order: number | null
    subtitle: string | null
    excerpt: string | null
    minParticipants: number | null
    maxParticipants: number | null
    idealGroupSize: number | null
    physicalDemand: string | null
    indoorOutdoor: string | null
    duration: number | null
    setupTime: number | null
    difficultyLevel: string | null
    scalable: boolean | null
    canCombine: boolean | null
    price: number | null
    featuredImageUrl: string | null
    featuredImageAlt: string | null
    videoUrl: string | null
    instructionPdfUrl: string | null
  }

  export type ActivityCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    title: number
    slug: number
    category: number
    status: number
    featured: number
    order: number
    subtitle: number
    excerpt: number
    description: number
    minParticipants: number
    maxParticipants: number
    idealGroupSize: number
    objectives: number
    learningOutcomes: number
    physicalDemand: number
    indoorOutdoor: number
    duration: number
    materialsNeeded: number
    setupTime: number
    facilitatorGuide: number
    difficultyLevel: number
    scalable: number
    canCombine: number
    price: number
    featuredImageUrl: number
    featuredImageAlt: number
    galleryImages: number
    videoUrl: number
    instructionPdfUrl: number
    seo: number
    _all: number
  }


  export type ActivityAvgAggregateInputType = {
    order?: true
    minParticipants?: true
    maxParticipants?: true
    idealGroupSize?: true
    duration?: true
    setupTime?: true
    price?: true
  }

  export type ActivitySumAggregateInputType = {
    order?: true
    minParticipants?: true
    maxParticipants?: true
    idealGroupSize?: true
    duration?: true
    setupTime?: true
    price?: true
  }

  export type ActivityMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    title?: true
    slug?: true
    category?: true
    status?: true
    featured?: true
    order?: true
    subtitle?: true
    excerpt?: true
    minParticipants?: true
    maxParticipants?: true
    idealGroupSize?: true
    physicalDemand?: true
    indoorOutdoor?: true
    duration?: true
    setupTime?: true
    difficultyLevel?: true
    scalable?: true
    canCombine?: true
    price?: true
    featuredImageUrl?: true
    featuredImageAlt?: true
    videoUrl?: true
    instructionPdfUrl?: true
  }

  export type ActivityMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    title?: true
    slug?: true
    category?: true
    status?: true
    featured?: true
    order?: true
    subtitle?: true
    excerpt?: true
    minParticipants?: true
    maxParticipants?: true
    idealGroupSize?: true
    physicalDemand?: true
    indoorOutdoor?: true
    duration?: true
    setupTime?: true
    difficultyLevel?: true
    scalable?: true
    canCombine?: true
    price?: true
    featuredImageUrl?: true
    featuredImageAlt?: true
    videoUrl?: true
    instructionPdfUrl?: true
  }

  export type ActivityCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    title?: true
    slug?: true
    category?: true
    status?: true
    featured?: true
    order?: true
    subtitle?: true
    excerpt?: true
    description?: true
    minParticipants?: true
    maxParticipants?: true
    idealGroupSize?: true
    objectives?: true
    learningOutcomes?: true
    physicalDemand?: true
    indoorOutdoor?: true
    duration?: true
    materialsNeeded?: true
    setupTime?: true
    facilitatorGuide?: true
    difficultyLevel?: true
    scalable?: true
    canCombine?: true
    price?: true
    featuredImageUrl?: true
    featuredImageAlt?: true
    galleryImages?: true
    videoUrl?: true
    instructionPdfUrl?: true
    seo?: true
    _all?: true
  }

  export type ActivityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Activity to aggregate.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Activities
    **/
    _count?: true | ActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActivityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActivitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityMaxAggregateInputType
  }

  export type GetActivityAggregateType<T extends ActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivity[P]>
      : GetScalarType<T[P], AggregateActivity[P]>
  }




  export type ActivityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithAggregationInput | ActivityOrderByWithAggregationInput[]
    by: ActivityScalarFieldEnum[] | ActivityScalarFieldEnum
    having?: ActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityCountAggregateInputType | true
    _avg?: ActivityAvgAggregateInputType
    _sum?: ActivitySumAggregateInputType
    _min?: ActivityMinAggregateInputType
    _max?: ActivityMaxAggregateInputType
  }

  export type ActivityGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    title: string
    slug: string
    category: string
    status: string
    featured: boolean
    order: number
    subtitle: string | null
    excerpt: string | null
    description: JsonValue | null
    minParticipants: number | null
    maxParticipants: number | null
    idealGroupSize: number | null
    objectives: JsonValue | null
    learningOutcomes: JsonValue | null
    physicalDemand: string | null
    indoorOutdoor: string | null
    duration: number
    materialsNeeded: JsonValue | null
    setupTime: number | null
    facilitatorGuide: JsonValue | null
    difficultyLevel: string | null
    scalable: boolean
    canCombine: boolean
    price: number | null
    featuredImageUrl: string | null
    featuredImageAlt: string | null
    galleryImages: JsonValue | null
    videoUrl: string | null
    instructionPdfUrl: string | null
    seo: JsonValue | null
    _count: ActivityCountAggregateOutputType | null
    _avg: ActivityAvgAggregateOutputType | null
    _sum: ActivitySumAggregateOutputType | null
    _min: ActivityMinAggregateOutputType | null
    _max: ActivityMaxAggregateOutputType | null
  }

  type GetActivityGroupByPayload<T extends ActivityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityGroupByOutputType[P]>
        }
      >
    >


  export type ActivitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    title?: boolean
    slug?: boolean
    category?: boolean
    status?: boolean
    featured?: boolean
    order?: boolean
    subtitle?: boolean
    excerpt?: boolean
    description?: boolean
    minParticipants?: boolean
    maxParticipants?: boolean
    idealGroupSize?: boolean
    objectives?: boolean
    learningOutcomes?: boolean
    physicalDemand?: boolean
    indoorOutdoor?: boolean
    duration?: boolean
    materialsNeeded?: boolean
    setupTime?: boolean
    facilitatorGuide?: boolean
    difficultyLevel?: boolean
    scalable?: boolean
    canCombine?: boolean
    price?: boolean
    featuredImageUrl?: boolean
    featuredImageAlt?: boolean
    galleryImages?: boolean
    videoUrl?: boolean
    instructionPdfUrl?: boolean
    seo?: boolean
    programLinks?: boolean | Activity$programLinksArgs<ExtArgs>
    orderItems?: boolean | Activity$orderItemsArgs<ExtArgs>
    _count?: boolean | ActivityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    title?: boolean
    slug?: boolean
    category?: boolean
    status?: boolean
    featured?: boolean
    order?: boolean
    subtitle?: boolean
    excerpt?: boolean
    description?: boolean
    minParticipants?: boolean
    maxParticipants?: boolean
    idealGroupSize?: boolean
    objectives?: boolean
    learningOutcomes?: boolean
    physicalDemand?: boolean
    indoorOutdoor?: boolean
    duration?: boolean
    materialsNeeded?: boolean
    setupTime?: boolean
    facilitatorGuide?: boolean
    difficultyLevel?: boolean
    scalable?: boolean
    canCombine?: boolean
    price?: boolean
    featuredImageUrl?: boolean
    featuredImageAlt?: boolean
    galleryImages?: boolean
    videoUrl?: boolean
    instructionPdfUrl?: boolean
    seo?: boolean
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    title?: boolean
    slug?: boolean
    category?: boolean
    status?: boolean
    featured?: boolean
    order?: boolean
    subtitle?: boolean
    excerpt?: boolean
    description?: boolean
    minParticipants?: boolean
    maxParticipants?: boolean
    idealGroupSize?: boolean
    objectives?: boolean
    learningOutcomes?: boolean
    physicalDemand?: boolean
    indoorOutdoor?: boolean
    duration?: boolean
    materialsNeeded?: boolean
    setupTime?: boolean
    facilitatorGuide?: boolean
    difficultyLevel?: boolean
    scalable?: boolean
    canCombine?: boolean
    price?: boolean
    featuredImageUrl?: boolean
    featuredImageAlt?: boolean
    galleryImages?: boolean
    videoUrl?: boolean
    instructionPdfUrl?: boolean
    seo?: boolean
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    title?: boolean
    slug?: boolean
    category?: boolean
    status?: boolean
    featured?: boolean
    order?: boolean
    subtitle?: boolean
    excerpt?: boolean
    description?: boolean
    minParticipants?: boolean
    maxParticipants?: boolean
    idealGroupSize?: boolean
    objectives?: boolean
    learningOutcomes?: boolean
    physicalDemand?: boolean
    indoorOutdoor?: boolean
    duration?: boolean
    materialsNeeded?: boolean
    setupTime?: boolean
    facilitatorGuide?: boolean
    difficultyLevel?: boolean
    scalable?: boolean
    canCombine?: boolean
    price?: boolean
    featuredImageUrl?: boolean
    featuredImageAlt?: boolean
    galleryImages?: boolean
    videoUrl?: boolean
    instructionPdfUrl?: boolean
    seo?: boolean
  }

  export type ActivityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "title" | "slug" | "category" | "status" | "featured" | "order" | "subtitle" | "excerpt" | "description" | "minParticipants" | "maxParticipants" | "idealGroupSize" | "objectives" | "learningOutcomes" | "physicalDemand" | "indoorOutdoor" | "duration" | "materialsNeeded" | "setupTime" | "facilitatorGuide" | "difficultyLevel" | "scalable" | "canCombine" | "price" | "featuredImageUrl" | "featuredImageAlt" | "galleryImages" | "videoUrl" | "instructionPdfUrl" | "seo", ExtArgs["result"]["activity"]>
  export type ActivityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    programLinks?: boolean | Activity$programLinksArgs<ExtArgs>
    orderItems?: boolean | Activity$orderItemsArgs<ExtArgs>
    _count?: boolean | ActivityCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ActivityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ActivityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ActivityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Activity"
    objects: {
      programLinks: Prisma.$ProgramActivityPayload<ExtArgs>[]
      orderItems: Prisma.$OrderItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      title: string
      slug: string
      category: string
      status: string
      featured: boolean
      order: number
      subtitle: string | null
      excerpt: string | null
      description: Prisma.JsonValue | null
      minParticipants: number | null
      maxParticipants: number | null
      idealGroupSize: number | null
      objectives: Prisma.JsonValue | null
      learningOutcomes: Prisma.JsonValue | null
      physicalDemand: string | null
      indoorOutdoor: string | null
      duration: number
      materialsNeeded: Prisma.JsonValue | null
      setupTime: number | null
      facilitatorGuide: Prisma.JsonValue | null
      difficultyLevel: string | null
      scalable: boolean
      canCombine: boolean
      price: number | null
      featuredImageUrl: string | null
      featuredImageAlt: string | null
      galleryImages: Prisma.JsonValue | null
      videoUrl: string | null
      instructionPdfUrl: string | null
      seo: Prisma.JsonValue | null
    }, ExtArgs["result"]["activity"]>
    composites: {}
  }

  type ActivityGetPayload<S extends boolean | null | undefined | ActivityDefaultArgs> = $Result.GetResult<Prisma.$ActivityPayload, S>

  type ActivityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActivityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActivityCountAggregateInputType | true
    }

  export interface ActivityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Activity'], meta: { name: 'Activity' } }
    /**
     * Find zero or one Activity that matches the filter.
     * @param {ActivityFindUniqueArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityFindUniqueArgs>(args: SelectSubset<T, ActivityFindUniqueArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Activity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActivityFindUniqueOrThrowArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Activity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindFirstArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityFindFirstArgs>(args?: SelectSubset<T, ActivityFindFirstArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Activity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindFirstOrThrowArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Activities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Activities
     * const activities = await prisma.activity.findMany()
     * 
     * // Get first 10 Activities
     * const activities = await prisma.activity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityWithIdOnly = await prisma.activity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivityFindManyArgs>(args?: SelectSubset<T, ActivityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Activity.
     * @param {ActivityCreateArgs} args - Arguments to create a Activity.
     * @example
     * // Create one Activity
     * const Activity = await prisma.activity.create({
     *   data: {
     *     // ... data to create a Activity
     *   }
     * })
     * 
     */
    create<T extends ActivityCreateArgs>(args: SelectSubset<T, ActivityCreateArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Activities.
     * @param {ActivityCreateManyArgs} args - Arguments to create many Activities.
     * @example
     * // Create many Activities
     * const activity = await prisma.activity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityCreateManyArgs>(args?: SelectSubset<T, ActivityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Activities and returns the data saved in the database.
     * @param {ActivityCreateManyAndReturnArgs} args - Arguments to create many Activities.
     * @example
     * // Create many Activities
     * const activity = await prisma.activity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Activities and only return the `id`
     * const activityWithIdOnly = await prisma.activity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivityCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Activity.
     * @param {ActivityDeleteArgs} args - Arguments to delete one Activity.
     * @example
     * // Delete one Activity
     * const Activity = await prisma.activity.delete({
     *   where: {
     *     // ... filter to delete one Activity
     *   }
     * })
     * 
     */
    delete<T extends ActivityDeleteArgs>(args: SelectSubset<T, ActivityDeleteArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Activity.
     * @param {ActivityUpdateArgs} args - Arguments to update one Activity.
     * @example
     * // Update one Activity
     * const activity = await prisma.activity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityUpdateArgs>(args: SelectSubset<T, ActivityUpdateArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Activities.
     * @param {ActivityDeleteManyArgs} args - Arguments to filter Activities to delete.
     * @example
     * // Delete a few Activities
     * const { count } = await prisma.activity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityDeleteManyArgs>(args?: SelectSubset<T, ActivityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Activities
     * const activity = await prisma.activity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityUpdateManyArgs>(args: SelectSubset<T, ActivityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Activities and returns the data updated in the database.
     * @param {ActivityUpdateManyAndReturnArgs} args - Arguments to update many Activities.
     * @example
     * // Update many Activities
     * const activity = await prisma.activity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Activities and only return the `id`
     * const activityWithIdOnly = await prisma.activity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ActivityUpdateManyAndReturnArgs>(args: SelectSubset<T, ActivityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Activity.
     * @param {ActivityUpsertArgs} args - Arguments to update or create a Activity.
     * @example
     * // Update or create a Activity
     * const activity = await prisma.activity.upsert({
     *   create: {
     *     // ... data to create a Activity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Activity we want to update
     *   }
     * })
     */
    upsert<T extends ActivityUpsertArgs>(args: SelectSubset<T, ActivityUpsertArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityCountArgs} args - Arguments to filter Activities to count.
     * @example
     * // Count the number of Activities
     * const count = await prisma.activity.count({
     *   where: {
     *     // ... the filter for the Activities we want to count
     *   }
     * })
    **/
    count<T extends ActivityCountArgs>(
      args?: Subset<T, ActivityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityAggregateArgs>(args: Subset<T, ActivityAggregateArgs>): Prisma.PrismaPromise<GetActivityAggregateType<T>>

    /**
     * Group by Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityGroupByArgs['orderBy'] }
        : { orderBy?: ActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Activity model
   */
  readonly fields: ActivityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Activity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    programLinks<T extends Activity$programLinksArgs<ExtArgs> = {}>(args?: Subset<T, Activity$programLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orderItems<T extends Activity$orderItemsArgs<ExtArgs> = {}>(args?: Subset<T, Activity$orderItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Activity model
   */
  interface ActivityFieldRefs {
    readonly id: FieldRef<"Activity", 'String'>
    readonly createdAt: FieldRef<"Activity", 'DateTime'>
    readonly updatedAt: FieldRef<"Activity", 'DateTime'>
    readonly title: FieldRef<"Activity", 'String'>
    readonly slug: FieldRef<"Activity", 'String'>
    readonly category: FieldRef<"Activity", 'String'>
    readonly status: FieldRef<"Activity", 'String'>
    readonly featured: FieldRef<"Activity", 'Boolean'>
    readonly order: FieldRef<"Activity", 'Int'>
    readonly subtitle: FieldRef<"Activity", 'String'>
    readonly excerpt: FieldRef<"Activity", 'String'>
    readonly description: FieldRef<"Activity", 'Json'>
    readonly minParticipants: FieldRef<"Activity", 'Int'>
    readonly maxParticipants: FieldRef<"Activity", 'Int'>
    readonly idealGroupSize: FieldRef<"Activity", 'Int'>
    readonly objectives: FieldRef<"Activity", 'Json'>
    readonly learningOutcomes: FieldRef<"Activity", 'Json'>
    readonly physicalDemand: FieldRef<"Activity", 'String'>
    readonly indoorOutdoor: FieldRef<"Activity", 'String'>
    readonly duration: FieldRef<"Activity", 'Int'>
    readonly materialsNeeded: FieldRef<"Activity", 'Json'>
    readonly setupTime: FieldRef<"Activity", 'Int'>
    readonly facilitatorGuide: FieldRef<"Activity", 'Json'>
    readonly difficultyLevel: FieldRef<"Activity", 'String'>
    readonly scalable: FieldRef<"Activity", 'Boolean'>
    readonly canCombine: FieldRef<"Activity", 'Boolean'>
    readonly price: FieldRef<"Activity", 'Int'>
    readonly featuredImageUrl: FieldRef<"Activity", 'String'>
    readonly featuredImageAlt: FieldRef<"Activity", 'String'>
    readonly galleryImages: FieldRef<"Activity", 'Json'>
    readonly videoUrl: FieldRef<"Activity", 'String'>
    readonly instructionPdfUrl: FieldRef<"Activity", 'String'>
    readonly seo: FieldRef<"Activity", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Activity findUnique
   */
  export type ActivityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity findUniqueOrThrow
   */
  export type ActivityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity findFirst
   */
  export type ActivityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Activities.
     */
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity findFirstOrThrow
   */
  export type ActivityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Activities.
     */
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity findMany
   */
  export type ActivityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activities to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity create
   */
  export type ActivityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The data needed to create a Activity.
     */
    data: XOR<ActivityCreateInput, ActivityUncheckedCreateInput>
  }

  /**
   * Activity createMany
   */
  export type ActivityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Activities.
     */
    data: ActivityCreateManyInput | ActivityCreateManyInput[]
  }

  /**
   * Activity createManyAndReturn
   */
  export type ActivityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * The data used to create many Activities.
     */
    data: ActivityCreateManyInput | ActivityCreateManyInput[]
  }

  /**
   * Activity update
   */
  export type ActivityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The data needed to update a Activity.
     */
    data: XOR<ActivityUpdateInput, ActivityUncheckedUpdateInput>
    /**
     * Choose, which Activity to update.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity updateMany
   */
  export type ActivityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Activities.
     */
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyInput>
    /**
     * Filter which Activities to update
     */
    where?: ActivityWhereInput
    /**
     * Limit how many Activities to update.
     */
    limit?: number
  }

  /**
   * Activity updateManyAndReturn
   */
  export type ActivityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * The data used to update Activities.
     */
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyInput>
    /**
     * Filter which Activities to update
     */
    where?: ActivityWhereInput
    /**
     * Limit how many Activities to update.
     */
    limit?: number
  }

  /**
   * Activity upsert
   */
  export type ActivityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The filter to search for the Activity to update in case it exists.
     */
    where: ActivityWhereUniqueInput
    /**
     * In case the Activity found by the `where` argument doesn't exist, create a new Activity with this data.
     */
    create: XOR<ActivityCreateInput, ActivityUncheckedCreateInput>
    /**
     * In case the Activity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityUpdateInput, ActivityUncheckedUpdateInput>
  }

  /**
   * Activity delete
   */
  export type ActivityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter which Activity to delete.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity deleteMany
   */
  export type ActivityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Activities to delete
     */
    where?: ActivityWhereInput
    /**
     * Limit how many Activities to delete.
     */
    limit?: number
  }

  /**
   * Activity.programLinks
   */
  export type Activity$programLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramActivity
     */
    select?: ProgramActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramActivity
     */
    omit?: ProgramActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramActivityInclude<ExtArgs> | null
    where?: ProgramActivityWhereInput
    orderBy?: ProgramActivityOrderByWithRelationInput | ProgramActivityOrderByWithRelationInput[]
    cursor?: ProgramActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProgramActivityScalarFieldEnum | ProgramActivityScalarFieldEnum[]
  }

  /**
   * Activity.orderItems
   */
  export type Activity$orderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * Activity without action
   */
  export type ActivityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
  }


  /**
   * Model ProgramActivity
   */

  export type AggregateProgramActivity = {
    _count: ProgramActivityCountAggregateOutputType | null
    _avg: ProgramActivityAvgAggregateOutputType | null
    _sum: ProgramActivitySumAggregateOutputType | null
    _min: ProgramActivityMinAggregateOutputType | null
    _max: ProgramActivityMaxAggregateOutputType | null
  }

  export type ProgramActivityAvgAggregateOutputType = {
    order: number | null
    duration: number | null
  }

  export type ProgramActivitySumAggregateOutputType = {
    order: number | null
    duration: number | null
  }

  export type ProgramActivityMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    programId: string | null
    activityId: string | null
    order: number | null
    duration: number | null
    notes: string | null
  }

  export type ProgramActivityMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    programId: string | null
    activityId: string | null
    order: number | null
    duration: number | null
    notes: string | null
  }

  export type ProgramActivityCountAggregateOutputType = {
    id: number
    createdAt: number
    programId: number
    activityId: number
    order: number
    duration: number
    notes: number
    _all: number
  }


  export type ProgramActivityAvgAggregateInputType = {
    order?: true
    duration?: true
  }

  export type ProgramActivitySumAggregateInputType = {
    order?: true
    duration?: true
  }

  export type ProgramActivityMinAggregateInputType = {
    id?: true
    createdAt?: true
    programId?: true
    activityId?: true
    order?: true
    duration?: true
    notes?: true
  }

  export type ProgramActivityMaxAggregateInputType = {
    id?: true
    createdAt?: true
    programId?: true
    activityId?: true
    order?: true
    duration?: true
    notes?: true
  }

  export type ProgramActivityCountAggregateInputType = {
    id?: true
    createdAt?: true
    programId?: true
    activityId?: true
    order?: true
    duration?: true
    notes?: true
    _all?: true
  }

  export type ProgramActivityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProgramActivity to aggregate.
     */
    where?: ProgramActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramActivities to fetch.
     */
    orderBy?: ProgramActivityOrderByWithRelationInput | ProgramActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProgramActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProgramActivities
    **/
    _count?: true | ProgramActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProgramActivityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProgramActivitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProgramActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProgramActivityMaxAggregateInputType
  }

  export type GetProgramActivityAggregateType<T extends ProgramActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateProgramActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProgramActivity[P]>
      : GetScalarType<T[P], AggregateProgramActivity[P]>
  }




  export type ProgramActivityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramActivityWhereInput
    orderBy?: ProgramActivityOrderByWithAggregationInput | ProgramActivityOrderByWithAggregationInput[]
    by: ProgramActivityScalarFieldEnum[] | ProgramActivityScalarFieldEnum
    having?: ProgramActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProgramActivityCountAggregateInputType | true
    _avg?: ProgramActivityAvgAggregateInputType
    _sum?: ProgramActivitySumAggregateInputType
    _min?: ProgramActivityMinAggregateInputType
    _max?: ProgramActivityMaxAggregateInputType
  }

  export type ProgramActivityGroupByOutputType = {
    id: string
    createdAt: Date
    programId: string
    activityId: string
    order: number
    duration: number | null
    notes: string | null
    _count: ProgramActivityCountAggregateOutputType | null
    _avg: ProgramActivityAvgAggregateOutputType | null
    _sum: ProgramActivitySumAggregateOutputType | null
    _min: ProgramActivityMinAggregateOutputType | null
    _max: ProgramActivityMaxAggregateOutputType | null
  }

  type GetProgramActivityGroupByPayload<T extends ProgramActivityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProgramActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProgramActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProgramActivityGroupByOutputType[P]>
            : GetScalarType<T[P], ProgramActivityGroupByOutputType[P]>
        }
      >
    >


  export type ProgramActivitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    programId?: boolean
    activityId?: boolean
    order?: boolean
    duration?: boolean
    notes?: boolean
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    activity?: boolean | ActivityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["programActivity"]>

  export type ProgramActivitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    programId?: boolean
    activityId?: boolean
    order?: boolean
    duration?: boolean
    notes?: boolean
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    activity?: boolean | ActivityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["programActivity"]>

  export type ProgramActivitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    programId?: boolean
    activityId?: boolean
    order?: boolean
    duration?: boolean
    notes?: boolean
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    activity?: boolean | ActivityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["programActivity"]>

  export type ProgramActivitySelectScalar = {
    id?: boolean
    createdAt?: boolean
    programId?: boolean
    activityId?: boolean
    order?: boolean
    duration?: boolean
    notes?: boolean
  }

  export type ProgramActivityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "programId" | "activityId" | "order" | "duration" | "notes", ExtArgs["result"]["programActivity"]>
  export type ProgramActivityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    activity?: boolean | ActivityDefaultArgs<ExtArgs>
  }
  export type ProgramActivityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    activity?: boolean | ActivityDefaultArgs<ExtArgs>
  }
  export type ProgramActivityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    activity?: boolean | ActivityDefaultArgs<ExtArgs>
  }

  export type $ProgramActivityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProgramActivity"
    objects: {
      program: Prisma.$ProgramPayload<ExtArgs>
      activity: Prisma.$ActivityPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      programId: string
      activityId: string
      order: number
      duration: number | null
      notes: string | null
    }, ExtArgs["result"]["programActivity"]>
    composites: {}
  }

  type ProgramActivityGetPayload<S extends boolean | null | undefined | ProgramActivityDefaultArgs> = $Result.GetResult<Prisma.$ProgramActivityPayload, S>

  type ProgramActivityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProgramActivityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProgramActivityCountAggregateInputType | true
    }

  export interface ProgramActivityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProgramActivity'], meta: { name: 'ProgramActivity' } }
    /**
     * Find zero or one ProgramActivity that matches the filter.
     * @param {ProgramActivityFindUniqueArgs} args - Arguments to find a ProgramActivity
     * @example
     * // Get one ProgramActivity
     * const programActivity = await prisma.programActivity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProgramActivityFindUniqueArgs>(args: SelectSubset<T, ProgramActivityFindUniqueArgs<ExtArgs>>): Prisma__ProgramActivityClient<$Result.GetResult<Prisma.$ProgramActivityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProgramActivity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProgramActivityFindUniqueOrThrowArgs} args - Arguments to find a ProgramActivity
     * @example
     * // Get one ProgramActivity
     * const programActivity = await prisma.programActivity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProgramActivityFindUniqueOrThrowArgs>(args: SelectSubset<T, ProgramActivityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProgramActivityClient<$Result.GetResult<Prisma.$ProgramActivityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProgramActivity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramActivityFindFirstArgs} args - Arguments to find a ProgramActivity
     * @example
     * // Get one ProgramActivity
     * const programActivity = await prisma.programActivity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProgramActivityFindFirstArgs>(args?: SelectSubset<T, ProgramActivityFindFirstArgs<ExtArgs>>): Prisma__ProgramActivityClient<$Result.GetResult<Prisma.$ProgramActivityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProgramActivity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramActivityFindFirstOrThrowArgs} args - Arguments to find a ProgramActivity
     * @example
     * // Get one ProgramActivity
     * const programActivity = await prisma.programActivity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProgramActivityFindFirstOrThrowArgs>(args?: SelectSubset<T, ProgramActivityFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProgramActivityClient<$Result.GetResult<Prisma.$ProgramActivityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProgramActivities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramActivityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProgramActivities
     * const programActivities = await prisma.programActivity.findMany()
     * 
     * // Get first 10 ProgramActivities
     * const programActivities = await prisma.programActivity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const programActivityWithIdOnly = await prisma.programActivity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProgramActivityFindManyArgs>(args?: SelectSubset<T, ProgramActivityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProgramActivity.
     * @param {ProgramActivityCreateArgs} args - Arguments to create a ProgramActivity.
     * @example
     * // Create one ProgramActivity
     * const ProgramActivity = await prisma.programActivity.create({
     *   data: {
     *     // ... data to create a ProgramActivity
     *   }
     * })
     * 
     */
    create<T extends ProgramActivityCreateArgs>(args: SelectSubset<T, ProgramActivityCreateArgs<ExtArgs>>): Prisma__ProgramActivityClient<$Result.GetResult<Prisma.$ProgramActivityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProgramActivities.
     * @param {ProgramActivityCreateManyArgs} args - Arguments to create many ProgramActivities.
     * @example
     * // Create many ProgramActivities
     * const programActivity = await prisma.programActivity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProgramActivityCreateManyArgs>(args?: SelectSubset<T, ProgramActivityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProgramActivities and returns the data saved in the database.
     * @param {ProgramActivityCreateManyAndReturnArgs} args - Arguments to create many ProgramActivities.
     * @example
     * // Create many ProgramActivities
     * const programActivity = await prisma.programActivity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProgramActivities and only return the `id`
     * const programActivityWithIdOnly = await prisma.programActivity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProgramActivityCreateManyAndReturnArgs>(args?: SelectSubset<T, ProgramActivityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramActivityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProgramActivity.
     * @param {ProgramActivityDeleteArgs} args - Arguments to delete one ProgramActivity.
     * @example
     * // Delete one ProgramActivity
     * const ProgramActivity = await prisma.programActivity.delete({
     *   where: {
     *     // ... filter to delete one ProgramActivity
     *   }
     * })
     * 
     */
    delete<T extends ProgramActivityDeleteArgs>(args: SelectSubset<T, ProgramActivityDeleteArgs<ExtArgs>>): Prisma__ProgramActivityClient<$Result.GetResult<Prisma.$ProgramActivityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProgramActivity.
     * @param {ProgramActivityUpdateArgs} args - Arguments to update one ProgramActivity.
     * @example
     * // Update one ProgramActivity
     * const programActivity = await prisma.programActivity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProgramActivityUpdateArgs>(args: SelectSubset<T, ProgramActivityUpdateArgs<ExtArgs>>): Prisma__ProgramActivityClient<$Result.GetResult<Prisma.$ProgramActivityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProgramActivities.
     * @param {ProgramActivityDeleteManyArgs} args - Arguments to filter ProgramActivities to delete.
     * @example
     * // Delete a few ProgramActivities
     * const { count } = await prisma.programActivity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProgramActivityDeleteManyArgs>(args?: SelectSubset<T, ProgramActivityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProgramActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProgramActivities
     * const programActivity = await prisma.programActivity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProgramActivityUpdateManyArgs>(args: SelectSubset<T, ProgramActivityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProgramActivities and returns the data updated in the database.
     * @param {ProgramActivityUpdateManyAndReturnArgs} args - Arguments to update many ProgramActivities.
     * @example
     * // Update many ProgramActivities
     * const programActivity = await prisma.programActivity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProgramActivities and only return the `id`
     * const programActivityWithIdOnly = await prisma.programActivity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProgramActivityUpdateManyAndReturnArgs>(args: SelectSubset<T, ProgramActivityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramActivityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProgramActivity.
     * @param {ProgramActivityUpsertArgs} args - Arguments to update or create a ProgramActivity.
     * @example
     * // Update or create a ProgramActivity
     * const programActivity = await prisma.programActivity.upsert({
     *   create: {
     *     // ... data to create a ProgramActivity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProgramActivity we want to update
     *   }
     * })
     */
    upsert<T extends ProgramActivityUpsertArgs>(args: SelectSubset<T, ProgramActivityUpsertArgs<ExtArgs>>): Prisma__ProgramActivityClient<$Result.GetResult<Prisma.$ProgramActivityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProgramActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramActivityCountArgs} args - Arguments to filter ProgramActivities to count.
     * @example
     * // Count the number of ProgramActivities
     * const count = await prisma.programActivity.count({
     *   where: {
     *     // ... the filter for the ProgramActivities we want to count
     *   }
     * })
    **/
    count<T extends ProgramActivityCountArgs>(
      args?: Subset<T, ProgramActivityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProgramActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProgramActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProgramActivityAggregateArgs>(args: Subset<T, ProgramActivityAggregateArgs>): Prisma.PrismaPromise<GetProgramActivityAggregateType<T>>

    /**
     * Group by ProgramActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProgramActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProgramActivityGroupByArgs['orderBy'] }
        : { orderBy?: ProgramActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProgramActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProgramActivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProgramActivity model
   */
  readonly fields: ProgramActivityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProgramActivity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProgramActivityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    program<T extends ProgramDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProgramDefaultArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    activity<T extends ActivityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ActivityDefaultArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProgramActivity model
   */
  interface ProgramActivityFieldRefs {
    readonly id: FieldRef<"ProgramActivity", 'String'>
    readonly createdAt: FieldRef<"ProgramActivity", 'DateTime'>
    readonly programId: FieldRef<"ProgramActivity", 'String'>
    readonly activityId: FieldRef<"ProgramActivity", 'String'>
    readonly order: FieldRef<"ProgramActivity", 'Int'>
    readonly duration: FieldRef<"ProgramActivity", 'Int'>
    readonly notes: FieldRef<"ProgramActivity", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ProgramActivity findUnique
   */
  export type ProgramActivityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramActivity
     */
    select?: ProgramActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramActivity
     */
    omit?: ProgramActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramActivityInclude<ExtArgs> | null
    /**
     * Filter, which ProgramActivity to fetch.
     */
    where: ProgramActivityWhereUniqueInput
  }

  /**
   * ProgramActivity findUniqueOrThrow
   */
  export type ProgramActivityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramActivity
     */
    select?: ProgramActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramActivity
     */
    omit?: ProgramActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramActivityInclude<ExtArgs> | null
    /**
     * Filter, which ProgramActivity to fetch.
     */
    where: ProgramActivityWhereUniqueInput
  }

  /**
   * ProgramActivity findFirst
   */
  export type ProgramActivityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramActivity
     */
    select?: ProgramActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramActivity
     */
    omit?: ProgramActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramActivityInclude<ExtArgs> | null
    /**
     * Filter, which ProgramActivity to fetch.
     */
    where?: ProgramActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramActivities to fetch.
     */
    orderBy?: ProgramActivityOrderByWithRelationInput | ProgramActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProgramActivities.
     */
    cursor?: ProgramActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProgramActivities.
     */
    distinct?: ProgramActivityScalarFieldEnum | ProgramActivityScalarFieldEnum[]
  }

  /**
   * ProgramActivity findFirstOrThrow
   */
  export type ProgramActivityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramActivity
     */
    select?: ProgramActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramActivity
     */
    omit?: ProgramActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramActivityInclude<ExtArgs> | null
    /**
     * Filter, which ProgramActivity to fetch.
     */
    where?: ProgramActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramActivities to fetch.
     */
    orderBy?: ProgramActivityOrderByWithRelationInput | ProgramActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProgramActivities.
     */
    cursor?: ProgramActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProgramActivities.
     */
    distinct?: ProgramActivityScalarFieldEnum | ProgramActivityScalarFieldEnum[]
  }

  /**
   * ProgramActivity findMany
   */
  export type ProgramActivityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramActivity
     */
    select?: ProgramActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramActivity
     */
    omit?: ProgramActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramActivityInclude<ExtArgs> | null
    /**
     * Filter, which ProgramActivities to fetch.
     */
    where?: ProgramActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramActivities to fetch.
     */
    orderBy?: ProgramActivityOrderByWithRelationInput | ProgramActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProgramActivities.
     */
    cursor?: ProgramActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramActivities.
     */
    skip?: number
    distinct?: ProgramActivityScalarFieldEnum | ProgramActivityScalarFieldEnum[]
  }

  /**
   * ProgramActivity create
   */
  export type ProgramActivityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramActivity
     */
    select?: ProgramActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramActivity
     */
    omit?: ProgramActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramActivityInclude<ExtArgs> | null
    /**
     * The data needed to create a ProgramActivity.
     */
    data: XOR<ProgramActivityCreateInput, ProgramActivityUncheckedCreateInput>
  }

  /**
   * ProgramActivity createMany
   */
  export type ProgramActivityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProgramActivities.
     */
    data: ProgramActivityCreateManyInput | ProgramActivityCreateManyInput[]
  }

  /**
   * ProgramActivity createManyAndReturn
   */
  export type ProgramActivityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramActivity
     */
    select?: ProgramActivitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramActivity
     */
    omit?: ProgramActivityOmit<ExtArgs> | null
    /**
     * The data used to create many ProgramActivities.
     */
    data: ProgramActivityCreateManyInput | ProgramActivityCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramActivityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProgramActivity update
   */
  export type ProgramActivityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramActivity
     */
    select?: ProgramActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramActivity
     */
    omit?: ProgramActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramActivityInclude<ExtArgs> | null
    /**
     * The data needed to update a ProgramActivity.
     */
    data: XOR<ProgramActivityUpdateInput, ProgramActivityUncheckedUpdateInput>
    /**
     * Choose, which ProgramActivity to update.
     */
    where: ProgramActivityWhereUniqueInput
  }

  /**
   * ProgramActivity updateMany
   */
  export type ProgramActivityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProgramActivities.
     */
    data: XOR<ProgramActivityUpdateManyMutationInput, ProgramActivityUncheckedUpdateManyInput>
    /**
     * Filter which ProgramActivities to update
     */
    where?: ProgramActivityWhereInput
    /**
     * Limit how many ProgramActivities to update.
     */
    limit?: number
  }

  /**
   * ProgramActivity updateManyAndReturn
   */
  export type ProgramActivityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramActivity
     */
    select?: ProgramActivitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramActivity
     */
    omit?: ProgramActivityOmit<ExtArgs> | null
    /**
     * The data used to update ProgramActivities.
     */
    data: XOR<ProgramActivityUpdateManyMutationInput, ProgramActivityUncheckedUpdateManyInput>
    /**
     * Filter which ProgramActivities to update
     */
    where?: ProgramActivityWhereInput
    /**
     * Limit how many ProgramActivities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramActivityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProgramActivity upsert
   */
  export type ProgramActivityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramActivity
     */
    select?: ProgramActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramActivity
     */
    omit?: ProgramActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramActivityInclude<ExtArgs> | null
    /**
     * The filter to search for the ProgramActivity to update in case it exists.
     */
    where: ProgramActivityWhereUniqueInput
    /**
     * In case the ProgramActivity found by the `where` argument doesn't exist, create a new ProgramActivity with this data.
     */
    create: XOR<ProgramActivityCreateInput, ProgramActivityUncheckedCreateInput>
    /**
     * In case the ProgramActivity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProgramActivityUpdateInput, ProgramActivityUncheckedUpdateInput>
  }

  /**
   * ProgramActivity delete
   */
  export type ProgramActivityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramActivity
     */
    select?: ProgramActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramActivity
     */
    omit?: ProgramActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramActivityInclude<ExtArgs> | null
    /**
     * Filter which ProgramActivity to delete.
     */
    where: ProgramActivityWhereUniqueInput
  }

  /**
   * ProgramActivity deleteMany
   */
  export type ProgramActivityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProgramActivities to delete
     */
    where?: ProgramActivityWhereInput
    /**
     * Limit how many ProgramActivities to delete.
     */
    limit?: number
  }

  /**
   * ProgramActivity without action
   */
  export type ProgramActivityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramActivity
     */
    select?: ProgramActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramActivity
     */
    omit?: ProgramActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramActivityInclude<ExtArgs> | null
  }


  /**
   * Model Extra
   */

  export type AggregateExtra = {
    _count: ExtraCountAggregateOutputType | null
    _avg: ExtraAvgAggregateOutputType | null
    _sum: ExtraSumAggregateOutputType | null
    _min: ExtraMinAggregateOutputType | null
    _max: ExtraMaxAggregateOutputType | null
  }

  export type ExtraAvgAggregateOutputType = {
    order: number | null
    priceFrom: number | null
  }

  export type ExtraSumAggregateOutputType = {
    order: number | null
    priceFrom: number | null
  }

  export type ExtraMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    title: string | null
    slug: string | null
    category: string | null
    status: string | null
    order: number | null
    excerpt: string | null
    priceFrom: number | null
    priceUnit: string | null
    featuredImageUrl: string | null
    featuredImageAlt: string | null
  }

  export type ExtraMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    title: string | null
    slug: string | null
    category: string | null
    status: string | null
    order: number | null
    excerpt: string | null
    priceFrom: number | null
    priceUnit: string | null
    featuredImageUrl: string | null
    featuredImageAlt: string | null
  }

  export type ExtraCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    title: number
    slug: number
    category: number
    status: number
    order: number
    excerpt: number
    description: number
    priceFrom: number
    priceUnit: number
    featuredImageUrl: number
    featuredImageAlt: number
    seo: number
    _all: number
  }


  export type ExtraAvgAggregateInputType = {
    order?: true
    priceFrom?: true
  }

  export type ExtraSumAggregateInputType = {
    order?: true
    priceFrom?: true
  }

  export type ExtraMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    title?: true
    slug?: true
    category?: true
    status?: true
    order?: true
    excerpt?: true
    priceFrom?: true
    priceUnit?: true
    featuredImageUrl?: true
    featuredImageAlt?: true
  }

  export type ExtraMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    title?: true
    slug?: true
    category?: true
    status?: true
    order?: true
    excerpt?: true
    priceFrom?: true
    priceUnit?: true
    featuredImageUrl?: true
    featuredImageAlt?: true
  }

  export type ExtraCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    title?: true
    slug?: true
    category?: true
    status?: true
    order?: true
    excerpt?: true
    description?: true
    priceFrom?: true
    priceUnit?: true
    featuredImageUrl?: true
    featuredImageAlt?: true
    seo?: true
    _all?: true
  }

  export type ExtraAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Extra to aggregate.
     */
    where?: ExtraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Extras to fetch.
     */
    orderBy?: ExtraOrderByWithRelationInput | ExtraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExtraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Extras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Extras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Extras
    **/
    _count?: true | ExtraCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExtraAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExtraSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExtraMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExtraMaxAggregateInputType
  }

  export type GetExtraAggregateType<T extends ExtraAggregateArgs> = {
        [P in keyof T & keyof AggregateExtra]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExtra[P]>
      : GetScalarType<T[P], AggregateExtra[P]>
  }




  export type ExtraGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExtraWhereInput
    orderBy?: ExtraOrderByWithAggregationInput | ExtraOrderByWithAggregationInput[]
    by: ExtraScalarFieldEnum[] | ExtraScalarFieldEnum
    having?: ExtraScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExtraCountAggregateInputType | true
    _avg?: ExtraAvgAggregateInputType
    _sum?: ExtraSumAggregateInputType
    _min?: ExtraMinAggregateInputType
    _max?: ExtraMaxAggregateInputType
  }

  export type ExtraGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    title: string
    slug: string
    category: string
    status: string
    order: number
    excerpt: string | null
    description: JsonValue | null
    priceFrom: number | null
    priceUnit: string | null
    featuredImageUrl: string | null
    featuredImageAlt: string | null
    seo: JsonValue | null
    _count: ExtraCountAggregateOutputType | null
    _avg: ExtraAvgAggregateOutputType | null
    _sum: ExtraSumAggregateOutputType | null
    _min: ExtraMinAggregateOutputType | null
    _max: ExtraMaxAggregateOutputType | null
  }

  type GetExtraGroupByPayload<T extends ExtraGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExtraGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExtraGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExtraGroupByOutputType[P]>
            : GetScalarType<T[P], ExtraGroupByOutputType[P]>
        }
      >
    >


  export type ExtraSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    title?: boolean
    slug?: boolean
    category?: boolean
    status?: boolean
    order?: boolean
    excerpt?: boolean
    description?: boolean
    priceFrom?: boolean
    priceUnit?: boolean
    featuredImageUrl?: boolean
    featuredImageAlt?: boolean
    seo?: boolean
    orderItems?: boolean | Extra$orderItemsArgs<ExtArgs>
    _count?: boolean | ExtraCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["extra"]>

  export type ExtraSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    title?: boolean
    slug?: boolean
    category?: boolean
    status?: boolean
    order?: boolean
    excerpt?: boolean
    description?: boolean
    priceFrom?: boolean
    priceUnit?: boolean
    featuredImageUrl?: boolean
    featuredImageAlt?: boolean
    seo?: boolean
  }, ExtArgs["result"]["extra"]>

  export type ExtraSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    title?: boolean
    slug?: boolean
    category?: boolean
    status?: boolean
    order?: boolean
    excerpt?: boolean
    description?: boolean
    priceFrom?: boolean
    priceUnit?: boolean
    featuredImageUrl?: boolean
    featuredImageAlt?: boolean
    seo?: boolean
  }, ExtArgs["result"]["extra"]>

  export type ExtraSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    title?: boolean
    slug?: boolean
    category?: boolean
    status?: boolean
    order?: boolean
    excerpt?: boolean
    description?: boolean
    priceFrom?: boolean
    priceUnit?: boolean
    featuredImageUrl?: boolean
    featuredImageAlt?: boolean
    seo?: boolean
  }

  export type ExtraOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "title" | "slug" | "category" | "status" | "order" | "excerpt" | "description" | "priceFrom" | "priceUnit" | "featuredImageUrl" | "featuredImageAlt" | "seo", ExtArgs["result"]["extra"]>
  export type ExtraInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderItems?: boolean | Extra$orderItemsArgs<ExtArgs>
    _count?: boolean | ExtraCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ExtraIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ExtraIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ExtraPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Extra"
    objects: {
      orderItems: Prisma.$OrderItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      title: string
      slug: string
      category: string
      status: string
      order: number
      excerpt: string | null
      description: Prisma.JsonValue | null
      priceFrom: number | null
      priceUnit: string | null
      featuredImageUrl: string | null
      featuredImageAlt: string | null
      seo: Prisma.JsonValue | null
    }, ExtArgs["result"]["extra"]>
    composites: {}
  }

  type ExtraGetPayload<S extends boolean | null | undefined | ExtraDefaultArgs> = $Result.GetResult<Prisma.$ExtraPayload, S>

  type ExtraCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExtraFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExtraCountAggregateInputType | true
    }

  export interface ExtraDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Extra'], meta: { name: 'Extra' } }
    /**
     * Find zero or one Extra that matches the filter.
     * @param {ExtraFindUniqueArgs} args - Arguments to find a Extra
     * @example
     * // Get one Extra
     * const extra = await prisma.extra.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExtraFindUniqueArgs>(args: SelectSubset<T, ExtraFindUniqueArgs<ExtArgs>>): Prisma__ExtraClient<$Result.GetResult<Prisma.$ExtraPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Extra that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExtraFindUniqueOrThrowArgs} args - Arguments to find a Extra
     * @example
     * // Get one Extra
     * const extra = await prisma.extra.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExtraFindUniqueOrThrowArgs>(args: SelectSubset<T, ExtraFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExtraClient<$Result.GetResult<Prisma.$ExtraPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Extra that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExtraFindFirstArgs} args - Arguments to find a Extra
     * @example
     * // Get one Extra
     * const extra = await prisma.extra.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExtraFindFirstArgs>(args?: SelectSubset<T, ExtraFindFirstArgs<ExtArgs>>): Prisma__ExtraClient<$Result.GetResult<Prisma.$ExtraPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Extra that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExtraFindFirstOrThrowArgs} args - Arguments to find a Extra
     * @example
     * // Get one Extra
     * const extra = await prisma.extra.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExtraFindFirstOrThrowArgs>(args?: SelectSubset<T, ExtraFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExtraClient<$Result.GetResult<Prisma.$ExtraPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Extras that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExtraFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Extras
     * const extras = await prisma.extra.findMany()
     * 
     * // Get first 10 Extras
     * const extras = await prisma.extra.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const extraWithIdOnly = await prisma.extra.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExtraFindManyArgs>(args?: SelectSubset<T, ExtraFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExtraPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Extra.
     * @param {ExtraCreateArgs} args - Arguments to create a Extra.
     * @example
     * // Create one Extra
     * const Extra = await prisma.extra.create({
     *   data: {
     *     // ... data to create a Extra
     *   }
     * })
     * 
     */
    create<T extends ExtraCreateArgs>(args: SelectSubset<T, ExtraCreateArgs<ExtArgs>>): Prisma__ExtraClient<$Result.GetResult<Prisma.$ExtraPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Extras.
     * @param {ExtraCreateManyArgs} args - Arguments to create many Extras.
     * @example
     * // Create many Extras
     * const extra = await prisma.extra.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExtraCreateManyArgs>(args?: SelectSubset<T, ExtraCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Extras and returns the data saved in the database.
     * @param {ExtraCreateManyAndReturnArgs} args - Arguments to create many Extras.
     * @example
     * // Create many Extras
     * const extra = await prisma.extra.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Extras and only return the `id`
     * const extraWithIdOnly = await prisma.extra.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExtraCreateManyAndReturnArgs>(args?: SelectSubset<T, ExtraCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExtraPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Extra.
     * @param {ExtraDeleteArgs} args - Arguments to delete one Extra.
     * @example
     * // Delete one Extra
     * const Extra = await prisma.extra.delete({
     *   where: {
     *     // ... filter to delete one Extra
     *   }
     * })
     * 
     */
    delete<T extends ExtraDeleteArgs>(args: SelectSubset<T, ExtraDeleteArgs<ExtArgs>>): Prisma__ExtraClient<$Result.GetResult<Prisma.$ExtraPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Extra.
     * @param {ExtraUpdateArgs} args - Arguments to update one Extra.
     * @example
     * // Update one Extra
     * const extra = await prisma.extra.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExtraUpdateArgs>(args: SelectSubset<T, ExtraUpdateArgs<ExtArgs>>): Prisma__ExtraClient<$Result.GetResult<Prisma.$ExtraPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Extras.
     * @param {ExtraDeleteManyArgs} args - Arguments to filter Extras to delete.
     * @example
     * // Delete a few Extras
     * const { count } = await prisma.extra.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExtraDeleteManyArgs>(args?: SelectSubset<T, ExtraDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Extras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExtraUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Extras
     * const extra = await prisma.extra.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExtraUpdateManyArgs>(args: SelectSubset<T, ExtraUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Extras and returns the data updated in the database.
     * @param {ExtraUpdateManyAndReturnArgs} args - Arguments to update many Extras.
     * @example
     * // Update many Extras
     * const extra = await prisma.extra.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Extras and only return the `id`
     * const extraWithIdOnly = await prisma.extra.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExtraUpdateManyAndReturnArgs>(args: SelectSubset<T, ExtraUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExtraPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Extra.
     * @param {ExtraUpsertArgs} args - Arguments to update or create a Extra.
     * @example
     * // Update or create a Extra
     * const extra = await prisma.extra.upsert({
     *   create: {
     *     // ... data to create a Extra
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Extra we want to update
     *   }
     * })
     */
    upsert<T extends ExtraUpsertArgs>(args: SelectSubset<T, ExtraUpsertArgs<ExtArgs>>): Prisma__ExtraClient<$Result.GetResult<Prisma.$ExtraPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Extras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExtraCountArgs} args - Arguments to filter Extras to count.
     * @example
     * // Count the number of Extras
     * const count = await prisma.extra.count({
     *   where: {
     *     // ... the filter for the Extras we want to count
     *   }
     * })
    **/
    count<T extends ExtraCountArgs>(
      args?: Subset<T, ExtraCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExtraCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Extra.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExtraAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExtraAggregateArgs>(args: Subset<T, ExtraAggregateArgs>): Prisma.PrismaPromise<GetExtraAggregateType<T>>

    /**
     * Group by Extra.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExtraGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExtraGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExtraGroupByArgs['orderBy'] }
        : { orderBy?: ExtraGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExtraGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExtraGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Extra model
   */
  readonly fields: ExtraFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Extra.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExtraClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orderItems<T extends Extra$orderItemsArgs<ExtArgs> = {}>(args?: Subset<T, Extra$orderItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Extra model
   */
  interface ExtraFieldRefs {
    readonly id: FieldRef<"Extra", 'String'>
    readonly createdAt: FieldRef<"Extra", 'DateTime'>
    readonly updatedAt: FieldRef<"Extra", 'DateTime'>
    readonly title: FieldRef<"Extra", 'String'>
    readonly slug: FieldRef<"Extra", 'String'>
    readonly category: FieldRef<"Extra", 'String'>
    readonly status: FieldRef<"Extra", 'String'>
    readonly order: FieldRef<"Extra", 'Int'>
    readonly excerpt: FieldRef<"Extra", 'String'>
    readonly description: FieldRef<"Extra", 'Json'>
    readonly priceFrom: FieldRef<"Extra", 'Int'>
    readonly priceUnit: FieldRef<"Extra", 'String'>
    readonly featuredImageUrl: FieldRef<"Extra", 'String'>
    readonly featuredImageAlt: FieldRef<"Extra", 'String'>
    readonly seo: FieldRef<"Extra", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Extra findUnique
   */
  export type ExtraFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Extra
     */
    select?: ExtraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Extra
     */
    omit?: ExtraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtraInclude<ExtArgs> | null
    /**
     * Filter, which Extra to fetch.
     */
    where: ExtraWhereUniqueInput
  }

  /**
   * Extra findUniqueOrThrow
   */
  export type ExtraFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Extra
     */
    select?: ExtraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Extra
     */
    omit?: ExtraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtraInclude<ExtArgs> | null
    /**
     * Filter, which Extra to fetch.
     */
    where: ExtraWhereUniqueInput
  }

  /**
   * Extra findFirst
   */
  export type ExtraFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Extra
     */
    select?: ExtraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Extra
     */
    omit?: ExtraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtraInclude<ExtArgs> | null
    /**
     * Filter, which Extra to fetch.
     */
    where?: ExtraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Extras to fetch.
     */
    orderBy?: ExtraOrderByWithRelationInput | ExtraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Extras.
     */
    cursor?: ExtraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Extras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Extras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Extras.
     */
    distinct?: ExtraScalarFieldEnum | ExtraScalarFieldEnum[]
  }

  /**
   * Extra findFirstOrThrow
   */
  export type ExtraFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Extra
     */
    select?: ExtraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Extra
     */
    omit?: ExtraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtraInclude<ExtArgs> | null
    /**
     * Filter, which Extra to fetch.
     */
    where?: ExtraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Extras to fetch.
     */
    orderBy?: ExtraOrderByWithRelationInput | ExtraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Extras.
     */
    cursor?: ExtraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Extras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Extras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Extras.
     */
    distinct?: ExtraScalarFieldEnum | ExtraScalarFieldEnum[]
  }

  /**
   * Extra findMany
   */
  export type ExtraFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Extra
     */
    select?: ExtraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Extra
     */
    omit?: ExtraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtraInclude<ExtArgs> | null
    /**
     * Filter, which Extras to fetch.
     */
    where?: ExtraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Extras to fetch.
     */
    orderBy?: ExtraOrderByWithRelationInput | ExtraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Extras.
     */
    cursor?: ExtraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Extras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Extras.
     */
    skip?: number
    distinct?: ExtraScalarFieldEnum | ExtraScalarFieldEnum[]
  }

  /**
   * Extra create
   */
  export type ExtraCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Extra
     */
    select?: ExtraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Extra
     */
    omit?: ExtraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtraInclude<ExtArgs> | null
    /**
     * The data needed to create a Extra.
     */
    data: XOR<ExtraCreateInput, ExtraUncheckedCreateInput>
  }

  /**
   * Extra createMany
   */
  export type ExtraCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Extras.
     */
    data: ExtraCreateManyInput | ExtraCreateManyInput[]
  }

  /**
   * Extra createManyAndReturn
   */
  export type ExtraCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Extra
     */
    select?: ExtraSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Extra
     */
    omit?: ExtraOmit<ExtArgs> | null
    /**
     * The data used to create many Extras.
     */
    data: ExtraCreateManyInput | ExtraCreateManyInput[]
  }

  /**
   * Extra update
   */
  export type ExtraUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Extra
     */
    select?: ExtraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Extra
     */
    omit?: ExtraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtraInclude<ExtArgs> | null
    /**
     * The data needed to update a Extra.
     */
    data: XOR<ExtraUpdateInput, ExtraUncheckedUpdateInput>
    /**
     * Choose, which Extra to update.
     */
    where: ExtraWhereUniqueInput
  }

  /**
   * Extra updateMany
   */
  export type ExtraUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Extras.
     */
    data: XOR<ExtraUpdateManyMutationInput, ExtraUncheckedUpdateManyInput>
    /**
     * Filter which Extras to update
     */
    where?: ExtraWhereInput
    /**
     * Limit how many Extras to update.
     */
    limit?: number
  }

  /**
   * Extra updateManyAndReturn
   */
  export type ExtraUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Extra
     */
    select?: ExtraSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Extra
     */
    omit?: ExtraOmit<ExtArgs> | null
    /**
     * The data used to update Extras.
     */
    data: XOR<ExtraUpdateManyMutationInput, ExtraUncheckedUpdateManyInput>
    /**
     * Filter which Extras to update
     */
    where?: ExtraWhereInput
    /**
     * Limit how many Extras to update.
     */
    limit?: number
  }

  /**
   * Extra upsert
   */
  export type ExtraUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Extra
     */
    select?: ExtraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Extra
     */
    omit?: ExtraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtraInclude<ExtArgs> | null
    /**
     * The filter to search for the Extra to update in case it exists.
     */
    where: ExtraWhereUniqueInput
    /**
     * In case the Extra found by the `where` argument doesn't exist, create a new Extra with this data.
     */
    create: XOR<ExtraCreateInput, ExtraUncheckedCreateInput>
    /**
     * In case the Extra was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExtraUpdateInput, ExtraUncheckedUpdateInput>
  }

  /**
   * Extra delete
   */
  export type ExtraDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Extra
     */
    select?: ExtraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Extra
     */
    omit?: ExtraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtraInclude<ExtArgs> | null
    /**
     * Filter which Extra to delete.
     */
    where: ExtraWhereUniqueInput
  }

  /**
   * Extra deleteMany
   */
  export type ExtraDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Extras to delete
     */
    where?: ExtraWhereInput
    /**
     * Limit how many Extras to delete.
     */
    limit?: number
  }

  /**
   * Extra.orderItems
   */
  export type Extra$orderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * Extra without action
   */
  export type ExtraDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Extra
     */
    select?: ExtraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Extra
     */
    omit?: ExtraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtraInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _avg: SessionAvgAggregateOutputType | null
    _sum: SessionSumAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionAvgAggregateOutputType = {
    teamSize: number | null
  }

  export type SessionSumAggregateOutputType = {
    teamSize: number | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    programId: string | null
    date: Date | null
    endDate: Date | null
    teamSize: number | null
    teamName: string | null
    companyName: string | null
    industryType: string | null
    customObjectives: string | null
    status: string | null
    isPublic: boolean | null
    debriefCompleted: boolean | null
    debriefGeneratedAt: Date | null
    notes: string | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    programId: string | null
    date: Date | null
    endDate: Date | null
    teamSize: number | null
    teamName: string | null
    companyName: string | null
    industryType: string | null
    customObjectives: string | null
    status: string | null
    isPublic: boolean | null
    debriefCompleted: boolean | null
    debriefGeneratedAt: Date | null
    notes: string | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    programId: number
    date: number
    endDate: number
    venue: number
    teamSize: number
    teamName: number
    companyName: number
    industryType: number
    objectives: number
    customObjectives: number
    status: number
    isPublic: number
    debriefCompleted: number
    debriefReport: number
    debriefGeneratedAt: number
    notes: number
    _all: number
  }


  export type SessionAvgAggregateInputType = {
    teamSize?: true
  }

  export type SessionSumAggregateInputType = {
    teamSize?: true
  }

  export type SessionMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    programId?: true
    date?: true
    endDate?: true
    teamSize?: true
    teamName?: true
    companyName?: true
    industryType?: true
    customObjectives?: true
    status?: true
    isPublic?: true
    debriefCompleted?: true
    debriefGeneratedAt?: true
    notes?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    programId?: true
    date?: true
    endDate?: true
    teamSize?: true
    teamName?: true
    companyName?: true
    industryType?: true
    customObjectives?: true
    status?: true
    isPublic?: true
    debriefCompleted?: true
    debriefGeneratedAt?: true
    notes?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    programId?: true
    date?: true
    endDate?: true
    venue?: true
    teamSize?: true
    teamName?: true
    companyName?: true
    industryType?: true
    objectives?: true
    customObjectives?: true
    status?: true
    isPublic?: true
    debriefCompleted?: true
    debriefReport?: true
    debriefGeneratedAt?: true
    notes?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _avg?: SessionAvgAggregateInputType
    _sum?: SessionSumAggregateInputType
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    programId: string | null
    date: Date
    endDate: Date | null
    venue: JsonValue
    teamSize: number | null
    teamName: string | null
    companyName: string | null
    industryType: string | null
    objectives: JsonValue | null
    customObjectives: string | null
    status: string
    isPublic: boolean
    debriefCompleted: boolean
    debriefReport: JsonValue | null
    debriefGeneratedAt: Date | null
    notes: string | null
    _count: SessionCountAggregateOutputType | null
    _avg: SessionAvgAggregateOutputType | null
    _sum: SessionSumAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    programId?: boolean
    date?: boolean
    endDate?: boolean
    venue?: boolean
    teamSize?: boolean
    teamName?: boolean
    companyName?: boolean
    industryType?: boolean
    objectives?: boolean
    customObjectives?: boolean
    status?: boolean
    isPublic?: boolean
    debriefCompleted?: boolean
    debriefReport?: boolean
    debriefGeneratedAt?: boolean
    notes?: boolean
    program?: boolean | Session$programArgs<ExtArgs>
    orders?: boolean | Session$ordersArgs<ExtArgs>
    _count?: boolean | SessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    programId?: boolean
    date?: boolean
    endDate?: boolean
    venue?: boolean
    teamSize?: boolean
    teamName?: boolean
    companyName?: boolean
    industryType?: boolean
    objectives?: boolean
    customObjectives?: boolean
    status?: boolean
    isPublic?: boolean
    debriefCompleted?: boolean
    debriefReport?: boolean
    debriefGeneratedAt?: boolean
    notes?: boolean
    program?: boolean | Session$programArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    programId?: boolean
    date?: boolean
    endDate?: boolean
    venue?: boolean
    teamSize?: boolean
    teamName?: boolean
    companyName?: boolean
    industryType?: boolean
    objectives?: boolean
    customObjectives?: boolean
    status?: boolean
    isPublic?: boolean
    debriefCompleted?: boolean
    debriefReport?: boolean
    debriefGeneratedAt?: boolean
    notes?: boolean
    program?: boolean | Session$programArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    programId?: boolean
    date?: boolean
    endDate?: boolean
    venue?: boolean
    teamSize?: boolean
    teamName?: boolean
    companyName?: boolean
    industryType?: boolean
    objectives?: boolean
    customObjectives?: boolean
    status?: boolean
    isPublic?: boolean
    debriefCompleted?: boolean
    debriefReport?: boolean
    debriefGeneratedAt?: boolean
    notes?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "programId" | "date" | "endDate" | "venue" | "teamSize" | "teamName" | "companyName" | "industryType" | "objectives" | "customObjectives" | "status" | "isPublic" | "debriefCompleted" | "debriefReport" | "debriefGeneratedAt" | "notes", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    program?: boolean | Session$programArgs<ExtArgs>
    orders?: boolean | Session$ordersArgs<ExtArgs>
    _count?: boolean | SessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    program?: boolean | Session$programArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    program?: boolean | Session$programArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      program: Prisma.$ProgramPayload<ExtArgs> | null
      orders: Prisma.$OrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      programId: string | null
      date: Date
      endDate: Date | null
      venue: Prisma.JsonValue
      teamSize: number | null
      teamName: string | null
      companyName: string | null
      industryType: string | null
      objectives: Prisma.JsonValue | null
      customObjectives: string | null
      status: string
      isPublic: boolean
      debriefCompleted: boolean
      debriefReport: Prisma.JsonValue | null
      debriefGeneratedAt: Date | null
      notes: string | null
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    program<T extends Session$programArgs<ExtArgs> = {}>(args?: Subset<T, Session$programArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    orders<T extends Session$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Session$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly updatedAt: FieldRef<"Session", 'DateTime'>
    readonly programId: FieldRef<"Session", 'String'>
    readonly date: FieldRef<"Session", 'DateTime'>
    readonly endDate: FieldRef<"Session", 'DateTime'>
    readonly venue: FieldRef<"Session", 'Json'>
    readonly teamSize: FieldRef<"Session", 'Int'>
    readonly teamName: FieldRef<"Session", 'String'>
    readonly companyName: FieldRef<"Session", 'String'>
    readonly industryType: FieldRef<"Session", 'String'>
    readonly objectives: FieldRef<"Session", 'Json'>
    readonly customObjectives: FieldRef<"Session", 'String'>
    readonly status: FieldRef<"Session", 'String'>
    readonly isPublic: FieldRef<"Session", 'Boolean'>
    readonly debriefCompleted: FieldRef<"Session", 'Boolean'>
    readonly debriefReport: FieldRef<"Session", 'Json'>
    readonly debriefGeneratedAt: FieldRef<"Session", 'DateTime'>
    readonly notes: FieldRef<"Session", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session.program
   */
  export type Session$programArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    where?: ProgramWhereInput
  }

  /**
   * Session.orders
   */
  export type Session$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model Customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerAvgAggregateOutputType = {
    teamSize: number | null
    averagePaymentDays: number | null
    totalInvoiced: number | null
    totalPaid: number | null
    invoiceCount: number | null
    overdueCount: number | null
  }

  export type CustomerSumAggregateOutputType = {
    teamSize: number | null
    averagePaymentDays: number | null
    totalInvoiced: number | null
    totalPaid: number | null
    invoiceCount: number | null
    overdueCount: number | null
  }

  export type CustomerMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    email: string | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    organization: string | null
    organizationType: string | null
    industryType: string | null
    teamSize: number | null
    notes: string | null
    averagePaymentDays: number | null
    paymentReliability: string | null
    totalInvoiced: number | null
    totalPaid: number | null
    invoiceCount: number | null
    overdueCount: number | null
    lastInvoiceDate: Date | null
    lastPaymentDate: Date | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    email: string | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    organization: string | null
    organizationType: string | null
    industryType: string | null
    teamSize: number | null
    notes: string | null
    averagePaymentDays: number | null
    paymentReliability: string | null
    totalInvoiced: number | null
    totalPaid: number | null
    invoiceCount: number | null
    overdueCount: number | null
    lastInvoiceDate: Date | null
    lastPaymentDate: Date | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    email: number
    firstName: number
    lastName: number
    phone: number
    organization: number
    organizationType: number
    industryType: number
    teamSize: number
    address: number
    billingInfo: number
    tags: number
    notes: number
    gdprConsent: number
    averagePaymentDays: number
    paymentReliability: number
    totalInvoiced: number
    totalPaid: number
    invoiceCount: number
    overdueCount: number
    lastInvoiceDate: number
    lastPaymentDate: number
    _all: number
  }


  export type CustomerAvgAggregateInputType = {
    teamSize?: true
    averagePaymentDays?: true
    totalInvoiced?: true
    totalPaid?: true
    invoiceCount?: true
    overdueCount?: true
  }

  export type CustomerSumAggregateInputType = {
    teamSize?: true
    averagePaymentDays?: true
    totalInvoiced?: true
    totalPaid?: true
    invoiceCount?: true
    overdueCount?: true
  }

  export type CustomerMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    email?: true
    firstName?: true
    lastName?: true
    phone?: true
    organization?: true
    organizationType?: true
    industryType?: true
    teamSize?: true
    notes?: true
    averagePaymentDays?: true
    paymentReliability?: true
    totalInvoiced?: true
    totalPaid?: true
    invoiceCount?: true
    overdueCount?: true
    lastInvoiceDate?: true
    lastPaymentDate?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    email?: true
    firstName?: true
    lastName?: true
    phone?: true
    organization?: true
    organizationType?: true
    industryType?: true
    teamSize?: true
    notes?: true
    averagePaymentDays?: true
    paymentReliability?: true
    totalInvoiced?: true
    totalPaid?: true
    invoiceCount?: true
    overdueCount?: true
    lastInvoiceDate?: true
    lastPaymentDate?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    email?: true
    firstName?: true
    lastName?: true
    phone?: true
    organization?: true
    organizationType?: true
    industryType?: true
    teamSize?: true
    address?: true
    billingInfo?: true
    tags?: true
    notes?: true
    gdprConsent?: true
    averagePaymentDays?: true
    paymentReliability?: true
    totalInvoiced?: true
    totalPaid?: true
    invoiceCount?: true
    overdueCount?: true
    lastInvoiceDate?: true
    lastPaymentDate?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithAggregationInput | CustomerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _avg?: CustomerAvgAggregateInputType
    _sum?: CustomerSumAggregateInputType
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    email: string
    firstName: string
    lastName: string
    phone: string | null
    organization: string | null
    organizationType: string | null
    industryType: string | null
    teamSize: number | null
    address: JsonValue | null
    billingInfo: JsonValue | null
    tags: JsonValue | null
    notes: string | null
    gdprConsent: JsonValue | null
    averagePaymentDays: number | null
    paymentReliability: string | null
    totalInvoiced: number
    totalPaid: number
    invoiceCount: number
    overdueCount: number
    lastInvoiceDate: Date | null
    lastPaymentDate: Date | null
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    organization?: boolean
    organizationType?: boolean
    industryType?: boolean
    teamSize?: boolean
    address?: boolean
    billingInfo?: boolean
    tags?: boolean
    notes?: boolean
    gdprConsent?: boolean
    averagePaymentDays?: boolean
    paymentReliability?: boolean
    totalInvoiced?: boolean
    totalPaid?: boolean
    invoiceCount?: boolean
    overdueCount?: boolean
    lastInvoiceDate?: boolean
    lastPaymentDate?: boolean
    orders?: boolean | Customer$ordersArgs<ExtArgs>
    invoices?: boolean | Customer$invoicesArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    organization?: boolean
    organizationType?: boolean
    industryType?: boolean
    teamSize?: boolean
    address?: boolean
    billingInfo?: boolean
    tags?: boolean
    notes?: boolean
    gdprConsent?: boolean
    averagePaymentDays?: boolean
    paymentReliability?: boolean
    totalInvoiced?: boolean
    totalPaid?: boolean
    invoiceCount?: boolean
    overdueCount?: boolean
    lastInvoiceDate?: boolean
    lastPaymentDate?: boolean
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    organization?: boolean
    organizationType?: boolean
    industryType?: boolean
    teamSize?: boolean
    address?: boolean
    billingInfo?: boolean
    tags?: boolean
    notes?: boolean
    gdprConsent?: boolean
    averagePaymentDays?: boolean
    paymentReliability?: boolean
    totalInvoiced?: boolean
    totalPaid?: boolean
    invoiceCount?: boolean
    overdueCount?: boolean
    lastInvoiceDate?: boolean
    lastPaymentDate?: boolean
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    organization?: boolean
    organizationType?: boolean
    industryType?: boolean
    teamSize?: boolean
    address?: boolean
    billingInfo?: boolean
    tags?: boolean
    notes?: boolean
    gdprConsent?: boolean
    averagePaymentDays?: boolean
    paymentReliability?: boolean
    totalInvoiced?: boolean
    totalPaid?: boolean
    invoiceCount?: boolean
    overdueCount?: boolean
    lastInvoiceDate?: boolean
    lastPaymentDate?: boolean
  }

  export type CustomerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "email" | "firstName" | "lastName" | "phone" | "organization" | "organizationType" | "industryType" | "teamSize" | "address" | "billingInfo" | "tags" | "notes" | "gdprConsent" | "averagePaymentDays" | "paymentReliability" | "totalInvoiced" | "totalPaid" | "invoiceCount" | "overdueCount" | "lastInvoiceDate" | "lastPaymentDate", ExtArgs["result"]["customer"]>
  export type CustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | Customer$ordersArgs<ExtArgs>
    invoices?: boolean | Customer$invoicesArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CustomerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customer"
    objects: {
      orders: Prisma.$OrderPayload<ExtArgs>[]
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      email: string
      firstName: string
      lastName: string
      phone: string | null
      organization: string | null
      organizationType: string | null
      industryType: string | null
      teamSize: number | null
      address: Prisma.JsonValue | null
      billingInfo: Prisma.JsonValue | null
      tags: Prisma.JsonValue | null
      notes: string | null
      gdprConsent: Prisma.JsonValue | null
      averagePaymentDays: number | null
      paymentReliability: string | null
      totalInvoiced: number
      totalPaid: number
      invoiceCount: number
      overdueCount: number
      lastInvoiceDate: Date | null
      lastPaymentDate: Date | null
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type CustomerGetPayload<S extends boolean | null | undefined | CustomerDefaultArgs> = $Result.GetResult<Prisma.$CustomerPayload, S>

  type CustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface CustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customer'], meta: { name: 'Customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerFindUniqueArgs>(args: SelectSubset<T, CustomerFindUniqueArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerFindFirstArgs>(args?: SelectSubset<T, CustomerFindFirstArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerFindManyArgs>(args?: SelectSubset<T, CustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends CustomerCreateArgs>(args: SelectSubset<T, CustomerCreateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customers.
     * @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerCreateManyArgs>(args?: SelectSubset<T, CustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Customers and returns the data saved in the database.
     * @param {CustomerCreateManyAndReturnArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends CustomerDeleteArgs>(args: SelectSubset<T, CustomerDeleteArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerUpdateArgs>(args: SelectSubset<T, CustomerUpdateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerDeleteManyArgs>(args?: SelectSubset<T, CustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerUpdateManyArgs>(args: SelectSubset<T, CustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers and returns the data updated in the database.
     * @param {CustomerUpdateManyAndReturnArgs} args - Arguments to update many Customers.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends CustomerUpsertArgs>(args: SelectSubset<T, CustomerUpsertArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customer model
   */
  readonly fields: CustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orders<T extends Customer$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Customer$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoices<T extends Customer$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Customer$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customer model
   */
  interface CustomerFieldRefs {
    readonly id: FieldRef<"Customer", 'String'>
    readonly createdAt: FieldRef<"Customer", 'DateTime'>
    readonly updatedAt: FieldRef<"Customer", 'DateTime'>
    readonly email: FieldRef<"Customer", 'String'>
    readonly firstName: FieldRef<"Customer", 'String'>
    readonly lastName: FieldRef<"Customer", 'String'>
    readonly phone: FieldRef<"Customer", 'String'>
    readonly organization: FieldRef<"Customer", 'String'>
    readonly organizationType: FieldRef<"Customer", 'String'>
    readonly industryType: FieldRef<"Customer", 'String'>
    readonly teamSize: FieldRef<"Customer", 'Int'>
    readonly address: FieldRef<"Customer", 'Json'>
    readonly billingInfo: FieldRef<"Customer", 'Json'>
    readonly tags: FieldRef<"Customer", 'Json'>
    readonly notes: FieldRef<"Customer", 'String'>
    readonly gdprConsent: FieldRef<"Customer", 'Json'>
    readonly averagePaymentDays: FieldRef<"Customer", 'Int'>
    readonly paymentReliability: FieldRef<"Customer", 'String'>
    readonly totalInvoiced: FieldRef<"Customer", 'Int'>
    readonly totalPaid: FieldRef<"Customer", 'Int'>
    readonly invoiceCount: FieldRef<"Customer", 'Int'>
    readonly overdueCount: FieldRef<"Customer", 'Int'>
    readonly lastInvoiceDate: FieldRef<"Customer", 'DateTime'>
    readonly lastPaymentDate: FieldRef<"Customer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Customer findUnique
   */
  export type CustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findFirst
   */
  export type CustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer create
   */
  export type CustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a Customer.
     */
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }

  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
  }

  /**
   * Customer createManyAndReturn
   */
  export type CustomerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
  }

  /**
   * Customer update
   */
  export type CustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer updateManyAndReturn
   */
  export type CustomerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }

  /**
   * Customer delete
   */
  export type CustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to delete.
     */
    limit?: number
  }

  /**
   * Customer.orders
   */
  export type Customer$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Customer.invoices
   */
  export type Customer$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Customer without action
   */
  export type CustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
  }


  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    teamSize: number | null
  }

  export type OrderSumAggregateOutputType = {
    teamSize: number | null
  }

  export type OrderMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    orderNumber: string | null
    customerId: string | null
    source: string | null
    status: string | null
    sessionName: string | null
    teamSize: number | null
    customObjectives: string | null
    industryType: string | null
    paymentMethod: string | null
    paymentDueDate: Date | null
    invoiceEmail: string | null
    linkedSessionId: string | null
    internalNotes: string | null
  }

  export type OrderMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    orderNumber: string | null
    customerId: string | null
    source: string | null
    status: string | null
    sessionName: string | null
    teamSize: number | null
    customObjectives: string | null
    industryType: string | null
    paymentMethod: string | null
    paymentDueDate: Date | null
    invoiceEmail: string | null
    linkedSessionId: string | null
    internalNotes: string | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    orderNumber: number
    customerId: number
    source: number
    status: number
    sessionName: number
    dates: number
    venue: number
    teamSize: number
    teamComposition: number
    objectives: number
    customObjectives: number
    industryType: number
    technicalRequirements: number
    pricing: number
    paymentMethod: number
    paymentDueDate: number
    invoiceEmail: number
    logistics: number
    contacts: number
    documents: number
    linkedSessionId: number
    internalNotes: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    teamSize?: true
  }

  export type OrderSumAggregateInputType = {
    teamSize?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    orderNumber?: true
    customerId?: true
    source?: true
    status?: true
    sessionName?: true
    teamSize?: true
    customObjectives?: true
    industryType?: true
    paymentMethod?: true
    paymentDueDate?: true
    invoiceEmail?: true
    linkedSessionId?: true
    internalNotes?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    orderNumber?: true
    customerId?: true
    source?: true
    status?: true
    sessionName?: true
    teamSize?: true
    customObjectives?: true
    industryType?: true
    paymentMethod?: true
    paymentDueDate?: true
    invoiceEmail?: true
    linkedSessionId?: true
    internalNotes?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    orderNumber?: true
    customerId?: true
    source?: true
    status?: true
    sessionName?: true
    dates?: true
    venue?: true
    teamSize?: true
    teamComposition?: true
    objectives?: true
    customObjectives?: true
    industryType?: true
    technicalRequirements?: true
    pricing?: true
    paymentMethod?: true
    paymentDueDate?: true
    invoiceEmail?: true
    logistics?: true
    contacts?: true
    documents?: true
    linkedSessionId?: true
    internalNotes?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    orderNumber: string
    customerId: string | null
    source: string
    status: string
    sessionName: string | null
    dates: JsonValue
    venue: JsonValue
    teamSize: number | null
    teamComposition: JsonValue | null
    objectives: JsonValue | null
    customObjectives: string | null
    industryType: string | null
    technicalRequirements: JsonValue | null
    pricing: JsonValue | null
    paymentMethod: string | null
    paymentDueDate: Date | null
    invoiceEmail: string | null
    logistics: JsonValue | null
    contacts: JsonValue | null
    documents: JsonValue | null
    linkedSessionId: string | null
    internalNotes: string | null
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    orderNumber?: boolean
    customerId?: boolean
    source?: boolean
    status?: boolean
    sessionName?: boolean
    dates?: boolean
    venue?: boolean
    teamSize?: boolean
    teamComposition?: boolean
    objectives?: boolean
    customObjectives?: boolean
    industryType?: boolean
    technicalRequirements?: boolean
    pricing?: boolean
    paymentMethod?: boolean
    paymentDueDate?: boolean
    invoiceEmail?: boolean
    logistics?: boolean
    contacts?: boolean
    documents?: boolean
    linkedSessionId?: boolean
    internalNotes?: boolean
    customer?: boolean | Order$customerArgs<ExtArgs>
    items?: boolean | Order$itemsArgs<ExtArgs>
    linkedSession?: boolean | Order$linkedSessionArgs<ExtArgs>
    invoices?: boolean | Order$invoicesArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    orderNumber?: boolean
    customerId?: boolean
    source?: boolean
    status?: boolean
    sessionName?: boolean
    dates?: boolean
    venue?: boolean
    teamSize?: boolean
    teamComposition?: boolean
    objectives?: boolean
    customObjectives?: boolean
    industryType?: boolean
    technicalRequirements?: boolean
    pricing?: boolean
    paymentMethod?: boolean
    paymentDueDate?: boolean
    invoiceEmail?: boolean
    logistics?: boolean
    contacts?: boolean
    documents?: boolean
    linkedSessionId?: boolean
    internalNotes?: boolean
    customer?: boolean | Order$customerArgs<ExtArgs>
    linkedSession?: boolean | Order$linkedSessionArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    orderNumber?: boolean
    customerId?: boolean
    source?: boolean
    status?: boolean
    sessionName?: boolean
    dates?: boolean
    venue?: boolean
    teamSize?: boolean
    teamComposition?: boolean
    objectives?: boolean
    customObjectives?: boolean
    industryType?: boolean
    technicalRequirements?: boolean
    pricing?: boolean
    paymentMethod?: boolean
    paymentDueDate?: boolean
    invoiceEmail?: boolean
    logistics?: boolean
    contacts?: boolean
    documents?: boolean
    linkedSessionId?: boolean
    internalNotes?: boolean
    customer?: boolean | Order$customerArgs<ExtArgs>
    linkedSession?: boolean | Order$linkedSessionArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    orderNumber?: boolean
    customerId?: boolean
    source?: boolean
    status?: boolean
    sessionName?: boolean
    dates?: boolean
    venue?: boolean
    teamSize?: boolean
    teamComposition?: boolean
    objectives?: boolean
    customObjectives?: boolean
    industryType?: boolean
    technicalRequirements?: boolean
    pricing?: boolean
    paymentMethod?: boolean
    paymentDueDate?: boolean
    invoiceEmail?: boolean
    logistics?: boolean
    contacts?: boolean
    documents?: boolean
    linkedSessionId?: boolean
    internalNotes?: boolean
  }

  export type OrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "orderNumber" | "customerId" | "source" | "status" | "sessionName" | "dates" | "venue" | "teamSize" | "teamComposition" | "objectives" | "customObjectives" | "industryType" | "technicalRequirements" | "pricing" | "paymentMethod" | "paymentDueDate" | "invoiceEmail" | "logistics" | "contacts" | "documents" | "linkedSessionId" | "internalNotes", ExtArgs["result"]["order"]>
  export type OrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | Order$customerArgs<ExtArgs>
    items?: boolean | Order$itemsArgs<ExtArgs>
    linkedSession?: boolean | Order$linkedSessionArgs<ExtArgs>
    invoices?: boolean | Order$invoicesArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | Order$customerArgs<ExtArgs>
    linkedSession?: boolean | Order$linkedSessionArgs<ExtArgs>
  }
  export type OrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | Order$customerArgs<ExtArgs>
    linkedSession?: boolean | Order$linkedSessionArgs<ExtArgs>
  }

  export type $OrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Order"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs> | null
      items: Prisma.$OrderItemPayload<ExtArgs>[]
      linkedSession: Prisma.$SessionPayload<ExtArgs> | null
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      orderNumber: string
      customerId: string | null
      source: string
      status: string
      sessionName: string | null
      dates: Prisma.JsonValue
      venue: Prisma.JsonValue
      teamSize: number | null
      teamComposition: Prisma.JsonValue | null
      objectives: Prisma.JsonValue | null
      customObjectives: string | null
      industryType: string | null
      technicalRequirements: Prisma.JsonValue | null
      pricing: Prisma.JsonValue | null
      paymentMethod: string | null
      paymentDueDate: Date | null
      invoiceEmail: string | null
      logistics: Prisma.JsonValue | null
      contacts: Prisma.JsonValue | null
      documents: Prisma.JsonValue | null
      linkedSessionId: string | null
      internalNotes: string | null
    }, ExtArgs["result"]["order"]>
    composites: {}
  }

  type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<Prisma.$OrderPayload, S>

  type OrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order'], meta: { name: 'Order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderFindUniqueArgs>(args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderFindFirstArgs>(args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderFindManyArgs>(args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
     */
    create<T extends OrderCreateArgs>(args: SelectSubset<T, OrderCreateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Orders.
     * @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderCreateManyArgs>(args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Orders and returns the data saved in the database.
     * @param {OrderCreateManyAndReturnArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
     */
    delete<T extends OrderDeleteArgs>(args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderUpdateArgs>(args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderDeleteManyArgs>(args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderUpdateManyArgs>(args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders and returns the data updated in the database.
     * @param {OrderUpdateManyAndReturnArgs} args - Arguments to update many Orders.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
     */
    upsert<T extends OrderUpsertArgs>(args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Order model
   */
  readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends Order$customerArgs<ExtArgs> = {}>(args?: Subset<T, Order$customerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    items<T extends Order$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Order$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    linkedSession<T extends Order$linkedSessionArgs<ExtArgs> = {}>(args?: Subset<T, Order$linkedSessionArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    invoices<T extends Order$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Order$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Order model
   */
  interface OrderFieldRefs {
    readonly id: FieldRef<"Order", 'String'>
    readonly createdAt: FieldRef<"Order", 'DateTime'>
    readonly updatedAt: FieldRef<"Order", 'DateTime'>
    readonly orderNumber: FieldRef<"Order", 'String'>
    readonly customerId: FieldRef<"Order", 'String'>
    readonly source: FieldRef<"Order", 'String'>
    readonly status: FieldRef<"Order", 'String'>
    readonly sessionName: FieldRef<"Order", 'String'>
    readonly dates: FieldRef<"Order", 'Json'>
    readonly venue: FieldRef<"Order", 'Json'>
    readonly teamSize: FieldRef<"Order", 'Int'>
    readonly teamComposition: FieldRef<"Order", 'Json'>
    readonly objectives: FieldRef<"Order", 'Json'>
    readonly customObjectives: FieldRef<"Order", 'String'>
    readonly industryType: FieldRef<"Order", 'String'>
    readonly technicalRequirements: FieldRef<"Order", 'Json'>
    readonly pricing: FieldRef<"Order", 'Json'>
    readonly paymentMethod: FieldRef<"Order", 'String'>
    readonly paymentDueDate: FieldRef<"Order", 'DateTime'>
    readonly invoiceEmail: FieldRef<"Order", 'String'>
    readonly logistics: FieldRef<"Order", 'Json'>
    readonly contacts: FieldRef<"Order", 'Json'>
    readonly documents: FieldRef<"Order", 'Json'>
    readonly linkedSessionId: FieldRef<"Order", 'String'>
    readonly internalNotes: FieldRef<"Order", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }

  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
  }

  /**
   * Order createManyAndReturn
   */
  export type OrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
  }

  /**
   * Order updateManyAndReturn
   */
  export type OrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }

  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to delete.
     */
    limit?: number
  }

  /**
   * Order.customer
   */
  export type Order$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * Order.items
   */
  export type Order$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * Order.linkedSession
   */
  export type Order$linkedSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
  }

  /**
   * Order.invoices
   */
  export type Order$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Order without action
   */
  export type OrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
  }


  /**
   * Model OrderItem
   */

  export type AggregateOrderItem = {
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  export type OrderItemAvgAggregateOutputType = {
    price: number | null
  }

  export type OrderItemSumAggregateOutputType = {
    price: number | null
  }

  export type OrderItemMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    orderId: string | null
    programId: string | null
    activityId: string | null
    extraId: string | null
    date: string | null
    startTime: string | null
    endTime: string | null
    price: number | null
    notes: string | null
  }

  export type OrderItemMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    orderId: string | null
    programId: string | null
    activityId: string | null
    extraId: string | null
    date: string | null
    startTime: string | null
    endTime: string | null
    price: number | null
    notes: string | null
  }

  export type OrderItemCountAggregateOutputType = {
    id: number
    createdAt: number
    orderId: number
    programId: number
    activityId: number
    extraId: number
    date: number
    startTime: number
    endTime: number
    price: number
    notes: number
    _all: number
  }


  export type OrderItemAvgAggregateInputType = {
    price?: true
  }

  export type OrderItemSumAggregateInputType = {
    price?: true
  }

  export type OrderItemMinAggregateInputType = {
    id?: true
    createdAt?: true
    orderId?: true
    programId?: true
    activityId?: true
    extraId?: true
    date?: true
    startTime?: true
    endTime?: true
    price?: true
    notes?: true
  }

  export type OrderItemMaxAggregateInputType = {
    id?: true
    createdAt?: true
    orderId?: true
    programId?: true
    activityId?: true
    extraId?: true
    date?: true
    startTime?: true
    endTime?: true
    price?: true
    notes?: true
  }

  export type OrderItemCountAggregateInputType = {
    id?: true
    createdAt?: true
    orderId?: true
    programId?: true
    activityId?: true
    extraId?: true
    date?: true
    startTime?: true
    endTime?: true
    price?: true
    notes?: true
    _all?: true
  }

  export type OrderItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItem to aggregate.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderItems
    **/
    _count?: true | OrderItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderItemMaxAggregateInputType
  }

  export type GetOrderItemAggregateType<T extends OrderItemAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderItem[P]>
      : GetScalarType<T[P], AggregateOrderItem[P]>
  }




  export type OrderItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithAggregationInput | OrderItemOrderByWithAggregationInput[]
    by: OrderItemScalarFieldEnum[] | OrderItemScalarFieldEnum
    having?: OrderItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderItemCountAggregateInputType | true
    _avg?: OrderItemAvgAggregateInputType
    _sum?: OrderItemSumAggregateInputType
    _min?: OrderItemMinAggregateInputType
    _max?: OrderItemMaxAggregateInputType
  }

  export type OrderItemGroupByOutputType = {
    id: string
    createdAt: Date
    orderId: string
    programId: string | null
    activityId: string | null
    extraId: string | null
    date: string
    startTime: string | null
    endTime: string | null
    price: number
    notes: string | null
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  type GetOrderItemGroupByPayload<T extends OrderItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
            : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
        }
      >
    >


  export type OrderItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    orderId?: boolean
    programId?: boolean
    activityId?: boolean
    extraId?: boolean
    date?: boolean
    startTime?: boolean
    endTime?: boolean
    price?: boolean
    notes?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    program?: boolean | OrderItem$programArgs<ExtArgs>
    activity?: boolean | OrderItem$activityArgs<ExtArgs>
    extra?: boolean | OrderItem$extraArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    orderId?: boolean
    programId?: boolean
    activityId?: boolean
    extraId?: boolean
    date?: boolean
    startTime?: boolean
    endTime?: boolean
    price?: boolean
    notes?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    program?: boolean | OrderItem$programArgs<ExtArgs>
    activity?: boolean | OrderItem$activityArgs<ExtArgs>
    extra?: boolean | OrderItem$extraArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    orderId?: boolean
    programId?: boolean
    activityId?: boolean
    extraId?: boolean
    date?: boolean
    startTime?: boolean
    endTime?: boolean
    price?: boolean
    notes?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    program?: boolean | OrderItem$programArgs<ExtArgs>
    activity?: boolean | OrderItem$activityArgs<ExtArgs>
    extra?: boolean | OrderItem$extraArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectScalar = {
    id?: boolean
    createdAt?: boolean
    orderId?: boolean
    programId?: boolean
    activityId?: boolean
    extraId?: boolean
    date?: boolean
    startTime?: boolean
    endTime?: boolean
    price?: boolean
    notes?: boolean
  }

  export type OrderItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "orderId" | "programId" | "activityId" | "extraId" | "date" | "startTime" | "endTime" | "price" | "notes", ExtArgs["result"]["orderItem"]>
  export type OrderItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    program?: boolean | OrderItem$programArgs<ExtArgs>
    activity?: boolean | OrderItem$activityArgs<ExtArgs>
    extra?: boolean | OrderItem$extraArgs<ExtArgs>
  }
  export type OrderItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    program?: boolean | OrderItem$programArgs<ExtArgs>
    activity?: boolean | OrderItem$activityArgs<ExtArgs>
    extra?: boolean | OrderItem$extraArgs<ExtArgs>
  }
  export type OrderItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    program?: boolean | OrderItem$programArgs<ExtArgs>
    activity?: boolean | OrderItem$activityArgs<ExtArgs>
    extra?: boolean | OrderItem$extraArgs<ExtArgs>
  }

  export type $OrderItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderItem"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
      program: Prisma.$ProgramPayload<ExtArgs> | null
      activity: Prisma.$ActivityPayload<ExtArgs> | null
      extra: Prisma.$ExtraPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      orderId: string
      programId: string | null
      activityId: string | null
      extraId: string | null
      date: string
      startTime: string | null
      endTime: string | null
      price: number
      notes: string | null
    }, ExtArgs["result"]["orderItem"]>
    composites: {}
  }

  type OrderItemGetPayload<S extends boolean | null | undefined | OrderItemDefaultArgs> = $Result.GetResult<Prisma.$OrderItemPayload, S>

  type OrderItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderItemCountAggregateInputType | true
    }

  export interface OrderItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderItem'], meta: { name: 'OrderItem' } }
    /**
     * Find zero or one OrderItem that matches the filter.
     * @param {OrderItemFindUniqueArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderItemFindUniqueArgs>(args: SelectSubset<T, OrderItemFindUniqueArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrderItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderItemFindUniqueOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderItemFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderItemFindFirstArgs>(args?: SelectSubset<T, OrderItemFindFirstArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderItemFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderItems
     * const orderItems = await prisma.orderItem.findMany()
     * 
     * // Get first 10 OrderItems
     * const orderItems = await prisma.orderItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderItemFindManyArgs>(args?: SelectSubset<T, OrderItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrderItem.
     * @param {OrderItemCreateArgs} args - Arguments to create a OrderItem.
     * @example
     * // Create one OrderItem
     * const OrderItem = await prisma.orderItem.create({
     *   data: {
     *     // ... data to create a OrderItem
     *   }
     * })
     * 
     */
    create<T extends OrderItemCreateArgs>(args: SelectSubset<T, OrderItemCreateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrderItems.
     * @param {OrderItemCreateManyArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderItemCreateManyArgs>(args?: SelectSubset<T, OrderItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrderItems and returns the data saved in the database.
     * @param {OrderItemCreateManyAndReturnArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrderItems and only return the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderItemCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OrderItem.
     * @param {OrderItemDeleteArgs} args - Arguments to delete one OrderItem.
     * @example
     * // Delete one OrderItem
     * const OrderItem = await prisma.orderItem.delete({
     *   where: {
     *     // ... filter to delete one OrderItem
     *   }
     * })
     * 
     */
    delete<T extends OrderItemDeleteArgs>(args: SelectSubset<T, OrderItemDeleteArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrderItem.
     * @param {OrderItemUpdateArgs} args - Arguments to update one OrderItem.
     * @example
     * // Update one OrderItem
     * const orderItem = await prisma.orderItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderItemUpdateArgs>(args: SelectSubset<T, OrderItemUpdateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrderItems.
     * @param {OrderItemDeleteManyArgs} args - Arguments to filter OrderItems to delete.
     * @example
     * // Delete a few OrderItems
     * const { count } = await prisma.orderItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderItemDeleteManyArgs>(args?: SelectSubset<T, OrderItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderItemUpdateManyArgs>(args: SelectSubset<T, OrderItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItems and returns the data updated in the database.
     * @param {OrderItemUpdateManyAndReturnArgs} args - Arguments to update many OrderItems.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrderItems and only return the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderItemUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OrderItem.
     * @param {OrderItemUpsertArgs} args - Arguments to update or create a OrderItem.
     * @example
     * // Update or create a OrderItem
     * const orderItem = await prisma.orderItem.upsert({
     *   create: {
     *     // ... data to create a OrderItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderItem we want to update
     *   }
     * })
     */
    upsert<T extends OrderItemUpsertArgs>(args: SelectSubset<T, OrderItemUpsertArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemCountArgs} args - Arguments to filter OrderItems to count.
     * @example
     * // Count the number of OrderItems
     * const count = await prisma.orderItem.count({
     *   where: {
     *     // ... the filter for the OrderItems we want to count
     *   }
     * })
    **/
    count<T extends OrderItemCountArgs>(
      args?: Subset<T, OrderItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderItemAggregateArgs>(args: Subset<T, OrderItemAggregateArgs>): Prisma.PrismaPromise<GetOrderItemAggregateType<T>>

    /**
     * Group by OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderItemGroupByArgs['orderBy'] }
        : { orderBy?: OrderItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderItem model
   */
  readonly fields: OrderItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    program<T extends OrderItem$programArgs<ExtArgs> = {}>(args?: Subset<T, OrderItem$programArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    activity<T extends OrderItem$activityArgs<ExtArgs> = {}>(args?: Subset<T, OrderItem$activityArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    extra<T extends OrderItem$extraArgs<ExtArgs> = {}>(args?: Subset<T, OrderItem$extraArgs<ExtArgs>>): Prisma__ExtraClient<$Result.GetResult<Prisma.$ExtraPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderItem model
   */
  interface OrderItemFieldRefs {
    readonly id: FieldRef<"OrderItem", 'String'>
    readonly createdAt: FieldRef<"OrderItem", 'DateTime'>
    readonly orderId: FieldRef<"OrderItem", 'String'>
    readonly programId: FieldRef<"OrderItem", 'String'>
    readonly activityId: FieldRef<"OrderItem", 'String'>
    readonly extraId: FieldRef<"OrderItem", 'String'>
    readonly date: FieldRef<"OrderItem", 'String'>
    readonly startTime: FieldRef<"OrderItem", 'String'>
    readonly endTime: FieldRef<"OrderItem", 'String'>
    readonly price: FieldRef<"OrderItem", 'Int'>
    readonly notes: FieldRef<"OrderItem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * OrderItem findUnique
   */
  export type OrderItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findUniqueOrThrow
   */
  export type OrderItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findFirst
   */
  export type OrderItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findFirstOrThrow
   */
  export type OrderItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findMany
   */
  export type OrderItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItems to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem create
   */
  export type OrderItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderItem.
     */
    data: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
  }

  /**
   * OrderItem createMany
   */
  export type OrderItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
  }

  /**
   * OrderItem createManyAndReturn
   */
  export type OrderItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderItem update
   */
  export type OrderItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderItem.
     */
    data: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
    /**
     * Choose, which OrderItem to update.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem updateMany
   */
  export type OrderItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderItems.
     */
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyInput>
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to update.
     */
    limit?: number
  }

  /**
   * OrderItem updateManyAndReturn
   */
  export type OrderItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * The data used to update OrderItems.
     */
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyInput>
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderItem upsert
   */
  export type OrderItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderItem to update in case it exists.
     */
    where: OrderItemWhereUniqueInput
    /**
     * In case the OrderItem found by the `where` argument doesn't exist, create a new OrderItem with this data.
     */
    create: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
    /**
     * In case the OrderItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
  }

  /**
   * OrderItem delete
   */
  export type OrderItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter which OrderItem to delete.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem deleteMany
   */
  export type OrderItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItems to delete
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to delete.
     */
    limit?: number
  }

  /**
   * OrderItem.program
   */
  export type OrderItem$programArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    where?: ProgramWhereInput
  }

  /**
   * OrderItem.activity
   */
  export type OrderItem$activityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    where?: ActivityWhereInput
  }

  /**
   * OrderItem.extra
   */
  export type OrderItem$extraArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Extra
     */
    select?: ExtraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Extra
     */
    omit?: ExtraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtraInclude<ExtArgs> | null
    where?: ExtraWhereInput
  }

  /**
   * OrderItem without action
   */
  export type OrderItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
  }


  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    subtotal: number | null
    vatRate: number | null
    vatAmount: number | null
    totalAmount: number | null
    paidAmount: number | null
  }

  export type InvoiceSumAggregateOutputType = {
    subtotal: number | null
    vatRate: number | null
    vatAmount: number | null
    totalAmount: number | null
    paidAmount: number | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    invoiceNumber: string | null
    status: string | null
    customerId: string | null
    orderId: string | null
    issueDate: Date | null
    dueDate: Date | null
    paidDate: Date | null
    subtotal: number | null
    vatRate: number | null
    vatAmount: number | null
    totalAmount: number | null
    paidAmount: number | null
    paymentMethod: string | null
    bankAccount: string | null
    variableSymbol: string | null
    currency: string | null
    pdfUrl: string | null
    pdfGeneratedAt: Date | null
    textBeforeItems: string | null
    textAfterItems: string | null
    notes: string | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    invoiceNumber: string | null
    status: string | null
    customerId: string | null
    orderId: string | null
    issueDate: Date | null
    dueDate: Date | null
    paidDate: Date | null
    subtotal: number | null
    vatRate: number | null
    vatAmount: number | null
    totalAmount: number | null
    paidAmount: number | null
    paymentMethod: string | null
    bankAccount: string | null
    variableSymbol: string | null
    currency: string | null
    pdfUrl: string | null
    pdfGeneratedAt: Date | null
    textBeforeItems: string | null
    textAfterItems: string | null
    notes: string | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    invoiceNumber: number
    status: number
    customerId: number
    orderId: number
    issueDate: number
    dueDate: number
    paidDate: number
    items: number
    subtotal: number
    vatRate: number
    vatAmount: number
    totalAmount: number
    paidAmount: number
    paymentMethod: number
    bankAccount: number
    variableSymbol: number
    currency: number
    pdfUrl: number
    pdfGeneratedAt: number
    textBeforeItems: number
    textAfterItems: number
    notes: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    subtotal?: true
    vatRate?: true
    vatAmount?: true
    totalAmount?: true
    paidAmount?: true
  }

  export type InvoiceSumAggregateInputType = {
    subtotal?: true
    vatRate?: true
    vatAmount?: true
    totalAmount?: true
    paidAmount?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    invoiceNumber?: true
    status?: true
    customerId?: true
    orderId?: true
    issueDate?: true
    dueDate?: true
    paidDate?: true
    subtotal?: true
    vatRate?: true
    vatAmount?: true
    totalAmount?: true
    paidAmount?: true
    paymentMethod?: true
    bankAccount?: true
    variableSymbol?: true
    currency?: true
    pdfUrl?: true
    pdfGeneratedAt?: true
    textBeforeItems?: true
    textAfterItems?: true
    notes?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    invoiceNumber?: true
    status?: true
    customerId?: true
    orderId?: true
    issueDate?: true
    dueDate?: true
    paidDate?: true
    subtotal?: true
    vatRate?: true
    vatAmount?: true
    totalAmount?: true
    paidAmount?: true
    paymentMethod?: true
    bankAccount?: true
    variableSymbol?: true
    currency?: true
    pdfUrl?: true
    pdfGeneratedAt?: true
    textBeforeItems?: true
    textAfterItems?: true
    notes?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    invoiceNumber?: true
    status?: true
    customerId?: true
    orderId?: true
    issueDate?: true
    dueDate?: true
    paidDate?: true
    items?: true
    subtotal?: true
    vatRate?: true
    vatAmount?: true
    totalAmount?: true
    paidAmount?: true
    paymentMethod?: true
    bankAccount?: true
    variableSymbol?: true
    currency?: true
    pdfUrl?: true
    pdfGeneratedAt?: true
    textBeforeItems?: true
    textAfterItems?: true
    notes?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    invoiceNumber: string
    status: string
    customerId: string
    orderId: string | null
    issueDate: Date
    dueDate: Date
    paidDate: Date | null
    items: JsonValue
    subtotal: number
    vatRate: number | null
    vatAmount: number | null
    totalAmount: number
    paidAmount: number
    paymentMethod: string | null
    bankAccount: string | null
    variableSymbol: string | null
    currency: string
    pdfUrl: string | null
    pdfGeneratedAt: Date | null
    textBeforeItems: string | null
    textAfterItems: string | null
    notes: string | null
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoiceNumber?: boolean
    status?: boolean
    customerId?: boolean
    orderId?: boolean
    issueDate?: boolean
    dueDate?: boolean
    paidDate?: boolean
    items?: boolean
    subtotal?: boolean
    vatRate?: boolean
    vatAmount?: boolean
    totalAmount?: boolean
    paidAmount?: boolean
    paymentMethod?: boolean
    bankAccount?: boolean
    variableSymbol?: boolean
    currency?: boolean
    pdfUrl?: boolean
    pdfGeneratedAt?: boolean
    textBeforeItems?: boolean
    textAfterItems?: boolean
    notes?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    order?: boolean | Invoice$orderArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoiceNumber?: boolean
    status?: boolean
    customerId?: boolean
    orderId?: boolean
    issueDate?: boolean
    dueDate?: boolean
    paidDate?: boolean
    items?: boolean
    subtotal?: boolean
    vatRate?: boolean
    vatAmount?: boolean
    totalAmount?: boolean
    paidAmount?: boolean
    paymentMethod?: boolean
    bankAccount?: boolean
    variableSymbol?: boolean
    currency?: boolean
    pdfUrl?: boolean
    pdfGeneratedAt?: boolean
    textBeforeItems?: boolean
    textAfterItems?: boolean
    notes?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    order?: boolean | Invoice$orderArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoiceNumber?: boolean
    status?: boolean
    customerId?: boolean
    orderId?: boolean
    issueDate?: boolean
    dueDate?: boolean
    paidDate?: boolean
    items?: boolean
    subtotal?: boolean
    vatRate?: boolean
    vatAmount?: boolean
    totalAmount?: boolean
    paidAmount?: boolean
    paymentMethod?: boolean
    bankAccount?: boolean
    variableSymbol?: boolean
    currency?: boolean
    pdfUrl?: boolean
    pdfGeneratedAt?: boolean
    textBeforeItems?: boolean
    textAfterItems?: boolean
    notes?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    order?: boolean | Invoice$orderArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoiceNumber?: boolean
    status?: boolean
    customerId?: boolean
    orderId?: boolean
    issueDate?: boolean
    dueDate?: boolean
    paidDate?: boolean
    items?: boolean
    subtotal?: boolean
    vatRate?: boolean
    vatAmount?: boolean
    totalAmount?: boolean
    paidAmount?: boolean
    paymentMethod?: boolean
    bankAccount?: boolean
    variableSymbol?: boolean
    currency?: boolean
    pdfUrl?: boolean
    pdfGeneratedAt?: boolean
    textBeforeItems?: boolean
    textAfterItems?: boolean
    notes?: boolean
  }

  export type InvoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "invoiceNumber" | "status" | "customerId" | "orderId" | "issueDate" | "dueDate" | "paidDate" | "items" | "subtotal" | "vatRate" | "vatAmount" | "totalAmount" | "paidAmount" | "paymentMethod" | "bankAccount" | "variableSymbol" | "currency" | "pdfUrl" | "pdfGeneratedAt" | "textBeforeItems" | "textAfterItems" | "notes", ExtArgs["result"]["invoice"]>
  export type InvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    order?: boolean | Invoice$orderArgs<ExtArgs>
  }
  export type InvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    order?: boolean | Invoice$orderArgs<ExtArgs>
  }
  export type InvoiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    order?: boolean | Invoice$orderArgs<ExtArgs>
  }

  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoice"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
      order: Prisma.$OrderPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      invoiceNumber: string
      status: string
      customerId: string
      orderId: string | null
      issueDate: Date
      dueDate: Date
      paidDate: Date | null
      items: Prisma.JsonValue
      subtotal: number
      vatRate: number | null
      vatAmount: number | null
      totalAmount: number
      paidAmount: number
      paymentMethod: string | null
      bankAccount: string | null
      variableSymbol: string | null
      currency: string
      pdfUrl: string | null
      pdfGeneratedAt: Date | null
      textBeforeItems: string | null
      textAfterItems: string | null
      notes: string | null
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> = $Result.GetResult<Prisma.$InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceFindUniqueArgs>(args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceFindFirstArgs>(args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceFindManyArgs>(args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends InvoiceCreateArgs>(args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invoices.
     * @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceCreateManyArgs>(args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invoices and returns the data saved in the database.
     * @param {InvoiceCreateManyAndReturnArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends InvoiceDeleteArgs>(args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceUpdateArgs>(args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceDeleteManyArgs>(args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceUpdateManyArgs>(args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices and returns the data updated in the database.
     * @param {InvoiceUpdateManyAndReturnArgs} args - Arguments to update many Invoices.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvoiceUpdateManyAndReturnArgs>(args: SelectSubset<T, InvoiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceUpsertArgs>(args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice model
   */
  readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    order<T extends Invoice$orderArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$orderArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoice model
   */
  interface InvoiceFieldRefs {
    readonly id: FieldRef<"Invoice", 'String'>
    readonly createdAt: FieldRef<"Invoice", 'DateTime'>
    readonly updatedAt: FieldRef<"Invoice", 'DateTime'>
    readonly invoiceNumber: FieldRef<"Invoice", 'String'>
    readonly status: FieldRef<"Invoice", 'String'>
    readonly customerId: FieldRef<"Invoice", 'String'>
    readonly orderId: FieldRef<"Invoice", 'String'>
    readonly issueDate: FieldRef<"Invoice", 'DateTime'>
    readonly dueDate: FieldRef<"Invoice", 'DateTime'>
    readonly paidDate: FieldRef<"Invoice", 'DateTime'>
    readonly items: FieldRef<"Invoice", 'Json'>
    readonly subtotal: FieldRef<"Invoice", 'Int'>
    readonly vatRate: FieldRef<"Invoice", 'Int'>
    readonly vatAmount: FieldRef<"Invoice", 'Int'>
    readonly totalAmount: FieldRef<"Invoice", 'Int'>
    readonly paidAmount: FieldRef<"Invoice", 'Int'>
    readonly paymentMethod: FieldRef<"Invoice", 'String'>
    readonly bankAccount: FieldRef<"Invoice", 'String'>
    readonly variableSymbol: FieldRef<"Invoice", 'String'>
    readonly currency: FieldRef<"Invoice", 'String'>
    readonly pdfUrl: FieldRef<"Invoice", 'String'>
    readonly pdfGeneratedAt: FieldRef<"Invoice", 'DateTime'>
    readonly textBeforeItems: FieldRef<"Invoice", 'String'>
    readonly textAfterItems: FieldRef<"Invoice", 'String'>
    readonly notes: FieldRef<"Invoice", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }

  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
  }

  /**
   * Invoice createManyAndReturn
   */
  export type InvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
  }

  /**
   * Invoice updateManyAndReturn
   */
  export type InvoiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }

  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to delete.
     */
    limit?: number
  }

  /**
   * Invoice.order
   */
  export type Invoice$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
  }

  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: Date | null
    image: string | null
    password: string | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: Date | null
    image: string | null
    password: string | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    emailVerified: number
    image: number
    password: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    password?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    password?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    password?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string | null
    email: string
    emailVerified: Date | null
    image: string | null
    password: string | null
    role: string
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    password?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    password?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    password?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    password?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "emailVerified" | "image" | "password" | "role" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      sessions: Prisma.$UserSessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      email: string
      emailVerified: Date | null
      image: string | null
      password: string | null
      role: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'DateTime'>
    readonly image: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    where?: UserSessionWhereInput
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    cursor?: UserSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountSumAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    provider: number
    providerAccountId: number
    refresh_token: number
    access_token: number
    expires_at: number
    token_type: number
    scope: number
    id_token: number
    session_state: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    expires_at?: true
  }

  export type AccountSumAggregateInputType = {
    expires_at?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "provider" | "providerAccountId" | "refresh_token" | "access_token" | "expires_at" | "token_type" | "scope" | "id_token" | "session_state", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      provider: string
      providerAccountId: string
      refresh_token: string | null
      access_token: string | null
      expires_at: number | null
      token_type: string | null
      scope: string | null
      id_token: string | null
      session_state: string | null
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly type: FieldRef<"Account", 'String'>
    readonly provider: FieldRef<"Account", 'String'>
    readonly providerAccountId: FieldRef<"Account", 'String'>
    readonly refresh_token: FieldRef<"Account", 'String'>
    readonly access_token: FieldRef<"Account", 'String'>
    readonly expires_at: FieldRef<"Account", 'Int'>
    readonly token_type: FieldRef<"Account", 'String'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly id_token: FieldRef<"Account", 'String'>
    readonly session_state: FieldRef<"Account", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model UserSession
   */

  export type AggregateUserSession = {
    _count: UserSessionCountAggregateOutputType | null
    _min: UserSessionMinAggregateOutputType | null
    _max: UserSessionMaxAggregateOutputType | null
  }

  export type UserSessionMinAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type UserSessionMaxAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type UserSessionCountAggregateOutputType = {
    id: number
    sessionToken: number
    userId: number
    expires: number
    _all: number
  }


  export type UserSessionMinAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type UserSessionMaxAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type UserSessionCountAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    _all?: true
  }

  export type UserSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSession to aggregate.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSessions
    **/
    _count?: true | UserSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSessionMaxAggregateInputType
  }

  export type GetUserSessionAggregateType<T extends UserSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSession[P]>
      : GetScalarType<T[P], AggregateUserSession[P]>
  }




  export type UserSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSessionWhereInput
    orderBy?: UserSessionOrderByWithAggregationInput | UserSessionOrderByWithAggregationInput[]
    by: UserSessionScalarFieldEnum[] | UserSessionScalarFieldEnum
    having?: UserSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSessionCountAggregateInputType | true
    _min?: UserSessionMinAggregateInputType
    _max?: UserSessionMaxAggregateInputType
  }

  export type UserSessionGroupByOutputType = {
    id: string
    sessionToken: string
    userId: string
    expires: Date
    _count: UserSessionCountAggregateOutputType | null
    _min: UserSessionMinAggregateOutputType | null
    _max: UserSessionMaxAggregateOutputType | null
  }

  type GetUserSessionGroupByPayload<T extends UserSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSessionGroupByOutputType[P]>
            : GetScalarType<T[P], UserSessionGroupByOutputType[P]>
        }
      >
    >


  export type UserSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSession"]>

  export type UserSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSession"]>

  export type UserSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSession"]>

  export type UserSessionSelectScalar = {
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
  }

  export type UserSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionToken" | "userId" | "expires", ExtArgs["result"]["userSession"]>
  export type UserSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSession"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionToken: string
      userId: string
      expires: Date
    }, ExtArgs["result"]["userSession"]>
    composites: {}
  }

  type UserSessionGetPayload<S extends boolean | null | undefined | UserSessionDefaultArgs> = $Result.GetResult<Prisma.$UserSessionPayload, S>

  type UserSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserSessionCountAggregateInputType | true
    }

  export interface UserSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSession'], meta: { name: 'UserSession' } }
    /**
     * Find zero or one UserSession that matches the filter.
     * @param {UserSessionFindUniqueArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSessionFindUniqueArgs>(args: SelectSubset<T, UserSessionFindUniqueArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserSessionFindUniqueOrThrowArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindFirstArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSessionFindFirstArgs>(args?: SelectSubset<T, UserSessionFindFirstArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindFirstOrThrowArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSessions
     * const userSessions = await prisma.userSession.findMany()
     * 
     * // Get first 10 UserSessions
     * const userSessions = await prisma.userSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userSessionWithIdOnly = await prisma.userSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserSessionFindManyArgs>(args?: SelectSubset<T, UserSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserSession.
     * @param {UserSessionCreateArgs} args - Arguments to create a UserSession.
     * @example
     * // Create one UserSession
     * const UserSession = await prisma.userSession.create({
     *   data: {
     *     // ... data to create a UserSession
     *   }
     * })
     * 
     */
    create<T extends UserSessionCreateArgs>(args: SelectSubset<T, UserSessionCreateArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserSessions.
     * @param {UserSessionCreateManyArgs} args - Arguments to create many UserSessions.
     * @example
     * // Create many UserSessions
     * const userSession = await prisma.userSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSessionCreateManyArgs>(args?: SelectSubset<T, UserSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserSessions and returns the data saved in the database.
     * @param {UserSessionCreateManyAndReturnArgs} args - Arguments to create many UserSessions.
     * @example
     * // Create many UserSessions
     * const userSession = await prisma.userSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserSessions and only return the `id`
     * const userSessionWithIdOnly = await prisma.userSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, UserSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserSession.
     * @param {UserSessionDeleteArgs} args - Arguments to delete one UserSession.
     * @example
     * // Delete one UserSession
     * const UserSession = await prisma.userSession.delete({
     *   where: {
     *     // ... filter to delete one UserSession
     *   }
     * })
     * 
     */
    delete<T extends UserSessionDeleteArgs>(args: SelectSubset<T, UserSessionDeleteArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserSession.
     * @param {UserSessionUpdateArgs} args - Arguments to update one UserSession.
     * @example
     * // Update one UserSession
     * const userSession = await prisma.userSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSessionUpdateArgs>(args: SelectSubset<T, UserSessionUpdateArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserSessions.
     * @param {UserSessionDeleteManyArgs} args - Arguments to filter UserSessions to delete.
     * @example
     * // Delete a few UserSessions
     * const { count } = await prisma.userSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSessionDeleteManyArgs>(args?: SelectSubset<T, UserSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSessions
     * const userSession = await prisma.userSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSessionUpdateManyArgs>(args: SelectSubset<T, UserSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSessions and returns the data updated in the database.
     * @param {UserSessionUpdateManyAndReturnArgs} args - Arguments to update many UserSessions.
     * @example
     * // Update many UserSessions
     * const userSession = await prisma.userSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserSessions and only return the `id`
     * const userSessionWithIdOnly = await prisma.userSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, UserSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserSession.
     * @param {UserSessionUpsertArgs} args - Arguments to update or create a UserSession.
     * @example
     * // Update or create a UserSession
     * const userSession = await prisma.userSession.upsert({
     *   create: {
     *     // ... data to create a UserSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSession we want to update
     *   }
     * })
     */
    upsert<T extends UserSessionUpsertArgs>(args: SelectSubset<T, UserSessionUpsertArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionCountArgs} args - Arguments to filter UserSessions to count.
     * @example
     * // Count the number of UserSessions
     * const count = await prisma.userSession.count({
     *   where: {
     *     // ... the filter for the UserSessions we want to count
     *   }
     * })
    **/
    count<T extends UserSessionCountArgs>(
      args?: Subset<T, UserSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSessionAggregateArgs>(args: Subset<T, UserSessionAggregateArgs>): Prisma.PrismaPromise<GetUserSessionAggregateType<T>>

    /**
     * Group by UserSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSessionGroupByArgs['orderBy'] }
        : { orderBy?: UserSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSession model
   */
  readonly fields: UserSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSession model
   */
  interface UserSessionFieldRefs {
    readonly id: FieldRef<"UserSession", 'String'>
    readonly sessionToken: FieldRef<"UserSession", 'String'>
    readonly userId: FieldRef<"UserSession", 'String'>
    readonly expires: FieldRef<"UserSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserSession findUnique
   */
  export type UserSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession findUniqueOrThrow
   */
  export type UserSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession findFirst
   */
  export type UserSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSessions.
     */
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * UserSession findFirstOrThrow
   */
  export type UserSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSessions.
     */
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * UserSession findMany
   */
  export type UserSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSessions to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * UserSession create
   */
  export type UserSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSession.
     */
    data: XOR<UserSessionCreateInput, UserSessionUncheckedCreateInput>
  }

  /**
   * UserSession createMany
   */
  export type UserSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSessions.
     */
    data: UserSessionCreateManyInput | UserSessionCreateManyInput[]
  }

  /**
   * UserSession createManyAndReturn
   */
  export type UserSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * The data used to create many UserSessions.
     */
    data: UserSessionCreateManyInput | UserSessionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSession update
   */
  export type UserSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSession.
     */
    data: XOR<UserSessionUpdateInput, UserSessionUncheckedUpdateInput>
    /**
     * Choose, which UserSession to update.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession updateMany
   */
  export type UserSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSessions.
     */
    data: XOR<UserSessionUpdateManyMutationInput, UserSessionUncheckedUpdateManyInput>
    /**
     * Filter which UserSessions to update
     */
    where?: UserSessionWhereInput
    /**
     * Limit how many UserSessions to update.
     */
    limit?: number
  }

  /**
   * UserSession updateManyAndReturn
   */
  export type UserSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * The data used to update UserSessions.
     */
    data: XOR<UserSessionUpdateManyMutationInput, UserSessionUncheckedUpdateManyInput>
    /**
     * Filter which UserSessions to update
     */
    where?: UserSessionWhereInput
    /**
     * Limit how many UserSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSession upsert
   */
  export type UserSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSession to update in case it exists.
     */
    where: UserSessionWhereUniqueInput
    /**
     * In case the UserSession found by the `where` argument doesn't exist, create a new UserSession with this data.
     */
    create: XOR<UserSessionCreateInput, UserSessionUncheckedCreateInput>
    /**
     * In case the UserSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSessionUpdateInput, UserSessionUncheckedUpdateInput>
  }

  /**
   * UserSession delete
   */
  export type UserSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter which UserSession to delete.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession deleteMany
   */
  export type UserSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSessions to delete
     */
    where?: UserSessionWhereInput
    /**
     * Limit how many UserSessions to delete.
     */
    limit?: number
  }

  /**
   * UserSession without action
   */
  export type UserSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
  }


  /**
   * Model VerificationToken
   */

  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  export type VerificationTokenMinAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenMaxAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenCountAggregateOutputType = {
    identifier: number
    token: number
    expires: number
    _all: number
  }


  export type VerificationTokenMinAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenMaxAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenCountAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
    _all?: true
  }

  export type VerificationTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationToken to aggregate.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationTokens
    **/
    _count?: true | VerificationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type GetVerificationTokenAggregateType<T extends VerificationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>
  }




  export type VerificationTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationTokenWhereInput
    orderBy?: VerificationTokenOrderByWithAggregationInput | VerificationTokenOrderByWithAggregationInput[]
    by: VerificationTokenScalarFieldEnum[] | VerificationTokenScalarFieldEnum
    having?: VerificationTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationTokenCountAggregateInputType | true
    _min?: VerificationTokenMinAggregateInputType
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type VerificationTokenGroupByOutputType = {
    identifier: string
    token: string
    expires: Date
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  type GetVerificationTokenGroupByPayload<T extends VerificationTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
        }
      >
    >


  export type VerificationTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectScalar = {
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }

  export type VerificationTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"identifier" | "token" | "expires", ExtArgs["result"]["verificationToken"]>

  export type $VerificationTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerificationToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      identifier: string
      token: string
      expires: Date
    }, ExtArgs["result"]["verificationToken"]>
    composites: {}
  }

  type VerificationTokenGetPayload<S extends boolean | null | undefined | VerificationTokenDefaultArgs> = $Result.GetResult<Prisma.$VerificationTokenPayload, S>

  type VerificationTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationTokenCountAggregateInputType | true
    }

  export interface VerificationTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationToken'], meta: { name: 'VerificationToken' } }
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationTokenFindUniqueArgs>(args: SelectSubset<T, VerificationTokenFindUniqueArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VerificationToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationTokenFindFirstArgs>(args?: SelectSubset<T, VerificationTokenFindFirstArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     * 
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     * 
     * // Only select the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.findMany({ select: { identifier: true } })
     * 
     */
    findMany<T extends VerificationTokenFindManyArgs>(args?: SelectSubset<T, VerificationTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     * 
     */
    create<T extends VerificationTokenCreateArgs>(args: SelectSubset<T, VerificationTokenCreateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VerificationTokens.
     * @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationTokenCreateManyArgs>(args?: SelectSubset<T, VerificationTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerificationTokens and returns the data saved in the database.
     * @param {VerificationTokenCreateManyAndReturnArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.createManyAndReturn({
     *   select: { identifier: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     * 
     */
    delete<T extends VerificationTokenDeleteArgs>(args: SelectSubset<T, VerificationTokenDeleteArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationTokenUpdateArgs>(args: SelectSubset<T, VerificationTokenUpdateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationTokenDeleteManyArgs>(args?: SelectSubset<T, VerificationTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationTokenUpdateManyArgs>(args: SelectSubset<T, VerificationTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens and returns the data updated in the database.
     * @param {VerificationTokenUpdateManyAndReturnArgs} args - Arguments to update many VerificationTokens.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.updateManyAndReturn({
     *   select: { identifier: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
     */
    upsert<T extends VerificationTokenUpsertArgs>(args: SelectSubset<T, VerificationTokenUpsertArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
    **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationTokenAggregateArgs>(args: Subset<T, VerificationTokenAggregateArgs>): Prisma.PrismaPromise<GetVerificationTokenAggregateType<T>>

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: VerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerificationToken model
   */
  readonly fields: VerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerificationToken model
   */
  interface VerificationTokenFieldRefs {
    readonly identifier: FieldRef<"VerificationToken", 'String'>
    readonly token: FieldRef<"VerificationToken", 'String'>
    readonly expires: FieldRef<"VerificationToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerificationToken findUnique
   */
  export type VerificationTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findFirst
   */
  export type VerificationTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationTokens to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to create a VerificationToken.
     */
    data: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
  }

  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
  }

  /**
   * VerificationToken createManyAndReturn
   */
  export type VerificationTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
  }

  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to update a VerificationToken.
     */
    data: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
    /**
     * Choose, which VerificationToken to update.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken updateManyAndReturn
   */
  export type VerificationTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     */
    where: VerificationTokenWhereUniqueInput
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     */
    create: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
  }

  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter which VerificationToken to delete.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationTokens to delete
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to delete.
     */
    limit?: number
  }

  /**
   * VerificationToken without action
   */
  export type VerificationTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
  }


  /**
   * Model Settings
   */

  export type AggregateSettings = {
    _count: SettingsCountAggregateOutputType | null
    _min: SettingsMinAggregateOutputType | null
    _max: SettingsMaxAggregateOutputType | null
  }

  export type SettingsMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    siteTitle: string | null
    siteDescription: string | null
    contactEmail: string | null
    contactPhone: string | null
    companyIco: string | null
    companyDic: string | null
    companyBankAccount: string | null
  }

  export type SettingsMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    siteTitle: string | null
    siteDescription: string | null
    contactEmail: string | null
    contactPhone: string | null
    companyIco: string | null
    companyDic: string | null
    companyBankAccount: string | null
  }

  export type SettingsCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    siteTitle: number
    siteDescription: number
    contactEmail: number
    contactPhone: number
    address: number
    socialLinks: number
    defaultSeo: number
    companyIco: number
    companyDic: number
    companyBankAccount: number
    _all: number
  }


  export type SettingsMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    siteTitle?: true
    siteDescription?: true
    contactEmail?: true
    contactPhone?: true
    companyIco?: true
    companyDic?: true
    companyBankAccount?: true
  }

  export type SettingsMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    siteTitle?: true
    siteDescription?: true
    contactEmail?: true
    contactPhone?: true
    companyIco?: true
    companyDic?: true
    companyBankAccount?: true
  }

  export type SettingsCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    siteTitle?: true
    siteDescription?: true
    contactEmail?: true
    contactPhone?: true
    address?: true
    socialLinks?: true
    defaultSeo?: true
    companyIco?: true
    companyDic?: true
    companyBankAccount?: true
    _all?: true
  }

  export type SettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Settings to aggregate.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Settings
    **/
    _count?: true | SettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SettingsMaxAggregateInputType
  }

  export type GetSettingsAggregateType<T extends SettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSettings[P]>
      : GetScalarType<T[P], AggregateSettings[P]>
  }




  export type SettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettingsWhereInput
    orderBy?: SettingsOrderByWithAggregationInput | SettingsOrderByWithAggregationInput[]
    by: SettingsScalarFieldEnum[] | SettingsScalarFieldEnum
    having?: SettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SettingsCountAggregateInputType | true
    _min?: SettingsMinAggregateInputType
    _max?: SettingsMaxAggregateInputType
  }

  export type SettingsGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    siteTitle: string
    siteDescription: string | null
    contactEmail: string | null
    contactPhone: string | null
    address: JsonValue | null
    socialLinks: JsonValue | null
    defaultSeo: JsonValue | null
    companyIco: string | null
    companyDic: string | null
    companyBankAccount: string | null
    _count: SettingsCountAggregateOutputType | null
    _min: SettingsMinAggregateOutputType | null
    _max: SettingsMaxAggregateOutputType | null
  }

  type GetSettingsGroupByPayload<T extends SettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SettingsGroupByOutputType[P]>
            : GetScalarType<T[P], SettingsGroupByOutputType[P]>
        }
      >
    >


  export type SettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    siteTitle?: boolean
    siteDescription?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    address?: boolean
    socialLinks?: boolean
    defaultSeo?: boolean
    companyIco?: boolean
    companyDic?: boolean
    companyBankAccount?: boolean
  }, ExtArgs["result"]["settings"]>

  export type SettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    siteTitle?: boolean
    siteDescription?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    address?: boolean
    socialLinks?: boolean
    defaultSeo?: boolean
    companyIco?: boolean
    companyDic?: boolean
    companyBankAccount?: boolean
  }, ExtArgs["result"]["settings"]>

  export type SettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    siteTitle?: boolean
    siteDescription?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    address?: boolean
    socialLinks?: boolean
    defaultSeo?: boolean
    companyIco?: boolean
    companyDic?: boolean
    companyBankAccount?: boolean
  }, ExtArgs["result"]["settings"]>

  export type SettingsSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    siteTitle?: boolean
    siteDescription?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    address?: boolean
    socialLinks?: boolean
    defaultSeo?: boolean
    companyIco?: boolean
    companyDic?: boolean
    companyBankAccount?: boolean
  }

  export type SettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "siteTitle" | "siteDescription" | "contactEmail" | "contactPhone" | "address" | "socialLinks" | "defaultSeo" | "companyIco" | "companyDic" | "companyBankAccount", ExtArgs["result"]["settings"]>

  export type $SettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Settings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      siteTitle: string
      siteDescription: string | null
      contactEmail: string | null
      contactPhone: string | null
      address: Prisma.JsonValue | null
      socialLinks: Prisma.JsonValue | null
      defaultSeo: Prisma.JsonValue | null
      companyIco: string | null
      companyDic: string | null
      companyBankAccount: string | null
    }, ExtArgs["result"]["settings"]>
    composites: {}
  }

  type SettingsGetPayload<S extends boolean | null | undefined | SettingsDefaultArgs> = $Result.GetResult<Prisma.$SettingsPayload, S>

  type SettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SettingsCountAggregateInputType | true
    }

  export interface SettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Settings'], meta: { name: 'Settings' } }
    /**
     * Find zero or one Settings that matches the filter.
     * @param {SettingsFindUniqueArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SettingsFindUniqueArgs>(args: SelectSubset<T, SettingsFindUniqueArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Settings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SettingsFindUniqueOrThrowArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, SettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsFindFirstArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SettingsFindFirstArgs>(args?: SelectSubset<T, SettingsFindFirstArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Settings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsFindFirstOrThrowArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, SettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Settings
     * const settings = await prisma.settings.findMany()
     * 
     * // Get first 10 Settings
     * const settings = await prisma.settings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const settingsWithIdOnly = await prisma.settings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SettingsFindManyArgs>(args?: SelectSubset<T, SettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Settings.
     * @param {SettingsCreateArgs} args - Arguments to create a Settings.
     * @example
     * // Create one Settings
     * const Settings = await prisma.settings.create({
     *   data: {
     *     // ... data to create a Settings
     *   }
     * })
     * 
     */
    create<T extends SettingsCreateArgs>(args: SelectSubset<T, SettingsCreateArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Settings.
     * @param {SettingsCreateManyArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const settings = await prisma.settings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SettingsCreateManyArgs>(args?: SelectSubset<T, SettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Settings and returns the data saved in the database.
     * @param {SettingsCreateManyAndReturnArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const settings = await prisma.settings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Settings and only return the `id`
     * const settingsWithIdOnly = await prisma.settings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, SettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Settings.
     * @param {SettingsDeleteArgs} args - Arguments to delete one Settings.
     * @example
     * // Delete one Settings
     * const Settings = await prisma.settings.delete({
     *   where: {
     *     // ... filter to delete one Settings
     *   }
     * })
     * 
     */
    delete<T extends SettingsDeleteArgs>(args: SelectSubset<T, SettingsDeleteArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Settings.
     * @param {SettingsUpdateArgs} args - Arguments to update one Settings.
     * @example
     * // Update one Settings
     * const settings = await prisma.settings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SettingsUpdateArgs>(args: SelectSubset<T, SettingsUpdateArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Settings.
     * @param {SettingsDeleteManyArgs} args - Arguments to filter Settings to delete.
     * @example
     * // Delete a few Settings
     * const { count } = await prisma.settings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SettingsDeleteManyArgs>(args?: SelectSubset<T, SettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Settings
     * const settings = await prisma.settings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SettingsUpdateManyArgs>(args: SelectSubset<T, SettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings and returns the data updated in the database.
     * @param {SettingsUpdateManyAndReturnArgs} args - Arguments to update many Settings.
     * @example
     * // Update many Settings
     * const settings = await prisma.settings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Settings and only return the `id`
     * const settingsWithIdOnly = await prisma.settings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, SettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Settings.
     * @param {SettingsUpsertArgs} args - Arguments to update or create a Settings.
     * @example
     * // Update or create a Settings
     * const settings = await prisma.settings.upsert({
     *   create: {
     *     // ... data to create a Settings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Settings we want to update
     *   }
     * })
     */
    upsert<T extends SettingsUpsertArgs>(args: SelectSubset<T, SettingsUpsertArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsCountArgs} args - Arguments to filter Settings to count.
     * @example
     * // Count the number of Settings
     * const count = await prisma.settings.count({
     *   where: {
     *     // ... the filter for the Settings we want to count
     *   }
     * })
    **/
    count<T extends SettingsCountArgs>(
      args?: Subset<T, SettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SettingsAggregateArgs>(args: Subset<T, SettingsAggregateArgs>): Prisma.PrismaPromise<GetSettingsAggregateType<T>>

    /**
     * Group by Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SettingsGroupByArgs['orderBy'] }
        : { orderBy?: SettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Settings model
   */
  readonly fields: SettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Settings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Settings model
   */
  interface SettingsFieldRefs {
    readonly id: FieldRef<"Settings", 'String'>
    readonly createdAt: FieldRef<"Settings", 'DateTime'>
    readonly updatedAt: FieldRef<"Settings", 'DateTime'>
    readonly siteTitle: FieldRef<"Settings", 'String'>
    readonly siteDescription: FieldRef<"Settings", 'String'>
    readonly contactEmail: FieldRef<"Settings", 'String'>
    readonly contactPhone: FieldRef<"Settings", 'String'>
    readonly address: FieldRef<"Settings", 'Json'>
    readonly socialLinks: FieldRef<"Settings", 'Json'>
    readonly defaultSeo: FieldRef<"Settings", 'Json'>
    readonly companyIco: FieldRef<"Settings", 'String'>
    readonly companyDic: FieldRef<"Settings", 'String'>
    readonly companyBankAccount: FieldRef<"Settings", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Settings findUnique
   */
  export type SettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings findUniqueOrThrow
   */
  export type SettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings findFirst
   */
  export type SettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * Settings findFirstOrThrow
   */
  export type SettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * Settings findMany
   */
  export type SettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Settings.
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * Settings create
   */
  export type SettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * The data needed to create a Settings.
     */
    data: XOR<SettingsCreateInput, SettingsUncheckedCreateInput>
  }

  /**
   * Settings createMany
   */
  export type SettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Settings.
     */
    data: SettingsCreateManyInput | SettingsCreateManyInput[]
  }

  /**
   * Settings createManyAndReturn
   */
  export type SettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * The data used to create many Settings.
     */
    data: SettingsCreateManyInput | SettingsCreateManyInput[]
  }

  /**
   * Settings update
   */
  export type SettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * The data needed to update a Settings.
     */
    data: XOR<SettingsUpdateInput, SettingsUncheckedUpdateInput>
    /**
     * Choose, which Settings to update.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings updateMany
   */
  export type SettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Settings.
     */
    data: XOR<SettingsUpdateManyMutationInput, SettingsUncheckedUpdateManyInput>
    /**
     * Filter which Settings to update
     */
    where?: SettingsWhereInput
    /**
     * Limit how many Settings to update.
     */
    limit?: number
  }

  /**
   * Settings updateManyAndReturn
   */
  export type SettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * The data used to update Settings.
     */
    data: XOR<SettingsUpdateManyMutationInput, SettingsUncheckedUpdateManyInput>
    /**
     * Filter which Settings to update
     */
    where?: SettingsWhereInput
    /**
     * Limit how many Settings to update.
     */
    limit?: number
  }

  /**
   * Settings upsert
   */
  export type SettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * The filter to search for the Settings to update in case it exists.
     */
    where: SettingsWhereUniqueInput
    /**
     * In case the Settings found by the `where` argument doesn't exist, create a new Settings with this data.
     */
    create: XOR<SettingsCreateInput, SettingsUncheckedCreateInput>
    /**
     * In case the Settings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SettingsUpdateInput, SettingsUncheckedUpdateInput>
  }

  /**
   * Settings delete
   */
  export type SettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter which Settings to delete.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings deleteMany
   */
  export type SettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Settings to delete
     */
    where?: SettingsWhereInput
    /**
     * Limit how many Settings to delete.
     */
    limit?: number
  }

  /**
   * Settings without action
   */
  export type SettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
  }


  /**
   * Model AIUsage
   */

  export type AggregateAIUsage = {
    _count: AIUsageCountAggregateOutputType | null
    _avg: AIUsageAvgAggregateOutputType | null
    _sum: AIUsageSumAggregateOutputType | null
    _min: AIUsageMinAggregateOutputType | null
    _max: AIUsageMaxAggregateOutputType | null
  }

  export type AIUsageAvgAggregateOutputType = {
    promptTokens: number | null
    completionTokens: number | null
    totalTokens: number | null
    latencyMs: number | null
    estimatedCost: number | null
  }

  export type AIUsageSumAggregateOutputType = {
    promptTokens: number | null
    completionTokens: number | null
    totalTokens: number | null
    latencyMs: number | null
    estimatedCost: number | null
  }

  export type AIUsageMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    feature: string | null
    sessionId: string | null
    orderId: string | null
    model: string | null
    promptTokens: number | null
    completionTokens: number | null
    totalTokens: number | null
    latencyMs: number | null
    estimatedCost: number | null
  }

  export type AIUsageMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    feature: string | null
    sessionId: string | null
    orderId: string | null
    model: string | null
    promptTokens: number | null
    completionTokens: number | null
    totalTokens: number | null
    latencyMs: number | null
    estimatedCost: number | null
  }

  export type AIUsageCountAggregateOutputType = {
    id: number
    createdAt: number
    feature: number
    sessionId: number
    orderId: number
    model: number
    promptTokens: number
    completionTokens: number
    totalTokens: number
    latencyMs: number
    estimatedCost: number
    _all: number
  }


  export type AIUsageAvgAggregateInputType = {
    promptTokens?: true
    completionTokens?: true
    totalTokens?: true
    latencyMs?: true
    estimatedCost?: true
  }

  export type AIUsageSumAggregateInputType = {
    promptTokens?: true
    completionTokens?: true
    totalTokens?: true
    latencyMs?: true
    estimatedCost?: true
  }

  export type AIUsageMinAggregateInputType = {
    id?: true
    createdAt?: true
    feature?: true
    sessionId?: true
    orderId?: true
    model?: true
    promptTokens?: true
    completionTokens?: true
    totalTokens?: true
    latencyMs?: true
    estimatedCost?: true
  }

  export type AIUsageMaxAggregateInputType = {
    id?: true
    createdAt?: true
    feature?: true
    sessionId?: true
    orderId?: true
    model?: true
    promptTokens?: true
    completionTokens?: true
    totalTokens?: true
    latencyMs?: true
    estimatedCost?: true
  }

  export type AIUsageCountAggregateInputType = {
    id?: true
    createdAt?: true
    feature?: true
    sessionId?: true
    orderId?: true
    model?: true
    promptTokens?: true
    completionTokens?: true
    totalTokens?: true
    latencyMs?: true
    estimatedCost?: true
    _all?: true
  }

  export type AIUsageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIUsage to aggregate.
     */
    where?: AIUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIUsages to fetch.
     */
    orderBy?: AIUsageOrderByWithRelationInput | AIUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AIUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AIUsages
    **/
    _count?: true | AIUsageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AIUsageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AIUsageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AIUsageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AIUsageMaxAggregateInputType
  }

  export type GetAIUsageAggregateType<T extends AIUsageAggregateArgs> = {
        [P in keyof T & keyof AggregateAIUsage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAIUsage[P]>
      : GetScalarType<T[P], AggregateAIUsage[P]>
  }




  export type AIUsageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIUsageWhereInput
    orderBy?: AIUsageOrderByWithAggregationInput | AIUsageOrderByWithAggregationInput[]
    by: AIUsageScalarFieldEnum[] | AIUsageScalarFieldEnum
    having?: AIUsageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AIUsageCountAggregateInputType | true
    _avg?: AIUsageAvgAggregateInputType
    _sum?: AIUsageSumAggregateInputType
    _min?: AIUsageMinAggregateInputType
    _max?: AIUsageMaxAggregateInputType
  }

  export type AIUsageGroupByOutputType = {
    id: string
    createdAt: Date
    feature: string
    sessionId: string | null
    orderId: string | null
    model: string
    promptTokens: number
    completionTokens: number
    totalTokens: number
    latencyMs: number | null
    estimatedCost: number | null
    _count: AIUsageCountAggregateOutputType | null
    _avg: AIUsageAvgAggregateOutputType | null
    _sum: AIUsageSumAggregateOutputType | null
    _min: AIUsageMinAggregateOutputType | null
    _max: AIUsageMaxAggregateOutputType | null
  }

  type GetAIUsageGroupByPayload<T extends AIUsageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AIUsageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AIUsageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AIUsageGroupByOutputType[P]>
            : GetScalarType<T[P], AIUsageGroupByOutputType[P]>
        }
      >
    >


  export type AIUsageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    feature?: boolean
    sessionId?: boolean
    orderId?: boolean
    model?: boolean
    promptTokens?: boolean
    completionTokens?: boolean
    totalTokens?: boolean
    latencyMs?: boolean
    estimatedCost?: boolean
  }, ExtArgs["result"]["aIUsage"]>

  export type AIUsageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    feature?: boolean
    sessionId?: boolean
    orderId?: boolean
    model?: boolean
    promptTokens?: boolean
    completionTokens?: boolean
    totalTokens?: boolean
    latencyMs?: boolean
    estimatedCost?: boolean
  }, ExtArgs["result"]["aIUsage"]>

  export type AIUsageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    feature?: boolean
    sessionId?: boolean
    orderId?: boolean
    model?: boolean
    promptTokens?: boolean
    completionTokens?: boolean
    totalTokens?: boolean
    latencyMs?: boolean
    estimatedCost?: boolean
  }, ExtArgs["result"]["aIUsage"]>

  export type AIUsageSelectScalar = {
    id?: boolean
    createdAt?: boolean
    feature?: boolean
    sessionId?: boolean
    orderId?: boolean
    model?: boolean
    promptTokens?: boolean
    completionTokens?: boolean
    totalTokens?: boolean
    latencyMs?: boolean
    estimatedCost?: boolean
  }

  export type AIUsageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "feature" | "sessionId" | "orderId" | "model" | "promptTokens" | "completionTokens" | "totalTokens" | "latencyMs" | "estimatedCost", ExtArgs["result"]["aIUsage"]>

  export type $AIUsagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AIUsage"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      feature: string
      sessionId: string | null
      orderId: string | null
      model: string
      promptTokens: number
      completionTokens: number
      totalTokens: number
      latencyMs: number | null
      estimatedCost: number | null
    }, ExtArgs["result"]["aIUsage"]>
    composites: {}
  }

  type AIUsageGetPayload<S extends boolean | null | undefined | AIUsageDefaultArgs> = $Result.GetResult<Prisma.$AIUsagePayload, S>

  type AIUsageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AIUsageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AIUsageCountAggregateInputType | true
    }

  export interface AIUsageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AIUsage'], meta: { name: 'AIUsage' } }
    /**
     * Find zero or one AIUsage that matches the filter.
     * @param {AIUsageFindUniqueArgs} args - Arguments to find a AIUsage
     * @example
     * // Get one AIUsage
     * const aIUsage = await prisma.aIUsage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AIUsageFindUniqueArgs>(args: SelectSubset<T, AIUsageFindUniqueArgs<ExtArgs>>): Prisma__AIUsageClient<$Result.GetResult<Prisma.$AIUsagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AIUsage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AIUsageFindUniqueOrThrowArgs} args - Arguments to find a AIUsage
     * @example
     * // Get one AIUsage
     * const aIUsage = await prisma.aIUsage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AIUsageFindUniqueOrThrowArgs>(args: SelectSubset<T, AIUsageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AIUsageClient<$Result.GetResult<Prisma.$AIUsagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIUsage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIUsageFindFirstArgs} args - Arguments to find a AIUsage
     * @example
     * // Get one AIUsage
     * const aIUsage = await prisma.aIUsage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AIUsageFindFirstArgs>(args?: SelectSubset<T, AIUsageFindFirstArgs<ExtArgs>>): Prisma__AIUsageClient<$Result.GetResult<Prisma.$AIUsagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIUsage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIUsageFindFirstOrThrowArgs} args - Arguments to find a AIUsage
     * @example
     * // Get one AIUsage
     * const aIUsage = await prisma.aIUsage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AIUsageFindFirstOrThrowArgs>(args?: SelectSubset<T, AIUsageFindFirstOrThrowArgs<ExtArgs>>): Prisma__AIUsageClient<$Result.GetResult<Prisma.$AIUsagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AIUsages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIUsageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AIUsages
     * const aIUsages = await prisma.aIUsage.findMany()
     * 
     * // Get first 10 AIUsages
     * const aIUsages = await prisma.aIUsage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aIUsageWithIdOnly = await prisma.aIUsage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AIUsageFindManyArgs>(args?: SelectSubset<T, AIUsageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AIUsage.
     * @param {AIUsageCreateArgs} args - Arguments to create a AIUsage.
     * @example
     * // Create one AIUsage
     * const AIUsage = await prisma.aIUsage.create({
     *   data: {
     *     // ... data to create a AIUsage
     *   }
     * })
     * 
     */
    create<T extends AIUsageCreateArgs>(args: SelectSubset<T, AIUsageCreateArgs<ExtArgs>>): Prisma__AIUsageClient<$Result.GetResult<Prisma.$AIUsagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AIUsages.
     * @param {AIUsageCreateManyArgs} args - Arguments to create many AIUsages.
     * @example
     * // Create many AIUsages
     * const aIUsage = await prisma.aIUsage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AIUsageCreateManyArgs>(args?: SelectSubset<T, AIUsageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AIUsages and returns the data saved in the database.
     * @param {AIUsageCreateManyAndReturnArgs} args - Arguments to create many AIUsages.
     * @example
     * // Create many AIUsages
     * const aIUsage = await prisma.aIUsage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AIUsages and only return the `id`
     * const aIUsageWithIdOnly = await prisma.aIUsage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AIUsageCreateManyAndReturnArgs>(args?: SelectSubset<T, AIUsageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIUsagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AIUsage.
     * @param {AIUsageDeleteArgs} args - Arguments to delete one AIUsage.
     * @example
     * // Delete one AIUsage
     * const AIUsage = await prisma.aIUsage.delete({
     *   where: {
     *     // ... filter to delete one AIUsage
     *   }
     * })
     * 
     */
    delete<T extends AIUsageDeleteArgs>(args: SelectSubset<T, AIUsageDeleteArgs<ExtArgs>>): Prisma__AIUsageClient<$Result.GetResult<Prisma.$AIUsagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AIUsage.
     * @param {AIUsageUpdateArgs} args - Arguments to update one AIUsage.
     * @example
     * // Update one AIUsage
     * const aIUsage = await prisma.aIUsage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AIUsageUpdateArgs>(args: SelectSubset<T, AIUsageUpdateArgs<ExtArgs>>): Prisma__AIUsageClient<$Result.GetResult<Prisma.$AIUsagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AIUsages.
     * @param {AIUsageDeleteManyArgs} args - Arguments to filter AIUsages to delete.
     * @example
     * // Delete a few AIUsages
     * const { count } = await prisma.aIUsage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AIUsageDeleteManyArgs>(args?: SelectSubset<T, AIUsageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIUsageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AIUsages
     * const aIUsage = await prisma.aIUsage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AIUsageUpdateManyArgs>(args: SelectSubset<T, AIUsageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIUsages and returns the data updated in the database.
     * @param {AIUsageUpdateManyAndReturnArgs} args - Arguments to update many AIUsages.
     * @example
     * // Update many AIUsages
     * const aIUsage = await prisma.aIUsage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AIUsages and only return the `id`
     * const aIUsageWithIdOnly = await prisma.aIUsage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AIUsageUpdateManyAndReturnArgs>(args: SelectSubset<T, AIUsageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIUsagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AIUsage.
     * @param {AIUsageUpsertArgs} args - Arguments to update or create a AIUsage.
     * @example
     * // Update or create a AIUsage
     * const aIUsage = await prisma.aIUsage.upsert({
     *   create: {
     *     // ... data to create a AIUsage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AIUsage we want to update
     *   }
     * })
     */
    upsert<T extends AIUsageUpsertArgs>(args: SelectSubset<T, AIUsageUpsertArgs<ExtArgs>>): Prisma__AIUsageClient<$Result.GetResult<Prisma.$AIUsagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AIUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIUsageCountArgs} args - Arguments to filter AIUsages to count.
     * @example
     * // Count the number of AIUsages
     * const count = await prisma.aIUsage.count({
     *   where: {
     *     // ... the filter for the AIUsages we want to count
     *   }
     * })
    **/
    count<T extends AIUsageCountArgs>(
      args?: Subset<T, AIUsageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AIUsageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AIUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIUsageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AIUsageAggregateArgs>(args: Subset<T, AIUsageAggregateArgs>): Prisma.PrismaPromise<GetAIUsageAggregateType<T>>

    /**
     * Group by AIUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIUsageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AIUsageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AIUsageGroupByArgs['orderBy'] }
        : { orderBy?: AIUsageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AIUsageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAIUsageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AIUsage model
   */
  readonly fields: AIUsageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AIUsage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AIUsageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AIUsage model
   */
  interface AIUsageFieldRefs {
    readonly id: FieldRef<"AIUsage", 'String'>
    readonly createdAt: FieldRef<"AIUsage", 'DateTime'>
    readonly feature: FieldRef<"AIUsage", 'String'>
    readonly sessionId: FieldRef<"AIUsage", 'String'>
    readonly orderId: FieldRef<"AIUsage", 'String'>
    readonly model: FieldRef<"AIUsage", 'String'>
    readonly promptTokens: FieldRef<"AIUsage", 'Int'>
    readonly completionTokens: FieldRef<"AIUsage", 'Int'>
    readonly totalTokens: FieldRef<"AIUsage", 'Int'>
    readonly latencyMs: FieldRef<"AIUsage", 'Int'>
    readonly estimatedCost: FieldRef<"AIUsage", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * AIUsage findUnique
   */
  export type AIUsageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsage
     */
    select?: AIUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsage
     */
    omit?: AIUsageOmit<ExtArgs> | null
    /**
     * Filter, which AIUsage to fetch.
     */
    where: AIUsageWhereUniqueInput
  }

  /**
   * AIUsage findUniqueOrThrow
   */
  export type AIUsageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsage
     */
    select?: AIUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsage
     */
    omit?: AIUsageOmit<ExtArgs> | null
    /**
     * Filter, which AIUsage to fetch.
     */
    where: AIUsageWhereUniqueInput
  }

  /**
   * AIUsage findFirst
   */
  export type AIUsageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsage
     */
    select?: AIUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsage
     */
    omit?: AIUsageOmit<ExtArgs> | null
    /**
     * Filter, which AIUsage to fetch.
     */
    where?: AIUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIUsages to fetch.
     */
    orderBy?: AIUsageOrderByWithRelationInput | AIUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIUsages.
     */
    cursor?: AIUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIUsages.
     */
    distinct?: AIUsageScalarFieldEnum | AIUsageScalarFieldEnum[]
  }

  /**
   * AIUsage findFirstOrThrow
   */
  export type AIUsageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsage
     */
    select?: AIUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsage
     */
    omit?: AIUsageOmit<ExtArgs> | null
    /**
     * Filter, which AIUsage to fetch.
     */
    where?: AIUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIUsages to fetch.
     */
    orderBy?: AIUsageOrderByWithRelationInput | AIUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIUsages.
     */
    cursor?: AIUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIUsages.
     */
    distinct?: AIUsageScalarFieldEnum | AIUsageScalarFieldEnum[]
  }

  /**
   * AIUsage findMany
   */
  export type AIUsageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsage
     */
    select?: AIUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsage
     */
    omit?: AIUsageOmit<ExtArgs> | null
    /**
     * Filter, which AIUsages to fetch.
     */
    where?: AIUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIUsages to fetch.
     */
    orderBy?: AIUsageOrderByWithRelationInput | AIUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AIUsages.
     */
    cursor?: AIUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIUsages.
     */
    skip?: number
    distinct?: AIUsageScalarFieldEnum | AIUsageScalarFieldEnum[]
  }

  /**
   * AIUsage create
   */
  export type AIUsageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsage
     */
    select?: AIUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsage
     */
    omit?: AIUsageOmit<ExtArgs> | null
    /**
     * The data needed to create a AIUsage.
     */
    data: XOR<AIUsageCreateInput, AIUsageUncheckedCreateInput>
  }

  /**
   * AIUsage createMany
   */
  export type AIUsageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AIUsages.
     */
    data: AIUsageCreateManyInput | AIUsageCreateManyInput[]
  }

  /**
   * AIUsage createManyAndReturn
   */
  export type AIUsageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsage
     */
    select?: AIUsageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsage
     */
    omit?: AIUsageOmit<ExtArgs> | null
    /**
     * The data used to create many AIUsages.
     */
    data: AIUsageCreateManyInput | AIUsageCreateManyInput[]
  }

  /**
   * AIUsage update
   */
  export type AIUsageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsage
     */
    select?: AIUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsage
     */
    omit?: AIUsageOmit<ExtArgs> | null
    /**
     * The data needed to update a AIUsage.
     */
    data: XOR<AIUsageUpdateInput, AIUsageUncheckedUpdateInput>
    /**
     * Choose, which AIUsage to update.
     */
    where: AIUsageWhereUniqueInput
  }

  /**
   * AIUsage updateMany
   */
  export type AIUsageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AIUsages.
     */
    data: XOR<AIUsageUpdateManyMutationInput, AIUsageUncheckedUpdateManyInput>
    /**
     * Filter which AIUsages to update
     */
    where?: AIUsageWhereInput
    /**
     * Limit how many AIUsages to update.
     */
    limit?: number
  }

  /**
   * AIUsage updateManyAndReturn
   */
  export type AIUsageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsage
     */
    select?: AIUsageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsage
     */
    omit?: AIUsageOmit<ExtArgs> | null
    /**
     * The data used to update AIUsages.
     */
    data: XOR<AIUsageUpdateManyMutationInput, AIUsageUncheckedUpdateManyInput>
    /**
     * Filter which AIUsages to update
     */
    where?: AIUsageWhereInput
    /**
     * Limit how many AIUsages to update.
     */
    limit?: number
  }

  /**
   * AIUsage upsert
   */
  export type AIUsageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsage
     */
    select?: AIUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsage
     */
    omit?: AIUsageOmit<ExtArgs> | null
    /**
     * The filter to search for the AIUsage to update in case it exists.
     */
    where: AIUsageWhereUniqueInput
    /**
     * In case the AIUsage found by the `where` argument doesn't exist, create a new AIUsage with this data.
     */
    create: XOR<AIUsageCreateInput, AIUsageUncheckedCreateInput>
    /**
     * In case the AIUsage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AIUsageUpdateInput, AIUsageUncheckedUpdateInput>
  }

  /**
   * AIUsage delete
   */
  export type AIUsageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsage
     */
    select?: AIUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsage
     */
    omit?: AIUsageOmit<ExtArgs> | null
    /**
     * Filter which AIUsage to delete.
     */
    where: AIUsageWhereUniqueInput
  }

  /**
   * AIUsage deleteMany
   */
  export type AIUsageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIUsages to delete
     */
    where?: AIUsageWhereInput
    /**
     * Limit how many AIUsages to delete.
     */
    limit?: number
  }

  /**
   * AIUsage without action
   */
  export type AIUsageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsage
     */
    select?: AIUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsage
     */
    omit?: AIUsageOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const ProgramScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    title: 'title',
    slug: 'slug',
    category: 'category',
    status: 'status',
    featured: 'featured',
    order: 'order',
    subtitle: 'subtitle',
    excerpt: 'excerpt',
    description: 'description',
    teamSize: 'teamSize',
    minTeamSize: 'minTeamSize',
    maxTeamSize: 'maxTeamSize',
    objectives: 'objectives',
    industryType: 'industryType',
    physicalLevel: 'physicalLevel',
    indoorOutdoor: 'indoorOutdoor',
    duration: 'duration',
    includesCatering: 'includesCatering',
    debriefIncluded: 'debriefIncluded',
    facilitationRequired: 'facilitationRequired',
    technicalRequirements: 'technicalRequirements',
    materialsIncluded: 'materialsIncluded',
    venueRequirements: 'venueRequirements',
    price: 'price',
    pricePerPerson: 'pricePerPerson',
    pricingNotes: 'pricingNotes',
    featuredImageUrl: 'featuredImageUrl',
    featuredImageAlt: 'featuredImageAlt',
    galleryImages: 'galleryImages',
    videoUrl: 'videoUrl',
    seo: 'seo'
  };

  export type ProgramScalarFieldEnum = (typeof ProgramScalarFieldEnum)[keyof typeof ProgramScalarFieldEnum]


  export const ActivityScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    title: 'title',
    slug: 'slug',
    category: 'category',
    status: 'status',
    featured: 'featured',
    order: 'order',
    subtitle: 'subtitle',
    excerpt: 'excerpt',
    description: 'description',
    minParticipants: 'minParticipants',
    maxParticipants: 'maxParticipants',
    idealGroupSize: 'idealGroupSize',
    objectives: 'objectives',
    learningOutcomes: 'learningOutcomes',
    physicalDemand: 'physicalDemand',
    indoorOutdoor: 'indoorOutdoor',
    duration: 'duration',
    materialsNeeded: 'materialsNeeded',
    setupTime: 'setupTime',
    facilitatorGuide: 'facilitatorGuide',
    difficultyLevel: 'difficultyLevel',
    scalable: 'scalable',
    canCombine: 'canCombine',
    price: 'price',
    featuredImageUrl: 'featuredImageUrl',
    featuredImageAlt: 'featuredImageAlt',
    galleryImages: 'galleryImages',
    videoUrl: 'videoUrl',
    instructionPdfUrl: 'instructionPdfUrl',
    seo: 'seo'
  };

  export type ActivityScalarFieldEnum = (typeof ActivityScalarFieldEnum)[keyof typeof ActivityScalarFieldEnum]


  export const ProgramActivityScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    programId: 'programId',
    activityId: 'activityId',
    order: 'order',
    duration: 'duration',
    notes: 'notes'
  };

  export type ProgramActivityScalarFieldEnum = (typeof ProgramActivityScalarFieldEnum)[keyof typeof ProgramActivityScalarFieldEnum]


  export const ExtraScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    title: 'title',
    slug: 'slug',
    category: 'category',
    status: 'status',
    order: 'order',
    excerpt: 'excerpt',
    description: 'description',
    priceFrom: 'priceFrom',
    priceUnit: 'priceUnit',
    featuredImageUrl: 'featuredImageUrl',
    featuredImageAlt: 'featuredImageAlt',
    seo: 'seo'
  };

  export type ExtraScalarFieldEnum = (typeof ExtraScalarFieldEnum)[keyof typeof ExtraScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    programId: 'programId',
    date: 'date',
    endDate: 'endDate',
    venue: 'venue',
    teamSize: 'teamSize',
    teamName: 'teamName',
    companyName: 'companyName',
    industryType: 'industryType',
    objectives: 'objectives',
    customObjectives: 'customObjectives',
    status: 'status',
    isPublic: 'isPublic',
    debriefCompleted: 'debriefCompleted',
    debriefReport: 'debriefReport',
    debriefGeneratedAt: 'debriefGeneratedAt',
    notes: 'notes'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    email: 'email',
    firstName: 'firstName',
    lastName: 'lastName',
    phone: 'phone',
    organization: 'organization',
    organizationType: 'organizationType',
    industryType: 'industryType',
    teamSize: 'teamSize',
    address: 'address',
    billingInfo: 'billingInfo',
    tags: 'tags',
    notes: 'notes',
    gdprConsent: 'gdprConsent',
    averagePaymentDays: 'averagePaymentDays',
    paymentReliability: 'paymentReliability',
    totalInvoiced: 'totalInvoiced',
    totalPaid: 'totalPaid',
    invoiceCount: 'invoiceCount',
    overdueCount: 'overdueCount',
    lastInvoiceDate: 'lastInvoiceDate',
    lastPaymentDate: 'lastPaymentDate'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    orderNumber: 'orderNumber',
    customerId: 'customerId',
    source: 'source',
    status: 'status',
    sessionName: 'sessionName',
    dates: 'dates',
    venue: 'venue',
    teamSize: 'teamSize',
    teamComposition: 'teamComposition',
    objectives: 'objectives',
    customObjectives: 'customObjectives',
    industryType: 'industryType',
    technicalRequirements: 'technicalRequirements',
    pricing: 'pricing',
    paymentMethod: 'paymentMethod',
    paymentDueDate: 'paymentDueDate',
    invoiceEmail: 'invoiceEmail',
    logistics: 'logistics',
    contacts: 'contacts',
    documents: 'documents',
    linkedSessionId: 'linkedSessionId',
    internalNotes: 'internalNotes'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const OrderItemScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    orderId: 'orderId',
    programId: 'programId',
    activityId: 'activityId',
    extraId: 'extraId',
    date: 'date',
    startTime: 'startTime',
    endTime: 'endTime',
    price: 'price',
    notes: 'notes'
  };

  export type OrderItemScalarFieldEnum = (typeof OrderItemScalarFieldEnum)[keyof typeof OrderItemScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    invoiceNumber: 'invoiceNumber',
    status: 'status',
    customerId: 'customerId',
    orderId: 'orderId',
    issueDate: 'issueDate',
    dueDate: 'dueDate',
    paidDate: 'paidDate',
    items: 'items',
    subtotal: 'subtotal',
    vatRate: 'vatRate',
    vatAmount: 'vatAmount',
    totalAmount: 'totalAmount',
    paidAmount: 'paidAmount',
    paymentMethod: 'paymentMethod',
    bankAccount: 'bankAccount',
    variableSymbol: 'variableSymbol',
    currency: 'currency',
    pdfUrl: 'pdfUrl',
    pdfGeneratedAt: 'pdfGeneratedAt',
    textBeforeItems: 'textBeforeItems',
    textAfterItems: 'textAfterItems',
    notes: 'notes'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    emailVerified: 'emailVerified',
    image: 'image',
    password: 'password',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    expires_at: 'expires_at',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const UserSessionScalarFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    userId: 'userId',
    expires: 'expires'
  };

  export type UserSessionScalarFieldEnum = (typeof UserSessionScalarFieldEnum)[keyof typeof UserSessionScalarFieldEnum]


  export const VerificationTokenScalarFieldEnum: {
    identifier: 'identifier',
    token: 'token',
    expires: 'expires'
  };

  export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


  export const SettingsScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    siteTitle: 'siteTitle',
    siteDescription: 'siteDescription',
    contactEmail: 'contactEmail',
    contactPhone: 'contactPhone',
    address: 'address',
    socialLinks: 'socialLinks',
    defaultSeo: 'defaultSeo',
    companyIco: 'companyIco',
    companyDic: 'companyDic',
    companyBankAccount: 'companyBankAccount'
  };

  export type SettingsScalarFieldEnum = (typeof SettingsScalarFieldEnum)[keyof typeof SettingsScalarFieldEnum]


  export const AIUsageScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    feature: 'feature',
    sessionId: 'sessionId',
    orderId: 'orderId',
    model: 'model',
    promptTokens: 'promptTokens',
    completionTokens: 'completionTokens',
    totalTokens: 'totalTokens',
    latencyMs: 'latencyMs',
    estimatedCost: 'estimatedCost'
  };

  export type AIUsageScalarFieldEnum = (typeof AIUsageScalarFieldEnum)[keyof typeof AIUsageScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type ProgramWhereInput = {
    AND?: ProgramWhereInput | ProgramWhereInput[]
    OR?: ProgramWhereInput[]
    NOT?: ProgramWhereInput | ProgramWhereInput[]
    id?: StringFilter<"Program"> | string
    createdAt?: DateTimeFilter<"Program"> | Date | string
    updatedAt?: DateTimeFilter<"Program"> | Date | string
    title?: StringFilter<"Program"> | string
    slug?: StringFilter<"Program"> | string
    category?: StringFilter<"Program"> | string
    status?: StringFilter<"Program"> | string
    featured?: BoolFilter<"Program"> | boolean
    order?: IntFilter<"Program"> | number
    subtitle?: StringNullableFilter<"Program"> | string | null
    excerpt?: StringNullableFilter<"Program"> | string | null
    description?: JsonNullableFilter<"Program">
    teamSize?: IntNullableFilter<"Program"> | number | null
    minTeamSize?: IntNullableFilter<"Program"> | number | null
    maxTeamSize?: IntNullableFilter<"Program"> | number | null
    objectives?: JsonNullableFilter<"Program">
    industryType?: StringNullableFilter<"Program"> | string | null
    physicalLevel?: StringNullableFilter<"Program"> | string | null
    indoorOutdoor?: StringNullableFilter<"Program"> | string | null
    duration?: IntFilter<"Program"> | number
    includesCatering?: BoolFilter<"Program"> | boolean
    debriefIncluded?: BoolFilter<"Program"> | boolean
    facilitationRequired?: BoolFilter<"Program"> | boolean
    technicalRequirements?: JsonNullableFilter<"Program">
    materialsIncluded?: JsonNullableFilter<"Program">
    venueRequirements?: JsonNullableFilter<"Program">
    price?: IntNullableFilter<"Program"> | number | null
    pricePerPerson?: IntNullableFilter<"Program"> | number | null
    pricingNotes?: StringNullableFilter<"Program"> | string | null
    featuredImageUrl?: StringNullableFilter<"Program"> | string | null
    featuredImageAlt?: StringNullableFilter<"Program"> | string | null
    galleryImages?: JsonNullableFilter<"Program">
    videoUrl?: StringNullableFilter<"Program"> | string | null
    seo?: JsonNullableFilter<"Program">
    sessions?: SessionListRelationFilter
    activityLinks?: ProgramActivityListRelationFilter
    orderItems?: OrderItemListRelationFilter
  }

  export type ProgramOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    category?: SortOrder
    status?: SortOrder
    featured?: SortOrder
    order?: SortOrder
    subtitle?: SortOrderInput | SortOrder
    excerpt?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    teamSize?: SortOrderInput | SortOrder
    minTeamSize?: SortOrderInput | SortOrder
    maxTeamSize?: SortOrderInput | SortOrder
    objectives?: SortOrderInput | SortOrder
    industryType?: SortOrderInput | SortOrder
    physicalLevel?: SortOrderInput | SortOrder
    indoorOutdoor?: SortOrderInput | SortOrder
    duration?: SortOrder
    includesCatering?: SortOrder
    debriefIncluded?: SortOrder
    facilitationRequired?: SortOrder
    technicalRequirements?: SortOrderInput | SortOrder
    materialsIncluded?: SortOrderInput | SortOrder
    venueRequirements?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    pricePerPerson?: SortOrderInput | SortOrder
    pricingNotes?: SortOrderInput | SortOrder
    featuredImageUrl?: SortOrderInput | SortOrder
    featuredImageAlt?: SortOrderInput | SortOrder
    galleryImages?: SortOrderInput | SortOrder
    videoUrl?: SortOrderInput | SortOrder
    seo?: SortOrderInput | SortOrder
    sessions?: SessionOrderByRelationAggregateInput
    activityLinks?: ProgramActivityOrderByRelationAggregateInput
    orderItems?: OrderItemOrderByRelationAggregateInput
  }

  export type ProgramWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: ProgramWhereInput | ProgramWhereInput[]
    OR?: ProgramWhereInput[]
    NOT?: ProgramWhereInput | ProgramWhereInput[]
    createdAt?: DateTimeFilter<"Program"> | Date | string
    updatedAt?: DateTimeFilter<"Program"> | Date | string
    title?: StringFilter<"Program"> | string
    category?: StringFilter<"Program"> | string
    status?: StringFilter<"Program"> | string
    featured?: BoolFilter<"Program"> | boolean
    order?: IntFilter<"Program"> | number
    subtitle?: StringNullableFilter<"Program"> | string | null
    excerpt?: StringNullableFilter<"Program"> | string | null
    description?: JsonNullableFilter<"Program">
    teamSize?: IntNullableFilter<"Program"> | number | null
    minTeamSize?: IntNullableFilter<"Program"> | number | null
    maxTeamSize?: IntNullableFilter<"Program"> | number | null
    objectives?: JsonNullableFilter<"Program">
    industryType?: StringNullableFilter<"Program"> | string | null
    physicalLevel?: StringNullableFilter<"Program"> | string | null
    indoorOutdoor?: StringNullableFilter<"Program"> | string | null
    duration?: IntFilter<"Program"> | number
    includesCatering?: BoolFilter<"Program"> | boolean
    debriefIncluded?: BoolFilter<"Program"> | boolean
    facilitationRequired?: BoolFilter<"Program"> | boolean
    technicalRequirements?: JsonNullableFilter<"Program">
    materialsIncluded?: JsonNullableFilter<"Program">
    venueRequirements?: JsonNullableFilter<"Program">
    price?: IntNullableFilter<"Program"> | number | null
    pricePerPerson?: IntNullableFilter<"Program"> | number | null
    pricingNotes?: StringNullableFilter<"Program"> | string | null
    featuredImageUrl?: StringNullableFilter<"Program"> | string | null
    featuredImageAlt?: StringNullableFilter<"Program"> | string | null
    galleryImages?: JsonNullableFilter<"Program">
    videoUrl?: StringNullableFilter<"Program"> | string | null
    seo?: JsonNullableFilter<"Program">
    sessions?: SessionListRelationFilter
    activityLinks?: ProgramActivityListRelationFilter
    orderItems?: OrderItemListRelationFilter
  }, "id" | "slug">

  export type ProgramOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    category?: SortOrder
    status?: SortOrder
    featured?: SortOrder
    order?: SortOrder
    subtitle?: SortOrderInput | SortOrder
    excerpt?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    teamSize?: SortOrderInput | SortOrder
    minTeamSize?: SortOrderInput | SortOrder
    maxTeamSize?: SortOrderInput | SortOrder
    objectives?: SortOrderInput | SortOrder
    industryType?: SortOrderInput | SortOrder
    physicalLevel?: SortOrderInput | SortOrder
    indoorOutdoor?: SortOrderInput | SortOrder
    duration?: SortOrder
    includesCatering?: SortOrder
    debriefIncluded?: SortOrder
    facilitationRequired?: SortOrder
    technicalRequirements?: SortOrderInput | SortOrder
    materialsIncluded?: SortOrderInput | SortOrder
    venueRequirements?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    pricePerPerson?: SortOrderInput | SortOrder
    pricingNotes?: SortOrderInput | SortOrder
    featuredImageUrl?: SortOrderInput | SortOrder
    featuredImageAlt?: SortOrderInput | SortOrder
    galleryImages?: SortOrderInput | SortOrder
    videoUrl?: SortOrderInput | SortOrder
    seo?: SortOrderInput | SortOrder
    _count?: ProgramCountOrderByAggregateInput
    _avg?: ProgramAvgOrderByAggregateInput
    _max?: ProgramMaxOrderByAggregateInput
    _min?: ProgramMinOrderByAggregateInput
    _sum?: ProgramSumOrderByAggregateInput
  }

  export type ProgramScalarWhereWithAggregatesInput = {
    AND?: ProgramScalarWhereWithAggregatesInput | ProgramScalarWhereWithAggregatesInput[]
    OR?: ProgramScalarWhereWithAggregatesInput[]
    NOT?: ProgramScalarWhereWithAggregatesInput | ProgramScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Program"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Program"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Program"> | Date | string
    title?: StringWithAggregatesFilter<"Program"> | string
    slug?: StringWithAggregatesFilter<"Program"> | string
    category?: StringWithAggregatesFilter<"Program"> | string
    status?: StringWithAggregatesFilter<"Program"> | string
    featured?: BoolWithAggregatesFilter<"Program"> | boolean
    order?: IntWithAggregatesFilter<"Program"> | number
    subtitle?: StringNullableWithAggregatesFilter<"Program"> | string | null
    excerpt?: StringNullableWithAggregatesFilter<"Program"> | string | null
    description?: JsonNullableWithAggregatesFilter<"Program">
    teamSize?: IntNullableWithAggregatesFilter<"Program"> | number | null
    minTeamSize?: IntNullableWithAggregatesFilter<"Program"> | number | null
    maxTeamSize?: IntNullableWithAggregatesFilter<"Program"> | number | null
    objectives?: JsonNullableWithAggregatesFilter<"Program">
    industryType?: StringNullableWithAggregatesFilter<"Program"> | string | null
    physicalLevel?: StringNullableWithAggregatesFilter<"Program"> | string | null
    indoorOutdoor?: StringNullableWithAggregatesFilter<"Program"> | string | null
    duration?: IntWithAggregatesFilter<"Program"> | number
    includesCatering?: BoolWithAggregatesFilter<"Program"> | boolean
    debriefIncluded?: BoolWithAggregatesFilter<"Program"> | boolean
    facilitationRequired?: BoolWithAggregatesFilter<"Program"> | boolean
    technicalRequirements?: JsonNullableWithAggregatesFilter<"Program">
    materialsIncluded?: JsonNullableWithAggregatesFilter<"Program">
    venueRequirements?: JsonNullableWithAggregatesFilter<"Program">
    price?: IntNullableWithAggregatesFilter<"Program"> | number | null
    pricePerPerson?: IntNullableWithAggregatesFilter<"Program"> | number | null
    pricingNotes?: StringNullableWithAggregatesFilter<"Program"> | string | null
    featuredImageUrl?: StringNullableWithAggregatesFilter<"Program"> | string | null
    featuredImageAlt?: StringNullableWithAggregatesFilter<"Program"> | string | null
    galleryImages?: JsonNullableWithAggregatesFilter<"Program">
    videoUrl?: StringNullableWithAggregatesFilter<"Program"> | string | null
    seo?: JsonNullableWithAggregatesFilter<"Program">
  }

  export type ActivityWhereInput = {
    AND?: ActivityWhereInput | ActivityWhereInput[]
    OR?: ActivityWhereInput[]
    NOT?: ActivityWhereInput | ActivityWhereInput[]
    id?: StringFilter<"Activity"> | string
    createdAt?: DateTimeFilter<"Activity"> | Date | string
    updatedAt?: DateTimeFilter<"Activity"> | Date | string
    title?: StringFilter<"Activity"> | string
    slug?: StringFilter<"Activity"> | string
    category?: StringFilter<"Activity"> | string
    status?: StringFilter<"Activity"> | string
    featured?: BoolFilter<"Activity"> | boolean
    order?: IntFilter<"Activity"> | number
    subtitle?: StringNullableFilter<"Activity"> | string | null
    excerpt?: StringNullableFilter<"Activity"> | string | null
    description?: JsonNullableFilter<"Activity">
    minParticipants?: IntNullableFilter<"Activity"> | number | null
    maxParticipants?: IntNullableFilter<"Activity"> | number | null
    idealGroupSize?: IntNullableFilter<"Activity"> | number | null
    objectives?: JsonNullableFilter<"Activity">
    learningOutcomes?: JsonNullableFilter<"Activity">
    physicalDemand?: StringNullableFilter<"Activity"> | string | null
    indoorOutdoor?: StringNullableFilter<"Activity"> | string | null
    duration?: IntFilter<"Activity"> | number
    materialsNeeded?: JsonNullableFilter<"Activity">
    setupTime?: IntNullableFilter<"Activity"> | number | null
    facilitatorGuide?: JsonNullableFilter<"Activity">
    difficultyLevel?: StringNullableFilter<"Activity"> | string | null
    scalable?: BoolFilter<"Activity"> | boolean
    canCombine?: BoolFilter<"Activity"> | boolean
    price?: IntNullableFilter<"Activity"> | number | null
    featuredImageUrl?: StringNullableFilter<"Activity"> | string | null
    featuredImageAlt?: StringNullableFilter<"Activity"> | string | null
    galleryImages?: JsonNullableFilter<"Activity">
    videoUrl?: StringNullableFilter<"Activity"> | string | null
    instructionPdfUrl?: StringNullableFilter<"Activity"> | string | null
    seo?: JsonNullableFilter<"Activity">
    programLinks?: ProgramActivityListRelationFilter
    orderItems?: OrderItemListRelationFilter
  }

  export type ActivityOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    category?: SortOrder
    status?: SortOrder
    featured?: SortOrder
    order?: SortOrder
    subtitle?: SortOrderInput | SortOrder
    excerpt?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    minParticipants?: SortOrderInput | SortOrder
    maxParticipants?: SortOrderInput | SortOrder
    idealGroupSize?: SortOrderInput | SortOrder
    objectives?: SortOrderInput | SortOrder
    learningOutcomes?: SortOrderInput | SortOrder
    physicalDemand?: SortOrderInput | SortOrder
    indoorOutdoor?: SortOrderInput | SortOrder
    duration?: SortOrder
    materialsNeeded?: SortOrderInput | SortOrder
    setupTime?: SortOrderInput | SortOrder
    facilitatorGuide?: SortOrderInput | SortOrder
    difficultyLevel?: SortOrderInput | SortOrder
    scalable?: SortOrder
    canCombine?: SortOrder
    price?: SortOrderInput | SortOrder
    featuredImageUrl?: SortOrderInput | SortOrder
    featuredImageAlt?: SortOrderInput | SortOrder
    galleryImages?: SortOrderInput | SortOrder
    videoUrl?: SortOrderInput | SortOrder
    instructionPdfUrl?: SortOrderInput | SortOrder
    seo?: SortOrderInput | SortOrder
    programLinks?: ProgramActivityOrderByRelationAggregateInput
    orderItems?: OrderItemOrderByRelationAggregateInput
  }

  export type ActivityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: ActivityWhereInput | ActivityWhereInput[]
    OR?: ActivityWhereInput[]
    NOT?: ActivityWhereInput | ActivityWhereInput[]
    createdAt?: DateTimeFilter<"Activity"> | Date | string
    updatedAt?: DateTimeFilter<"Activity"> | Date | string
    title?: StringFilter<"Activity"> | string
    category?: StringFilter<"Activity"> | string
    status?: StringFilter<"Activity"> | string
    featured?: BoolFilter<"Activity"> | boolean
    order?: IntFilter<"Activity"> | number
    subtitle?: StringNullableFilter<"Activity"> | string | null
    excerpt?: StringNullableFilter<"Activity"> | string | null
    description?: JsonNullableFilter<"Activity">
    minParticipants?: IntNullableFilter<"Activity"> | number | null
    maxParticipants?: IntNullableFilter<"Activity"> | number | null
    idealGroupSize?: IntNullableFilter<"Activity"> | number | null
    objectives?: JsonNullableFilter<"Activity">
    learningOutcomes?: JsonNullableFilter<"Activity">
    physicalDemand?: StringNullableFilter<"Activity"> | string | null
    indoorOutdoor?: StringNullableFilter<"Activity"> | string | null
    duration?: IntFilter<"Activity"> | number
    materialsNeeded?: JsonNullableFilter<"Activity">
    setupTime?: IntNullableFilter<"Activity"> | number | null
    facilitatorGuide?: JsonNullableFilter<"Activity">
    difficultyLevel?: StringNullableFilter<"Activity"> | string | null
    scalable?: BoolFilter<"Activity"> | boolean
    canCombine?: BoolFilter<"Activity"> | boolean
    price?: IntNullableFilter<"Activity"> | number | null
    featuredImageUrl?: StringNullableFilter<"Activity"> | string | null
    featuredImageAlt?: StringNullableFilter<"Activity"> | string | null
    galleryImages?: JsonNullableFilter<"Activity">
    videoUrl?: StringNullableFilter<"Activity"> | string | null
    instructionPdfUrl?: StringNullableFilter<"Activity"> | string | null
    seo?: JsonNullableFilter<"Activity">
    programLinks?: ProgramActivityListRelationFilter
    orderItems?: OrderItemListRelationFilter
  }, "id" | "slug">

  export type ActivityOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    category?: SortOrder
    status?: SortOrder
    featured?: SortOrder
    order?: SortOrder
    subtitle?: SortOrderInput | SortOrder
    excerpt?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    minParticipants?: SortOrderInput | SortOrder
    maxParticipants?: SortOrderInput | SortOrder
    idealGroupSize?: SortOrderInput | SortOrder
    objectives?: SortOrderInput | SortOrder
    learningOutcomes?: SortOrderInput | SortOrder
    physicalDemand?: SortOrderInput | SortOrder
    indoorOutdoor?: SortOrderInput | SortOrder
    duration?: SortOrder
    materialsNeeded?: SortOrderInput | SortOrder
    setupTime?: SortOrderInput | SortOrder
    facilitatorGuide?: SortOrderInput | SortOrder
    difficultyLevel?: SortOrderInput | SortOrder
    scalable?: SortOrder
    canCombine?: SortOrder
    price?: SortOrderInput | SortOrder
    featuredImageUrl?: SortOrderInput | SortOrder
    featuredImageAlt?: SortOrderInput | SortOrder
    galleryImages?: SortOrderInput | SortOrder
    videoUrl?: SortOrderInput | SortOrder
    instructionPdfUrl?: SortOrderInput | SortOrder
    seo?: SortOrderInput | SortOrder
    _count?: ActivityCountOrderByAggregateInput
    _avg?: ActivityAvgOrderByAggregateInput
    _max?: ActivityMaxOrderByAggregateInput
    _min?: ActivityMinOrderByAggregateInput
    _sum?: ActivitySumOrderByAggregateInput
  }

  export type ActivityScalarWhereWithAggregatesInput = {
    AND?: ActivityScalarWhereWithAggregatesInput | ActivityScalarWhereWithAggregatesInput[]
    OR?: ActivityScalarWhereWithAggregatesInput[]
    NOT?: ActivityScalarWhereWithAggregatesInput | ActivityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Activity"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Activity"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Activity"> | Date | string
    title?: StringWithAggregatesFilter<"Activity"> | string
    slug?: StringWithAggregatesFilter<"Activity"> | string
    category?: StringWithAggregatesFilter<"Activity"> | string
    status?: StringWithAggregatesFilter<"Activity"> | string
    featured?: BoolWithAggregatesFilter<"Activity"> | boolean
    order?: IntWithAggregatesFilter<"Activity"> | number
    subtitle?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    excerpt?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    description?: JsonNullableWithAggregatesFilter<"Activity">
    minParticipants?: IntNullableWithAggregatesFilter<"Activity"> | number | null
    maxParticipants?: IntNullableWithAggregatesFilter<"Activity"> | number | null
    idealGroupSize?: IntNullableWithAggregatesFilter<"Activity"> | number | null
    objectives?: JsonNullableWithAggregatesFilter<"Activity">
    learningOutcomes?: JsonNullableWithAggregatesFilter<"Activity">
    physicalDemand?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    indoorOutdoor?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    duration?: IntWithAggregatesFilter<"Activity"> | number
    materialsNeeded?: JsonNullableWithAggregatesFilter<"Activity">
    setupTime?: IntNullableWithAggregatesFilter<"Activity"> | number | null
    facilitatorGuide?: JsonNullableWithAggregatesFilter<"Activity">
    difficultyLevel?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    scalable?: BoolWithAggregatesFilter<"Activity"> | boolean
    canCombine?: BoolWithAggregatesFilter<"Activity"> | boolean
    price?: IntNullableWithAggregatesFilter<"Activity"> | number | null
    featuredImageUrl?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    featuredImageAlt?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    galleryImages?: JsonNullableWithAggregatesFilter<"Activity">
    videoUrl?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    instructionPdfUrl?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    seo?: JsonNullableWithAggregatesFilter<"Activity">
  }

  export type ProgramActivityWhereInput = {
    AND?: ProgramActivityWhereInput | ProgramActivityWhereInput[]
    OR?: ProgramActivityWhereInput[]
    NOT?: ProgramActivityWhereInput | ProgramActivityWhereInput[]
    id?: StringFilter<"ProgramActivity"> | string
    createdAt?: DateTimeFilter<"ProgramActivity"> | Date | string
    programId?: StringFilter<"ProgramActivity"> | string
    activityId?: StringFilter<"ProgramActivity"> | string
    order?: IntFilter<"ProgramActivity"> | number
    duration?: IntNullableFilter<"ProgramActivity"> | number | null
    notes?: StringNullableFilter<"ProgramActivity"> | string | null
    program?: XOR<ProgramScalarRelationFilter, ProgramWhereInput>
    activity?: XOR<ActivityScalarRelationFilter, ActivityWhereInput>
  }

  export type ProgramActivityOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    programId?: SortOrder
    activityId?: SortOrder
    order?: SortOrder
    duration?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    program?: ProgramOrderByWithRelationInput
    activity?: ActivityOrderByWithRelationInput
  }

  export type ProgramActivityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    programId_activityId?: ProgramActivityProgramIdActivityIdCompoundUniqueInput
    AND?: ProgramActivityWhereInput | ProgramActivityWhereInput[]
    OR?: ProgramActivityWhereInput[]
    NOT?: ProgramActivityWhereInput | ProgramActivityWhereInput[]
    createdAt?: DateTimeFilter<"ProgramActivity"> | Date | string
    programId?: StringFilter<"ProgramActivity"> | string
    activityId?: StringFilter<"ProgramActivity"> | string
    order?: IntFilter<"ProgramActivity"> | number
    duration?: IntNullableFilter<"ProgramActivity"> | number | null
    notes?: StringNullableFilter<"ProgramActivity"> | string | null
    program?: XOR<ProgramScalarRelationFilter, ProgramWhereInput>
    activity?: XOR<ActivityScalarRelationFilter, ActivityWhereInput>
  }, "id" | "programId_activityId">

  export type ProgramActivityOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    programId?: SortOrder
    activityId?: SortOrder
    order?: SortOrder
    duration?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: ProgramActivityCountOrderByAggregateInput
    _avg?: ProgramActivityAvgOrderByAggregateInput
    _max?: ProgramActivityMaxOrderByAggregateInput
    _min?: ProgramActivityMinOrderByAggregateInput
    _sum?: ProgramActivitySumOrderByAggregateInput
  }

  export type ProgramActivityScalarWhereWithAggregatesInput = {
    AND?: ProgramActivityScalarWhereWithAggregatesInput | ProgramActivityScalarWhereWithAggregatesInput[]
    OR?: ProgramActivityScalarWhereWithAggregatesInput[]
    NOT?: ProgramActivityScalarWhereWithAggregatesInput | ProgramActivityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProgramActivity"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ProgramActivity"> | Date | string
    programId?: StringWithAggregatesFilter<"ProgramActivity"> | string
    activityId?: StringWithAggregatesFilter<"ProgramActivity"> | string
    order?: IntWithAggregatesFilter<"ProgramActivity"> | number
    duration?: IntNullableWithAggregatesFilter<"ProgramActivity"> | number | null
    notes?: StringNullableWithAggregatesFilter<"ProgramActivity"> | string | null
  }

  export type ExtraWhereInput = {
    AND?: ExtraWhereInput | ExtraWhereInput[]
    OR?: ExtraWhereInput[]
    NOT?: ExtraWhereInput | ExtraWhereInput[]
    id?: StringFilter<"Extra"> | string
    createdAt?: DateTimeFilter<"Extra"> | Date | string
    updatedAt?: DateTimeFilter<"Extra"> | Date | string
    title?: StringFilter<"Extra"> | string
    slug?: StringFilter<"Extra"> | string
    category?: StringFilter<"Extra"> | string
    status?: StringFilter<"Extra"> | string
    order?: IntFilter<"Extra"> | number
    excerpt?: StringNullableFilter<"Extra"> | string | null
    description?: JsonNullableFilter<"Extra">
    priceFrom?: IntNullableFilter<"Extra"> | number | null
    priceUnit?: StringNullableFilter<"Extra"> | string | null
    featuredImageUrl?: StringNullableFilter<"Extra"> | string | null
    featuredImageAlt?: StringNullableFilter<"Extra"> | string | null
    seo?: JsonNullableFilter<"Extra">
    orderItems?: OrderItemListRelationFilter
  }

  export type ExtraOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    category?: SortOrder
    status?: SortOrder
    order?: SortOrder
    excerpt?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    priceFrom?: SortOrderInput | SortOrder
    priceUnit?: SortOrderInput | SortOrder
    featuredImageUrl?: SortOrderInput | SortOrder
    featuredImageAlt?: SortOrderInput | SortOrder
    seo?: SortOrderInput | SortOrder
    orderItems?: OrderItemOrderByRelationAggregateInput
  }

  export type ExtraWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: ExtraWhereInput | ExtraWhereInput[]
    OR?: ExtraWhereInput[]
    NOT?: ExtraWhereInput | ExtraWhereInput[]
    createdAt?: DateTimeFilter<"Extra"> | Date | string
    updatedAt?: DateTimeFilter<"Extra"> | Date | string
    title?: StringFilter<"Extra"> | string
    category?: StringFilter<"Extra"> | string
    status?: StringFilter<"Extra"> | string
    order?: IntFilter<"Extra"> | number
    excerpt?: StringNullableFilter<"Extra"> | string | null
    description?: JsonNullableFilter<"Extra">
    priceFrom?: IntNullableFilter<"Extra"> | number | null
    priceUnit?: StringNullableFilter<"Extra"> | string | null
    featuredImageUrl?: StringNullableFilter<"Extra"> | string | null
    featuredImageAlt?: StringNullableFilter<"Extra"> | string | null
    seo?: JsonNullableFilter<"Extra">
    orderItems?: OrderItemListRelationFilter
  }, "id" | "slug">

  export type ExtraOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    category?: SortOrder
    status?: SortOrder
    order?: SortOrder
    excerpt?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    priceFrom?: SortOrderInput | SortOrder
    priceUnit?: SortOrderInput | SortOrder
    featuredImageUrl?: SortOrderInput | SortOrder
    featuredImageAlt?: SortOrderInput | SortOrder
    seo?: SortOrderInput | SortOrder
    _count?: ExtraCountOrderByAggregateInput
    _avg?: ExtraAvgOrderByAggregateInput
    _max?: ExtraMaxOrderByAggregateInput
    _min?: ExtraMinOrderByAggregateInput
    _sum?: ExtraSumOrderByAggregateInput
  }

  export type ExtraScalarWhereWithAggregatesInput = {
    AND?: ExtraScalarWhereWithAggregatesInput | ExtraScalarWhereWithAggregatesInput[]
    OR?: ExtraScalarWhereWithAggregatesInput[]
    NOT?: ExtraScalarWhereWithAggregatesInput | ExtraScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Extra"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Extra"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Extra"> | Date | string
    title?: StringWithAggregatesFilter<"Extra"> | string
    slug?: StringWithAggregatesFilter<"Extra"> | string
    category?: StringWithAggregatesFilter<"Extra"> | string
    status?: StringWithAggregatesFilter<"Extra"> | string
    order?: IntWithAggregatesFilter<"Extra"> | number
    excerpt?: StringNullableWithAggregatesFilter<"Extra"> | string | null
    description?: JsonNullableWithAggregatesFilter<"Extra">
    priceFrom?: IntNullableWithAggregatesFilter<"Extra"> | number | null
    priceUnit?: StringNullableWithAggregatesFilter<"Extra"> | string | null
    featuredImageUrl?: StringNullableWithAggregatesFilter<"Extra"> | string | null
    featuredImageAlt?: StringNullableWithAggregatesFilter<"Extra"> | string | null
    seo?: JsonNullableWithAggregatesFilter<"Extra">
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    programId?: StringNullableFilter<"Session"> | string | null
    date?: DateTimeFilter<"Session"> | Date | string
    endDate?: DateTimeNullableFilter<"Session"> | Date | string | null
    venue?: JsonFilter<"Session">
    teamSize?: IntNullableFilter<"Session"> | number | null
    teamName?: StringNullableFilter<"Session"> | string | null
    companyName?: StringNullableFilter<"Session"> | string | null
    industryType?: StringNullableFilter<"Session"> | string | null
    objectives?: JsonNullableFilter<"Session">
    customObjectives?: StringNullableFilter<"Session"> | string | null
    status?: StringFilter<"Session"> | string
    isPublic?: BoolFilter<"Session"> | boolean
    debriefCompleted?: BoolFilter<"Session"> | boolean
    debriefReport?: JsonNullableFilter<"Session">
    debriefGeneratedAt?: DateTimeNullableFilter<"Session"> | Date | string | null
    notes?: StringNullableFilter<"Session"> | string | null
    program?: XOR<ProgramNullableScalarRelationFilter, ProgramWhereInput> | null
    orders?: OrderListRelationFilter
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    programId?: SortOrderInput | SortOrder
    date?: SortOrder
    endDate?: SortOrderInput | SortOrder
    venue?: SortOrder
    teamSize?: SortOrderInput | SortOrder
    teamName?: SortOrderInput | SortOrder
    companyName?: SortOrderInput | SortOrder
    industryType?: SortOrderInput | SortOrder
    objectives?: SortOrderInput | SortOrder
    customObjectives?: SortOrderInput | SortOrder
    status?: SortOrder
    isPublic?: SortOrder
    debriefCompleted?: SortOrder
    debriefReport?: SortOrderInput | SortOrder
    debriefGeneratedAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    program?: ProgramOrderByWithRelationInput
    orders?: OrderOrderByRelationAggregateInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    programId?: StringNullableFilter<"Session"> | string | null
    date?: DateTimeFilter<"Session"> | Date | string
    endDate?: DateTimeNullableFilter<"Session"> | Date | string | null
    venue?: JsonFilter<"Session">
    teamSize?: IntNullableFilter<"Session"> | number | null
    teamName?: StringNullableFilter<"Session"> | string | null
    companyName?: StringNullableFilter<"Session"> | string | null
    industryType?: StringNullableFilter<"Session"> | string | null
    objectives?: JsonNullableFilter<"Session">
    customObjectives?: StringNullableFilter<"Session"> | string | null
    status?: StringFilter<"Session"> | string
    isPublic?: BoolFilter<"Session"> | boolean
    debriefCompleted?: BoolFilter<"Session"> | boolean
    debriefReport?: JsonNullableFilter<"Session">
    debriefGeneratedAt?: DateTimeNullableFilter<"Session"> | Date | string | null
    notes?: StringNullableFilter<"Session"> | string | null
    program?: XOR<ProgramNullableScalarRelationFilter, ProgramWhereInput> | null
    orders?: OrderListRelationFilter
  }, "id">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    programId?: SortOrderInput | SortOrder
    date?: SortOrder
    endDate?: SortOrderInput | SortOrder
    venue?: SortOrder
    teamSize?: SortOrderInput | SortOrder
    teamName?: SortOrderInput | SortOrder
    companyName?: SortOrderInput | SortOrder
    industryType?: SortOrderInput | SortOrder
    objectives?: SortOrderInput | SortOrder
    customObjectives?: SortOrderInput | SortOrder
    status?: SortOrder
    isPublic?: SortOrder
    debriefCompleted?: SortOrder
    debriefReport?: SortOrderInput | SortOrder
    debriefGeneratedAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: SessionCountOrderByAggregateInput
    _avg?: SessionAvgOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
    _sum?: SessionSumOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    programId?: StringNullableWithAggregatesFilter<"Session"> | string | null
    date?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"Session"> | Date | string | null
    venue?: JsonWithAggregatesFilter<"Session">
    teamSize?: IntNullableWithAggregatesFilter<"Session"> | number | null
    teamName?: StringNullableWithAggregatesFilter<"Session"> | string | null
    companyName?: StringNullableWithAggregatesFilter<"Session"> | string | null
    industryType?: StringNullableWithAggregatesFilter<"Session"> | string | null
    objectives?: JsonNullableWithAggregatesFilter<"Session">
    customObjectives?: StringNullableWithAggregatesFilter<"Session"> | string | null
    status?: StringWithAggregatesFilter<"Session"> | string
    isPublic?: BoolWithAggregatesFilter<"Session"> | boolean
    debriefCompleted?: BoolWithAggregatesFilter<"Session"> | boolean
    debriefReport?: JsonNullableWithAggregatesFilter<"Session">
    debriefGeneratedAt?: DateTimeNullableWithAggregatesFilter<"Session"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"Session"> | string | null
  }

  export type CustomerWhereInput = {
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    id?: StringFilter<"Customer"> | string
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    email?: StringFilter<"Customer"> | string
    firstName?: StringFilter<"Customer"> | string
    lastName?: StringFilter<"Customer"> | string
    phone?: StringNullableFilter<"Customer"> | string | null
    organization?: StringNullableFilter<"Customer"> | string | null
    organizationType?: StringNullableFilter<"Customer"> | string | null
    industryType?: StringNullableFilter<"Customer"> | string | null
    teamSize?: IntNullableFilter<"Customer"> | number | null
    address?: JsonNullableFilter<"Customer">
    billingInfo?: JsonNullableFilter<"Customer">
    tags?: JsonNullableFilter<"Customer">
    notes?: StringNullableFilter<"Customer"> | string | null
    gdprConsent?: JsonNullableFilter<"Customer">
    averagePaymentDays?: IntNullableFilter<"Customer"> | number | null
    paymentReliability?: StringNullableFilter<"Customer"> | string | null
    totalInvoiced?: IntFilter<"Customer"> | number
    totalPaid?: IntFilter<"Customer"> | number
    invoiceCount?: IntFilter<"Customer"> | number
    overdueCount?: IntFilter<"Customer"> | number
    lastInvoiceDate?: DateTimeNullableFilter<"Customer"> | Date | string | null
    lastPaymentDate?: DateTimeNullableFilter<"Customer"> | Date | string | null
    orders?: OrderListRelationFilter
    invoices?: InvoiceListRelationFilter
  }

  export type CustomerOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrderInput | SortOrder
    organization?: SortOrderInput | SortOrder
    organizationType?: SortOrderInput | SortOrder
    industryType?: SortOrderInput | SortOrder
    teamSize?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    billingInfo?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    gdprConsent?: SortOrderInput | SortOrder
    averagePaymentDays?: SortOrderInput | SortOrder
    paymentReliability?: SortOrderInput | SortOrder
    totalInvoiced?: SortOrder
    totalPaid?: SortOrder
    invoiceCount?: SortOrder
    overdueCount?: SortOrder
    lastInvoiceDate?: SortOrderInput | SortOrder
    lastPaymentDate?: SortOrderInput | SortOrder
    orders?: OrderOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
  }

  export type CustomerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    firstName?: StringFilter<"Customer"> | string
    lastName?: StringFilter<"Customer"> | string
    phone?: StringNullableFilter<"Customer"> | string | null
    organization?: StringNullableFilter<"Customer"> | string | null
    organizationType?: StringNullableFilter<"Customer"> | string | null
    industryType?: StringNullableFilter<"Customer"> | string | null
    teamSize?: IntNullableFilter<"Customer"> | number | null
    address?: JsonNullableFilter<"Customer">
    billingInfo?: JsonNullableFilter<"Customer">
    tags?: JsonNullableFilter<"Customer">
    notes?: StringNullableFilter<"Customer"> | string | null
    gdprConsent?: JsonNullableFilter<"Customer">
    averagePaymentDays?: IntNullableFilter<"Customer"> | number | null
    paymentReliability?: StringNullableFilter<"Customer"> | string | null
    totalInvoiced?: IntFilter<"Customer"> | number
    totalPaid?: IntFilter<"Customer"> | number
    invoiceCount?: IntFilter<"Customer"> | number
    overdueCount?: IntFilter<"Customer"> | number
    lastInvoiceDate?: DateTimeNullableFilter<"Customer"> | Date | string | null
    lastPaymentDate?: DateTimeNullableFilter<"Customer"> | Date | string | null
    orders?: OrderListRelationFilter
    invoices?: InvoiceListRelationFilter
  }, "id" | "email">

  export type CustomerOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrderInput | SortOrder
    organization?: SortOrderInput | SortOrder
    organizationType?: SortOrderInput | SortOrder
    industryType?: SortOrderInput | SortOrder
    teamSize?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    billingInfo?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    gdprConsent?: SortOrderInput | SortOrder
    averagePaymentDays?: SortOrderInput | SortOrder
    paymentReliability?: SortOrderInput | SortOrder
    totalInvoiced?: SortOrder
    totalPaid?: SortOrder
    invoiceCount?: SortOrder
    overdueCount?: SortOrder
    lastInvoiceDate?: SortOrderInput | SortOrder
    lastPaymentDate?: SortOrderInput | SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _avg?: CustomerAvgOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
    _sum?: CustomerSumOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    OR?: CustomerScalarWhereWithAggregatesInput[]
    NOT?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Customer"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
    email?: StringWithAggregatesFilter<"Customer"> | string
    firstName?: StringWithAggregatesFilter<"Customer"> | string
    lastName?: StringWithAggregatesFilter<"Customer"> | string
    phone?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    organization?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    organizationType?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    industryType?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    teamSize?: IntNullableWithAggregatesFilter<"Customer"> | number | null
    address?: JsonNullableWithAggregatesFilter<"Customer">
    billingInfo?: JsonNullableWithAggregatesFilter<"Customer">
    tags?: JsonNullableWithAggregatesFilter<"Customer">
    notes?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    gdprConsent?: JsonNullableWithAggregatesFilter<"Customer">
    averagePaymentDays?: IntNullableWithAggregatesFilter<"Customer"> | number | null
    paymentReliability?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    totalInvoiced?: IntWithAggregatesFilter<"Customer"> | number
    totalPaid?: IntWithAggregatesFilter<"Customer"> | number
    invoiceCount?: IntWithAggregatesFilter<"Customer"> | number
    overdueCount?: IntWithAggregatesFilter<"Customer"> | number
    lastInvoiceDate?: DateTimeNullableWithAggregatesFilter<"Customer"> | Date | string | null
    lastPaymentDate?: DateTimeNullableWithAggregatesFilter<"Customer"> | Date | string | null
  }

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    id?: StringFilter<"Order"> | string
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    orderNumber?: StringFilter<"Order"> | string
    customerId?: StringNullableFilter<"Order"> | string | null
    source?: StringFilter<"Order"> | string
    status?: StringFilter<"Order"> | string
    sessionName?: StringNullableFilter<"Order"> | string | null
    dates?: JsonFilter<"Order">
    venue?: JsonFilter<"Order">
    teamSize?: IntNullableFilter<"Order"> | number | null
    teamComposition?: JsonNullableFilter<"Order">
    objectives?: JsonNullableFilter<"Order">
    customObjectives?: StringNullableFilter<"Order"> | string | null
    industryType?: StringNullableFilter<"Order"> | string | null
    technicalRequirements?: JsonNullableFilter<"Order">
    pricing?: JsonNullableFilter<"Order">
    paymentMethod?: StringNullableFilter<"Order"> | string | null
    paymentDueDate?: DateTimeNullableFilter<"Order"> | Date | string | null
    invoiceEmail?: StringNullableFilter<"Order"> | string | null
    logistics?: JsonNullableFilter<"Order">
    contacts?: JsonNullableFilter<"Order">
    documents?: JsonNullableFilter<"Order">
    linkedSessionId?: StringNullableFilter<"Order"> | string | null
    internalNotes?: StringNullableFilter<"Order"> | string | null
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    items?: OrderItemListRelationFilter
    linkedSession?: XOR<SessionNullableScalarRelationFilter, SessionWhereInput> | null
    invoices?: InvoiceListRelationFilter
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    orderNumber?: SortOrder
    customerId?: SortOrderInput | SortOrder
    source?: SortOrder
    status?: SortOrder
    sessionName?: SortOrderInput | SortOrder
    dates?: SortOrder
    venue?: SortOrder
    teamSize?: SortOrderInput | SortOrder
    teamComposition?: SortOrderInput | SortOrder
    objectives?: SortOrderInput | SortOrder
    customObjectives?: SortOrderInput | SortOrder
    industryType?: SortOrderInput | SortOrder
    technicalRequirements?: SortOrderInput | SortOrder
    pricing?: SortOrderInput | SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    paymentDueDate?: SortOrderInput | SortOrder
    invoiceEmail?: SortOrderInput | SortOrder
    logistics?: SortOrderInput | SortOrder
    contacts?: SortOrderInput | SortOrder
    documents?: SortOrderInput | SortOrder
    linkedSessionId?: SortOrderInput | SortOrder
    internalNotes?: SortOrderInput | SortOrder
    customer?: CustomerOrderByWithRelationInput
    items?: OrderItemOrderByRelationAggregateInput
    linkedSession?: SessionOrderByWithRelationInput
    invoices?: InvoiceOrderByRelationAggregateInput
  }

  export type OrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    orderNumber?: string
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    customerId?: StringNullableFilter<"Order"> | string | null
    source?: StringFilter<"Order"> | string
    status?: StringFilter<"Order"> | string
    sessionName?: StringNullableFilter<"Order"> | string | null
    dates?: JsonFilter<"Order">
    venue?: JsonFilter<"Order">
    teamSize?: IntNullableFilter<"Order"> | number | null
    teamComposition?: JsonNullableFilter<"Order">
    objectives?: JsonNullableFilter<"Order">
    customObjectives?: StringNullableFilter<"Order"> | string | null
    industryType?: StringNullableFilter<"Order"> | string | null
    technicalRequirements?: JsonNullableFilter<"Order">
    pricing?: JsonNullableFilter<"Order">
    paymentMethod?: StringNullableFilter<"Order"> | string | null
    paymentDueDate?: DateTimeNullableFilter<"Order"> | Date | string | null
    invoiceEmail?: StringNullableFilter<"Order"> | string | null
    logistics?: JsonNullableFilter<"Order">
    contacts?: JsonNullableFilter<"Order">
    documents?: JsonNullableFilter<"Order">
    linkedSessionId?: StringNullableFilter<"Order"> | string | null
    internalNotes?: StringNullableFilter<"Order"> | string | null
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    items?: OrderItemListRelationFilter
    linkedSession?: XOR<SessionNullableScalarRelationFilter, SessionWhereInput> | null
    invoices?: InvoiceListRelationFilter
  }, "id" | "orderNumber">

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    orderNumber?: SortOrder
    customerId?: SortOrderInput | SortOrder
    source?: SortOrder
    status?: SortOrder
    sessionName?: SortOrderInput | SortOrder
    dates?: SortOrder
    venue?: SortOrder
    teamSize?: SortOrderInput | SortOrder
    teamComposition?: SortOrderInput | SortOrder
    objectives?: SortOrderInput | SortOrder
    customObjectives?: SortOrderInput | SortOrder
    industryType?: SortOrderInput | SortOrder
    technicalRequirements?: SortOrderInput | SortOrder
    pricing?: SortOrderInput | SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    paymentDueDate?: SortOrderInput | SortOrder
    invoiceEmail?: SortOrderInput | SortOrder
    logistics?: SortOrderInput | SortOrder
    contacts?: SortOrderInput | SortOrder
    documents?: SortOrderInput | SortOrder
    linkedSessionId?: SortOrderInput | SortOrder
    internalNotes?: SortOrderInput | SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    OR?: OrderScalarWhereWithAggregatesInput[]
    NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Order"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    orderNumber?: StringWithAggregatesFilter<"Order"> | string
    customerId?: StringNullableWithAggregatesFilter<"Order"> | string | null
    source?: StringWithAggregatesFilter<"Order"> | string
    status?: StringWithAggregatesFilter<"Order"> | string
    sessionName?: StringNullableWithAggregatesFilter<"Order"> | string | null
    dates?: JsonWithAggregatesFilter<"Order">
    venue?: JsonWithAggregatesFilter<"Order">
    teamSize?: IntNullableWithAggregatesFilter<"Order"> | number | null
    teamComposition?: JsonNullableWithAggregatesFilter<"Order">
    objectives?: JsonNullableWithAggregatesFilter<"Order">
    customObjectives?: StringNullableWithAggregatesFilter<"Order"> | string | null
    industryType?: StringNullableWithAggregatesFilter<"Order"> | string | null
    technicalRequirements?: JsonNullableWithAggregatesFilter<"Order">
    pricing?: JsonNullableWithAggregatesFilter<"Order">
    paymentMethod?: StringNullableWithAggregatesFilter<"Order"> | string | null
    paymentDueDate?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    invoiceEmail?: StringNullableWithAggregatesFilter<"Order"> | string | null
    logistics?: JsonNullableWithAggregatesFilter<"Order">
    contacts?: JsonNullableWithAggregatesFilter<"Order">
    documents?: JsonNullableWithAggregatesFilter<"Order">
    linkedSessionId?: StringNullableWithAggregatesFilter<"Order"> | string | null
    internalNotes?: StringNullableWithAggregatesFilter<"Order"> | string | null
  }

  export type OrderItemWhereInput = {
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    id?: StringFilter<"OrderItem"> | string
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
    orderId?: StringFilter<"OrderItem"> | string
    programId?: StringNullableFilter<"OrderItem"> | string | null
    activityId?: StringNullableFilter<"OrderItem"> | string | null
    extraId?: StringNullableFilter<"OrderItem"> | string | null
    date?: StringFilter<"OrderItem"> | string
    startTime?: StringNullableFilter<"OrderItem"> | string | null
    endTime?: StringNullableFilter<"OrderItem"> | string | null
    price?: IntFilter<"OrderItem"> | number
    notes?: StringNullableFilter<"OrderItem"> | string | null
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    program?: XOR<ProgramNullableScalarRelationFilter, ProgramWhereInput> | null
    activity?: XOR<ActivityNullableScalarRelationFilter, ActivityWhereInput> | null
    extra?: XOR<ExtraNullableScalarRelationFilter, ExtraWhereInput> | null
  }

  export type OrderItemOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    orderId?: SortOrder
    programId?: SortOrderInput | SortOrder
    activityId?: SortOrderInput | SortOrder
    extraId?: SortOrderInput | SortOrder
    date?: SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    price?: SortOrder
    notes?: SortOrderInput | SortOrder
    order?: OrderOrderByWithRelationInput
    program?: ProgramOrderByWithRelationInput
    activity?: ActivityOrderByWithRelationInput
    extra?: ExtraOrderByWithRelationInput
  }

  export type OrderItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
    orderId?: StringFilter<"OrderItem"> | string
    programId?: StringNullableFilter<"OrderItem"> | string | null
    activityId?: StringNullableFilter<"OrderItem"> | string | null
    extraId?: StringNullableFilter<"OrderItem"> | string | null
    date?: StringFilter<"OrderItem"> | string
    startTime?: StringNullableFilter<"OrderItem"> | string | null
    endTime?: StringNullableFilter<"OrderItem"> | string | null
    price?: IntFilter<"OrderItem"> | number
    notes?: StringNullableFilter<"OrderItem"> | string | null
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    program?: XOR<ProgramNullableScalarRelationFilter, ProgramWhereInput> | null
    activity?: XOR<ActivityNullableScalarRelationFilter, ActivityWhereInput> | null
    extra?: XOR<ExtraNullableScalarRelationFilter, ExtraWhereInput> | null
  }, "id">

  export type OrderItemOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    orderId?: SortOrder
    programId?: SortOrderInput | SortOrder
    activityId?: SortOrderInput | SortOrder
    extraId?: SortOrderInput | SortOrder
    date?: SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    price?: SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: OrderItemCountOrderByAggregateInput
    _avg?: OrderItemAvgOrderByAggregateInput
    _max?: OrderItemMaxOrderByAggregateInput
    _min?: OrderItemMinOrderByAggregateInput
    _sum?: OrderItemSumOrderByAggregateInput
  }

  export type OrderItemScalarWhereWithAggregatesInput = {
    AND?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    OR?: OrderItemScalarWhereWithAggregatesInput[]
    NOT?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OrderItem"> | string
    createdAt?: DateTimeWithAggregatesFilter<"OrderItem"> | Date | string
    orderId?: StringWithAggregatesFilter<"OrderItem"> | string
    programId?: StringNullableWithAggregatesFilter<"OrderItem"> | string | null
    activityId?: StringNullableWithAggregatesFilter<"OrderItem"> | string | null
    extraId?: StringNullableWithAggregatesFilter<"OrderItem"> | string | null
    date?: StringWithAggregatesFilter<"OrderItem"> | string
    startTime?: StringNullableWithAggregatesFilter<"OrderItem"> | string | null
    endTime?: StringNullableWithAggregatesFilter<"OrderItem"> | string | null
    price?: IntWithAggregatesFilter<"OrderItem"> | number
    notes?: StringNullableWithAggregatesFilter<"OrderItem"> | string | null
  }

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    id?: StringFilter<"Invoice"> | string
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    invoiceNumber?: StringFilter<"Invoice"> | string
    status?: StringFilter<"Invoice"> | string
    customerId?: StringFilter<"Invoice"> | string
    orderId?: StringNullableFilter<"Invoice"> | string | null
    issueDate?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    paidDate?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    items?: JsonFilter<"Invoice">
    subtotal?: IntFilter<"Invoice"> | number
    vatRate?: IntNullableFilter<"Invoice"> | number | null
    vatAmount?: IntNullableFilter<"Invoice"> | number | null
    totalAmount?: IntFilter<"Invoice"> | number
    paidAmount?: IntFilter<"Invoice"> | number
    paymentMethod?: StringNullableFilter<"Invoice"> | string | null
    bankAccount?: StringNullableFilter<"Invoice"> | string | null
    variableSymbol?: StringNullableFilter<"Invoice"> | string | null
    currency?: StringFilter<"Invoice"> | string
    pdfUrl?: StringNullableFilter<"Invoice"> | string | null
    pdfGeneratedAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    textBeforeItems?: StringNullableFilter<"Invoice"> | string | null
    textAfterItems?: StringNullableFilter<"Invoice"> | string | null
    notes?: StringNullableFilter<"Invoice"> | string | null
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    order?: XOR<OrderNullableScalarRelationFilter, OrderWhereInput> | null
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    invoiceNumber?: SortOrder
    status?: SortOrder
    customerId?: SortOrder
    orderId?: SortOrderInput | SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    paidDate?: SortOrderInput | SortOrder
    items?: SortOrder
    subtotal?: SortOrder
    vatRate?: SortOrderInput | SortOrder
    vatAmount?: SortOrderInput | SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    bankAccount?: SortOrderInput | SortOrder
    variableSymbol?: SortOrderInput | SortOrder
    currency?: SortOrder
    pdfUrl?: SortOrderInput | SortOrder
    pdfGeneratedAt?: SortOrderInput | SortOrder
    textBeforeItems?: SortOrderInput | SortOrder
    textAfterItems?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    customer?: CustomerOrderByWithRelationInput
    order?: OrderOrderByWithRelationInput
  }

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    invoiceNumber?: string
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    status?: StringFilter<"Invoice"> | string
    customerId?: StringFilter<"Invoice"> | string
    orderId?: StringNullableFilter<"Invoice"> | string | null
    issueDate?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    paidDate?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    items?: JsonFilter<"Invoice">
    subtotal?: IntFilter<"Invoice"> | number
    vatRate?: IntNullableFilter<"Invoice"> | number | null
    vatAmount?: IntNullableFilter<"Invoice"> | number | null
    totalAmount?: IntFilter<"Invoice"> | number
    paidAmount?: IntFilter<"Invoice"> | number
    paymentMethod?: StringNullableFilter<"Invoice"> | string | null
    bankAccount?: StringNullableFilter<"Invoice"> | string | null
    variableSymbol?: StringNullableFilter<"Invoice"> | string | null
    currency?: StringFilter<"Invoice"> | string
    pdfUrl?: StringNullableFilter<"Invoice"> | string | null
    pdfGeneratedAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    textBeforeItems?: StringNullableFilter<"Invoice"> | string | null
    textAfterItems?: StringNullableFilter<"Invoice"> | string | null
    notes?: StringNullableFilter<"Invoice"> | string | null
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    order?: XOR<OrderNullableScalarRelationFilter, OrderWhereInput> | null
  }, "id" | "invoiceNumber">

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    invoiceNumber?: SortOrder
    status?: SortOrder
    customerId?: SortOrder
    orderId?: SortOrderInput | SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    paidDate?: SortOrderInput | SortOrder
    items?: SortOrder
    subtotal?: SortOrder
    vatRate?: SortOrderInput | SortOrder
    vatAmount?: SortOrderInput | SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    bankAccount?: SortOrderInput | SortOrder
    variableSymbol?: SortOrderInput | SortOrder
    currency?: SortOrder
    pdfUrl?: SortOrderInput | SortOrder
    pdfGeneratedAt?: SortOrderInput | SortOrder
    textBeforeItems?: SortOrderInput | SortOrder
    textAfterItems?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    OR?: InvoiceScalarWhereWithAggregatesInput[]
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Invoice"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    invoiceNumber?: StringWithAggregatesFilter<"Invoice"> | string
    status?: StringWithAggregatesFilter<"Invoice"> | string
    customerId?: StringWithAggregatesFilter<"Invoice"> | string
    orderId?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    issueDate?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    dueDate?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    paidDate?: DateTimeNullableWithAggregatesFilter<"Invoice"> | Date | string | null
    items?: JsonWithAggregatesFilter<"Invoice">
    subtotal?: IntWithAggregatesFilter<"Invoice"> | number
    vatRate?: IntNullableWithAggregatesFilter<"Invoice"> | number | null
    vatAmount?: IntNullableWithAggregatesFilter<"Invoice"> | number | null
    totalAmount?: IntWithAggregatesFilter<"Invoice"> | number
    paidAmount?: IntWithAggregatesFilter<"Invoice"> | number
    paymentMethod?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    bankAccount?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    variableSymbol?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    currency?: StringWithAggregatesFilter<"Invoice"> | string
    pdfUrl?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    pdfGeneratedAt?: DateTimeNullableWithAggregatesFilter<"Invoice"> | Date | string | null
    textBeforeItems?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    textAfterItems?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    accounts?: AccountListRelationFilter
    sessions?: UserSessionListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accounts?: AccountOrderByRelationAggregateInput
    sessions?: UserSessionOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    accounts?: AccountListRelationFilter
    sessions?: UserSessionListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringWithAggregatesFilter<"User"> | string
    emailVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "provider_providerAccountId">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    type?: StringWithAggregatesFilter<"Account"> | string
    provider?: StringWithAggregatesFilter<"Account"> | string
    providerAccountId?: StringWithAggregatesFilter<"Account"> | string
    refresh_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    access_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    expires_at?: IntNullableWithAggregatesFilter<"Account"> | number | null
    token_type?: StringNullableWithAggregatesFilter<"Account"> | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    id_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    session_state?: StringNullableWithAggregatesFilter<"Account"> | string | null
  }

  export type UserSessionWhereInput = {
    AND?: UserSessionWhereInput | UserSessionWhereInput[]
    OR?: UserSessionWhereInput[]
    NOT?: UserSessionWhereInput | UserSessionWhereInput[]
    id?: StringFilter<"UserSession"> | string
    sessionToken?: StringFilter<"UserSession"> | string
    userId?: StringFilter<"UserSession"> | string
    expires?: DateTimeFilter<"UserSession"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserSessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionToken?: string
    AND?: UserSessionWhereInput | UserSessionWhereInput[]
    OR?: UserSessionWhereInput[]
    NOT?: UserSessionWhereInput | UserSessionWhereInput[]
    userId?: StringFilter<"UserSession"> | string
    expires?: DateTimeFilter<"UserSession"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "sessionToken">

  export type UserSessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    _count?: UserSessionCountOrderByAggregateInput
    _max?: UserSessionMaxOrderByAggregateInput
    _min?: UserSessionMinOrderByAggregateInput
  }

  export type UserSessionScalarWhereWithAggregatesInput = {
    AND?: UserSessionScalarWhereWithAggregatesInput | UserSessionScalarWhereWithAggregatesInput[]
    OR?: UserSessionScalarWhereWithAggregatesInput[]
    NOT?: UserSessionScalarWhereWithAggregatesInput | UserSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserSession"> | string
    sessionToken?: StringWithAggregatesFilter<"UserSession"> | string
    userId?: StringWithAggregatesFilter<"UserSession"> | string
    expires?: DateTimeWithAggregatesFilter<"UserSession"> | Date | string
  }

  export type VerificationTokenWhereInput = {
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    token?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }

  export type VerificationTokenOrderByWithRelationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenWhereUniqueInput = Prisma.AtLeast<{
    token?: string
    identifier_token?: VerificationTokenIdentifierTokenCompoundUniqueInput
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }, "token" | "identifier_token">

  export type VerificationTokenOrderByWithAggregationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _count?: VerificationTokenCountOrderByAggregateInput
    _max?: VerificationTokenMaxOrderByAggregateInput
    _min?: VerificationTokenMinOrderByAggregateInput
  }

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    OR?: VerificationTokenScalarWhereWithAggregatesInput[]
    NOT?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    identifier?: StringWithAggregatesFilter<"VerificationToken"> | string
    token?: StringWithAggregatesFilter<"VerificationToken"> | string
    expires?: DateTimeWithAggregatesFilter<"VerificationToken"> | Date | string
  }

  export type SettingsWhereInput = {
    AND?: SettingsWhereInput | SettingsWhereInput[]
    OR?: SettingsWhereInput[]
    NOT?: SettingsWhereInput | SettingsWhereInput[]
    id?: StringFilter<"Settings"> | string
    createdAt?: DateTimeFilter<"Settings"> | Date | string
    updatedAt?: DateTimeFilter<"Settings"> | Date | string
    siteTitle?: StringFilter<"Settings"> | string
    siteDescription?: StringNullableFilter<"Settings"> | string | null
    contactEmail?: StringNullableFilter<"Settings"> | string | null
    contactPhone?: StringNullableFilter<"Settings"> | string | null
    address?: JsonNullableFilter<"Settings">
    socialLinks?: JsonNullableFilter<"Settings">
    defaultSeo?: JsonNullableFilter<"Settings">
    companyIco?: StringNullableFilter<"Settings"> | string | null
    companyDic?: StringNullableFilter<"Settings"> | string | null
    companyBankAccount?: StringNullableFilter<"Settings"> | string | null
  }

  export type SettingsOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    siteTitle?: SortOrder
    siteDescription?: SortOrderInput | SortOrder
    contactEmail?: SortOrderInput | SortOrder
    contactPhone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    socialLinks?: SortOrderInput | SortOrder
    defaultSeo?: SortOrderInput | SortOrder
    companyIco?: SortOrderInput | SortOrder
    companyDic?: SortOrderInput | SortOrder
    companyBankAccount?: SortOrderInput | SortOrder
  }

  export type SettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SettingsWhereInput | SettingsWhereInput[]
    OR?: SettingsWhereInput[]
    NOT?: SettingsWhereInput | SettingsWhereInput[]
    createdAt?: DateTimeFilter<"Settings"> | Date | string
    updatedAt?: DateTimeFilter<"Settings"> | Date | string
    siteTitle?: StringFilter<"Settings"> | string
    siteDescription?: StringNullableFilter<"Settings"> | string | null
    contactEmail?: StringNullableFilter<"Settings"> | string | null
    contactPhone?: StringNullableFilter<"Settings"> | string | null
    address?: JsonNullableFilter<"Settings">
    socialLinks?: JsonNullableFilter<"Settings">
    defaultSeo?: JsonNullableFilter<"Settings">
    companyIco?: StringNullableFilter<"Settings"> | string | null
    companyDic?: StringNullableFilter<"Settings"> | string | null
    companyBankAccount?: StringNullableFilter<"Settings"> | string | null
  }, "id">

  export type SettingsOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    siteTitle?: SortOrder
    siteDescription?: SortOrderInput | SortOrder
    contactEmail?: SortOrderInput | SortOrder
    contactPhone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    socialLinks?: SortOrderInput | SortOrder
    defaultSeo?: SortOrderInput | SortOrder
    companyIco?: SortOrderInput | SortOrder
    companyDic?: SortOrderInput | SortOrder
    companyBankAccount?: SortOrderInput | SortOrder
    _count?: SettingsCountOrderByAggregateInput
    _max?: SettingsMaxOrderByAggregateInput
    _min?: SettingsMinOrderByAggregateInput
  }

  export type SettingsScalarWhereWithAggregatesInput = {
    AND?: SettingsScalarWhereWithAggregatesInput | SettingsScalarWhereWithAggregatesInput[]
    OR?: SettingsScalarWhereWithAggregatesInput[]
    NOT?: SettingsScalarWhereWithAggregatesInput | SettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Settings"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Settings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Settings"> | Date | string
    siteTitle?: StringWithAggregatesFilter<"Settings"> | string
    siteDescription?: StringNullableWithAggregatesFilter<"Settings"> | string | null
    contactEmail?: StringNullableWithAggregatesFilter<"Settings"> | string | null
    contactPhone?: StringNullableWithAggregatesFilter<"Settings"> | string | null
    address?: JsonNullableWithAggregatesFilter<"Settings">
    socialLinks?: JsonNullableWithAggregatesFilter<"Settings">
    defaultSeo?: JsonNullableWithAggregatesFilter<"Settings">
    companyIco?: StringNullableWithAggregatesFilter<"Settings"> | string | null
    companyDic?: StringNullableWithAggregatesFilter<"Settings"> | string | null
    companyBankAccount?: StringNullableWithAggregatesFilter<"Settings"> | string | null
  }

  export type AIUsageWhereInput = {
    AND?: AIUsageWhereInput | AIUsageWhereInput[]
    OR?: AIUsageWhereInput[]
    NOT?: AIUsageWhereInput | AIUsageWhereInput[]
    id?: StringFilter<"AIUsage"> | string
    createdAt?: DateTimeFilter<"AIUsage"> | Date | string
    feature?: StringFilter<"AIUsage"> | string
    sessionId?: StringNullableFilter<"AIUsage"> | string | null
    orderId?: StringNullableFilter<"AIUsage"> | string | null
    model?: StringFilter<"AIUsage"> | string
    promptTokens?: IntFilter<"AIUsage"> | number
    completionTokens?: IntFilter<"AIUsage"> | number
    totalTokens?: IntFilter<"AIUsage"> | number
    latencyMs?: IntNullableFilter<"AIUsage"> | number | null
    estimatedCost?: FloatNullableFilter<"AIUsage"> | number | null
  }

  export type AIUsageOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    feature?: SortOrder
    sessionId?: SortOrderInput | SortOrder
    orderId?: SortOrderInput | SortOrder
    model?: SortOrder
    promptTokens?: SortOrder
    completionTokens?: SortOrder
    totalTokens?: SortOrder
    latencyMs?: SortOrderInput | SortOrder
    estimatedCost?: SortOrderInput | SortOrder
  }

  export type AIUsageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AIUsageWhereInput | AIUsageWhereInput[]
    OR?: AIUsageWhereInput[]
    NOT?: AIUsageWhereInput | AIUsageWhereInput[]
    createdAt?: DateTimeFilter<"AIUsage"> | Date | string
    feature?: StringFilter<"AIUsage"> | string
    sessionId?: StringNullableFilter<"AIUsage"> | string | null
    orderId?: StringNullableFilter<"AIUsage"> | string | null
    model?: StringFilter<"AIUsage"> | string
    promptTokens?: IntFilter<"AIUsage"> | number
    completionTokens?: IntFilter<"AIUsage"> | number
    totalTokens?: IntFilter<"AIUsage"> | number
    latencyMs?: IntNullableFilter<"AIUsage"> | number | null
    estimatedCost?: FloatNullableFilter<"AIUsage"> | number | null
  }, "id">

  export type AIUsageOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    feature?: SortOrder
    sessionId?: SortOrderInput | SortOrder
    orderId?: SortOrderInput | SortOrder
    model?: SortOrder
    promptTokens?: SortOrder
    completionTokens?: SortOrder
    totalTokens?: SortOrder
    latencyMs?: SortOrderInput | SortOrder
    estimatedCost?: SortOrderInput | SortOrder
    _count?: AIUsageCountOrderByAggregateInput
    _avg?: AIUsageAvgOrderByAggregateInput
    _max?: AIUsageMaxOrderByAggregateInput
    _min?: AIUsageMinOrderByAggregateInput
    _sum?: AIUsageSumOrderByAggregateInput
  }

  export type AIUsageScalarWhereWithAggregatesInput = {
    AND?: AIUsageScalarWhereWithAggregatesInput | AIUsageScalarWhereWithAggregatesInput[]
    OR?: AIUsageScalarWhereWithAggregatesInput[]
    NOT?: AIUsageScalarWhereWithAggregatesInput | AIUsageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AIUsage"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AIUsage"> | Date | string
    feature?: StringWithAggregatesFilter<"AIUsage"> | string
    sessionId?: StringNullableWithAggregatesFilter<"AIUsage"> | string | null
    orderId?: StringNullableWithAggregatesFilter<"AIUsage"> | string | null
    model?: StringWithAggregatesFilter<"AIUsage"> | string
    promptTokens?: IntWithAggregatesFilter<"AIUsage"> | number
    completionTokens?: IntWithAggregatesFilter<"AIUsage"> | number
    totalTokens?: IntWithAggregatesFilter<"AIUsage"> | number
    latencyMs?: IntNullableWithAggregatesFilter<"AIUsage"> | number | null
    estimatedCost?: FloatNullableWithAggregatesFilter<"AIUsage"> | number | null
  }

  export type ProgramCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title: string
    slug: string
    category?: string
    status?: string
    featured?: boolean
    order?: number
    subtitle?: string | null
    excerpt?: string | null
    description?: NullableJsonNullValueInput | InputJsonValue
    teamSize?: number | null
    minTeamSize?: number | null
    maxTeamSize?: number | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    industryType?: string | null
    physicalLevel?: string | null
    indoorOutdoor?: string | null
    duration: number
    includesCatering?: boolean
    debriefIncluded?: boolean
    facilitationRequired?: boolean
    technicalRequirements?: NullableJsonNullValueInput | InputJsonValue
    materialsIncluded?: NullableJsonNullValueInput | InputJsonValue
    venueRequirements?: NullableJsonNullValueInput | InputJsonValue
    price?: number | null
    pricePerPerson?: number | null
    pricingNotes?: string | null
    featuredImageUrl?: string | null
    featuredImageAlt?: string | null
    galleryImages?: NullableJsonNullValueInput | InputJsonValue
    videoUrl?: string | null
    seo?: NullableJsonNullValueInput | InputJsonValue
    sessions?: SessionCreateNestedManyWithoutProgramInput
    activityLinks?: ProgramActivityCreateNestedManyWithoutProgramInput
    orderItems?: OrderItemCreateNestedManyWithoutProgramInput
  }

  export type ProgramUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title: string
    slug: string
    category?: string
    status?: string
    featured?: boolean
    order?: number
    subtitle?: string | null
    excerpt?: string | null
    description?: NullableJsonNullValueInput | InputJsonValue
    teamSize?: number | null
    minTeamSize?: number | null
    maxTeamSize?: number | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    industryType?: string | null
    physicalLevel?: string | null
    indoorOutdoor?: string | null
    duration: number
    includesCatering?: boolean
    debriefIncluded?: boolean
    facilitationRequired?: boolean
    technicalRequirements?: NullableJsonNullValueInput | InputJsonValue
    materialsIncluded?: NullableJsonNullValueInput | InputJsonValue
    venueRequirements?: NullableJsonNullValueInput | InputJsonValue
    price?: number | null
    pricePerPerson?: number | null
    pricingNotes?: string | null
    featuredImageUrl?: string | null
    featuredImageAlt?: string | null
    galleryImages?: NullableJsonNullValueInput | InputJsonValue
    videoUrl?: string | null
    seo?: NullableJsonNullValueInput | InputJsonValue
    sessions?: SessionUncheckedCreateNestedManyWithoutProgramInput
    activityLinks?: ProgramActivityUncheckedCreateNestedManyWithoutProgramInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProgramInput
  }

  export type ProgramUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableJsonNullValueInput | InputJsonValue
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    minTeamSize?: NullableIntFieldUpdateOperationsInput | number | null
    maxTeamSize?: NullableIntFieldUpdateOperationsInput | number | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    industryType?: NullableStringFieldUpdateOperationsInput | string | null
    physicalLevel?: NullableStringFieldUpdateOperationsInput | string | null
    indoorOutdoor?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    includesCatering?: BoolFieldUpdateOperationsInput | boolean
    debriefIncluded?: BoolFieldUpdateOperationsInput | boolean
    facilitationRequired?: BoolFieldUpdateOperationsInput | boolean
    technicalRequirements?: NullableJsonNullValueInput | InputJsonValue
    materialsIncluded?: NullableJsonNullValueInput | InputJsonValue
    venueRequirements?: NullableJsonNullValueInput | InputJsonValue
    price?: NullableIntFieldUpdateOperationsInput | number | null
    pricePerPerson?: NullableIntFieldUpdateOperationsInput | number | null
    pricingNotes?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    galleryImages?: NullableJsonNullValueInput | InputJsonValue
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    seo?: NullableJsonNullValueInput | InputJsonValue
    sessions?: SessionUpdateManyWithoutProgramNestedInput
    activityLinks?: ProgramActivityUpdateManyWithoutProgramNestedInput
    orderItems?: OrderItemUpdateManyWithoutProgramNestedInput
  }

  export type ProgramUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableJsonNullValueInput | InputJsonValue
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    minTeamSize?: NullableIntFieldUpdateOperationsInput | number | null
    maxTeamSize?: NullableIntFieldUpdateOperationsInput | number | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    industryType?: NullableStringFieldUpdateOperationsInput | string | null
    physicalLevel?: NullableStringFieldUpdateOperationsInput | string | null
    indoorOutdoor?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    includesCatering?: BoolFieldUpdateOperationsInput | boolean
    debriefIncluded?: BoolFieldUpdateOperationsInput | boolean
    facilitationRequired?: BoolFieldUpdateOperationsInput | boolean
    technicalRequirements?: NullableJsonNullValueInput | InputJsonValue
    materialsIncluded?: NullableJsonNullValueInput | InputJsonValue
    venueRequirements?: NullableJsonNullValueInput | InputJsonValue
    price?: NullableIntFieldUpdateOperationsInput | number | null
    pricePerPerson?: NullableIntFieldUpdateOperationsInput | number | null
    pricingNotes?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    galleryImages?: NullableJsonNullValueInput | InputJsonValue
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    seo?: NullableJsonNullValueInput | InputJsonValue
    sessions?: SessionUncheckedUpdateManyWithoutProgramNestedInput
    activityLinks?: ProgramActivityUncheckedUpdateManyWithoutProgramNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type ProgramCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title: string
    slug: string
    category?: string
    status?: string
    featured?: boolean
    order?: number
    subtitle?: string | null
    excerpt?: string | null
    description?: NullableJsonNullValueInput | InputJsonValue
    teamSize?: number | null
    minTeamSize?: number | null
    maxTeamSize?: number | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    industryType?: string | null
    physicalLevel?: string | null
    indoorOutdoor?: string | null
    duration: number
    includesCatering?: boolean
    debriefIncluded?: boolean
    facilitationRequired?: boolean
    technicalRequirements?: NullableJsonNullValueInput | InputJsonValue
    materialsIncluded?: NullableJsonNullValueInput | InputJsonValue
    venueRequirements?: NullableJsonNullValueInput | InputJsonValue
    price?: number | null
    pricePerPerson?: number | null
    pricingNotes?: string | null
    featuredImageUrl?: string | null
    featuredImageAlt?: string | null
    galleryImages?: NullableJsonNullValueInput | InputJsonValue
    videoUrl?: string | null
    seo?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ProgramUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableJsonNullValueInput | InputJsonValue
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    minTeamSize?: NullableIntFieldUpdateOperationsInput | number | null
    maxTeamSize?: NullableIntFieldUpdateOperationsInput | number | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    industryType?: NullableStringFieldUpdateOperationsInput | string | null
    physicalLevel?: NullableStringFieldUpdateOperationsInput | string | null
    indoorOutdoor?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    includesCatering?: BoolFieldUpdateOperationsInput | boolean
    debriefIncluded?: BoolFieldUpdateOperationsInput | boolean
    facilitationRequired?: BoolFieldUpdateOperationsInput | boolean
    technicalRequirements?: NullableJsonNullValueInput | InputJsonValue
    materialsIncluded?: NullableJsonNullValueInput | InputJsonValue
    venueRequirements?: NullableJsonNullValueInput | InputJsonValue
    price?: NullableIntFieldUpdateOperationsInput | number | null
    pricePerPerson?: NullableIntFieldUpdateOperationsInput | number | null
    pricingNotes?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    galleryImages?: NullableJsonNullValueInput | InputJsonValue
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    seo?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ProgramUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableJsonNullValueInput | InputJsonValue
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    minTeamSize?: NullableIntFieldUpdateOperationsInput | number | null
    maxTeamSize?: NullableIntFieldUpdateOperationsInput | number | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    industryType?: NullableStringFieldUpdateOperationsInput | string | null
    physicalLevel?: NullableStringFieldUpdateOperationsInput | string | null
    indoorOutdoor?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    includesCatering?: BoolFieldUpdateOperationsInput | boolean
    debriefIncluded?: BoolFieldUpdateOperationsInput | boolean
    facilitationRequired?: BoolFieldUpdateOperationsInput | boolean
    technicalRequirements?: NullableJsonNullValueInput | InputJsonValue
    materialsIncluded?: NullableJsonNullValueInput | InputJsonValue
    venueRequirements?: NullableJsonNullValueInput | InputJsonValue
    price?: NullableIntFieldUpdateOperationsInput | number | null
    pricePerPerson?: NullableIntFieldUpdateOperationsInput | number | null
    pricingNotes?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    galleryImages?: NullableJsonNullValueInput | InputJsonValue
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    seo?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ActivityCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title: string
    slug: string
    category?: string
    status?: string
    featured?: boolean
    order?: number
    subtitle?: string | null
    excerpt?: string | null
    description?: NullableJsonNullValueInput | InputJsonValue
    minParticipants?: number | null
    maxParticipants?: number | null
    idealGroupSize?: number | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    learningOutcomes?: NullableJsonNullValueInput | InputJsonValue
    physicalDemand?: string | null
    indoorOutdoor?: string | null
    duration: number
    materialsNeeded?: NullableJsonNullValueInput | InputJsonValue
    setupTime?: number | null
    facilitatorGuide?: NullableJsonNullValueInput | InputJsonValue
    difficultyLevel?: string | null
    scalable?: boolean
    canCombine?: boolean
    price?: number | null
    featuredImageUrl?: string | null
    featuredImageAlt?: string | null
    galleryImages?: NullableJsonNullValueInput | InputJsonValue
    videoUrl?: string | null
    instructionPdfUrl?: string | null
    seo?: NullableJsonNullValueInput | InputJsonValue
    programLinks?: ProgramActivityCreateNestedManyWithoutActivityInput
    orderItems?: OrderItemCreateNestedManyWithoutActivityInput
  }

  export type ActivityUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title: string
    slug: string
    category?: string
    status?: string
    featured?: boolean
    order?: number
    subtitle?: string | null
    excerpt?: string | null
    description?: NullableJsonNullValueInput | InputJsonValue
    minParticipants?: number | null
    maxParticipants?: number | null
    idealGroupSize?: number | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    learningOutcomes?: NullableJsonNullValueInput | InputJsonValue
    physicalDemand?: string | null
    indoorOutdoor?: string | null
    duration: number
    materialsNeeded?: NullableJsonNullValueInput | InputJsonValue
    setupTime?: number | null
    facilitatorGuide?: NullableJsonNullValueInput | InputJsonValue
    difficultyLevel?: string | null
    scalable?: boolean
    canCombine?: boolean
    price?: number | null
    featuredImageUrl?: string | null
    featuredImageAlt?: string | null
    galleryImages?: NullableJsonNullValueInput | InputJsonValue
    videoUrl?: string | null
    instructionPdfUrl?: string | null
    seo?: NullableJsonNullValueInput | InputJsonValue
    programLinks?: ProgramActivityUncheckedCreateNestedManyWithoutActivityInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutActivityInput
  }

  export type ActivityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableJsonNullValueInput | InputJsonValue
    minParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    idealGroupSize?: NullableIntFieldUpdateOperationsInput | number | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    learningOutcomes?: NullableJsonNullValueInput | InputJsonValue
    physicalDemand?: NullableStringFieldUpdateOperationsInput | string | null
    indoorOutdoor?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    materialsNeeded?: NullableJsonNullValueInput | InputJsonValue
    setupTime?: NullableIntFieldUpdateOperationsInput | number | null
    facilitatorGuide?: NullableJsonNullValueInput | InputJsonValue
    difficultyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    scalable?: BoolFieldUpdateOperationsInput | boolean
    canCombine?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableIntFieldUpdateOperationsInput | number | null
    featuredImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    galleryImages?: NullableJsonNullValueInput | InputJsonValue
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    instructionPdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    seo?: NullableJsonNullValueInput | InputJsonValue
    programLinks?: ProgramActivityUpdateManyWithoutActivityNestedInput
    orderItems?: OrderItemUpdateManyWithoutActivityNestedInput
  }

  export type ActivityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableJsonNullValueInput | InputJsonValue
    minParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    idealGroupSize?: NullableIntFieldUpdateOperationsInput | number | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    learningOutcomes?: NullableJsonNullValueInput | InputJsonValue
    physicalDemand?: NullableStringFieldUpdateOperationsInput | string | null
    indoorOutdoor?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    materialsNeeded?: NullableJsonNullValueInput | InputJsonValue
    setupTime?: NullableIntFieldUpdateOperationsInput | number | null
    facilitatorGuide?: NullableJsonNullValueInput | InputJsonValue
    difficultyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    scalable?: BoolFieldUpdateOperationsInput | boolean
    canCombine?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableIntFieldUpdateOperationsInput | number | null
    featuredImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    galleryImages?: NullableJsonNullValueInput | InputJsonValue
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    instructionPdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    seo?: NullableJsonNullValueInput | InputJsonValue
    programLinks?: ProgramActivityUncheckedUpdateManyWithoutActivityNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutActivityNestedInput
  }

  export type ActivityCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title: string
    slug: string
    category?: string
    status?: string
    featured?: boolean
    order?: number
    subtitle?: string | null
    excerpt?: string | null
    description?: NullableJsonNullValueInput | InputJsonValue
    minParticipants?: number | null
    maxParticipants?: number | null
    idealGroupSize?: number | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    learningOutcomes?: NullableJsonNullValueInput | InputJsonValue
    physicalDemand?: string | null
    indoorOutdoor?: string | null
    duration: number
    materialsNeeded?: NullableJsonNullValueInput | InputJsonValue
    setupTime?: number | null
    facilitatorGuide?: NullableJsonNullValueInput | InputJsonValue
    difficultyLevel?: string | null
    scalable?: boolean
    canCombine?: boolean
    price?: number | null
    featuredImageUrl?: string | null
    featuredImageAlt?: string | null
    galleryImages?: NullableJsonNullValueInput | InputJsonValue
    videoUrl?: string | null
    instructionPdfUrl?: string | null
    seo?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ActivityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableJsonNullValueInput | InputJsonValue
    minParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    idealGroupSize?: NullableIntFieldUpdateOperationsInput | number | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    learningOutcomes?: NullableJsonNullValueInput | InputJsonValue
    physicalDemand?: NullableStringFieldUpdateOperationsInput | string | null
    indoorOutdoor?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    materialsNeeded?: NullableJsonNullValueInput | InputJsonValue
    setupTime?: NullableIntFieldUpdateOperationsInput | number | null
    facilitatorGuide?: NullableJsonNullValueInput | InputJsonValue
    difficultyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    scalable?: BoolFieldUpdateOperationsInput | boolean
    canCombine?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableIntFieldUpdateOperationsInput | number | null
    featuredImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    galleryImages?: NullableJsonNullValueInput | InputJsonValue
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    instructionPdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    seo?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ActivityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableJsonNullValueInput | InputJsonValue
    minParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    idealGroupSize?: NullableIntFieldUpdateOperationsInput | number | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    learningOutcomes?: NullableJsonNullValueInput | InputJsonValue
    physicalDemand?: NullableStringFieldUpdateOperationsInput | string | null
    indoorOutdoor?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    materialsNeeded?: NullableJsonNullValueInput | InputJsonValue
    setupTime?: NullableIntFieldUpdateOperationsInput | number | null
    facilitatorGuide?: NullableJsonNullValueInput | InputJsonValue
    difficultyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    scalable?: BoolFieldUpdateOperationsInput | boolean
    canCombine?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableIntFieldUpdateOperationsInput | number | null
    featuredImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    galleryImages?: NullableJsonNullValueInput | InputJsonValue
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    instructionPdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    seo?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ProgramActivityCreateInput = {
    id?: string
    createdAt?: Date | string
    order?: number
    duration?: number | null
    notes?: string | null
    program: ProgramCreateNestedOneWithoutActivityLinksInput
    activity: ActivityCreateNestedOneWithoutProgramLinksInput
  }

  export type ProgramActivityUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    programId: string
    activityId: string
    order?: number
    duration?: number | null
    notes?: string | null
  }

  export type ProgramActivityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: IntFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    program?: ProgramUpdateOneRequiredWithoutActivityLinksNestedInput
    activity?: ActivityUpdateOneRequiredWithoutProgramLinksNestedInput
  }

  export type ProgramActivityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    programId?: StringFieldUpdateOperationsInput | string
    activityId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProgramActivityCreateManyInput = {
    id?: string
    createdAt?: Date | string
    programId: string
    activityId: string
    order?: number
    duration?: number | null
    notes?: string | null
  }

  export type ProgramActivityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: IntFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProgramActivityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    programId?: StringFieldUpdateOperationsInput | string
    activityId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExtraCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title: string
    slug: string
    category: string
    status?: string
    order?: number
    excerpt?: string | null
    description?: NullableJsonNullValueInput | InputJsonValue
    priceFrom?: number | null
    priceUnit?: string | null
    featuredImageUrl?: string | null
    featuredImageAlt?: string | null
    seo?: NullableJsonNullValueInput | InputJsonValue
    orderItems?: OrderItemCreateNestedManyWithoutExtraInput
  }

  export type ExtraUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title: string
    slug: string
    category: string
    status?: string
    order?: number
    excerpt?: string | null
    description?: NullableJsonNullValueInput | InputJsonValue
    priceFrom?: number | null
    priceUnit?: string | null
    featuredImageUrl?: string | null
    featuredImageAlt?: string | null
    seo?: NullableJsonNullValueInput | InputJsonValue
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutExtraInput
  }

  export type ExtraUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableJsonNullValueInput | InputJsonValue
    priceFrom?: NullableIntFieldUpdateOperationsInput | number | null
    priceUnit?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    seo?: NullableJsonNullValueInput | InputJsonValue
    orderItems?: OrderItemUpdateManyWithoutExtraNestedInput
  }

  export type ExtraUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableJsonNullValueInput | InputJsonValue
    priceFrom?: NullableIntFieldUpdateOperationsInput | number | null
    priceUnit?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    seo?: NullableJsonNullValueInput | InputJsonValue
    orderItems?: OrderItemUncheckedUpdateManyWithoutExtraNestedInput
  }

  export type ExtraCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title: string
    slug: string
    category: string
    status?: string
    order?: number
    excerpt?: string | null
    description?: NullableJsonNullValueInput | InputJsonValue
    priceFrom?: number | null
    priceUnit?: string | null
    featuredImageUrl?: string | null
    featuredImageAlt?: string | null
    seo?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ExtraUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableJsonNullValueInput | InputJsonValue
    priceFrom?: NullableIntFieldUpdateOperationsInput | number | null
    priceUnit?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    seo?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ExtraUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableJsonNullValueInput | InputJsonValue
    priceFrom?: NullableIntFieldUpdateOperationsInput | number | null
    priceUnit?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    seo?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SessionCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    date: Date | string
    endDate?: Date | string | null
    venue: JsonNullValueInput | InputJsonValue
    teamSize?: number | null
    teamName?: string | null
    companyName?: string | null
    industryType?: string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    customObjectives?: string | null
    status?: string
    isPublic?: boolean
    debriefCompleted?: boolean
    debriefReport?: NullableJsonNullValueInput | InputJsonValue
    debriefGeneratedAt?: Date | string | null
    notes?: string | null
    program?: ProgramCreateNestedOneWithoutSessionsInput
    orders?: OrderCreateNestedManyWithoutLinkedSessionInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    programId?: string | null
    date: Date | string
    endDate?: Date | string | null
    venue: JsonNullValueInput | InputJsonValue
    teamSize?: number | null
    teamName?: string | null
    companyName?: string | null
    industryType?: string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    customObjectives?: string | null
    status?: string
    isPublic?: boolean
    debriefCompleted?: boolean
    debriefReport?: NullableJsonNullValueInput | InputJsonValue
    debriefGeneratedAt?: Date | string | null
    notes?: string | null
    orders?: OrderUncheckedCreateNestedManyWithoutLinkedSessionInput
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    venue?: JsonNullValueInput | InputJsonValue
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    teamName?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    industryType?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    customObjectives?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    debriefCompleted?: BoolFieldUpdateOperationsInput | boolean
    debriefReport?: NullableJsonNullValueInput | InputJsonValue
    debriefGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    program?: ProgramUpdateOneWithoutSessionsNestedInput
    orders?: OrderUpdateManyWithoutLinkedSessionNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    programId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    venue?: JsonNullValueInput | InputJsonValue
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    teamName?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    industryType?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    customObjectives?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    debriefCompleted?: BoolFieldUpdateOperationsInput | boolean
    debriefReport?: NullableJsonNullValueInput | InputJsonValue
    debriefGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: OrderUncheckedUpdateManyWithoutLinkedSessionNestedInput
  }

  export type SessionCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    programId?: string | null
    date: Date | string
    endDate?: Date | string | null
    venue: JsonNullValueInput | InputJsonValue
    teamSize?: number | null
    teamName?: string | null
    companyName?: string | null
    industryType?: string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    customObjectives?: string | null
    status?: string
    isPublic?: boolean
    debriefCompleted?: boolean
    debriefReport?: NullableJsonNullValueInput | InputJsonValue
    debriefGeneratedAt?: Date | string | null
    notes?: string | null
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    venue?: JsonNullValueInput | InputJsonValue
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    teamName?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    industryType?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    customObjectives?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    debriefCompleted?: BoolFieldUpdateOperationsInput | boolean
    debriefReport?: NullableJsonNullValueInput | InputJsonValue
    debriefGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    programId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    venue?: JsonNullValueInput | InputJsonValue
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    teamName?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    industryType?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    customObjectives?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    debriefCompleted?: BoolFieldUpdateOperationsInput | boolean
    debriefReport?: NullableJsonNullValueInput | InputJsonValue
    debriefGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    firstName: string
    lastName: string
    phone?: string | null
    organization?: string | null
    organizationType?: string | null
    industryType?: string | null
    teamSize?: number | null
    address?: NullableJsonNullValueInput | InputJsonValue
    billingInfo?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    gdprConsent?: NullableJsonNullValueInput | InputJsonValue
    averagePaymentDays?: number | null
    paymentReliability?: string | null
    totalInvoiced?: number
    totalPaid?: number
    invoiceCount?: number
    overdueCount?: number
    lastInvoiceDate?: Date | string | null
    lastPaymentDate?: Date | string | null
    orders?: OrderCreateNestedManyWithoutCustomerInput
    invoices?: InvoiceCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    firstName: string
    lastName: string
    phone?: string | null
    organization?: string | null
    organizationType?: string | null
    industryType?: string | null
    teamSize?: number | null
    address?: NullableJsonNullValueInput | InputJsonValue
    billingInfo?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    gdprConsent?: NullableJsonNullValueInput | InputJsonValue
    averagePaymentDays?: number | null
    paymentReliability?: string | null
    totalInvoiced?: number
    totalPaid?: number
    invoiceCount?: number
    overdueCount?: number
    lastInvoiceDate?: Date | string | null
    lastPaymentDate?: Date | string | null
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    organizationType?: NullableStringFieldUpdateOperationsInput | string | null
    industryType?: NullableStringFieldUpdateOperationsInput | string | null
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    address?: NullableJsonNullValueInput | InputJsonValue
    billingInfo?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    gdprConsent?: NullableJsonNullValueInput | InputJsonValue
    averagePaymentDays?: NullableIntFieldUpdateOperationsInput | number | null
    paymentReliability?: NullableStringFieldUpdateOperationsInput | string | null
    totalInvoiced?: IntFieldUpdateOperationsInput | number
    totalPaid?: IntFieldUpdateOperationsInput | number
    invoiceCount?: IntFieldUpdateOperationsInput | number
    overdueCount?: IntFieldUpdateOperationsInput | number
    lastInvoiceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    invoices?: InvoiceUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    organizationType?: NullableStringFieldUpdateOperationsInput | string | null
    industryType?: NullableStringFieldUpdateOperationsInput | string | null
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    address?: NullableJsonNullValueInput | InputJsonValue
    billingInfo?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    gdprConsent?: NullableJsonNullValueInput | InputJsonValue
    averagePaymentDays?: NullableIntFieldUpdateOperationsInput | number | null
    paymentReliability?: NullableStringFieldUpdateOperationsInput | string | null
    totalInvoiced?: IntFieldUpdateOperationsInput | number
    totalPaid?: IntFieldUpdateOperationsInput | number
    invoiceCount?: IntFieldUpdateOperationsInput | number
    overdueCount?: IntFieldUpdateOperationsInput | number
    lastInvoiceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    firstName: string
    lastName: string
    phone?: string | null
    organization?: string | null
    organizationType?: string | null
    industryType?: string | null
    teamSize?: number | null
    address?: NullableJsonNullValueInput | InputJsonValue
    billingInfo?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    gdprConsent?: NullableJsonNullValueInput | InputJsonValue
    averagePaymentDays?: number | null
    paymentReliability?: string | null
    totalInvoiced?: number
    totalPaid?: number
    invoiceCount?: number
    overdueCount?: number
    lastInvoiceDate?: Date | string | null
    lastPaymentDate?: Date | string | null
  }

  export type CustomerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    organizationType?: NullableStringFieldUpdateOperationsInput | string | null
    industryType?: NullableStringFieldUpdateOperationsInput | string | null
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    address?: NullableJsonNullValueInput | InputJsonValue
    billingInfo?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    gdprConsent?: NullableJsonNullValueInput | InputJsonValue
    averagePaymentDays?: NullableIntFieldUpdateOperationsInput | number | null
    paymentReliability?: NullableStringFieldUpdateOperationsInput | string | null
    totalInvoiced?: IntFieldUpdateOperationsInput | number
    totalPaid?: IntFieldUpdateOperationsInput | number
    invoiceCount?: IntFieldUpdateOperationsInput | number
    overdueCount?: IntFieldUpdateOperationsInput | number
    lastInvoiceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CustomerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    organizationType?: NullableStringFieldUpdateOperationsInput | string | null
    industryType?: NullableStringFieldUpdateOperationsInput | string | null
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    address?: NullableJsonNullValueInput | InputJsonValue
    billingInfo?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    gdprConsent?: NullableJsonNullValueInput | InputJsonValue
    averagePaymentDays?: NullableIntFieldUpdateOperationsInput | number | null
    paymentReliability?: NullableStringFieldUpdateOperationsInput | string | null
    totalInvoiced?: IntFieldUpdateOperationsInput | number
    totalPaid?: IntFieldUpdateOperationsInput | number
    invoiceCount?: IntFieldUpdateOperationsInput | number
    overdueCount?: IntFieldUpdateOperationsInput | number
    lastInvoiceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    orderNumber: string
    source?: string
    status?: string
    sessionName?: string | null
    dates: JsonNullValueInput | InputJsonValue
    venue: JsonNullValueInput | InputJsonValue
    teamSize?: number | null
    teamComposition?: NullableJsonNullValueInput | InputJsonValue
    objectives?: NullableJsonNullValueInput | InputJsonValue
    customObjectives?: string | null
    industryType?: string | null
    technicalRequirements?: NullableJsonNullValueInput | InputJsonValue
    pricing?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: string | null
    paymentDueDate?: Date | string | null
    invoiceEmail?: string | null
    logistics?: NullableJsonNullValueInput | InputJsonValue
    contacts?: NullableJsonNullValueInput | InputJsonValue
    documents?: NullableJsonNullValueInput | InputJsonValue
    internalNotes?: string | null
    customer?: CustomerCreateNestedOneWithoutOrdersInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    linkedSession?: SessionCreateNestedOneWithoutOrdersInput
    invoices?: InvoiceCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    orderNumber: string
    customerId?: string | null
    source?: string
    status?: string
    sessionName?: string | null
    dates: JsonNullValueInput | InputJsonValue
    venue: JsonNullValueInput | InputJsonValue
    teamSize?: number | null
    teamComposition?: NullableJsonNullValueInput | InputJsonValue
    objectives?: NullableJsonNullValueInput | InputJsonValue
    customObjectives?: string | null
    industryType?: string | null
    technicalRequirements?: NullableJsonNullValueInput | InputJsonValue
    pricing?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: string | null
    paymentDueDate?: Date | string | null
    invoiceEmail?: string | null
    logistics?: NullableJsonNullValueInput | InputJsonValue
    contacts?: NullableJsonNullValueInput | InputJsonValue
    documents?: NullableJsonNullValueInput | InputJsonValue
    linkedSessionId?: string | null
    internalNotes?: string | null
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sessionName?: NullableStringFieldUpdateOperationsInput | string | null
    dates?: JsonNullValueInput | InputJsonValue
    venue?: JsonNullValueInput | InputJsonValue
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    teamComposition?: NullableJsonNullValueInput | InputJsonValue
    objectives?: NullableJsonNullValueInput | InputJsonValue
    customObjectives?: NullableStringFieldUpdateOperationsInput | string | null
    industryType?: NullableStringFieldUpdateOperationsInput | string | null
    technicalRequirements?: NullableJsonNullValueInput | InputJsonValue
    pricing?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoiceEmail?: NullableStringFieldUpdateOperationsInput | string | null
    logistics?: NullableJsonNullValueInput | InputJsonValue
    contacts?: NullableJsonNullValueInput | InputJsonValue
    documents?: NullableJsonNullValueInput | InputJsonValue
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerUpdateOneWithoutOrdersNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    linkedSession?: SessionUpdateOneWithoutOrdersNestedInput
    invoices?: InvoiceUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sessionName?: NullableStringFieldUpdateOperationsInput | string | null
    dates?: JsonNullValueInput | InputJsonValue
    venue?: JsonNullValueInput | InputJsonValue
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    teamComposition?: NullableJsonNullValueInput | InputJsonValue
    objectives?: NullableJsonNullValueInput | InputJsonValue
    customObjectives?: NullableStringFieldUpdateOperationsInput | string | null
    industryType?: NullableStringFieldUpdateOperationsInput | string | null
    technicalRequirements?: NullableJsonNullValueInput | InputJsonValue
    pricing?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoiceEmail?: NullableStringFieldUpdateOperationsInput | string | null
    logistics?: NullableJsonNullValueInput | InputJsonValue
    contacts?: NullableJsonNullValueInput | InputJsonValue
    documents?: NullableJsonNullValueInput | InputJsonValue
    linkedSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    orderNumber: string
    customerId?: string | null
    source?: string
    status?: string
    sessionName?: string | null
    dates: JsonNullValueInput | InputJsonValue
    venue: JsonNullValueInput | InputJsonValue
    teamSize?: number | null
    teamComposition?: NullableJsonNullValueInput | InputJsonValue
    objectives?: NullableJsonNullValueInput | InputJsonValue
    customObjectives?: string | null
    industryType?: string | null
    technicalRequirements?: NullableJsonNullValueInput | InputJsonValue
    pricing?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: string | null
    paymentDueDate?: Date | string | null
    invoiceEmail?: string | null
    logistics?: NullableJsonNullValueInput | InputJsonValue
    contacts?: NullableJsonNullValueInput | InputJsonValue
    documents?: NullableJsonNullValueInput | InputJsonValue
    linkedSessionId?: string | null
    internalNotes?: string | null
  }

  export type OrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sessionName?: NullableStringFieldUpdateOperationsInput | string | null
    dates?: JsonNullValueInput | InputJsonValue
    venue?: JsonNullValueInput | InputJsonValue
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    teamComposition?: NullableJsonNullValueInput | InputJsonValue
    objectives?: NullableJsonNullValueInput | InputJsonValue
    customObjectives?: NullableStringFieldUpdateOperationsInput | string | null
    industryType?: NullableStringFieldUpdateOperationsInput | string | null
    technicalRequirements?: NullableJsonNullValueInput | InputJsonValue
    pricing?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoiceEmail?: NullableStringFieldUpdateOperationsInput | string | null
    logistics?: NullableJsonNullValueInput | InputJsonValue
    contacts?: NullableJsonNullValueInput | InputJsonValue
    documents?: NullableJsonNullValueInput | InputJsonValue
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sessionName?: NullableStringFieldUpdateOperationsInput | string | null
    dates?: JsonNullValueInput | InputJsonValue
    venue?: JsonNullValueInput | InputJsonValue
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    teamComposition?: NullableJsonNullValueInput | InputJsonValue
    objectives?: NullableJsonNullValueInput | InputJsonValue
    customObjectives?: NullableStringFieldUpdateOperationsInput | string | null
    industryType?: NullableStringFieldUpdateOperationsInput | string | null
    technicalRequirements?: NullableJsonNullValueInput | InputJsonValue
    pricing?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoiceEmail?: NullableStringFieldUpdateOperationsInput | string | null
    logistics?: NullableJsonNullValueInput | InputJsonValue
    contacts?: NullableJsonNullValueInput | InputJsonValue
    documents?: NullableJsonNullValueInput | InputJsonValue
    linkedSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderItemCreateInput = {
    id?: string
    createdAt?: Date | string
    date: string
    startTime?: string | null
    endTime?: string | null
    price?: number
    notes?: string | null
    order: OrderCreateNestedOneWithoutItemsInput
    program?: ProgramCreateNestedOneWithoutOrderItemsInput
    activity?: ActivityCreateNestedOneWithoutOrderItemsInput
    extra?: ExtraCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    orderId: string
    programId?: string | null
    activityId?: string | null
    extraId?: string | null
    date: string
    startTime?: string | null
    endTime?: string | null
    price?: number
    notes?: string | null
  }

  export type OrderItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: StringFieldUpdateOperationsInput | string
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    order?: OrderUpdateOneRequiredWithoutItemsNestedInput
    program?: ProgramUpdateOneWithoutOrderItemsNestedInput
    activity?: ActivityUpdateOneWithoutOrderItemsNestedInput
    extra?: ExtraUpdateOneWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: StringFieldUpdateOperationsInput | string
    programId?: NullableStringFieldUpdateOperationsInput | string | null
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    extraId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: StringFieldUpdateOperationsInput | string
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderItemCreateManyInput = {
    id?: string
    createdAt?: Date | string
    orderId: string
    programId?: string | null
    activityId?: string | null
    extraId?: string | null
    date: string
    startTime?: string | null
    endTime?: string | null
    price?: number
    notes?: string | null
  }

  export type OrderItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: StringFieldUpdateOperationsInput | string
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: StringFieldUpdateOperationsInput | string
    programId?: NullableStringFieldUpdateOperationsInput | string | null
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    extraId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: StringFieldUpdateOperationsInput | string
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InvoiceCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceNumber: string
    status?: string
    issueDate?: Date | string
    dueDate: Date | string
    paidDate?: Date | string | null
    items: JsonNullValueInput | InputJsonValue
    subtotal: number
    vatRate?: number | null
    vatAmount?: number | null
    totalAmount: number
    paidAmount?: number
    paymentMethod?: string | null
    bankAccount?: string | null
    variableSymbol?: string | null
    currency?: string
    pdfUrl?: string | null
    pdfGeneratedAt?: Date | string | null
    textBeforeItems?: string | null
    textAfterItems?: string | null
    notes?: string | null
    customer: CustomerCreateNestedOneWithoutInvoicesInput
    order?: OrderCreateNestedOneWithoutInvoicesInput
  }

  export type InvoiceUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceNumber: string
    status?: string
    customerId: string
    orderId?: string | null
    issueDate?: Date | string
    dueDate: Date | string
    paidDate?: Date | string | null
    items: JsonNullValueInput | InputJsonValue
    subtotal: number
    vatRate?: number | null
    vatAmount?: number | null
    totalAmount: number
    paidAmount?: number
    paymentMethod?: string | null
    bankAccount?: string | null
    variableSymbol?: string | null
    currency?: string
    pdfUrl?: string | null
    pdfGeneratedAt?: Date | string | null
    textBeforeItems?: string | null
    textAfterItems?: string | null
    notes?: string | null
  }

  export type InvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: JsonNullValueInput | InputJsonValue
    subtotal?: IntFieldUpdateOperationsInput | number
    vatRate?: NullableIntFieldUpdateOperationsInput | number | null
    vatAmount?: NullableIntFieldUpdateOperationsInput | number | null
    totalAmount?: IntFieldUpdateOperationsInput | number
    paidAmount?: IntFieldUpdateOperationsInput | number
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    variableSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    pdfGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    textBeforeItems?: NullableStringFieldUpdateOperationsInput | string | null
    textAfterItems?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerUpdateOneRequiredWithoutInvoicesNestedInput
    order?: OrderUpdateOneWithoutInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: JsonNullValueInput | InputJsonValue
    subtotal?: IntFieldUpdateOperationsInput | number
    vatRate?: NullableIntFieldUpdateOperationsInput | number | null
    vatAmount?: NullableIntFieldUpdateOperationsInput | number | null
    totalAmount?: IntFieldUpdateOperationsInput | number
    paidAmount?: IntFieldUpdateOperationsInput | number
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    variableSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    pdfGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    textBeforeItems?: NullableStringFieldUpdateOperationsInput | string | null
    textAfterItems?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InvoiceCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceNumber: string
    status?: string
    customerId: string
    orderId?: string | null
    issueDate?: Date | string
    dueDate: Date | string
    paidDate?: Date | string | null
    items: JsonNullValueInput | InputJsonValue
    subtotal: number
    vatRate?: number | null
    vatAmount?: number | null
    totalAmount: number
    paidAmount?: number
    paymentMethod?: string | null
    bankAccount?: string | null
    variableSymbol?: string | null
    currency?: string
    pdfUrl?: string | null
    pdfGeneratedAt?: Date | string | null
    textBeforeItems?: string | null
    textAfterItems?: string | null
    notes?: string | null
  }

  export type InvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: JsonNullValueInput | InputJsonValue
    subtotal?: IntFieldUpdateOperationsInput | number
    vatRate?: NullableIntFieldUpdateOperationsInput | number | null
    vatAmount?: NullableIntFieldUpdateOperationsInput | number | null
    totalAmount?: IntFieldUpdateOperationsInput | number
    paidAmount?: IntFieldUpdateOperationsInput | number
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    variableSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    pdfGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    textBeforeItems?: NullableStringFieldUpdateOperationsInput | string | null
    textAfterItems?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: JsonNullValueInput | InputJsonValue
    subtotal?: IntFieldUpdateOperationsInput | number
    vatRate?: NullableIntFieldUpdateOperationsInput | number | null
    vatAmount?: NullableIntFieldUpdateOperationsInput | number | null
    totalAmount?: IntFieldUpdateOperationsInput | number
    paidAmount?: IntFieldUpdateOperationsInput | number
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    variableSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    pdfGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    textBeforeItems?: NullableStringFieldUpdateOperationsInput | string | null
    textAfterItems?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserSessionCreateInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type UserSessionUncheckedCreateInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type UserSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type UserSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionCreateManyInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type UserSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUncheckedCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateManyInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateManyMutationInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateManyInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingsCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    siteTitle: string
    siteDescription?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    defaultSeo?: NullableJsonNullValueInput | InputJsonValue
    companyIco?: string | null
    companyDic?: string | null
    companyBankAccount?: string | null
  }

  export type SettingsUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    siteTitle: string
    siteDescription?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    defaultSeo?: NullableJsonNullValueInput | InputJsonValue
    companyIco?: string | null
    companyDic?: string | null
    companyBankAccount?: string | null
  }

  export type SettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    siteTitle?: StringFieldUpdateOperationsInput | string
    siteDescription?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    defaultSeo?: NullableJsonNullValueInput | InputJsonValue
    companyIco?: NullableStringFieldUpdateOperationsInput | string | null
    companyDic?: NullableStringFieldUpdateOperationsInput | string | null
    companyBankAccount?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    siteTitle?: StringFieldUpdateOperationsInput | string
    siteDescription?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    defaultSeo?: NullableJsonNullValueInput | InputJsonValue
    companyIco?: NullableStringFieldUpdateOperationsInput | string | null
    companyDic?: NullableStringFieldUpdateOperationsInput | string | null
    companyBankAccount?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SettingsCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    siteTitle: string
    siteDescription?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    defaultSeo?: NullableJsonNullValueInput | InputJsonValue
    companyIco?: string | null
    companyDic?: string | null
    companyBankAccount?: string | null
  }

  export type SettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    siteTitle?: StringFieldUpdateOperationsInput | string
    siteDescription?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    defaultSeo?: NullableJsonNullValueInput | InputJsonValue
    companyIco?: NullableStringFieldUpdateOperationsInput | string | null
    companyDic?: NullableStringFieldUpdateOperationsInput | string | null
    companyBankAccount?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    siteTitle?: StringFieldUpdateOperationsInput | string
    siteDescription?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    defaultSeo?: NullableJsonNullValueInput | InputJsonValue
    companyIco?: NullableStringFieldUpdateOperationsInput | string | null
    companyDic?: NullableStringFieldUpdateOperationsInput | string | null
    companyBankAccount?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AIUsageCreateInput = {
    id?: string
    createdAt?: Date | string
    feature: string
    sessionId?: string | null
    orderId?: string | null
    model: string
    promptTokens: number
    completionTokens: number
    totalTokens: number
    latencyMs?: number | null
    estimatedCost?: number | null
  }

  export type AIUsageUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    feature: string
    sessionId?: string | null
    orderId?: string | null
    model: string
    promptTokens: number
    completionTokens: number
    totalTokens: number
    latencyMs?: number | null
    estimatedCost?: number | null
  }

  export type AIUsageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    feature?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    model?: StringFieldUpdateOperationsInput | string
    promptTokens?: IntFieldUpdateOperationsInput | number
    completionTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    latencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedCost?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type AIUsageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    feature?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    model?: StringFieldUpdateOperationsInput | string
    promptTokens?: IntFieldUpdateOperationsInput | number
    completionTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    latencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedCost?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type AIUsageCreateManyInput = {
    id?: string
    createdAt?: Date | string
    feature: string
    sessionId?: string | null
    orderId?: string | null
    model: string
    promptTokens: number
    completionTokens: number
    totalTokens: number
    latencyMs?: number | null
    estimatedCost?: number | null
  }

  export type AIUsageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    feature?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    model?: StringFieldUpdateOperationsInput | string
    promptTokens?: IntFieldUpdateOperationsInput | number
    completionTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    latencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedCost?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type AIUsageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    feature?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    model?: StringFieldUpdateOperationsInput | string
    promptTokens?: IntFieldUpdateOperationsInput | number
    completionTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    latencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedCost?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type ProgramActivityListRelationFilter = {
    every?: ProgramActivityWhereInput
    some?: ProgramActivityWhereInput
    none?: ProgramActivityWhereInput
  }

  export type OrderItemListRelationFilter = {
    every?: OrderItemWhereInput
    some?: OrderItemWhereInput
    none?: OrderItemWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProgramActivityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProgramCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    category?: SortOrder
    status?: SortOrder
    featured?: SortOrder
    order?: SortOrder
    subtitle?: SortOrder
    excerpt?: SortOrder
    description?: SortOrder
    teamSize?: SortOrder
    minTeamSize?: SortOrder
    maxTeamSize?: SortOrder
    objectives?: SortOrder
    industryType?: SortOrder
    physicalLevel?: SortOrder
    indoorOutdoor?: SortOrder
    duration?: SortOrder
    includesCatering?: SortOrder
    debriefIncluded?: SortOrder
    facilitationRequired?: SortOrder
    technicalRequirements?: SortOrder
    materialsIncluded?: SortOrder
    venueRequirements?: SortOrder
    price?: SortOrder
    pricePerPerson?: SortOrder
    pricingNotes?: SortOrder
    featuredImageUrl?: SortOrder
    featuredImageAlt?: SortOrder
    galleryImages?: SortOrder
    videoUrl?: SortOrder
    seo?: SortOrder
  }

  export type ProgramAvgOrderByAggregateInput = {
    order?: SortOrder
    teamSize?: SortOrder
    minTeamSize?: SortOrder
    maxTeamSize?: SortOrder
    duration?: SortOrder
    price?: SortOrder
    pricePerPerson?: SortOrder
  }

  export type ProgramMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    category?: SortOrder
    status?: SortOrder
    featured?: SortOrder
    order?: SortOrder
    subtitle?: SortOrder
    excerpt?: SortOrder
    teamSize?: SortOrder
    minTeamSize?: SortOrder
    maxTeamSize?: SortOrder
    industryType?: SortOrder
    physicalLevel?: SortOrder
    indoorOutdoor?: SortOrder
    duration?: SortOrder
    includesCatering?: SortOrder
    debriefIncluded?: SortOrder
    facilitationRequired?: SortOrder
    price?: SortOrder
    pricePerPerson?: SortOrder
    pricingNotes?: SortOrder
    featuredImageUrl?: SortOrder
    featuredImageAlt?: SortOrder
    videoUrl?: SortOrder
  }

  export type ProgramMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    category?: SortOrder
    status?: SortOrder
    featured?: SortOrder
    order?: SortOrder
    subtitle?: SortOrder
    excerpt?: SortOrder
    teamSize?: SortOrder
    minTeamSize?: SortOrder
    maxTeamSize?: SortOrder
    industryType?: SortOrder
    physicalLevel?: SortOrder
    indoorOutdoor?: SortOrder
    duration?: SortOrder
    includesCatering?: SortOrder
    debriefIncluded?: SortOrder
    facilitationRequired?: SortOrder
    price?: SortOrder
    pricePerPerson?: SortOrder
    pricingNotes?: SortOrder
    featuredImageUrl?: SortOrder
    featuredImageAlt?: SortOrder
    videoUrl?: SortOrder
  }

  export type ProgramSumOrderByAggregateInput = {
    order?: SortOrder
    teamSize?: SortOrder
    minTeamSize?: SortOrder
    maxTeamSize?: SortOrder
    duration?: SortOrder
    price?: SortOrder
    pricePerPerson?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type ActivityCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    category?: SortOrder
    status?: SortOrder
    featured?: SortOrder
    order?: SortOrder
    subtitle?: SortOrder
    excerpt?: SortOrder
    description?: SortOrder
    minParticipants?: SortOrder
    maxParticipants?: SortOrder
    idealGroupSize?: SortOrder
    objectives?: SortOrder
    learningOutcomes?: SortOrder
    physicalDemand?: SortOrder
    indoorOutdoor?: SortOrder
    duration?: SortOrder
    materialsNeeded?: SortOrder
    setupTime?: SortOrder
    facilitatorGuide?: SortOrder
    difficultyLevel?: SortOrder
    scalable?: SortOrder
    canCombine?: SortOrder
    price?: SortOrder
    featuredImageUrl?: SortOrder
    featuredImageAlt?: SortOrder
    galleryImages?: SortOrder
    videoUrl?: SortOrder
    instructionPdfUrl?: SortOrder
    seo?: SortOrder
  }

  export type ActivityAvgOrderByAggregateInput = {
    order?: SortOrder
    minParticipants?: SortOrder
    maxParticipants?: SortOrder
    idealGroupSize?: SortOrder
    duration?: SortOrder
    setupTime?: SortOrder
    price?: SortOrder
  }

  export type ActivityMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    category?: SortOrder
    status?: SortOrder
    featured?: SortOrder
    order?: SortOrder
    subtitle?: SortOrder
    excerpt?: SortOrder
    minParticipants?: SortOrder
    maxParticipants?: SortOrder
    idealGroupSize?: SortOrder
    physicalDemand?: SortOrder
    indoorOutdoor?: SortOrder
    duration?: SortOrder
    setupTime?: SortOrder
    difficultyLevel?: SortOrder
    scalable?: SortOrder
    canCombine?: SortOrder
    price?: SortOrder
    featuredImageUrl?: SortOrder
    featuredImageAlt?: SortOrder
    videoUrl?: SortOrder
    instructionPdfUrl?: SortOrder
  }

  export type ActivityMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    category?: SortOrder
    status?: SortOrder
    featured?: SortOrder
    order?: SortOrder
    subtitle?: SortOrder
    excerpt?: SortOrder
    minParticipants?: SortOrder
    maxParticipants?: SortOrder
    idealGroupSize?: SortOrder
    physicalDemand?: SortOrder
    indoorOutdoor?: SortOrder
    duration?: SortOrder
    setupTime?: SortOrder
    difficultyLevel?: SortOrder
    scalable?: SortOrder
    canCombine?: SortOrder
    price?: SortOrder
    featuredImageUrl?: SortOrder
    featuredImageAlt?: SortOrder
    videoUrl?: SortOrder
    instructionPdfUrl?: SortOrder
  }

  export type ActivitySumOrderByAggregateInput = {
    order?: SortOrder
    minParticipants?: SortOrder
    maxParticipants?: SortOrder
    idealGroupSize?: SortOrder
    duration?: SortOrder
    setupTime?: SortOrder
    price?: SortOrder
  }

  export type ProgramScalarRelationFilter = {
    is?: ProgramWhereInput
    isNot?: ProgramWhereInput
  }

  export type ActivityScalarRelationFilter = {
    is?: ActivityWhereInput
    isNot?: ActivityWhereInput
  }

  export type ProgramActivityProgramIdActivityIdCompoundUniqueInput = {
    programId: string
    activityId: string
  }

  export type ProgramActivityCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    programId?: SortOrder
    activityId?: SortOrder
    order?: SortOrder
    duration?: SortOrder
    notes?: SortOrder
  }

  export type ProgramActivityAvgOrderByAggregateInput = {
    order?: SortOrder
    duration?: SortOrder
  }

  export type ProgramActivityMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    programId?: SortOrder
    activityId?: SortOrder
    order?: SortOrder
    duration?: SortOrder
    notes?: SortOrder
  }

  export type ProgramActivityMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    programId?: SortOrder
    activityId?: SortOrder
    order?: SortOrder
    duration?: SortOrder
    notes?: SortOrder
  }

  export type ProgramActivitySumOrderByAggregateInput = {
    order?: SortOrder
    duration?: SortOrder
  }

  export type ExtraCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    category?: SortOrder
    status?: SortOrder
    order?: SortOrder
    excerpt?: SortOrder
    description?: SortOrder
    priceFrom?: SortOrder
    priceUnit?: SortOrder
    featuredImageUrl?: SortOrder
    featuredImageAlt?: SortOrder
    seo?: SortOrder
  }

  export type ExtraAvgOrderByAggregateInput = {
    order?: SortOrder
    priceFrom?: SortOrder
  }

  export type ExtraMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    category?: SortOrder
    status?: SortOrder
    order?: SortOrder
    excerpt?: SortOrder
    priceFrom?: SortOrder
    priceUnit?: SortOrder
    featuredImageUrl?: SortOrder
    featuredImageAlt?: SortOrder
  }

  export type ExtraMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    category?: SortOrder
    status?: SortOrder
    order?: SortOrder
    excerpt?: SortOrder
    priceFrom?: SortOrder
    priceUnit?: SortOrder
    featuredImageUrl?: SortOrder
    featuredImageAlt?: SortOrder
  }

  export type ExtraSumOrderByAggregateInput = {
    order?: SortOrder
    priceFrom?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ProgramNullableScalarRelationFilter = {
    is?: ProgramWhereInput | null
    isNot?: ProgramWhereInput | null
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    programId?: SortOrder
    date?: SortOrder
    endDate?: SortOrder
    venue?: SortOrder
    teamSize?: SortOrder
    teamName?: SortOrder
    companyName?: SortOrder
    industryType?: SortOrder
    objectives?: SortOrder
    customObjectives?: SortOrder
    status?: SortOrder
    isPublic?: SortOrder
    debriefCompleted?: SortOrder
    debriefReport?: SortOrder
    debriefGeneratedAt?: SortOrder
    notes?: SortOrder
  }

  export type SessionAvgOrderByAggregateInput = {
    teamSize?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    programId?: SortOrder
    date?: SortOrder
    endDate?: SortOrder
    teamSize?: SortOrder
    teamName?: SortOrder
    companyName?: SortOrder
    industryType?: SortOrder
    customObjectives?: SortOrder
    status?: SortOrder
    isPublic?: SortOrder
    debriefCompleted?: SortOrder
    debriefGeneratedAt?: SortOrder
    notes?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    programId?: SortOrder
    date?: SortOrder
    endDate?: SortOrder
    teamSize?: SortOrder
    teamName?: SortOrder
    companyName?: SortOrder
    industryType?: SortOrder
    customObjectives?: SortOrder
    status?: SortOrder
    isPublic?: SortOrder
    debriefCompleted?: SortOrder
    debriefGeneratedAt?: SortOrder
    notes?: SortOrder
  }

  export type SessionSumOrderByAggregateInput = {
    teamSize?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type InvoiceListRelationFilter = {
    every?: InvoiceWhereInput
    some?: InvoiceWhereInput
    none?: InvoiceWhereInput
  }

  export type InvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    organization?: SortOrder
    organizationType?: SortOrder
    industryType?: SortOrder
    teamSize?: SortOrder
    address?: SortOrder
    billingInfo?: SortOrder
    tags?: SortOrder
    notes?: SortOrder
    gdprConsent?: SortOrder
    averagePaymentDays?: SortOrder
    paymentReliability?: SortOrder
    totalInvoiced?: SortOrder
    totalPaid?: SortOrder
    invoiceCount?: SortOrder
    overdueCount?: SortOrder
    lastInvoiceDate?: SortOrder
    lastPaymentDate?: SortOrder
  }

  export type CustomerAvgOrderByAggregateInput = {
    teamSize?: SortOrder
    averagePaymentDays?: SortOrder
    totalInvoiced?: SortOrder
    totalPaid?: SortOrder
    invoiceCount?: SortOrder
    overdueCount?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    organization?: SortOrder
    organizationType?: SortOrder
    industryType?: SortOrder
    teamSize?: SortOrder
    notes?: SortOrder
    averagePaymentDays?: SortOrder
    paymentReliability?: SortOrder
    totalInvoiced?: SortOrder
    totalPaid?: SortOrder
    invoiceCount?: SortOrder
    overdueCount?: SortOrder
    lastInvoiceDate?: SortOrder
    lastPaymentDate?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    organization?: SortOrder
    organizationType?: SortOrder
    industryType?: SortOrder
    teamSize?: SortOrder
    notes?: SortOrder
    averagePaymentDays?: SortOrder
    paymentReliability?: SortOrder
    totalInvoiced?: SortOrder
    totalPaid?: SortOrder
    invoiceCount?: SortOrder
    overdueCount?: SortOrder
    lastInvoiceDate?: SortOrder
    lastPaymentDate?: SortOrder
  }

  export type CustomerSumOrderByAggregateInput = {
    teamSize?: SortOrder
    averagePaymentDays?: SortOrder
    totalInvoiced?: SortOrder
    totalPaid?: SortOrder
    invoiceCount?: SortOrder
    overdueCount?: SortOrder
  }

  export type CustomerNullableScalarRelationFilter = {
    is?: CustomerWhereInput | null
    isNot?: CustomerWhereInput | null
  }

  export type SessionNullableScalarRelationFilter = {
    is?: SessionWhereInput | null
    isNot?: SessionWhereInput | null
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    orderNumber?: SortOrder
    customerId?: SortOrder
    source?: SortOrder
    status?: SortOrder
    sessionName?: SortOrder
    dates?: SortOrder
    venue?: SortOrder
    teamSize?: SortOrder
    teamComposition?: SortOrder
    objectives?: SortOrder
    customObjectives?: SortOrder
    industryType?: SortOrder
    technicalRequirements?: SortOrder
    pricing?: SortOrder
    paymentMethod?: SortOrder
    paymentDueDate?: SortOrder
    invoiceEmail?: SortOrder
    logistics?: SortOrder
    contacts?: SortOrder
    documents?: SortOrder
    linkedSessionId?: SortOrder
    internalNotes?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    teamSize?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    orderNumber?: SortOrder
    customerId?: SortOrder
    source?: SortOrder
    status?: SortOrder
    sessionName?: SortOrder
    teamSize?: SortOrder
    customObjectives?: SortOrder
    industryType?: SortOrder
    paymentMethod?: SortOrder
    paymentDueDate?: SortOrder
    invoiceEmail?: SortOrder
    linkedSessionId?: SortOrder
    internalNotes?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    orderNumber?: SortOrder
    customerId?: SortOrder
    source?: SortOrder
    status?: SortOrder
    sessionName?: SortOrder
    teamSize?: SortOrder
    customObjectives?: SortOrder
    industryType?: SortOrder
    paymentMethod?: SortOrder
    paymentDueDate?: SortOrder
    invoiceEmail?: SortOrder
    linkedSessionId?: SortOrder
    internalNotes?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    teamSize?: SortOrder
  }

  export type OrderScalarRelationFilter = {
    is?: OrderWhereInput
    isNot?: OrderWhereInput
  }

  export type ActivityNullableScalarRelationFilter = {
    is?: ActivityWhereInput | null
    isNot?: ActivityWhereInput | null
  }

  export type ExtraNullableScalarRelationFilter = {
    is?: ExtraWhereInput | null
    isNot?: ExtraWhereInput | null
  }

  export type OrderItemCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    orderId?: SortOrder
    programId?: SortOrder
    activityId?: SortOrder
    extraId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    price?: SortOrder
    notes?: SortOrder
  }

  export type OrderItemAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type OrderItemMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    orderId?: SortOrder
    programId?: SortOrder
    activityId?: SortOrder
    extraId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    price?: SortOrder
    notes?: SortOrder
  }

  export type OrderItemMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    orderId?: SortOrder
    programId?: SortOrder
    activityId?: SortOrder
    extraId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    price?: SortOrder
    notes?: SortOrder
  }

  export type OrderItemSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type CustomerScalarRelationFilter = {
    is?: CustomerWhereInput
    isNot?: CustomerWhereInput
  }

  export type OrderNullableScalarRelationFilter = {
    is?: OrderWhereInput | null
    isNot?: OrderWhereInput | null
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    invoiceNumber?: SortOrder
    status?: SortOrder
    customerId?: SortOrder
    orderId?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    paidDate?: SortOrder
    items?: SortOrder
    subtotal?: SortOrder
    vatRate?: SortOrder
    vatAmount?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    paymentMethod?: SortOrder
    bankAccount?: SortOrder
    variableSymbol?: SortOrder
    currency?: SortOrder
    pdfUrl?: SortOrder
    pdfGeneratedAt?: SortOrder
    textBeforeItems?: SortOrder
    textAfterItems?: SortOrder
    notes?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    subtotal?: SortOrder
    vatRate?: SortOrder
    vatAmount?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    invoiceNumber?: SortOrder
    status?: SortOrder
    customerId?: SortOrder
    orderId?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    paidDate?: SortOrder
    subtotal?: SortOrder
    vatRate?: SortOrder
    vatAmount?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    paymentMethod?: SortOrder
    bankAccount?: SortOrder
    variableSymbol?: SortOrder
    currency?: SortOrder
    pdfUrl?: SortOrder
    pdfGeneratedAt?: SortOrder
    textBeforeItems?: SortOrder
    textAfterItems?: SortOrder
    notes?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    invoiceNumber?: SortOrder
    status?: SortOrder
    customerId?: SortOrder
    orderId?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    paidDate?: SortOrder
    subtotal?: SortOrder
    vatRate?: SortOrder
    vatAmount?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    paymentMethod?: SortOrder
    bankAccount?: SortOrder
    variableSymbol?: SortOrder
    currency?: SortOrder
    pdfUrl?: SortOrder
    pdfGeneratedAt?: SortOrder
    textBeforeItems?: SortOrder
    textAfterItems?: SortOrder
    notes?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    subtotal?: SortOrder
    vatRate?: SortOrder
    vatAmount?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type UserSessionListRelationFilter = {
    every?: UserSessionWhereInput
    some?: UserSessionWhereInput
    none?: UserSessionWhereInput
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string
    providerAccountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type UserSessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type UserSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type UserSessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenIdentifierTokenCompoundUniqueInput = {
    identifier: string
    token: string
  }

  export type VerificationTokenCountOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMaxOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMinOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type SettingsCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    siteTitle?: SortOrder
    siteDescription?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrder
    address?: SortOrder
    socialLinks?: SortOrder
    defaultSeo?: SortOrder
    companyIco?: SortOrder
    companyDic?: SortOrder
    companyBankAccount?: SortOrder
  }

  export type SettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    siteTitle?: SortOrder
    siteDescription?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrder
    companyIco?: SortOrder
    companyDic?: SortOrder
    companyBankAccount?: SortOrder
  }

  export type SettingsMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    siteTitle?: SortOrder
    siteDescription?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrder
    companyIco?: SortOrder
    companyDic?: SortOrder
    companyBankAccount?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type AIUsageCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    feature?: SortOrder
    sessionId?: SortOrder
    orderId?: SortOrder
    model?: SortOrder
    promptTokens?: SortOrder
    completionTokens?: SortOrder
    totalTokens?: SortOrder
    latencyMs?: SortOrder
    estimatedCost?: SortOrder
  }

  export type AIUsageAvgOrderByAggregateInput = {
    promptTokens?: SortOrder
    completionTokens?: SortOrder
    totalTokens?: SortOrder
    latencyMs?: SortOrder
    estimatedCost?: SortOrder
  }

  export type AIUsageMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    feature?: SortOrder
    sessionId?: SortOrder
    orderId?: SortOrder
    model?: SortOrder
    promptTokens?: SortOrder
    completionTokens?: SortOrder
    totalTokens?: SortOrder
    latencyMs?: SortOrder
    estimatedCost?: SortOrder
  }

  export type AIUsageMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    feature?: SortOrder
    sessionId?: SortOrder
    orderId?: SortOrder
    model?: SortOrder
    promptTokens?: SortOrder
    completionTokens?: SortOrder
    totalTokens?: SortOrder
    latencyMs?: SortOrder
    estimatedCost?: SortOrder
  }

  export type AIUsageSumOrderByAggregateInput = {
    promptTokens?: SortOrder
    completionTokens?: SortOrder
    totalTokens?: SortOrder
    latencyMs?: SortOrder
    estimatedCost?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type SessionCreateNestedManyWithoutProgramInput = {
    create?: XOR<SessionCreateWithoutProgramInput, SessionUncheckedCreateWithoutProgramInput> | SessionCreateWithoutProgramInput[] | SessionUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutProgramInput | SessionCreateOrConnectWithoutProgramInput[]
    createMany?: SessionCreateManyProgramInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type ProgramActivityCreateNestedManyWithoutProgramInput = {
    create?: XOR<ProgramActivityCreateWithoutProgramInput, ProgramActivityUncheckedCreateWithoutProgramInput> | ProgramActivityCreateWithoutProgramInput[] | ProgramActivityUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: ProgramActivityCreateOrConnectWithoutProgramInput | ProgramActivityCreateOrConnectWithoutProgramInput[]
    createMany?: ProgramActivityCreateManyProgramInputEnvelope
    connect?: ProgramActivityWhereUniqueInput | ProgramActivityWhereUniqueInput[]
  }

  export type OrderItemCreateNestedManyWithoutProgramInput = {
    create?: XOR<OrderItemCreateWithoutProgramInput, OrderItemUncheckedCreateWithoutProgramInput> | OrderItemCreateWithoutProgramInput[] | OrderItemUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProgramInput | OrderItemCreateOrConnectWithoutProgramInput[]
    createMany?: OrderItemCreateManyProgramInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutProgramInput = {
    create?: XOR<SessionCreateWithoutProgramInput, SessionUncheckedCreateWithoutProgramInput> | SessionCreateWithoutProgramInput[] | SessionUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutProgramInput | SessionCreateOrConnectWithoutProgramInput[]
    createMany?: SessionCreateManyProgramInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type ProgramActivityUncheckedCreateNestedManyWithoutProgramInput = {
    create?: XOR<ProgramActivityCreateWithoutProgramInput, ProgramActivityUncheckedCreateWithoutProgramInput> | ProgramActivityCreateWithoutProgramInput[] | ProgramActivityUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: ProgramActivityCreateOrConnectWithoutProgramInput | ProgramActivityCreateOrConnectWithoutProgramInput[]
    createMany?: ProgramActivityCreateManyProgramInputEnvelope
    connect?: ProgramActivityWhereUniqueInput | ProgramActivityWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutProgramInput = {
    create?: XOR<OrderItemCreateWithoutProgramInput, OrderItemUncheckedCreateWithoutProgramInput> | OrderItemCreateWithoutProgramInput[] | OrderItemUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProgramInput | OrderItemCreateOrConnectWithoutProgramInput[]
    createMany?: OrderItemCreateManyProgramInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type SessionUpdateManyWithoutProgramNestedInput = {
    create?: XOR<SessionCreateWithoutProgramInput, SessionUncheckedCreateWithoutProgramInput> | SessionCreateWithoutProgramInput[] | SessionUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutProgramInput | SessionCreateOrConnectWithoutProgramInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutProgramInput | SessionUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: SessionCreateManyProgramInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutProgramInput | SessionUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutProgramInput | SessionUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type ProgramActivityUpdateManyWithoutProgramNestedInput = {
    create?: XOR<ProgramActivityCreateWithoutProgramInput, ProgramActivityUncheckedCreateWithoutProgramInput> | ProgramActivityCreateWithoutProgramInput[] | ProgramActivityUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: ProgramActivityCreateOrConnectWithoutProgramInput | ProgramActivityCreateOrConnectWithoutProgramInput[]
    upsert?: ProgramActivityUpsertWithWhereUniqueWithoutProgramInput | ProgramActivityUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: ProgramActivityCreateManyProgramInputEnvelope
    set?: ProgramActivityWhereUniqueInput | ProgramActivityWhereUniqueInput[]
    disconnect?: ProgramActivityWhereUniqueInput | ProgramActivityWhereUniqueInput[]
    delete?: ProgramActivityWhereUniqueInput | ProgramActivityWhereUniqueInput[]
    connect?: ProgramActivityWhereUniqueInput | ProgramActivityWhereUniqueInput[]
    update?: ProgramActivityUpdateWithWhereUniqueWithoutProgramInput | ProgramActivityUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: ProgramActivityUpdateManyWithWhereWithoutProgramInput | ProgramActivityUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: ProgramActivityScalarWhereInput | ProgramActivityScalarWhereInput[]
  }

  export type OrderItemUpdateManyWithoutProgramNestedInput = {
    create?: XOR<OrderItemCreateWithoutProgramInput, OrderItemUncheckedCreateWithoutProgramInput> | OrderItemCreateWithoutProgramInput[] | OrderItemUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProgramInput | OrderItemCreateOrConnectWithoutProgramInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutProgramInput | OrderItemUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: OrderItemCreateManyProgramInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutProgramInput | OrderItemUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutProgramInput | OrderItemUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutProgramNestedInput = {
    create?: XOR<SessionCreateWithoutProgramInput, SessionUncheckedCreateWithoutProgramInput> | SessionCreateWithoutProgramInput[] | SessionUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutProgramInput | SessionCreateOrConnectWithoutProgramInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutProgramInput | SessionUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: SessionCreateManyProgramInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutProgramInput | SessionUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutProgramInput | SessionUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type ProgramActivityUncheckedUpdateManyWithoutProgramNestedInput = {
    create?: XOR<ProgramActivityCreateWithoutProgramInput, ProgramActivityUncheckedCreateWithoutProgramInput> | ProgramActivityCreateWithoutProgramInput[] | ProgramActivityUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: ProgramActivityCreateOrConnectWithoutProgramInput | ProgramActivityCreateOrConnectWithoutProgramInput[]
    upsert?: ProgramActivityUpsertWithWhereUniqueWithoutProgramInput | ProgramActivityUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: ProgramActivityCreateManyProgramInputEnvelope
    set?: ProgramActivityWhereUniqueInput | ProgramActivityWhereUniqueInput[]
    disconnect?: ProgramActivityWhereUniqueInput | ProgramActivityWhereUniqueInput[]
    delete?: ProgramActivityWhereUniqueInput | ProgramActivityWhereUniqueInput[]
    connect?: ProgramActivityWhereUniqueInput | ProgramActivityWhereUniqueInput[]
    update?: ProgramActivityUpdateWithWhereUniqueWithoutProgramInput | ProgramActivityUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: ProgramActivityUpdateManyWithWhereWithoutProgramInput | ProgramActivityUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: ProgramActivityScalarWhereInput | ProgramActivityScalarWhereInput[]
  }

  export type OrderItemUncheckedUpdateManyWithoutProgramNestedInput = {
    create?: XOR<OrderItemCreateWithoutProgramInput, OrderItemUncheckedCreateWithoutProgramInput> | OrderItemCreateWithoutProgramInput[] | OrderItemUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProgramInput | OrderItemCreateOrConnectWithoutProgramInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutProgramInput | OrderItemUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: OrderItemCreateManyProgramInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutProgramInput | OrderItemUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutProgramInput | OrderItemUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type ProgramActivityCreateNestedManyWithoutActivityInput = {
    create?: XOR<ProgramActivityCreateWithoutActivityInput, ProgramActivityUncheckedCreateWithoutActivityInput> | ProgramActivityCreateWithoutActivityInput[] | ProgramActivityUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: ProgramActivityCreateOrConnectWithoutActivityInput | ProgramActivityCreateOrConnectWithoutActivityInput[]
    createMany?: ProgramActivityCreateManyActivityInputEnvelope
    connect?: ProgramActivityWhereUniqueInput | ProgramActivityWhereUniqueInput[]
  }

  export type OrderItemCreateNestedManyWithoutActivityInput = {
    create?: XOR<OrderItemCreateWithoutActivityInput, OrderItemUncheckedCreateWithoutActivityInput> | OrderItemCreateWithoutActivityInput[] | OrderItemUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutActivityInput | OrderItemCreateOrConnectWithoutActivityInput[]
    createMany?: OrderItemCreateManyActivityInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type ProgramActivityUncheckedCreateNestedManyWithoutActivityInput = {
    create?: XOR<ProgramActivityCreateWithoutActivityInput, ProgramActivityUncheckedCreateWithoutActivityInput> | ProgramActivityCreateWithoutActivityInput[] | ProgramActivityUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: ProgramActivityCreateOrConnectWithoutActivityInput | ProgramActivityCreateOrConnectWithoutActivityInput[]
    createMany?: ProgramActivityCreateManyActivityInputEnvelope
    connect?: ProgramActivityWhereUniqueInput | ProgramActivityWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutActivityInput = {
    create?: XOR<OrderItemCreateWithoutActivityInput, OrderItemUncheckedCreateWithoutActivityInput> | OrderItemCreateWithoutActivityInput[] | OrderItemUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutActivityInput | OrderItemCreateOrConnectWithoutActivityInput[]
    createMany?: OrderItemCreateManyActivityInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type ProgramActivityUpdateManyWithoutActivityNestedInput = {
    create?: XOR<ProgramActivityCreateWithoutActivityInput, ProgramActivityUncheckedCreateWithoutActivityInput> | ProgramActivityCreateWithoutActivityInput[] | ProgramActivityUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: ProgramActivityCreateOrConnectWithoutActivityInput | ProgramActivityCreateOrConnectWithoutActivityInput[]
    upsert?: ProgramActivityUpsertWithWhereUniqueWithoutActivityInput | ProgramActivityUpsertWithWhereUniqueWithoutActivityInput[]
    createMany?: ProgramActivityCreateManyActivityInputEnvelope
    set?: ProgramActivityWhereUniqueInput | ProgramActivityWhereUniqueInput[]
    disconnect?: ProgramActivityWhereUniqueInput | ProgramActivityWhereUniqueInput[]
    delete?: ProgramActivityWhereUniqueInput | ProgramActivityWhereUniqueInput[]
    connect?: ProgramActivityWhereUniqueInput | ProgramActivityWhereUniqueInput[]
    update?: ProgramActivityUpdateWithWhereUniqueWithoutActivityInput | ProgramActivityUpdateWithWhereUniqueWithoutActivityInput[]
    updateMany?: ProgramActivityUpdateManyWithWhereWithoutActivityInput | ProgramActivityUpdateManyWithWhereWithoutActivityInput[]
    deleteMany?: ProgramActivityScalarWhereInput | ProgramActivityScalarWhereInput[]
  }

  export type OrderItemUpdateManyWithoutActivityNestedInput = {
    create?: XOR<OrderItemCreateWithoutActivityInput, OrderItemUncheckedCreateWithoutActivityInput> | OrderItemCreateWithoutActivityInput[] | OrderItemUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutActivityInput | OrderItemCreateOrConnectWithoutActivityInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutActivityInput | OrderItemUpsertWithWhereUniqueWithoutActivityInput[]
    createMany?: OrderItemCreateManyActivityInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutActivityInput | OrderItemUpdateWithWhereUniqueWithoutActivityInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutActivityInput | OrderItemUpdateManyWithWhereWithoutActivityInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type ProgramActivityUncheckedUpdateManyWithoutActivityNestedInput = {
    create?: XOR<ProgramActivityCreateWithoutActivityInput, ProgramActivityUncheckedCreateWithoutActivityInput> | ProgramActivityCreateWithoutActivityInput[] | ProgramActivityUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: ProgramActivityCreateOrConnectWithoutActivityInput | ProgramActivityCreateOrConnectWithoutActivityInput[]
    upsert?: ProgramActivityUpsertWithWhereUniqueWithoutActivityInput | ProgramActivityUpsertWithWhereUniqueWithoutActivityInput[]
    createMany?: ProgramActivityCreateManyActivityInputEnvelope
    set?: ProgramActivityWhereUniqueInput | ProgramActivityWhereUniqueInput[]
    disconnect?: ProgramActivityWhereUniqueInput | ProgramActivityWhereUniqueInput[]
    delete?: ProgramActivityWhereUniqueInput | ProgramActivityWhereUniqueInput[]
    connect?: ProgramActivityWhereUniqueInput | ProgramActivityWhereUniqueInput[]
    update?: ProgramActivityUpdateWithWhereUniqueWithoutActivityInput | ProgramActivityUpdateWithWhereUniqueWithoutActivityInput[]
    updateMany?: ProgramActivityUpdateManyWithWhereWithoutActivityInput | ProgramActivityUpdateManyWithWhereWithoutActivityInput[]
    deleteMany?: ProgramActivityScalarWhereInput | ProgramActivityScalarWhereInput[]
  }

  export type OrderItemUncheckedUpdateManyWithoutActivityNestedInput = {
    create?: XOR<OrderItemCreateWithoutActivityInput, OrderItemUncheckedCreateWithoutActivityInput> | OrderItemCreateWithoutActivityInput[] | OrderItemUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutActivityInput | OrderItemCreateOrConnectWithoutActivityInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutActivityInput | OrderItemUpsertWithWhereUniqueWithoutActivityInput[]
    createMany?: OrderItemCreateManyActivityInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutActivityInput | OrderItemUpdateWithWhereUniqueWithoutActivityInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutActivityInput | OrderItemUpdateManyWithWhereWithoutActivityInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type ProgramCreateNestedOneWithoutActivityLinksInput = {
    create?: XOR<ProgramCreateWithoutActivityLinksInput, ProgramUncheckedCreateWithoutActivityLinksInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutActivityLinksInput
    connect?: ProgramWhereUniqueInput
  }

  export type ActivityCreateNestedOneWithoutProgramLinksInput = {
    create?: XOR<ActivityCreateWithoutProgramLinksInput, ActivityUncheckedCreateWithoutProgramLinksInput>
    connectOrCreate?: ActivityCreateOrConnectWithoutProgramLinksInput
    connect?: ActivityWhereUniqueInput
  }

  export type ProgramUpdateOneRequiredWithoutActivityLinksNestedInput = {
    create?: XOR<ProgramCreateWithoutActivityLinksInput, ProgramUncheckedCreateWithoutActivityLinksInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutActivityLinksInput
    upsert?: ProgramUpsertWithoutActivityLinksInput
    connect?: ProgramWhereUniqueInput
    update?: XOR<XOR<ProgramUpdateToOneWithWhereWithoutActivityLinksInput, ProgramUpdateWithoutActivityLinksInput>, ProgramUncheckedUpdateWithoutActivityLinksInput>
  }

  export type ActivityUpdateOneRequiredWithoutProgramLinksNestedInput = {
    create?: XOR<ActivityCreateWithoutProgramLinksInput, ActivityUncheckedCreateWithoutProgramLinksInput>
    connectOrCreate?: ActivityCreateOrConnectWithoutProgramLinksInput
    upsert?: ActivityUpsertWithoutProgramLinksInput
    connect?: ActivityWhereUniqueInput
    update?: XOR<XOR<ActivityUpdateToOneWithWhereWithoutProgramLinksInput, ActivityUpdateWithoutProgramLinksInput>, ActivityUncheckedUpdateWithoutProgramLinksInput>
  }

  export type OrderItemCreateNestedManyWithoutExtraInput = {
    create?: XOR<OrderItemCreateWithoutExtraInput, OrderItemUncheckedCreateWithoutExtraInput> | OrderItemCreateWithoutExtraInput[] | OrderItemUncheckedCreateWithoutExtraInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutExtraInput | OrderItemCreateOrConnectWithoutExtraInput[]
    createMany?: OrderItemCreateManyExtraInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutExtraInput = {
    create?: XOR<OrderItemCreateWithoutExtraInput, OrderItemUncheckedCreateWithoutExtraInput> | OrderItemCreateWithoutExtraInput[] | OrderItemUncheckedCreateWithoutExtraInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutExtraInput | OrderItemCreateOrConnectWithoutExtraInput[]
    createMany?: OrderItemCreateManyExtraInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type OrderItemUpdateManyWithoutExtraNestedInput = {
    create?: XOR<OrderItemCreateWithoutExtraInput, OrderItemUncheckedCreateWithoutExtraInput> | OrderItemCreateWithoutExtraInput[] | OrderItemUncheckedCreateWithoutExtraInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutExtraInput | OrderItemCreateOrConnectWithoutExtraInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutExtraInput | OrderItemUpsertWithWhereUniqueWithoutExtraInput[]
    createMany?: OrderItemCreateManyExtraInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutExtraInput | OrderItemUpdateWithWhereUniqueWithoutExtraInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutExtraInput | OrderItemUpdateManyWithWhereWithoutExtraInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type OrderItemUncheckedUpdateManyWithoutExtraNestedInput = {
    create?: XOR<OrderItemCreateWithoutExtraInput, OrderItemUncheckedCreateWithoutExtraInput> | OrderItemCreateWithoutExtraInput[] | OrderItemUncheckedCreateWithoutExtraInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutExtraInput | OrderItemCreateOrConnectWithoutExtraInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutExtraInput | OrderItemUpsertWithWhereUniqueWithoutExtraInput[]
    createMany?: OrderItemCreateManyExtraInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutExtraInput | OrderItemUpdateWithWhereUniqueWithoutExtraInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutExtraInput | OrderItemUpdateManyWithWhereWithoutExtraInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type ProgramCreateNestedOneWithoutSessionsInput = {
    create?: XOR<ProgramCreateWithoutSessionsInput, ProgramUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutSessionsInput
    connect?: ProgramWhereUniqueInput
  }

  export type OrderCreateNestedManyWithoutLinkedSessionInput = {
    create?: XOR<OrderCreateWithoutLinkedSessionInput, OrderUncheckedCreateWithoutLinkedSessionInput> | OrderCreateWithoutLinkedSessionInput[] | OrderUncheckedCreateWithoutLinkedSessionInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutLinkedSessionInput | OrderCreateOrConnectWithoutLinkedSessionInput[]
    createMany?: OrderCreateManyLinkedSessionInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutLinkedSessionInput = {
    create?: XOR<OrderCreateWithoutLinkedSessionInput, OrderUncheckedCreateWithoutLinkedSessionInput> | OrderCreateWithoutLinkedSessionInput[] | OrderUncheckedCreateWithoutLinkedSessionInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutLinkedSessionInput | OrderCreateOrConnectWithoutLinkedSessionInput[]
    createMany?: OrderCreateManyLinkedSessionInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type ProgramUpdateOneWithoutSessionsNestedInput = {
    create?: XOR<ProgramCreateWithoutSessionsInput, ProgramUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutSessionsInput
    upsert?: ProgramUpsertWithoutSessionsInput
    disconnect?: ProgramWhereInput | boolean
    delete?: ProgramWhereInput | boolean
    connect?: ProgramWhereUniqueInput
    update?: XOR<XOR<ProgramUpdateToOneWithWhereWithoutSessionsInput, ProgramUpdateWithoutSessionsInput>, ProgramUncheckedUpdateWithoutSessionsInput>
  }

  export type OrderUpdateManyWithoutLinkedSessionNestedInput = {
    create?: XOR<OrderCreateWithoutLinkedSessionInput, OrderUncheckedCreateWithoutLinkedSessionInput> | OrderCreateWithoutLinkedSessionInput[] | OrderUncheckedCreateWithoutLinkedSessionInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutLinkedSessionInput | OrderCreateOrConnectWithoutLinkedSessionInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutLinkedSessionInput | OrderUpsertWithWhereUniqueWithoutLinkedSessionInput[]
    createMany?: OrderCreateManyLinkedSessionInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutLinkedSessionInput | OrderUpdateWithWhereUniqueWithoutLinkedSessionInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutLinkedSessionInput | OrderUpdateManyWithWhereWithoutLinkedSessionInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutLinkedSessionNestedInput = {
    create?: XOR<OrderCreateWithoutLinkedSessionInput, OrderUncheckedCreateWithoutLinkedSessionInput> | OrderCreateWithoutLinkedSessionInput[] | OrderUncheckedCreateWithoutLinkedSessionInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutLinkedSessionInput | OrderCreateOrConnectWithoutLinkedSessionInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutLinkedSessionInput | OrderUpsertWithWhereUniqueWithoutLinkedSessionInput[]
    createMany?: OrderCreateManyLinkedSessionInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutLinkedSessionInput | OrderUpdateWithWhereUniqueWithoutLinkedSessionInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutLinkedSessionInput | OrderUpdateManyWithWhereWithoutLinkedSessionInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type OrderCreateNestedManyWithoutCustomerInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutCustomerInput = {
    create?: XOR<InvoiceCreateWithoutCustomerInput, InvoiceUncheckedCreateWithoutCustomerInput> | InvoiceCreateWithoutCustomerInput[] | InvoiceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCustomerInput | InvoiceCreateOrConnectWithoutCustomerInput[]
    createMany?: InvoiceCreateManyCustomerInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<InvoiceCreateWithoutCustomerInput, InvoiceUncheckedCreateWithoutCustomerInput> | InvoiceCreateWithoutCustomerInput[] | InvoiceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCustomerInput | InvoiceCreateOrConnectWithoutCustomerInput[]
    createMany?: InvoiceCreateManyCustomerInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type OrderUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutCustomerInput | OrderUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutCustomerInput | OrderUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutCustomerInput | OrderUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<InvoiceCreateWithoutCustomerInput, InvoiceUncheckedCreateWithoutCustomerInput> | InvoiceCreateWithoutCustomerInput[] | InvoiceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCustomerInput | InvoiceCreateOrConnectWithoutCustomerInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutCustomerInput | InvoiceUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: InvoiceCreateManyCustomerInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutCustomerInput | InvoiceUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutCustomerInput | InvoiceUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutCustomerInput | OrderUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutCustomerInput | OrderUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutCustomerInput | OrderUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<InvoiceCreateWithoutCustomerInput, InvoiceUncheckedCreateWithoutCustomerInput> | InvoiceCreateWithoutCustomerInput[] | InvoiceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCustomerInput | InvoiceCreateOrConnectWithoutCustomerInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutCustomerInput | InvoiceUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: InvoiceCreateManyCustomerInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutCustomerInput | InvoiceUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutCustomerInput | InvoiceUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type CustomerCreateNestedOneWithoutOrdersInput = {
    create?: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutOrdersInput
    connect?: CustomerWhereUniqueInput
  }

  export type OrderItemCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type SessionCreateNestedOneWithoutOrdersInput = {
    create?: XOR<SessionCreateWithoutOrdersInput, SessionUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: SessionCreateOrConnectWithoutOrdersInput
    connect?: SessionWhereUniqueInput
  }

  export type InvoiceCreateNestedManyWithoutOrderInput = {
    create?: XOR<InvoiceCreateWithoutOrderInput, InvoiceUncheckedCreateWithoutOrderInput> | InvoiceCreateWithoutOrderInput[] | InvoiceUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutOrderInput | InvoiceCreateOrConnectWithoutOrderInput[]
    createMany?: InvoiceCreateManyOrderInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<InvoiceCreateWithoutOrderInput, InvoiceUncheckedCreateWithoutOrderInput> | InvoiceCreateWithoutOrderInput[] | InvoiceUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutOrderInput | InvoiceCreateOrConnectWithoutOrderInput[]
    createMany?: InvoiceCreateManyOrderInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type CustomerUpdateOneWithoutOrdersNestedInput = {
    create?: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutOrdersInput
    upsert?: CustomerUpsertWithoutOrdersInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutOrdersInput, CustomerUpdateWithoutOrdersInput>, CustomerUncheckedUpdateWithoutOrdersInput>
  }

  export type OrderItemUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type SessionUpdateOneWithoutOrdersNestedInput = {
    create?: XOR<SessionCreateWithoutOrdersInput, SessionUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: SessionCreateOrConnectWithoutOrdersInput
    upsert?: SessionUpsertWithoutOrdersInput
    disconnect?: SessionWhereInput | boolean
    delete?: SessionWhereInput | boolean
    connect?: SessionWhereUniqueInput
    update?: XOR<XOR<SessionUpdateToOneWithWhereWithoutOrdersInput, SessionUpdateWithoutOrdersInput>, SessionUncheckedUpdateWithoutOrdersInput>
  }

  export type InvoiceUpdateManyWithoutOrderNestedInput = {
    create?: XOR<InvoiceCreateWithoutOrderInput, InvoiceUncheckedCreateWithoutOrderInput> | InvoiceCreateWithoutOrderInput[] | InvoiceUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutOrderInput | InvoiceCreateOrConnectWithoutOrderInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutOrderInput | InvoiceUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: InvoiceCreateManyOrderInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutOrderInput | InvoiceUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutOrderInput | InvoiceUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<InvoiceCreateWithoutOrderInput, InvoiceUncheckedCreateWithoutOrderInput> | InvoiceCreateWithoutOrderInput[] | InvoiceUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutOrderInput | InvoiceCreateOrConnectWithoutOrderInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutOrderInput | InvoiceUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: InvoiceCreateManyOrderInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutOrderInput | InvoiceUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutOrderInput | InvoiceUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type OrderCreateNestedOneWithoutItemsInput = {
    create?: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutItemsInput
    connect?: OrderWhereUniqueInput
  }

  export type ProgramCreateNestedOneWithoutOrderItemsInput = {
    create?: XOR<ProgramCreateWithoutOrderItemsInput, ProgramUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutOrderItemsInput
    connect?: ProgramWhereUniqueInput
  }

  export type ActivityCreateNestedOneWithoutOrderItemsInput = {
    create?: XOR<ActivityCreateWithoutOrderItemsInput, ActivityUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: ActivityCreateOrConnectWithoutOrderItemsInput
    connect?: ActivityWhereUniqueInput
  }

  export type ExtraCreateNestedOneWithoutOrderItemsInput = {
    create?: XOR<ExtraCreateWithoutOrderItemsInput, ExtraUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: ExtraCreateOrConnectWithoutOrderItemsInput
    connect?: ExtraWhereUniqueInput
  }

  export type OrderUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutItemsInput
    upsert?: OrderUpsertWithoutItemsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutItemsInput, OrderUpdateWithoutItemsInput>, OrderUncheckedUpdateWithoutItemsInput>
  }

  export type ProgramUpdateOneWithoutOrderItemsNestedInput = {
    create?: XOR<ProgramCreateWithoutOrderItemsInput, ProgramUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutOrderItemsInput
    upsert?: ProgramUpsertWithoutOrderItemsInput
    disconnect?: ProgramWhereInput | boolean
    delete?: ProgramWhereInput | boolean
    connect?: ProgramWhereUniqueInput
    update?: XOR<XOR<ProgramUpdateToOneWithWhereWithoutOrderItemsInput, ProgramUpdateWithoutOrderItemsInput>, ProgramUncheckedUpdateWithoutOrderItemsInput>
  }

  export type ActivityUpdateOneWithoutOrderItemsNestedInput = {
    create?: XOR<ActivityCreateWithoutOrderItemsInput, ActivityUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: ActivityCreateOrConnectWithoutOrderItemsInput
    upsert?: ActivityUpsertWithoutOrderItemsInput
    disconnect?: ActivityWhereInput | boolean
    delete?: ActivityWhereInput | boolean
    connect?: ActivityWhereUniqueInput
    update?: XOR<XOR<ActivityUpdateToOneWithWhereWithoutOrderItemsInput, ActivityUpdateWithoutOrderItemsInput>, ActivityUncheckedUpdateWithoutOrderItemsInput>
  }

  export type ExtraUpdateOneWithoutOrderItemsNestedInput = {
    create?: XOR<ExtraCreateWithoutOrderItemsInput, ExtraUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: ExtraCreateOrConnectWithoutOrderItemsInput
    upsert?: ExtraUpsertWithoutOrderItemsInput
    disconnect?: ExtraWhereInput | boolean
    delete?: ExtraWhereInput | boolean
    connect?: ExtraWhereUniqueInput
    update?: XOR<XOR<ExtraUpdateToOneWithWhereWithoutOrderItemsInput, ExtraUpdateWithoutOrderItemsInput>, ExtraUncheckedUpdateWithoutOrderItemsInput>
  }

  export type CustomerCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<CustomerCreateWithoutInvoicesInput, CustomerUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutInvoicesInput
    connect?: CustomerWhereUniqueInput
  }

  export type OrderCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<OrderCreateWithoutInvoicesInput, OrderUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: OrderCreateOrConnectWithoutInvoicesInput
    connect?: OrderWhereUniqueInput
  }

  export type CustomerUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<CustomerCreateWithoutInvoicesInput, CustomerUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutInvoicesInput
    upsert?: CustomerUpsertWithoutInvoicesInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutInvoicesInput, CustomerUpdateWithoutInvoicesInput>, CustomerUncheckedUpdateWithoutInvoicesInput>
  }

  export type OrderUpdateOneWithoutInvoicesNestedInput = {
    create?: XOR<OrderCreateWithoutInvoicesInput, OrderUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: OrderCreateOrConnectWithoutInvoicesInput
    upsert?: OrderUpsertWithoutInvoicesInput
    disconnect?: OrderWhereInput | boolean
    delete?: OrderWhereInput | boolean
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutInvoicesInput, OrderUpdateWithoutInvoicesInput>, OrderUncheckedUpdateWithoutInvoicesInput>
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type UserSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type UserSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type UserSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    upsert?: UserSessionUpsertWithWhereUniqueWithoutUserInput | UserSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    set?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    disconnect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    delete?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    update?: UserSessionUpdateWithWhereUniqueWithoutUserInput | UserSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSessionUpdateManyWithWhereWithoutUserInput | UserSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type UserSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    upsert?: UserSessionUpsertWithWhereUniqueWithoutUserInput | UserSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    set?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    disconnect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    delete?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    update?: UserSessionUpdateWithWhereUniqueWithoutUserInput | UserSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSessionUpdateManyWithWhereWithoutUserInput | UserSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type SessionCreateWithoutProgramInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    date: Date | string
    endDate?: Date | string | null
    venue: JsonNullValueInput | InputJsonValue
    teamSize?: number | null
    teamName?: string | null
    companyName?: string | null
    industryType?: string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    customObjectives?: string | null
    status?: string
    isPublic?: boolean
    debriefCompleted?: boolean
    debriefReport?: NullableJsonNullValueInput | InputJsonValue
    debriefGeneratedAt?: Date | string | null
    notes?: string | null
    orders?: OrderCreateNestedManyWithoutLinkedSessionInput
  }

  export type SessionUncheckedCreateWithoutProgramInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    date: Date | string
    endDate?: Date | string | null
    venue: JsonNullValueInput | InputJsonValue
    teamSize?: number | null
    teamName?: string | null
    companyName?: string | null
    industryType?: string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    customObjectives?: string | null
    status?: string
    isPublic?: boolean
    debriefCompleted?: boolean
    debriefReport?: NullableJsonNullValueInput | InputJsonValue
    debriefGeneratedAt?: Date | string | null
    notes?: string | null
    orders?: OrderUncheckedCreateNestedManyWithoutLinkedSessionInput
  }

  export type SessionCreateOrConnectWithoutProgramInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutProgramInput, SessionUncheckedCreateWithoutProgramInput>
  }

  export type SessionCreateManyProgramInputEnvelope = {
    data: SessionCreateManyProgramInput | SessionCreateManyProgramInput[]
  }

  export type ProgramActivityCreateWithoutProgramInput = {
    id?: string
    createdAt?: Date | string
    order?: number
    duration?: number | null
    notes?: string | null
    activity: ActivityCreateNestedOneWithoutProgramLinksInput
  }

  export type ProgramActivityUncheckedCreateWithoutProgramInput = {
    id?: string
    createdAt?: Date | string
    activityId: string
    order?: number
    duration?: number | null
    notes?: string | null
  }

  export type ProgramActivityCreateOrConnectWithoutProgramInput = {
    where: ProgramActivityWhereUniqueInput
    create: XOR<ProgramActivityCreateWithoutProgramInput, ProgramActivityUncheckedCreateWithoutProgramInput>
  }

  export type ProgramActivityCreateManyProgramInputEnvelope = {
    data: ProgramActivityCreateManyProgramInput | ProgramActivityCreateManyProgramInput[]
  }

  export type OrderItemCreateWithoutProgramInput = {
    id?: string
    createdAt?: Date | string
    date: string
    startTime?: string | null
    endTime?: string | null
    price?: number
    notes?: string | null
    order: OrderCreateNestedOneWithoutItemsInput
    activity?: ActivityCreateNestedOneWithoutOrderItemsInput
    extra?: ExtraCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateWithoutProgramInput = {
    id?: string
    createdAt?: Date | string
    orderId: string
    activityId?: string | null
    extraId?: string | null
    date: string
    startTime?: string | null
    endTime?: string | null
    price?: number
    notes?: string | null
  }

  export type OrderItemCreateOrConnectWithoutProgramInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutProgramInput, OrderItemUncheckedCreateWithoutProgramInput>
  }

  export type OrderItemCreateManyProgramInputEnvelope = {
    data: OrderItemCreateManyProgramInput | OrderItemCreateManyProgramInput[]
  }

  export type SessionUpsertWithWhereUniqueWithoutProgramInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutProgramInput, SessionUncheckedUpdateWithoutProgramInput>
    create: XOR<SessionCreateWithoutProgramInput, SessionUncheckedCreateWithoutProgramInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutProgramInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutProgramInput, SessionUncheckedUpdateWithoutProgramInput>
  }

  export type SessionUpdateManyWithWhereWithoutProgramInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutProgramInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    programId?: StringNullableFilter<"Session"> | string | null
    date?: DateTimeFilter<"Session"> | Date | string
    endDate?: DateTimeNullableFilter<"Session"> | Date | string | null
    venue?: JsonFilter<"Session">
    teamSize?: IntNullableFilter<"Session"> | number | null
    teamName?: StringNullableFilter<"Session"> | string | null
    companyName?: StringNullableFilter<"Session"> | string | null
    industryType?: StringNullableFilter<"Session"> | string | null
    objectives?: JsonNullableFilter<"Session">
    customObjectives?: StringNullableFilter<"Session"> | string | null
    status?: StringFilter<"Session"> | string
    isPublic?: BoolFilter<"Session"> | boolean
    debriefCompleted?: BoolFilter<"Session"> | boolean
    debriefReport?: JsonNullableFilter<"Session">
    debriefGeneratedAt?: DateTimeNullableFilter<"Session"> | Date | string | null
    notes?: StringNullableFilter<"Session"> | string | null
  }

  export type ProgramActivityUpsertWithWhereUniqueWithoutProgramInput = {
    where: ProgramActivityWhereUniqueInput
    update: XOR<ProgramActivityUpdateWithoutProgramInput, ProgramActivityUncheckedUpdateWithoutProgramInput>
    create: XOR<ProgramActivityCreateWithoutProgramInput, ProgramActivityUncheckedCreateWithoutProgramInput>
  }

  export type ProgramActivityUpdateWithWhereUniqueWithoutProgramInput = {
    where: ProgramActivityWhereUniqueInput
    data: XOR<ProgramActivityUpdateWithoutProgramInput, ProgramActivityUncheckedUpdateWithoutProgramInput>
  }

  export type ProgramActivityUpdateManyWithWhereWithoutProgramInput = {
    where: ProgramActivityScalarWhereInput
    data: XOR<ProgramActivityUpdateManyMutationInput, ProgramActivityUncheckedUpdateManyWithoutProgramInput>
  }

  export type ProgramActivityScalarWhereInput = {
    AND?: ProgramActivityScalarWhereInput | ProgramActivityScalarWhereInput[]
    OR?: ProgramActivityScalarWhereInput[]
    NOT?: ProgramActivityScalarWhereInput | ProgramActivityScalarWhereInput[]
    id?: StringFilter<"ProgramActivity"> | string
    createdAt?: DateTimeFilter<"ProgramActivity"> | Date | string
    programId?: StringFilter<"ProgramActivity"> | string
    activityId?: StringFilter<"ProgramActivity"> | string
    order?: IntFilter<"ProgramActivity"> | number
    duration?: IntNullableFilter<"ProgramActivity"> | number | null
    notes?: StringNullableFilter<"ProgramActivity"> | string | null
  }

  export type OrderItemUpsertWithWhereUniqueWithoutProgramInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutProgramInput, OrderItemUncheckedUpdateWithoutProgramInput>
    create: XOR<OrderItemCreateWithoutProgramInput, OrderItemUncheckedCreateWithoutProgramInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutProgramInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutProgramInput, OrderItemUncheckedUpdateWithoutProgramInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutProgramInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutProgramInput>
  }

  export type OrderItemScalarWhereInput = {
    AND?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    OR?: OrderItemScalarWhereInput[]
    NOT?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    id?: StringFilter<"OrderItem"> | string
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
    orderId?: StringFilter<"OrderItem"> | string
    programId?: StringNullableFilter<"OrderItem"> | string | null
    activityId?: StringNullableFilter<"OrderItem"> | string | null
    extraId?: StringNullableFilter<"OrderItem"> | string | null
    date?: StringFilter<"OrderItem"> | string
    startTime?: StringNullableFilter<"OrderItem"> | string | null
    endTime?: StringNullableFilter<"OrderItem"> | string | null
    price?: IntFilter<"OrderItem"> | number
    notes?: StringNullableFilter<"OrderItem"> | string | null
  }

  export type ProgramActivityCreateWithoutActivityInput = {
    id?: string
    createdAt?: Date | string
    order?: number
    duration?: number | null
    notes?: string | null
    program: ProgramCreateNestedOneWithoutActivityLinksInput
  }

  export type ProgramActivityUncheckedCreateWithoutActivityInput = {
    id?: string
    createdAt?: Date | string
    programId: string
    order?: number
    duration?: number | null
    notes?: string | null
  }

  export type ProgramActivityCreateOrConnectWithoutActivityInput = {
    where: ProgramActivityWhereUniqueInput
    create: XOR<ProgramActivityCreateWithoutActivityInput, ProgramActivityUncheckedCreateWithoutActivityInput>
  }

  export type ProgramActivityCreateManyActivityInputEnvelope = {
    data: ProgramActivityCreateManyActivityInput | ProgramActivityCreateManyActivityInput[]
  }

  export type OrderItemCreateWithoutActivityInput = {
    id?: string
    createdAt?: Date | string
    date: string
    startTime?: string | null
    endTime?: string | null
    price?: number
    notes?: string | null
    order: OrderCreateNestedOneWithoutItemsInput
    program?: ProgramCreateNestedOneWithoutOrderItemsInput
    extra?: ExtraCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateWithoutActivityInput = {
    id?: string
    createdAt?: Date | string
    orderId: string
    programId?: string | null
    extraId?: string | null
    date: string
    startTime?: string | null
    endTime?: string | null
    price?: number
    notes?: string | null
  }

  export type OrderItemCreateOrConnectWithoutActivityInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutActivityInput, OrderItemUncheckedCreateWithoutActivityInput>
  }

  export type OrderItemCreateManyActivityInputEnvelope = {
    data: OrderItemCreateManyActivityInput | OrderItemCreateManyActivityInput[]
  }

  export type ProgramActivityUpsertWithWhereUniqueWithoutActivityInput = {
    where: ProgramActivityWhereUniqueInput
    update: XOR<ProgramActivityUpdateWithoutActivityInput, ProgramActivityUncheckedUpdateWithoutActivityInput>
    create: XOR<ProgramActivityCreateWithoutActivityInput, ProgramActivityUncheckedCreateWithoutActivityInput>
  }

  export type ProgramActivityUpdateWithWhereUniqueWithoutActivityInput = {
    where: ProgramActivityWhereUniqueInput
    data: XOR<ProgramActivityUpdateWithoutActivityInput, ProgramActivityUncheckedUpdateWithoutActivityInput>
  }

  export type ProgramActivityUpdateManyWithWhereWithoutActivityInput = {
    where: ProgramActivityScalarWhereInput
    data: XOR<ProgramActivityUpdateManyMutationInput, ProgramActivityUncheckedUpdateManyWithoutActivityInput>
  }

  export type OrderItemUpsertWithWhereUniqueWithoutActivityInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutActivityInput, OrderItemUncheckedUpdateWithoutActivityInput>
    create: XOR<OrderItemCreateWithoutActivityInput, OrderItemUncheckedCreateWithoutActivityInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutActivityInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutActivityInput, OrderItemUncheckedUpdateWithoutActivityInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutActivityInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutActivityInput>
  }

  export type ProgramCreateWithoutActivityLinksInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title: string
    slug: string
    category?: string
    status?: string
    featured?: boolean
    order?: number
    subtitle?: string | null
    excerpt?: string | null
    description?: NullableJsonNullValueInput | InputJsonValue
    teamSize?: number | null
    minTeamSize?: number | null
    maxTeamSize?: number | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    industryType?: string | null
    physicalLevel?: string | null
    indoorOutdoor?: string | null
    duration: number
    includesCatering?: boolean
    debriefIncluded?: boolean
    facilitationRequired?: boolean
    technicalRequirements?: NullableJsonNullValueInput | InputJsonValue
    materialsIncluded?: NullableJsonNullValueInput | InputJsonValue
    venueRequirements?: NullableJsonNullValueInput | InputJsonValue
    price?: number | null
    pricePerPerson?: number | null
    pricingNotes?: string | null
    featuredImageUrl?: string | null
    featuredImageAlt?: string | null
    galleryImages?: NullableJsonNullValueInput | InputJsonValue
    videoUrl?: string | null
    seo?: NullableJsonNullValueInput | InputJsonValue
    sessions?: SessionCreateNestedManyWithoutProgramInput
    orderItems?: OrderItemCreateNestedManyWithoutProgramInput
  }

  export type ProgramUncheckedCreateWithoutActivityLinksInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title: string
    slug: string
    category?: string
    status?: string
    featured?: boolean
    order?: number
    subtitle?: string | null
    excerpt?: string | null
    description?: NullableJsonNullValueInput | InputJsonValue
    teamSize?: number | null
    minTeamSize?: number | null
    maxTeamSize?: number | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    industryType?: string | null
    physicalLevel?: string | null
    indoorOutdoor?: string | null
    duration: number
    includesCatering?: boolean
    debriefIncluded?: boolean
    facilitationRequired?: boolean
    technicalRequirements?: NullableJsonNullValueInput | InputJsonValue
    materialsIncluded?: NullableJsonNullValueInput | InputJsonValue
    venueRequirements?: NullableJsonNullValueInput | InputJsonValue
    price?: number | null
    pricePerPerson?: number | null
    pricingNotes?: string | null
    featuredImageUrl?: string | null
    featuredImageAlt?: string | null
    galleryImages?: NullableJsonNullValueInput | InputJsonValue
    videoUrl?: string | null
    seo?: NullableJsonNullValueInput | InputJsonValue
    sessions?: SessionUncheckedCreateNestedManyWithoutProgramInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProgramInput
  }

  export type ProgramCreateOrConnectWithoutActivityLinksInput = {
    where: ProgramWhereUniqueInput
    create: XOR<ProgramCreateWithoutActivityLinksInput, ProgramUncheckedCreateWithoutActivityLinksInput>
  }

  export type ActivityCreateWithoutProgramLinksInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title: string
    slug: string
    category?: string
    status?: string
    featured?: boolean
    order?: number
    subtitle?: string | null
    excerpt?: string | null
    description?: NullableJsonNullValueInput | InputJsonValue
    minParticipants?: number | null
    maxParticipants?: number | null
    idealGroupSize?: number | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    learningOutcomes?: NullableJsonNullValueInput | InputJsonValue
    physicalDemand?: string | null
    indoorOutdoor?: string | null
    duration: number
    materialsNeeded?: NullableJsonNullValueInput | InputJsonValue
    setupTime?: number | null
    facilitatorGuide?: NullableJsonNullValueInput | InputJsonValue
    difficultyLevel?: string | null
    scalable?: boolean
    canCombine?: boolean
    price?: number | null
    featuredImageUrl?: string | null
    featuredImageAlt?: string | null
    galleryImages?: NullableJsonNullValueInput | InputJsonValue
    videoUrl?: string | null
    instructionPdfUrl?: string | null
    seo?: NullableJsonNullValueInput | InputJsonValue
    orderItems?: OrderItemCreateNestedManyWithoutActivityInput
  }

  export type ActivityUncheckedCreateWithoutProgramLinksInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title: string
    slug: string
    category?: string
    status?: string
    featured?: boolean
    order?: number
    subtitle?: string | null
    excerpt?: string | null
    description?: NullableJsonNullValueInput | InputJsonValue
    minParticipants?: number | null
    maxParticipants?: number | null
    idealGroupSize?: number | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    learningOutcomes?: NullableJsonNullValueInput | InputJsonValue
    physicalDemand?: string | null
    indoorOutdoor?: string | null
    duration: number
    materialsNeeded?: NullableJsonNullValueInput | InputJsonValue
    setupTime?: number | null
    facilitatorGuide?: NullableJsonNullValueInput | InputJsonValue
    difficultyLevel?: string | null
    scalable?: boolean
    canCombine?: boolean
    price?: number | null
    featuredImageUrl?: string | null
    featuredImageAlt?: string | null
    galleryImages?: NullableJsonNullValueInput | InputJsonValue
    videoUrl?: string | null
    instructionPdfUrl?: string | null
    seo?: NullableJsonNullValueInput | InputJsonValue
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutActivityInput
  }

  export type ActivityCreateOrConnectWithoutProgramLinksInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutProgramLinksInput, ActivityUncheckedCreateWithoutProgramLinksInput>
  }

  export type ProgramUpsertWithoutActivityLinksInput = {
    update: XOR<ProgramUpdateWithoutActivityLinksInput, ProgramUncheckedUpdateWithoutActivityLinksInput>
    create: XOR<ProgramCreateWithoutActivityLinksInput, ProgramUncheckedCreateWithoutActivityLinksInput>
    where?: ProgramWhereInput
  }

  export type ProgramUpdateToOneWithWhereWithoutActivityLinksInput = {
    where?: ProgramWhereInput
    data: XOR<ProgramUpdateWithoutActivityLinksInput, ProgramUncheckedUpdateWithoutActivityLinksInput>
  }

  export type ProgramUpdateWithoutActivityLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableJsonNullValueInput | InputJsonValue
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    minTeamSize?: NullableIntFieldUpdateOperationsInput | number | null
    maxTeamSize?: NullableIntFieldUpdateOperationsInput | number | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    industryType?: NullableStringFieldUpdateOperationsInput | string | null
    physicalLevel?: NullableStringFieldUpdateOperationsInput | string | null
    indoorOutdoor?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    includesCatering?: BoolFieldUpdateOperationsInput | boolean
    debriefIncluded?: BoolFieldUpdateOperationsInput | boolean
    facilitationRequired?: BoolFieldUpdateOperationsInput | boolean
    technicalRequirements?: NullableJsonNullValueInput | InputJsonValue
    materialsIncluded?: NullableJsonNullValueInput | InputJsonValue
    venueRequirements?: NullableJsonNullValueInput | InputJsonValue
    price?: NullableIntFieldUpdateOperationsInput | number | null
    pricePerPerson?: NullableIntFieldUpdateOperationsInput | number | null
    pricingNotes?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    galleryImages?: NullableJsonNullValueInput | InputJsonValue
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    seo?: NullableJsonNullValueInput | InputJsonValue
    sessions?: SessionUpdateManyWithoutProgramNestedInput
    orderItems?: OrderItemUpdateManyWithoutProgramNestedInput
  }

  export type ProgramUncheckedUpdateWithoutActivityLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableJsonNullValueInput | InputJsonValue
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    minTeamSize?: NullableIntFieldUpdateOperationsInput | number | null
    maxTeamSize?: NullableIntFieldUpdateOperationsInput | number | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    industryType?: NullableStringFieldUpdateOperationsInput | string | null
    physicalLevel?: NullableStringFieldUpdateOperationsInput | string | null
    indoorOutdoor?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    includesCatering?: BoolFieldUpdateOperationsInput | boolean
    debriefIncluded?: BoolFieldUpdateOperationsInput | boolean
    facilitationRequired?: BoolFieldUpdateOperationsInput | boolean
    technicalRequirements?: NullableJsonNullValueInput | InputJsonValue
    materialsIncluded?: NullableJsonNullValueInput | InputJsonValue
    venueRequirements?: NullableJsonNullValueInput | InputJsonValue
    price?: NullableIntFieldUpdateOperationsInput | number | null
    pricePerPerson?: NullableIntFieldUpdateOperationsInput | number | null
    pricingNotes?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    galleryImages?: NullableJsonNullValueInput | InputJsonValue
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    seo?: NullableJsonNullValueInput | InputJsonValue
    sessions?: SessionUncheckedUpdateManyWithoutProgramNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type ActivityUpsertWithoutProgramLinksInput = {
    update: XOR<ActivityUpdateWithoutProgramLinksInput, ActivityUncheckedUpdateWithoutProgramLinksInput>
    create: XOR<ActivityCreateWithoutProgramLinksInput, ActivityUncheckedCreateWithoutProgramLinksInput>
    where?: ActivityWhereInput
  }

  export type ActivityUpdateToOneWithWhereWithoutProgramLinksInput = {
    where?: ActivityWhereInput
    data: XOR<ActivityUpdateWithoutProgramLinksInput, ActivityUncheckedUpdateWithoutProgramLinksInput>
  }

  export type ActivityUpdateWithoutProgramLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableJsonNullValueInput | InputJsonValue
    minParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    idealGroupSize?: NullableIntFieldUpdateOperationsInput | number | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    learningOutcomes?: NullableJsonNullValueInput | InputJsonValue
    physicalDemand?: NullableStringFieldUpdateOperationsInput | string | null
    indoorOutdoor?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    materialsNeeded?: NullableJsonNullValueInput | InputJsonValue
    setupTime?: NullableIntFieldUpdateOperationsInput | number | null
    facilitatorGuide?: NullableJsonNullValueInput | InputJsonValue
    difficultyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    scalable?: BoolFieldUpdateOperationsInput | boolean
    canCombine?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableIntFieldUpdateOperationsInput | number | null
    featuredImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    galleryImages?: NullableJsonNullValueInput | InputJsonValue
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    instructionPdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    seo?: NullableJsonNullValueInput | InputJsonValue
    orderItems?: OrderItemUpdateManyWithoutActivityNestedInput
  }

  export type ActivityUncheckedUpdateWithoutProgramLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableJsonNullValueInput | InputJsonValue
    minParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    idealGroupSize?: NullableIntFieldUpdateOperationsInput | number | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    learningOutcomes?: NullableJsonNullValueInput | InputJsonValue
    physicalDemand?: NullableStringFieldUpdateOperationsInput | string | null
    indoorOutdoor?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    materialsNeeded?: NullableJsonNullValueInput | InputJsonValue
    setupTime?: NullableIntFieldUpdateOperationsInput | number | null
    facilitatorGuide?: NullableJsonNullValueInput | InputJsonValue
    difficultyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    scalable?: BoolFieldUpdateOperationsInput | boolean
    canCombine?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableIntFieldUpdateOperationsInput | number | null
    featuredImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    galleryImages?: NullableJsonNullValueInput | InputJsonValue
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    instructionPdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    seo?: NullableJsonNullValueInput | InputJsonValue
    orderItems?: OrderItemUncheckedUpdateManyWithoutActivityNestedInput
  }

  export type OrderItemCreateWithoutExtraInput = {
    id?: string
    createdAt?: Date | string
    date: string
    startTime?: string | null
    endTime?: string | null
    price?: number
    notes?: string | null
    order: OrderCreateNestedOneWithoutItemsInput
    program?: ProgramCreateNestedOneWithoutOrderItemsInput
    activity?: ActivityCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateWithoutExtraInput = {
    id?: string
    createdAt?: Date | string
    orderId: string
    programId?: string | null
    activityId?: string | null
    date: string
    startTime?: string | null
    endTime?: string | null
    price?: number
    notes?: string | null
  }

  export type OrderItemCreateOrConnectWithoutExtraInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutExtraInput, OrderItemUncheckedCreateWithoutExtraInput>
  }

  export type OrderItemCreateManyExtraInputEnvelope = {
    data: OrderItemCreateManyExtraInput | OrderItemCreateManyExtraInput[]
  }

  export type OrderItemUpsertWithWhereUniqueWithoutExtraInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutExtraInput, OrderItemUncheckedUpdateWithoutExtraInput>
    create: XOR<OrderItemCreateWithoutExtraInput, OrderItemUncheckedCreateWithoutExtraInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutExtraInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutExtraInput, OrderItemUncheckedUpdateWithoutExtraInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutExtraInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutExtraInput>
  }

  export type ProgramCreateWithoutSessionsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title: string
    slug: string
    category?: string
    status?: string
    featured?: boolean
    order?: number
    subtitle?: string | null
    excerpt?: string | null
    description?: NullableJsonNullValueInput | InputJsonValue
    teamSize?: number | null
    minTeamSize?: number | null
    maxTeamSize?: number | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    industryType?: string | null
    physicalLevel?: string | null
    indoorOutdoor?: string | null
    duration: number
    includesCatering?: boolean
    debriefIncluded?: boolean
    facilitationRequired?: boolean
    technicalRequirements?: NullableJsonNullValueInput | InputJsonValue
    materialsIncluded?: NullableJsonNullValueInput | InputJsonValue
    venueRequirements?: NullableJsonNullValueInput | InputJsonValue
    price?: number | null
    pricePerPerson?: number | null
    pricingNotes?: string | null
    featuredImageUrl?: string | null
    featuredImageAlt?: string | null
    galleryImages?: NullableJsonNullValueInput | InputJsonValue
    videoUrl?: string | null
    seo?: NullableJsonNullValueInput | InputJsonValue
    activityLinks?: ProgramActivityCreateNestedManyWithoutProgramInput
    orderItems?: OrderItemCreateNestedManyWithoutProgramInput
  }

  export type ProgramUncheckedCreateWithoutSessionsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title: string
    slug: string
    category?: string
    status?: string
    featured?: boolean
    order?: number
    subtitle?: string | null
    excerpt?: string | null
    description?: NullableJsonNullValueInput | InputJsonValue
    teamSize?: number | null
    minTeamSize?: number | null
    maxTeamSize?: number | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    industryType?: string | null
    physicalLevel?: string | null
    indoorOutdoor?: string | null
    duration: number
    includesCatering?: boolean
    debriefIncluded?: boolean
    facilitationRequired?: boolean
    technicalRequirements?: NullableJsonNullValueInput | InputJsonValue
    materialsIncluded?: NullableJsonNullValueInput | InputJsonValue
    venueRequirements?: NullableJsonNullValueInput | InputJsonValue
    price?: number | null
    pricePerPerson?: number | null
    pricingNotes?: string | null
    featuredImageUrl?: string | null
    featuredImageAlt?: string | null
    galleryImages?: NullableJsonNullValueInput | InputJsonValue
    videoUrl?: string | null
    seo?: NullableJsonNullValueInput | InputJsonValue
    activityLinks?: ProgramActivityUncheckedCreateNestedManyWithoutProgramInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProgramInput
  }

  export type ProgramCreateOrConnectWithoutSessionsInput = {
    where: ProgramWhereUniqueInput
    create: XOR<ProgramCreateWithoutSessionsInput, ProgramUncheckedCreateWithoutSessionsInput>
  }

  export type OrderCreateWithoutLinkedSessionInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    orderNumber: string
    source?: string
    status?: string
    sessionName?: string | null
    dates: JsonNullValueInput | InputJsonValue
    venue: JsonNullValueInput | InputJsonValue
    teamSize?: number | null
    teamComposition?: NullableJsonNullValueInput | InputJsonValue
    objectives?: NullableJsonNullValueInput | InputJsonValue
    customObjectives?: string | null
    industryType?: string | null
    technicalRequirements?: NullableJsonNullValueInput | InputJsonValue
    pricing?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: string | null
    paymentDueDate?: Date | string | null
    invoiceEmail?: string | null
    logistics?: NullableJsonNullValueInput | InputJsonValue
    contacts?: NullableJsonNullValueInput | InputJsonValue
    documents?: NullableJsonNullValueInput | InputJsonValue
    internalNotes?: string | null
    customer?: CustomerCreateNestedOneWithoutOrdersInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    invoices?: InvoiceCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutLinkedSessionInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    orderNumber: string
    customerId?: string | null
    source?: string
    status?: string
    sessionName?: string | null
    dates: JsonNullValueInput | InputJsonValue
    venue: JsonNullValueInput | InputJsonValue
    teamSize?: number | null
    teamComposition?: NullableJsonNullValueInput | InputJsonValue
    objectives?: NullableJsonNullValueInput | InputJsonValue
    customObjectives?: string | null
    industryType?: string | null
    technicalRequirements?: NullableJsonNullValueInput | InputJsonValue
    pricing?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: string | null
    paymentDueDate?: Date | string | null
    invoiceEmail?: string | null
    logistics?: NullableJsonNullValueInput | InputJsonValue
    contacts?: NullableJsonNullValueInput | InputJsonValue
    documents?: NullableJsonNullValueInput | InputJsonValue
    internalNotes?: string | null
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutLinkedSessionInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutLinkedSessionInput, OrderUncheckedCreateWithoutLinkedSessionInput>
  }

  export type OrderCreateManyLinkedSessionInputEnvelope = {
    data: OrderCreateManyLinkedSessionInput | OrderCreateManyLinkedSessionInput[]
  }

  export type ProgramUpsertWithoutSessionsInput = {
    update: XOR<ProgramUpdateWithoutSessionsInput, ProgramUncheckedUpdateWithoutSessionsInput>
    create: XOR<ProgramCreateWithoutSessionsInput, ProgramUncheckedCreateWithoutSessionsInput>
    where?: ProgramWhereInput
  }

  export type ProgramUpdateToOneWithWhereWithoutSessionsInput = {
    where?: ProgramWhereInput
    data: XOR<ProgramUpdateWithoutSessionsInput, ProgramUncheckedUpdateWithoutSessionsInput>
  }

  export type ProgramUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableJsonNullValueInput | InputJsonValue
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    minTeamSize?: NullableIntFieldUpdateOperationsInput | number | null
    maxTeamSize?: NullableIntFieldUpdateOperationsInput | number | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    industryType?: NullableStringFieldUpdateOperationsInput | string | null
    physicalLevel?: NullableStringFieldUpdateOperationsInput | string | null
    indoorOutdoor?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    includesCatering?: BoolFieldUpdateOperationsInput | boolean
    debriefIncluded?: BoolFieldUpdateOperationsInput | boolean
    facilitationRequired?: BoolFieldUpdateOperationsInput | boolean
    technicalRequirements?: NullableJsonNullValueInput | InputJsonValue
    materialsIncluded?: NullableJsonNullValueInput | InputJsonValue
    venueRequirements?: NullableJsonNullValueInput | InputJsonValue
    price?: NullableIntFieldUpdateOperationsInput | number | null
    pricePerPerson?: NullableIntFieldUpdateOperationsInput | number | null
    pricingNotes?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    galleryImages?: NullableJsonNullValueInput | InputJsonValue
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    seo?: NullableJsonNullValueInput | InputJsonValue
    activityLinks?: ProgramActivityUpdateManyWithoutProgramNestedInput
    orderItems?: OrderItemUpdateManyWithoutProgramNestedInput
  }

  export type ProgramUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableJsonNullValueInput | InputJsonValue
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    minTeamSize?: NullableIntFieldUpdateOperationsInput | number | null
    maxTeamSize?: NullableIntFieldUpdateOperationsInput | number | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    industryType?: NullableStringFieldUpdateOperationsInput | string | null
    physicalLevel?: NullableStringFieldUpdateOperationsInput | string | null
    indoorOutdoor?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    includesCatering?: BoolFieldUpdateOperationsInput | boolean
    debriefIncluded?: BoolFieldUpdateOperationsInput | boolean
    facilitationRequired?: BoolFieldUpdateOperationsInput | boolean
    technicalRequirements?: NullableJsonNullValueInput | InputJsonValue
    materialsIncluded?: NullableJsonNullValueInput | InputJsonValue
    venueRequirements?: NullableJsonNullValueInput | InputJsonValue
    price?: NullableIntFieldUpdateOperationsInput | number | null
    pricePerPerson?: NullableIntFieldUpdateOperationsInput | number | null
    pricingNotes?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    galleryImages?: NullableJsonNullValueInput | InputJsonValue
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    seo?: NullableJsonNullValueInput | InputJsonValue
    activityLinks?: ProgramActivityUncheckedUpdateManyWithoutProgramNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type OrderUpsertWithWhereUniqueWithoutLinkedSessionInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutLinkedSessionInput, OrderUncheckedUpdateWithoutLinkedSessionInput>
    create: XOR<OrderCreateWithoutLinkedSessionInput, OrderUncheckedCreateWithoutLinkedSessionInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutLinkedSessionInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutLinkedSessionInput, OrderUncheckedUpdateWithoutLinkedSessionInput>
  }

  export type OrderUpdateManyWithWhereWithoutLinkedSessionInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutLinkedSessionInput>
  }

  export type OrderScalarWhereInput = {
    AND?: OrderScalarWhereInput | OrderScalarWhereInput[]
    OR?: OrderScalarWhereInput[]
    NOT?: OrderScalarWhereInput | OrderScalarWhereInput[]
    id?: StringFilter<"Order"> | string
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    orderNumber?: StringFilter<"Order"> | string
    customerId?: StringNullableFilter<"Order"> | string | null
    source?: StringFilter<"Order"> | string
    status?: StringFilter<"Order"> | string
    sessionName?: StringNullableFilter<"Order"> | string | null
    dates?: JsonFilter<"Order">
    venue?: JsonFilter<"Order">
    teamSize?: IntNullableFilter<"Order"> | number | null
    teamComposition?: JsonNullableFilter<"Order">
    objectives?: JsonNullableFilter<"Order">
    customObjectives?: StringNullableFilter<"Order"> | string | null
    industryType?: StringNullableFilter<"Order"> | string | null
    technicalRequirements?: JsonNullableFilter<"Order">
    pricing?: JsonNullableFilter<"Order">
    paymentMethod?: StringNullableFilter<"Order"> | string | null
    paymentDueDate?: DateTimeNullableFilter<"Order"> | Date | string | null
    invoiceEmail?: StringNullableFilter<"Order"> | string | null
    logistics?: JsonNullableFilter<"Order">
    contacts?: JsonNullableFilter<"Order">
    documents?: JsonNullableFilter<"Order">
    linkedSessionId?: StringNullableFilter<"Order"> | string | null
    internalNotes?: StringNullableFilter<"Order"> | string | null
  }

  export type OrderCreateWithoutCustomerInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    orderNumber: string
    source?: string
    status?: string
    sessionName?: string | null
    dates: JsonNullValueInput | InputJsonValue
    venue: JsonNullValueInput | InputJsonValue
    teamSize?: number | null
    teamComposition?: NullableJsonNullValueInput | InputJsonValue
    objectives?: NullableJsonNullValueInput | InputJsonValue
    customObjectives?: string | null
    industryType?: string | null
    technicalRequirements?: NullableJsonNullValueInput | InputJsonValue
    pricing?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: string | null
    paymentDueDate?: Date | string | null
    invoiceEmail?: string | null
    logistics?: NullableJsonNullValueInput | InputJsonValue
    contacts?: NullableJsonNullValueInput | InputJsonValue
    documents?: NullableJsonNullValueInput | InputJsonValue
    internalNotes?: string | null
    items?: OrderItemCreateNestedManyWithoutOrderInput
    linkedSession?: SessionCreateNestedOneWithoutOrdersInput
    invoices?: InvoiceCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutCustomerInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    orderNumber: string
    source?: string
    status?: string
    sessionName?: string | null
    dates: JsonNullValueInput | InputJsonValue
    venue: JsonNullValueInput | InputJsonValue
    teamSize?: number | null
    teamComposition?: NullableJsonNullValueInput | InputJsonValue
    objectives?: NullableJsonNullValueInput | InputJsonValue
    customObjectives?: string | null
    industryType?: string | null
    technicalRequirements?: NullableJsonNullValueInput | InputJsonValue
    pricing?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: string | null
    paymentDueDate?: Date | string | null
    invoiceEmail?: string | null
    logistics?: NullableJsonNullValueInput | InputJsonValue
    contacts?: NullableJsonNullValueInput | InputJsonValue
    documents?: NullableJsonNullValueInput | InputJsonValue
    linkedSessionId?: string | null
    internalNotes?: string | null
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutCustomerInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput>
  }

  export type OrderCreateManyCustomerInputEnvelope = {
    data: OrderCreateManyCustomerInput | OrderCreateManyCustomerInput[]
  }

  export type InvoiceCreateWithoutCustomerInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceNumber: string
    status?: string
    issueDate?: Date | string
    dueDate: Date | string
    paidDate?: Date | string | null
    items: JsonNullValueInput | InputJsonValue
    subtotal: number
    vatRate?: number | null
    vatAmount?: number | null
    totalAmount: number
    paidAmount?: number
    paymentMethod?: string | null
    bankAccount?: string | null
    variableSymbol?: string | null
    currency?: string
    pdfUrl?: string | null
    pdfGeneratedAt?: Date | string | null
    textBeforeItems?: string | null
    textAfterItems?: string | null
    notes?: string | null
    order?: OrderCreateNestedOneWithoutInvoicesInput
  }

  export type InvoiceUncheckedCreateWithoutCustomerInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceNumber: string
    status?: string
    orderId?: string | null
    issueDate?: Date | string
    dueDate: Date | string
    paidDate?: Date | string | null
    items: JsonNullValueInput | InputJsonValue
    subtotal: number
    vatRate?: number | null
    vatAmount?: number | null
    totalAmount: number
    paidAmount?: number
    paymentMethod?: string | null
    bankAccount?: string | null
    variableSymbol?: string | null
    currency?: string
    pdfUrl?: string | null
    pdfGeneratedAt?: Date | string | null
    textBeforeItems?: string | null
    textAfterItems?: string | null
    notes?: string | null
  }

  export type InvoiceCreateOrConnectWithoutCustomerInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutCustomerInput, InvoiceUncheckedCreateWithoutCustomerInput>
  }

  export type InvoiceCreateManyCustomerInputEnvelope = {
    data: InvoiceCreateManyCustomerInput | InvoiceCreateManyCustomerInput[]
  }

  export type OrderUpsertWithWhereUniqueWithoutCustomerInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutCustomerInput, OrderUncheckedUpdateWithoutCustomerInput>
    create: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutCustomerInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutCustomerInput, OrderUncheckedUpdateWithoutCustomerInput>
  }

  export type OrderUpdateManyWithWhereWithoutCustomerInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutCustomerInput>
  }

  export type InvoiceUpsertWithWhereUniqueWithoutCustomerInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutCustomerInput, InvoiceUncheckedUpdateWithoutCustomerInput>
    create: XOR<InvoiceCreateWithoutCustomerInput, InvoiceUncheckedCreateWithoutCustomerInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutCustomerInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutCustomerInput, InvoiceUncheckedUpdateWithoutCustomerInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutCustomerInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutCustomerInput>
  }

  export type InvoiceScalarWhereInput = {
    AND?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    OR?: InvoiceScalarWhereInput[]
    NOT?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    id?: StringFilter<"Invoice"> | string
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    invoiceNumber?: StringFilter<"Invoice"> | string
    status?: StringFilter<"Invoice"> | string
    customerId?: StringFilter<"Invoice"> | string
    orderId?: StringNullableFilter<"Invoice"> | string | null
    issueDate?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    paidDate?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    items?: JsonFilter<"Invoice">
    subtotal?: IntFilter<"Invoice"> | number
    vatRate?: IntNullableFilter<"Invoice"> | number | null
    vatAmount?: IntNullableFilter<"Invoice"> | number | null
    totalAmount?: IntFilter<"Invoice"> | number
    paidAmount?: IntFilter<"Invoice"> | number
    paymentMethod?: StringNullableFilter<"Invoice"> | string | null
    bankAccount?: StringNullableFilter<"Invoice"> | string | null
    variableSymbol?: StringNullableFilter<"Invoice"> | string | null
    currency?: StringFilter<"Invoice"> | string
    pdfUrl?: StringNullableFilter<"Invoice"> | string | null
    pdfGeneratedAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    textBeforeItems?: StringNullableFilter<"Invoice"> | string | null
    textAfterItems?: StringNullableFilter<"Invoice"> | string | null
    notes?: StringNullableFilter<"Invoice"> | string | null
  }

  export type CustomerCreateWithoutOrdersInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    firstName: string
    lastName: string
    phone?: string | null
    organization?: string | null
    organizationType?: string | null
    industryType?: string | null
    teamSize?: number | null
    address?: NullableJsonNullValueInput | InputJsonValue
    billingInfo?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    gdprConsent?: NullableJsonNullValueInput | InputJsonValue
    averagePaymentDays?: number | null
    paymentReliability?: string | null
    totalInvoiced?: number
    totalPaid?: number
    invoiceCount?: number
    overdueCount?: number
    lastInvoiceDate?: Date | string | null
    lastPaymentDate?: Date | string | null
    invoices?: InvoiceCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutOrdersInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    firstName: string
    lastName: string
    phone?: string | null
    organization?: string | null
    organizationType?: string | null
    industryType?: string | null
    teamSize?: number | null
    address?: NullableJsonNullValueInput | InputJsonValue
    billingInfo?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    gdprConsent?: NullableJsonNullValueInput | InputJsonValue
    averagePaymentDays?: number | null
    paymentReliability?: string | null
    totalInvoiced?: number
    totalPaid?: number
    invoiceCount?: number
    overdueCount?: number
    lastInvoiceDate?: Date | string | null
    lastPaymentDate?: Date | string | null
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutOrdersInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
  }

  export type OrderItemCreateWithoutOrderInput = {
    id?: string
    createdAt?: Date | string
    date: string
    startTime?: string | null
    endTime?: string | null
    price?: number
    notes?: string | null
    program?: ProgramCreateNestedOneWithoutOrderItemsInput
    activity?: ActivityCreateNestedOneWithoutOrderItemsInput
    extra?: ExtraCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateWithoutOrderInput = {
    id?: string
    createdAt?: Date | string
    programId?: string | null
    activityId?: string | null
    extraId?: string | null
    date: string
    startTime?: string | null
    endTime?: string | null
    price?: number
    notes?: string | null
  }

  export type OrderItemCreateOrConnectWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemCreateManyOrderInputEnvelope = {
    data: OrderItemCreateManyOrderInput | OrderItemCreateManyOrderInput[]
  }

  export type SessionCreateWithoutOrdersInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    date: Date | string
    endDate?: Date | string | null
    venue: JsonNullValueInput | InputJsonValue
    teamSize?: number | null
    teamName?: string | null
    companyName?: string | null
    industryType?: string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    customObjectives?: string | null
    status?: string
    isPublic?: boolean
    debriefCompleted?: boolean
    debriefReport?: NullableJsonNullValueInput | InputJsonValue
    debriefGeneratedAt?: Date | string | null
    notes?: string | null
    program?: ProgramCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateWithoutOrdersInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    programId?: string | null
    date: Date | string
    endDate?: Date | string | null
    venue: JsonNullValueInput | InputJsonValue
    teamSize?: number | null
    teamName?: string | null
    companyName?: string | null
    industryType?: string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    customObjectives?: string | null
    status?: string
    isPublic?: boolean
    debriefCompleted?: boolean
    debriefReport?: NullableJsonNullValueInput | InputJsonValue
    debriefGeneratedAt?: Date | string | null
    notes?: string | null
  }

  export type SessionCreateOrConnectWithoutOrdersInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutOrdersInput, SessionUncheckedCreateWithoutOrdersInput>
  }

  export type InvoiceCreateWithoutOrderInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceNumber: string
    status?: string
    issueDate?: Date | string
    dueDate: Date | string
    paidDate?: Date | string | null
    items: JsonNullValueInput | InputJsonValue
    subtotal: number
    vatRate?: number | null
    vatAmount?: number | null
    totalAmount: number
    paidAmount?: number
    paymentMethod?: string | null
    bankAccount?: string | null
    variableSymbol?: string | null
    currency?: string
    pdfUrl?: string | null
    pdfGeneratedAt?: Date | string | null
    textBeforeItems?: string | null
    textAfterItems?: string | null
    notes?: string | null
    customer: CustomerCreateNestedOneWithoutInvoicesInput
  }

  export type InvoiceUncheckedCreateWithoutOrderInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceNumber: string
    status?: string
    customerId: string
    issueDate?: Date | string
    dueDate: Date | string
    paidDate?: Date | string | null
    items: JsonNullValueInput | InputJsonValue
    subtotal: number
    vatRate?: number | null
    vatAmount?: number | null
    totalAmount: number
    paidAmount?: number
    paymentMethod?: string | null
    bankAccount?: string | null
    variableSymbol?: string | null
    currency?: string
    pdfUrl?: string | null
    pdfGeneratedAt?: Date | string | null
    textBeforeItems?: string | null
    textAfterItems?: string | null
    notes?: string | null
  }

  export type InvoiceCreateOrConnectWithoutOrderInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutOrderInput, InvoiceUncheckedCreateWithoutOrderInput>
  }

  export type InvoiceCreateManyOrderInputEnvelope = {
    data: InvoiceCreateManyOrderInput | InvoiceCreateManyOrderInput[]
  }

  export type CustomerUpsertWithoutOrdersInput = {
    update: XOR<CustomerUpdateWithoutOrdersInput, CustomerUncheckedUpdateWithoutOrdersInput>
    create: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutOrdersInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutOrdersInput, CustomerUncheckedUpdateWithoutOrdersInput>
  }

  export type CustomerUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    organizationType?: NullableStringFieldUpdateOperationsInput | string | null
    industryType?: NullableStringFieldUpdateOperationsInput | string | null
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    address?: NullableJsonNullValueInput | InputJsonValue
    billingInfo?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    gdprConsent?: NullableJsonNullValueInput | InputJsonValue
    averagePaymentDays?: NullableIntFieldUpdateOperationsInput | number | null
    paymentReliability?: NullableStringFieldUpdateOperationsInput | string | null
    totalInvoiced?: IntFieldUpdateOperationsInput | number
    totalPaid?: IntFieldUpdateOperationsInput | number
    invoiceCount?: IntFieldUpdateOperationsInput | number
    overdueCount?: IntFieldUpdateOperationsInput | number
    lastInvoiceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoices?: InvoiceUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    organizationType?: NullableStringFieldUpdateOperationsInput | string | null
    industryType?: NullableStringFieldUpdateOperationsInput | string | null
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    address?: NullableJsonNullValueInput | InputJsonValue
    billingInfo?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    gdprConsent?: NullableJsonNullValueInput | InputJsonValue
    averagePaymentDays?: NullableIntFieldUpdateOperationsInput | number | null
    paymentReliability?: NullableStringFieldUpdateOperationsInput | string | null
    totalInvoiced?: IntFieldUpdateOperationsInput | number
    totalPaid?: IntFieldUpdateOperationsInput | number
    invoiceCount?: IntFieldUpdateOperationsInput | number
    overdueCount?: IntFieldUpdateOperationsInput | number
    lastInvoiceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoices?: InvoiceUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type OrderItemUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutOrderInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutOrderInput>
  }

  export type SessionUpsertWithoutOrdersInput = {
    update: XOR<SessionUpdateWithoutOrdersInput, SessionUncheckedUpdateWithoutOrdersInput>
    create: XOR<SessionCreateWithoutOrdersInput, SessionUncheckedCreateWithoutOrdersInput>
    where?: SessionWhereInput
  }

  export type SessionUpdateToOneWithWhereWithoutOrdersInput = {
    where?: SessionWhereInput
    data: XOR<SessionUpdateWithoutOrdersInput, SessionUncheckedUpdateWithoutOrdersInput>
  }

  export type SessionUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    venue?: JsonNullValueInput | InputJsonValue
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    teamName?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    industryType?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    customObjectives?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    debriefCompleted?: BoolFieldUpdateOperationsInput | boolean
    debriefReport?: NullableJsonNullValueInput | InputJsonValue
    debriefGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    program?: ProgramUpdateOneWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    programId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    venue?: JsonNullValueInput | InputJsonValue
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    teamName?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    industryType?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    customObjectives?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    debriefCompleted?: BoolFieldUpdateOperationsInput | boolean
    debriefReport?: NullableJsonNullValueInput | InputJsonValue
    debriefGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InvoiceUpsertWithWhereUniqueWithoutOrderInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutOrderInput, InvoiceUncheckedUpdateWithoutOrderInput>
    create: XOR<InvoiceCreateWithoutOrderInput, InvoiceUncheckedCreateWithoutOrderInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutOrderInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutOrderInput, InvoiceUncheckedUpdateWithoutOrderInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutOrderInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutOrderInput>
  }

  export type OrderCreateWithoutItemsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    orderNumber: string
    source?: string
    status?: string
    sessionName?: string | null
    dates: JsonNullValueInput | InputJsonValue
    venue: JsonNullValueInput | InputJsonValue
    teamSize?: number | null
    teamComposition?: NullableJsonNullValueInput | InputJsonValue
    objectives?: NullableJsonNullValueInput | InputJsonValue
    customObjectives?: string | null
    industryType?: string | null
    technicalRequirements?: NullableJsonNullValueInput | InputJsonValue
    pricing?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: string | null
    paymentDueDate?: Date | string | null
    invoiceEmail?: string | null
    logistics?: NullableJsonNullValueInput | InputJsonValue
    contacts?: NullableJsonNullValueInput | InputJsonValue
    documents?: NullableJsonNullValueInput | InputJsonValue
    internalNotes?: string | null
    customer?: CustomerCreateNestedOneWithoutOrdersInput
    linkedSession?: SessionCreateNestedOneWithoutOrdersInput
    invoices?: InvoiceCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutItemsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    orderNumber: string
    customerId?: string | null
    source?: string
    status?: string
    sessionName?: string | null
    dates: JsonNullValueInput | InputJsonValue
    venue: JsonNullValueInput | InputJsonValue
    teamSize?: number | null
    teamComposition?: NullableJsonNullValueInput | InputJsonValue
    objectives?: NullableJsonNullValueInput | InputJsonValue
    customObjectives?: string | null
    industryType?: string | null
    technicalRequirements?: NullableJsonNullValueInput | InputJsonValue
    pricing?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: string | null
    paymentDueDate?: Date | string | null
    invoiceEmail?: string | null
    logistics?: NullableJsonNullValueInput | InputJsonValue
    contacts?: NullableJsonNullValueInput | InputJsonValue
    documents?: NullableJsonNullValueInput | InputJsonValue
    linkedSessionId?: string | null
    internalNotes?: string | null
    invoices?: InvoiceUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutItemsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
  }

  export type ProgramCreateWithoutOrderItemsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title: string
    slug: string
    category?: string
    status?: string
    featured?: boolean
    order?: number
    subtitle?: string | null
    excerpt?: string | null
    description?: NullableJsonNullValueInput | InputJsonValue
    teamSize?: number | null
    minTeamSize?: number | null
    maxTeamSize?: number | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    industryType?: string | null
    physicalLevel?: string | null
    indoorOutdoor?: string | null
    duration: number
    includesCatering?: boolean
    debriefIncluded?: boolean
    facilitationRequired?: boolean
    technicalRequirements?: NullableJsonNullValueInput | InputJsonValue
    materialsIncluded?: NullableJsonNullValueInput | InputJsonValue
    venueRequirements?: NullableJsonNullValueInput | InputJsonValue
    price?: number | null
    pricePerPerson?: number | null
    pricingNotes?: string | null
    featuredImageUrl?: string | null
    featuredImageAlt?: string | null
    galleryImages?: NullableJsonNullValueInput | InputJsonValue
    videoUrl?: string | null
    seo?: NullableJsonNullValueInput | InputJsonValue
    sessions?: SessionCreateNestedManyWithoutProgramInput
    activityLinks?: ProgramActivityCreateNestedManyWithoutProgramInput
  }

  export type ProgramUncheckedCreateWithoutOrderItemsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title: string
    slug: string
    category?: string
    status?: string
    featured?: boolean
    order?: number
    subtitle?: string | null
    excerpt?: string | null
    description?: NullableJsonNullValueInput | InputJsonValue
    teamSize?: number | null
    minTeamSize?: number | null
    maxTeamSize?: number | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    industryType?: string | null
    physicalLevel?: string | null
    indoorOutdoor?: string | null
    duration: number
    includesCatering?: boolean
    debriefIncluded?: boolean
    facilitationRequired?: boolean
    technicalRequirements?: NullableJsonNullValueInput | InputJsonValue
    materialsIncluded?: NullableJsonNullValueInput | InputJsonValue
    venueRequirements?: NullableJsonNullValueInput | InputJsonValue
    price?: number | null
    pricePerPerson?: number | null
    pricingNotes?: string | null
    featuredImageUrl?: string | null
    featuredImageAlt?: string | null
    galleryImages?: NullableJsonNullValueInput | InputJsonValue
    videoUrl?: string | null
    seo?: NullableJsonNullValueInput | InputJsonValue
    sessions?: SessionUncheckedCreateNestedManyWithoutProgramInput
    activityLinks?: ProgramActivityUncheckedCreateNestedManyWithoutProgramInput
  }

  export type ProgramCreateOrConnectWithoutOrderItemsInput = {
    where: ProgramWhereUniqueInput
    create: XOR<ProgramCreateWithoutOrderItemsInput, ProgramUncheckedCreateWithoutOrderItemsInput>
  }

  export type ActivityCreateWithoutOrderItemsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title: string
    slug: string
    category?: string
    status?: string
    featured?: boolean
    order?: number
    subtitle?: string | null
    excerpt?: string | null
    description?: NullableJsonNullValueInput | InputJsonValue
    minParticipants?: number | null
    maxParticipants?: number | null
    idealGroupSize?: number | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    learningOutcomes?: NullableJsonNullValueInput | InputJsonValue
    physicalDemand?: string | null
    indoorOutdoor?: string | null
    duration: number
    materialsNeeded?: NullableJsonNullValueInput | InputJsonValue
    setupTime?: number | null
    facilitatorGuide?: NullableJsonNullValueInput | InputJsonValue
    difficultyLevel?: string | null
    scalable?: boolean
    canCombine?: boolean
    price?: number | null
    featuredImageUrl?: string | null
    featuredImageAlt?: string | null
    galleryImages?: NullableJsonNullValueInput | InputJsonValue
    videoUrl?: string | null
    instructionPdfUrl?: string | null
    seo?: NullableJsonNullValueInput | InputJsonValue
    programLinks?: ProgramActivityCreateNestedManyWithoutActivityInput
  }

  export type ActivityUncheckedCreateWithoutOrderItemsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title: string
    slug: string
    category?: string
    status?: string
    featured?: boolean
    order?: number
    subtitle?: string | null
    excerpt?: string | null
    description?: NullableJsonNullValueInput | InputJsonValue
    minParticipants?: number | null
    maxParticipants?: number | null
    idealGroupSize?: number | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    learningOutcomes?: NullableJsonNullValueInput | InputJsonValue
    physicalDemand?: string | null
    indoorOutdoor?: string | null
    duration: number
    materialsNeeded?: NullableJsonNullValueInput | InputJsonValue
    setupTime?: number | null
    facilitatorGuide?: NullableJsonNullValueInput | InputJsonValue
    difficultyLevel?: string | null
    scalable?: boolean
    canCombine?: boolean
    price?: number | null
    featuredImageUrl?: string | null
    featuredImageAlt?: string | null
    galleryImages?: NullableJsonNullValueInput | InputJsonValue
    videoUrl?: string | null
    instructionPdfUrl?: string | null
    seo?: NullableJsonNullValueInput | InputJsonValue
    programLinks?: ProgramActivityUncheckedCreateNestedManyWithoutActivityInput
  }

  export type ActivityCreateOrConnectWithoutOrderItemsInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutOrderItemsInput, ActivityUncheckedCreateWithoutOrderItemsInput>
  }

  export type ExtraCreateWithoutOrderItemsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title: string
    slug: string
    category: string
    status?: string
    order?: number
    excerpt?: string | null
    description?: NullableJsonNullValueInput | InputJsonValue
    priceFrom?: number | null
    priceUnit?: string | null
    featuredImageUrl?: string | null
    featuredImageAlt?: string | null
    seo?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ExtraUncheckedCreateWithoutOrderItemsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title: string
    slug: string
    category: string
    status?: string
    order?: number
    excerpt?: string | null
    description?: NullableJsonNullValueInput | InputJsonValue
    priceFrom?: number | null
    priceUnit?: string | null
    featuredImageUrl?: string | null
    featuredImageAlt?: string | null
    seo?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ExtraCreateOrConnectWithoutOrderItemsInput = {
    where: ExtraWhereUniqueInput
    create: XOR<ExtraCreateWithoutOrderItemsInput, ExtraUncheckedCreateWithoutOrderItemsInput>
  }

  export type OrderUpsertWithoutItemsInput = {
    update: XOR<OrderUpdateWithoutItemsInput, OrderUncheckedUpdateWithoutItemsInput>
    create: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutItemsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutItemsInput, OrderUncheckedUpdateWithoutItemsInput>
  }

  export type OrderUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sessionName?: NullableStringFieldUpdateOperationsInput | string | null
    dates?: JsonNullValueInput | InputJsonValue
    venue?: JsonNullValueInput | InputJsonValue
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    teamComposition?: NullableJsonNullValueInput | InputJsonValue
    objectives?: NullableJsonNullValueInput | InputJsonValue
    customObjectives?: NullableStringFieldUpdateOperationsInput | string | null
    industryType?: NullableStringFieldUpdateOperationsInput | string | null
    technicalRequirements?: NullableJsonNullValueInput | InputJsonValue
    pricing?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoiceEmail?: NullableStringFieldUpdateOperationsInput | string | null
    logistics?: NullableJsonNullValueInput | InputJsonValue
    contacts?: NullableJsonNullValueInput | InputJsonValue
    documents?: NullableJsonNullValueInput | InputJsonValue
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerUpdateOneWithoutOrdersNestedInput
    linkedSession?: SessionUpdateOneWithoutOrdersNestedInput
    invoices?: InvoiceUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sessionName?: NullableStringFieldUpdateOperationsInput | string | null
    dates?: JsonNullValueInput | InputJsonValue
    venue?: JsonNullValueInput | InputJsonValue
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    teamComposition?: NullableJsonNullValueInput | InputJsonValue
    objectives?: NullableJsonNullValueInput | InputJsonValue
    customObjectives?: NullableStringFieldUpdateOperationsInput | string | null
    industryType?: NullableStringFieldUpdateOperationsInput | string | null
    technicalRequirements?: NullableJsonNullValueInput | InputJsonValue
    pricing?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoiceEmail?: NullableStringFieldUpdateOperationsInput | string | null
    logistics?: NullableJsonNullValueInput | InputJsonValue
    contacts?: NullableJsonNullValueInput | InputJsonValue
    documents?: NullableJsonNullValueInput | InputJsonValue
    linkedSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    invoices?: InvoiceUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type ProgramUpsertWithoutOrderItemsInput = {
    update: XOR<ProgramUpdateWithoutOrderItemsInput, ProgramUncheckedUpdateWithoutOrderItemsInput>
    create: XOR<ProgramCreateWithoutOrderItemsInput, ProgramUncheckedCreateWithoutOrderItemsInput>
    where?: ProgramWhereInput
  }

  export type ProgramUpdateToOneWithWhereWithoutOrderItemsInput = {
    where?: ProgramWhereInput
    data: XOR<ProgramUpdateWithoutOrderItemsInput, ProgramUncheckedUpdateWithoutOrderItemsInput>
  }

  export type ProgramUpdateWithoutOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableJsonNullValueInput | InputJsonValue
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    minTeamSize?: NullableIntFieldUpdateOperationsInput | number | null
    maxTeamSize?: NullableIntFieldUpdateOperationsInput | number | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    industryType?: NullableStringFieldUpdateOperationsInput | string | null
    physicalLevel?: NullableStringFieldUpdateOperationsInput | string | null
    indoorOutdoor?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    includesCatering?: BoolFieldUpdateOperationsInput | boolean
    debriefIncluded?: BoolFieldUpdateOperationsInput | boolean
    facilitationRequired?: BoolFieldUpdateOperationsInput | boolean
    technicalRequirements?: NullableJsonNullValueInput | InputJsonValue
    materialsIncluded?: NullableJsonNullValueInput | InputJsonValue
    venueRequirements?: NullableJsonNullValueInput | InputJsonValue
    price?: NullableIntFieldUpdateOperationsInput | number | null
    pricePerPerson?: NullableIntFieldUpdateOperationsInput | number | null
    pricingNotes?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    galleryImages?: NullableJsonNullValueInput | InputJsonValue
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    seo?: NullableJsonNullValueInput | InputJsonValue
    sessions?: SessionUpdateManyWithoutProgramNestedInput
    activityLinks?: ProgramActivityUpdateManyWithoutProgramNestedInput
  }

  export type ProgramUncheckedUpdateWithoutOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableJsonNullValueInput | InputJsonValue
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    minTeamSize?: NullableIntFieldUpdateOperationsInput | number | null
    maxTeamSize?: NullableIntFieldUpdateOperationsInput | number | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    industryType?: NullableStringFieldUpdateOperationsInput | string | null
    physicalLevel?: NullableStringFieldUpdateOperationsInput | string | null
    indoorOutdoor?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    includesCatering?: BoolFieldUpdateOperationsInput | boolean
    debriefIncluded?: BoolFieldUpdateOperationsInput | boolean
    facilitationRequired?: BoolFieldUpdateOperationsInput | boolean
    technicalRequirements?: NullableJsonNullValueInput | InputJsonValue
    materialsIncluded?: NullableJsonNullValueInput | InputJsonValue
    venueRequirements?: NullableJsonNullValueInput | InputJsonValue
    price?: NullableIntFieldUpdateOperationsInput | number | null
    pricePerPerson?: NullableIntFieldUpdateOperationsInput | number | null
    pricingNotes?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    galleryImages?: NullableJsonNullValueInput | InputJsonValue
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    seo?: NullableJsonNullValueInput | InputJsonValue
    sessions?: SessionUncheckedUpdateManyWithoutProgramNestedInput
    activityLinks?: ProgramActivityUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type ActivityUpsertWithoutOrderItemsInput = {
    update: XOR<ActivityUpdateWithoutOrderItemsInput, ActivityUncheckedUpdateWithoutOrderItemsInput>
    create: XOR<ActivityCreateWithoutOrderItemsInput, ActivityUncheckedCreateWithoutOrderItemsInput>
    where?: ActivityWhereInput
  }

  export type ActivityUpdateToOneWithWhereWithoutOrderItemsInput = {
    where?: ActivityWhereInput
    data: XOR<ActivityUpdateWithoutOrderItemsInput, ActivityUncheckedUpdateWithoutOrderItemsInput>
  }

  export type ActivityUpdateWithoutOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableJsonNullValueInput | InputJsonValue
    minParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    idealGroupSize?: NullableIntFieldUpdateOperationsInput | number | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    learningOutcomes?: NullableJsonNullValueInput | InputJsonValue
    physicalDemand?: NullableStringFieldUpdateOperationsInput | string | null
    indoorOutdoor?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    materialsNeeded?: NullableJsonNullValueInput | InputJsonValue
    setupTime?: NullableIntFieldUpdateOperationsInput | number | null
    facilitatorGuide?: NullableJsonNullValueInput | InputJsonValue
    difficultyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    scalable?: BoolFieldUpdateOperationsInput | boolean
    canCombine?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableIntFieldUpdateOperationsInput | number | null
    featuredImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    galleryImages?: NullableJsonNullValueInput | InputJsonValue
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    instructionPdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    seo?: NullableJsonNullValueInput | InputJsonValue
    programLinks?: ProgramActivityUpdateManyWithoutActivityNestedInput
  }

  export type ActivityUncheckedUpdateWithoutOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableJsonNullValueInput | InputJsonValue
    minParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    idealGroupSize?: NullableIntFieldUpdateOperationsInput | number | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    learningOutcomes?: NullableJsonNullValueInput | InputJsonValue
    physicalDemand?: NullableStringFieldUpdateOperationsInput | string | null
    indoorOutdoor?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    materialsNeeded?: NullableJsonNullValueInput | InputJsonValue
    setupTime?: NullableIntFieldUpdateOperationsInput | number | null
    facilitatorGuide?: NullableJsonNullValueInput | InputJsonValue
    difficultyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    scalable?: BoolFieldUpdateOperationsInput | boolean
    canCombine?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableIntFieldUpdateOperationsInput | number | null
    featuredImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    galleryImages?: NullableJsonNullValueInput | InputJsonValue
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    instructionPdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    seo?: NullableJsonNullValueInput | InputJsonValue
    programLinks?: ProgramActivityUncheckedUpdateManyWithoutActivityNestedInput
  }

  export type ExtraUpsertWithoutOrderItemsInput = {
    update: XOR<ExtraUpdateWithoutOrderItemsInput, ExtraUncheckedUpdateWithoutOrderItemsInput>
    create: XOR<ExtraCreateWithoutOrderItemsInput, ExtraUncheckedCreateWithoutOrderItemsInput>
    where?: ExtraWhereInput
  }

  export type ExtraUpdateToOneWithWhereWithoutOrderItemsInput = {
    where?: ExtraWhereInput
    data: XOR<ExtraUpdateWithoutOrderItemsInput, ExtraUncheckedUpdateWithoutOrderItemsInput>
  }

  export type ExtraUpdateWithoutOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableJsonNullValueInput | InputJsonValue
    priceFrom?: NullableIntFieldUpdateOperationsInput | number | null
    priceUnit?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    seo?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ExtraUncheckedUpdateWithoutOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableJsonNullValueInput | InputJsonValue
    priceFrom?: NullableIntFieldUpdateOperationsInput | number | null
    priceUnit?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    seo?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CustomerCreateWithoutInvoicesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    firstName: string
    lastName: string
    phone?: string | null
    organization?: string | null
    organizationType?: string | null
    industryType?: string | null
    teamSize?: number | null
    address?: NullableJsonNullValueInput | InputJsonValue
    billingInfo?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    gdprConsent?: NullableJsonNullValueInput | InputJsonValue
    averagePaymentDays?: number | null
    paymentReliability?: string | null
    totalInvoiced?: number
    totalPaid?: number
    invoiceCount?: number
    overdueCount?: number
    lastInvoiceDate?: Date | string | null
    lastPaymentDate?: Date | string | null
    orders?: OrderCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutInvoicesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    firstName: string
    lastName: string
    phone?: string | null
    organization?: string | null
    organizationType?: string | null
    industryType?: string | null
    teamSize?: number | null
    address?: NullableJsonNullValueInput | InputJsonValue
    billingInfo?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    gdprConsent?: NullableJsonNullValueInput | InputJsonValue
    averagePaymentDays?: number | null
    paymentReliability?: string | null
    totalInvoiced?: number
    totalPaid?: number
    invoiceCount?: number
    overdueCount?: number
    lastInvoiceDate?: Date | string | null
    lastPaymentDate?: Date | string | null
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutInvoicesInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutInvoicesInput, CustomerUncheckedCreateWithoutInvoicesInput>
  }

  export type OrderCreateWithoutInvoicesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    orderNumber: string
    source?: string
    status?: string
    sessionName?: string | null
    dates: JsonNullValueInput | InputJsonValue
    venue: JsonNullValueInput | InputJsonValue
    teamSize?: number | null
    teamComposition?: NullableJsonNullValueInput | InputJsonValue
    objectives?: NullableJsonNullValueInput | InputJsonValue
    customObjectives?: string | null
    industryType?: string | null
    technicalRequirements?: NullableJsonNullValueInput | InputJsonValue
    pricing?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: string | null
    paymentDueDate?: Date | string | null
    invoiceEmail?: string | null
    logistics?: NullableJsonNullValueInput | InputJsonValue
    contacts?: NullableJsonNullValueInput | InputJsonValue
    documents?: NullableJsonNullValueInput | InputJsonValue
    internalNotes?: string | null
    customer?: CustomerCreateNestedOneWithoutOrdersInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    linkedSession?: SessionCreateNestedOneWithoutOrdersInput
  }

  export type OrderUncheckedCreateWithoutInvoicesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    orderNumber: string
    customerId?: string | null
    source?: string
    status?: string
    sessionName?: string | null
    dates: JsonNullValueInput | InputJsonValue
    venue: JsonNullValueInput | InputJsonValue
    teamSize?: number | null
    teamComposition?: NullableJsonNullValueInput | InputJsonValue
    objectives?: NullableJsonNullValueInput | InputJsonValue
    customObjectives?: string | null
    industryType?: string | null
    technicalRequirements?: NullableJsonNullValueInput | InputJsonValue
    pricing?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: string | null
    paymentDueDate?: Date | string | null
    invoiceEmail?: string | null
    logistics?: NullableJsonNullValueInput | InputJsonValue
    contacts?: NullableJsonNullValueInput | InputJsonValue
    documents?: NullableJsonNullValueInput | InputJsonValue
    linkedSessionId?: string | null
    internalNotes?: string | null
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutInvoicesInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutInvoicesInput, OrderUncheckedCreateWithoutInvoicesInput>
  }

  export type CustomerUpsertWithoutInvoicesInput = {
    update: XOR<CustomerUpdateWithoutInvoicesInput, CustomerUncheckedUpdateWithoutInvoicesInput>
    create: XOR<CustomerCreateWithoutInvoicesInput, CustomerUncheckedCreateWithoutInvoicesInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutInvoicesInput, CustomerUncheckedUpdateWithoutInvoicesInput>
  }

  export type CustomerUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    organizationType?: NullableStringFieldUpdateOperationsInput | string | null
    industryType?: NullableStringFieldUpdateOperationsInput | string | null
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    address?: NullableJsonNullValueInput | InputJsonValue
    billingInfo?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    gdprConsent?: NullableJsonNullValueInput | InputJsonValue
    averagePaymentDays?: NullableIntFieldUpdateOperationsInput | number | null
    paymentReliability?: NullableStringFieldUpdateOperationsInput | string | null
    totalInvoiced?: IntFieldUpdateOperationsInput | number
    totalPaid?: IntFieldUpdateOperationsInput | number
    invoiceCount?: IntFieldUpdateOperationsInput | number
    overdueCount?: IntFieldUpdateOperationsInput | number
    lastInvoiceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orders?: OrderUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    organizationType?: NullableStringFieldUpdateOperationsInput | string | null
    industryType?: NullableStringFieldUpdateOperationsInput | string | null
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    address?: NullableJsonNullValueInput | InputJsonValue
    billingInfo?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    gdprConsent?: NullableJsonNullValueInput | InputJsonValue
    averagePaymentDays?: NullableIntFieldUpdateOperationsInput | number | null
    paymentReliability?: NullableStringFieldUpdateOperationsInput | string | null
    totalInvoiced?: IntFieldUpdateOperationsInput | number
    totalPaid?: IntFieldUpdateOperationsInput | number
    invoiceCount?: IntFieldUpdateOperationsInput | number
    overdueCount?: IntFieldUpdateOperationsInput | number
    lastInvoiceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type OrderUpsertWithoutInvoicesInput = {
    update: XOR<OrderUpdateWithoutInvoicesInput, OrderUncheckedUpdateWithoutInvoicesInput>
    create: XOR<OrderCreateWithoutInvoicesInput, OrderUncheckedCreateWithoutInvoicesInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutInvoicesInput, OrderUncheckedUpdateWithoutInvoicesInput>
  }

  export type OrderUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sessionName?: NullableStringFieldUpdateOperationsInput | string | null
    dates?: JsonNullValueInput | InputJsonValue
    venue?: JsonNullValueInput | InputJsonValue
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    teamComposition?: NullableJsonNullValueInput | InputJsonValue
    objectives?: NullableJsonNullValueInput | InputJsonValue
    customObjectives?: NullableStringFieldUpdateOperationsInput | string | null
    industryType?: NullableStringFieldUpdateOperationsInput | string | null
    technicalRequirements?: NullableJsonNullValueInput | InputJsonValue
    pricing?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoiceEmail?: NullableStringFieldUpdateOperationsInput | string | null
    logistics?: NullableJsonNullValueInput | InputJsonValue
    contacts?: NullableJsonNullValueInput | InputJsonValue
    documents?: NullableJsonNullValueInput | InputJsonValue
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerUpdateOneWithoutOrdersNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    linkedSession?: SessionUpdateOneWithoutOrdersNestedInput
  }

  export type OrderUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sessionName?: NullableStringFieldUpdateOperationsInput | string | null
    dates?: JsonNullValueInput | InputJsonValue
    venue?: JsonNullValueInput | InputJsonValue
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    teamComposition?: NullableJsonNullValueInput | InputJsonValue
    objectives?: NullableJsonNullValueInput | InputJsonValue
    customObjectives?: NullableStringFieldUpdateOperationsInput | string | null
    industryType?: NullableStringFieldUpdateOperationsInput | string | null
    technicalRequirements?: NullableJsonNullValueInput | InputJsonValue
    pricing?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoiceEmail?: NullableStringFieldUpdateOperationsInput | string | null
    logistics?: NullableJsonNullValueInput | InputJsonValue
    contacts?: NullableJsonNullValueInput | InputJsonValue
    documents?: NullableJsonNullValueInput | InputJsonValue
    linkedSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
  }

  export type UserSessionCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type UserSessionUncheckedCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type UserSessionCreateOrConnectWithoutUserInput = {
    where: UserSessionWhereUniqueInput
    create: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput>
  }

  export type UserSessionCreateManyUserInputEnvelope = {
    data: UserSessionCreateManyUserInput | UserSessionCreateManyUserInput[]
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
  }

  export type UserSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: UserSessionWhereUniqueInput
    update: XOR<UserSessionUpdateWithoutUserInput, UserSessionUncheckedUpdateWithoutUserInput>
    create: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput>
  }

  export type UserSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: UserSessionWhereUniqueInput
    data: XOR<UserSessionUpdateWithoutUserInput, UserSessionUncheckedUpdateWithoutUserInput>
  }

  export type UserSessionUpdateManyWithWhereWithoutUserInput = {
    where: UserSessionScalarWhereInput
    data: XOR<UserSessionUpdateManyMutationInput, UserSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type UserSessionScalarWhereInput = {
    AND?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
    OR?: UserSessionScalarWhereInput[]
    NOT?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
    id?: StringFilter<"UserSession"> | string
    sessionToken?: StringFilter<"UserSession"> | string
    userId?: StringFilter<"UserSession"> | string
    expires?: DateTimeFilter<"UserSession"> | Date | string
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: UserSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SessionCreateManyProgramInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    date: Date | string
    endDate?: Date | string | null
    venue: JsonNullValueInput | InputJsonValue
    teamSize?: number | null
    teamName?: string | null
    companyName?: string | null
    industryType?: string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    customObjectives?: string | null
    status?: string
    isPublic?: boolean
    debriefCompleted?: boolean
    debriefReport?: NullableJsonNullValueInput | InputJsonValue
    debriefGeneratedAt?: Date | string | null
    notes?: string | null
  }

  export type ProgramActivityCreateManyProgramInput = {
    id?: string
    createdAt?: Date | string
    activityId: string
    order?: number
    duration?: number | null
    notes?: string | null
  }

  export type OrderItemCreateManyProgramInput = {
    id?: string
    createdAt?: Date | string
    orderId: string
    activityId?: string | null
    extraId?: string | null
    date: string
    startTime?: string | null
    endTime?: string | null
    price?: number
    notes?: string | null
  }

  export type SessionUpdateWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    venue?: JsonNullValueInput | InputJsonValue
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    teamName?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    industryType?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    customObjectives?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    debriefCompleted?: BoolFieldUpdateOperationsInput | boolean
    debriefReport?: NullableJsonNullValueInput | InputJsonValue
    debriefGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: OrderUpdateManyWithoutLinkedSessionNestedInput
  }

  export type SessionUncheckedUpdateWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    venue?: JsonNullValueInput | InputJsonValue
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    teamName?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    industryType?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    customObjectives?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    debriefCompleted?: BoolFieldUpdateOperationsInput | boolean
    debriefReport?: NullableJsonNullValueInput | InputJsonValue
    debriefGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: OrderUncheckedUpdateManyWithoutLinkedSessionNestedInput
  }

  export type SessionUncheckedUpdateManyWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    venue?: JsonNullValueInput | InputJsonValue
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    teamName?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    industryType?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    customObjectives?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    debriefCompleted?: BoolFieldUpdateOperationsInput | boolean
    debriefReport?: NullableJsonNullValueInput | InputJsonValue
    debriefGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProgramActivityUpdateWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: IntFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    activity?: ActivityUpdateOneRequiredWithoutProgramLinksNestedInput
  }

  export type ProgramActivityUncheckedUpdateWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activityId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProgramActivityUncheckedUpdateManyWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activityId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderItemUpdateWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: StringFieldUpdateOperationsInput | string
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    order?: OrderUpdateOneRequiredWithoutItemsNestedInput
    activity?: ActivityUpdateOneWithoutOrderItemsNestedInput
    extra?: ExtraUpdateOneWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: StringFieldUpdateOperationsInput | string
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    extraId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: StringFieldUpdateOperationsInput | string
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderItemUncheckedUpdateManyWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: StringFieldUpdateOperationsInput | string
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    extraId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: StringFieldUpdateOperationsInput | string
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProgramActivityCreateManyActivityInput = {
    id?: string
    createdAt?: Date | string
    programId: string
    order?: number
    duration?: number | null
    notes?: string | null
  }

  export type OrderItemCreateManyActivityInput = {
    id?: string
    createdAt?: Date | string
    orderId: string
    programId?: string | null
    extraId?: string | null
    date: string
    startTime?: string | null
    endTime?: string | null
    price?: number
    notes?: string | null
  }

  export type ProgramActivityUpdateWithoutActivityInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: IntFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    program?: ProgramUpdateOneRequiredWithoutActivityLinksNestedInput
  }

  export type ProgramActivityUncheckedUpdateWithoutActivityInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    programId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProgramActivityUncheckedUpdateManyWithoutActivityInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    programId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderItemUpdateWithoutActivityInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: StringFieldUpdateOperationsInput | string
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    order?: OrderUpdateOneRequiredWithoutItemsNestedInput
    program?: ProgramUpdateOneWithoutOrderItemsNestedInput
    extra?: ExtraUpdateOneWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutActivityInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: StringFieldUpdateOperationsInput | string
    programId?: NullableStringFieldUpdateOperationsInput | string | null
    extraId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: StringFieldUpdateOperationsInput | string
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderItemUncheckedUpdateManyWithoutActivityInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: StringFieldUpdateOperationsInput | string
    programId?: NullableStringFieldUpdateOperationsInput | string | null
    extraId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: StringFieldUpdateOperationsInput | string
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderItemCreateManyExtraInput = {
    id?: string
    createdAt?: Date | string
    orderId: string
    programId?: string | null
    activityId?: string | null
    date: string
    startTime?: string | null
    endTime?: string | null
    price?: number
    notes?: string | null
  }

  export type OrderItemUpdateWithoutExtraInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: StringFieldUpdateOperationsInput | string
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    order?: OrderUpdateOneRequiredWithoutItemsNestedInput
    program?: ProgramUpdateOneWithoutOrderItemsNestedInput
    activity?: ActivityUpdateOneWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutExtraInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: StringFieldUpdateOperationsInput | string
    programId?: NullableStringFieldUpdateOperationsInput | string | null
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: StringFieldUpdateOperationsInput | string
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderItemUncheckedUpdateManyWithoutExtraInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: StringFieldUpdateOperationsInput | string
    programId?: NullableStringFieldUpdateOperationsInput | string | null
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: StringFieldUpdateOperationsInput | string
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderCreateManyLinkedSessionInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    orderNumber: string
    customerId?: string | null
    source?: string
    status?: string
    sessionName?: string | null
    dates: JsonNullValueInput | InputJsonValue
    venue: JsonNullValueInput | InputJsonValue
    teamSize?: number | null
    teamComposition?: NullableJsonNullValueInput | InputJsonValue
    objectives?: NullableJsonNullValueInput | InputJsonValue
    customObjectives?: string | null
    industryType?: string | null
    technicalRequirements?: NullableJsonNullValueInput | InputJsonValue
    pricing?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: string | null
    paymentDueDate?: Date | string | null
    invoiceEmail?: string | null
    logistics?: NullableJsonNullValueInput | InputJsonValue
    contacts?: NullableJsonNullValueInput | InputJsonValue
    documents?: NullableJsonNullValueInput | InputJsonValue
    internalNotes?: string | null
  }

  export type OrderUpdateWithoutLinkedSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sessionName?: NullableStringFieldUpdateOperationsInput | string | null
    dates?: JsonNullValueInput | InputJsonValue
    venue?: JsonNullValueInput | InputJsonValue
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    teamComposition?: NullableJsonNullValueInput | InputJsonValue
    objectives?: NullableJsonNullValueInput | InputJsonValue
    customObjectives?: NullableStringFieldUpdateOperationsInput | string | null
    industryType?: NullableStringFieldUpdateOperationsInput | string | null
    technicalRequirements?: NullableJsonNullValueInput | InputJsonValue
    pricing?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoiceEmail?: NullableStringFieldUpdateOperationsInput | string | null
    logistics?: NullableJsonNullValueInput | InputJsonValue
    contacts?: NullableJsonNullValueInput | InputJsonValue
    documents?: NullableJsonNullValueInput | InputJsonValue
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerUpdateOneWithoutOrdersNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    invoices?: InvoiceUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutLinkedSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sessionName?: NullableStringFieldUpdateOperationsInput | string | null
    dates?: JsonNullValueInput | InputJsonValue
    venue?: JsonNullValueInput | InputJsonValue
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    teamComposition?: NullableJsonNullValueInput | InputJsonValue
    objectives?: NullableJsonNullValueInput | InputJsonValue
    customObjectives?: NullableStringFieldUpdateOperationsInput | string | null
    industryType?: NullableStringFieldUpdateOperationsInput | string | null
    technicalRequirements?: NullableJsonNullValueInput | InputJsonValue
    pricing?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoiceEmail?: NullableStringFieldUpdateOperationsInput | string | null
    logistics?: NullableJsonNullValueInput | InputJsonValue
    contacts?: NullableJsonNullValueInput | InputJsonValue
    documents?: NullableJsonNullValueInput | InputJsonValue
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutLinkedSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sessionName?: NullableStringFieldUpdateOperationsInput | string | null
    dates?: JsonNullValueInput | InputJsonValue
    venue?: JsonNullValueInput | InputJsonValue
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    teamComposition?: NullableJsonNullValueInput | InputJsonValue
    objectives?: NullableJsonNullValueInput | InputJsonValue
    customObjectives?: NullableStringFieldUpdateOperationsInput | string | null
    industryType?: NullableStringFieldUpdateOperationsInput | string | null
    technicalRequirements?: NullableJsonNullValueInput | InputJsonValue
    pricing?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoiceEmail?: NullableStringFieldUpdateOperationsInput | string | null
    logistics?: NullableJsonNullValueInput | InputJsonValue
    contacts?: NullableJsonNullValueInput | InputJsonValue
    documents?: NullableJsonNullValueInput | InputJsonValue
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderCreateManyCustomerInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    orderNumber: string
    source?: string
    status?: string
    sessionName?: string | null
    dates: JsonNullValueInput | InputJsonValue
    venue: JsonNullValueInput | InputJsonValue
    teamSize?: number | null
    teamComposition?: NullableJsonNullValueInput | InputJsonValue
    objectives?: NullableJsonNullValueInput | InputJsonValue
    customObjectives?: string | null
    industryType?: string | null
    technicalRequirements?: NullableJsonNullValueInput | InputJsonValue
    pricing?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: string | null
    paymentDueDate?: Date | string | null
    invoiceEmail?: string | null
    logistics?: NullableJsonNullValueInput | InputJsonValue
    contacts?: NullableJsonNullValueInput | InputJsonValue
    documents?: NullableJsonNullValueInput | InputJsonValue
    linkedSessionId?: string | null
    internalNotes?: string | null
  }

  export type InvoiceCreateManyCustomerInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceNumber: string
    status?: string
    orderId?: string | null
    issueDate?: Date | string
    dueDate: Date | string
    paidDate?: Date | string | null
    items: JsonNullValueInput | InputJsonValue
    subtotal: number
    vatRate?: number | null
    vatAmount?: number | null
    totalAmount: number
    paidAmount?: number
    paymentMethod?: string | null
    bankAccount?: string | null
    variableSymbol?: string | null
    currency?: string
    pdfUrl?: string | null
    pdfGeneratedAt?: Date | string | null
    textBeforeItems?: string | null
    textAfterItems?: string | null
    notes?: string | null
  }

  export type OrderUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sessionName?: NullableStringFieldUpdateOperationsInput | string | null
    dates?: JsonNullValueInput | InputJsonValue
    venue?: JsonNullValueInput | InputJsonValue
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    teamComposition?: NullableJsonNullValueInput | InputJsonValue
    objectives?: NullableJsonNullValueInput | InputJsonValue
    customObjectives?: NullableStringFieldUpdateOperationsInput | string | null
    industryType?: NullableStringFieldUpdateOperationsInput | string | null
    technicalRequirements?: NullableJsonNullValueInput | InputJsonValue
    pricing?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoiceEmail?: NullableStringFieldUpdateOperationsInput | string | null
    logistics?: NullableJsonNullValueInput | InputJsonValue
    contacts?: NullableJsonNullValueInput | InputJsonValue
    documents?: NullableJsonNullValueInput | InputJsonValue
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    linkedSession?: SessionUpdateOneWithoutOrdersNestedInput
    invoices?: InvoiceUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sessionName?: NullableStringFieldUpdateOperationsInput | string | null
    dates?: JsonNullValueInput | InputJsonValue
    venue?: JsonNullValueInput | InputJsonValue
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    teamComposition?: NullableJsonNullValueInput | InputJsonValue
    objectives?: NullableJsonNullValueInput | InputJsonValue
    customObjectives?: NullableStringFieldUpdateOperationsInput | string | null
    industryType?: NullableStringFieldUpdateOperationsInput | string | null
    technicalRequirements?: NullableJsonNullValueInput | InputJsonValue
    pricing?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoiceEmail?: NullableStringFieldUpdateOperationsInput | string | null
    logistics?: NullableJsonNullValueInput | InputJsonValue
    contacts?: NullableJsonNullValueInput | InputJsonValue
    documents?: NullableJsonNullValueInput | InputJsonValue
    linkedSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sessionName?: NullableStringFieldUpdateOperationsInput | string | null
    dates?: JsonNullValueInput | InputJsonValue
    venue?: JsonNullValueInput | InputJsonValue
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    teamComposition?: NullableJsonNullValueInput | InputJsonValue
    objectives?: NullableJsonNullValueInput | InputJsonValue
    customObjectives?: NullableStringFieldUpdateOperationsInput | string | null
    industryType?: NullableStringFieldUpdateOperationsInput | string | null
    technicalRequirements?: NullableJsonNullValueInput | InputJsonValue
    pricing?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoiceEmail?: NullableStringFieldUpdateOperationsInput | string | null
    logistics?: NullableJsonNullValueInput | InputJsonValue
    contacts?: NullableJsonNullValueInput | InputJsonValue
    documents?: NullableJsonNullValueInput | InputJsonValue
    linkedSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InvoiceUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: JsonNullValueInput | InputJsonValue
    subtotal?: IntFieldUpdateOperationsInput | number
    vatRate?: NullableIntFieldUpdateOperationsInput | number | null
    vatAmount?: NullableIntFieldUpdateOperationsInput | number | null
    totalAmount?: IntFieldUpdateOperationsInput | number
    paidAmount?: IntFieldUpdateOperationsInput | number
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    variableSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    pdfGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    textBeforeItems?: NullableStringFieldUpdateOperationsInput | string | null
    textAfterItems?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    order?: OrderUpdateOneWithoutInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: JsonNullValueInput | InputJsonValue
    subtotal?: IntFieldUpdateOperationsInput | number
    vatRate?: NullableIntFieldUpdateOperationsInput | number | null
    vatAmount?: NullableIntFieldUpdateOperationsInput | number | null
    totalAmount?: IntFieldUpdateOperationsInput | number
    paidAmount?: IntFieldUpdateOperationsInput | number
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    variableSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    pdfGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    textBeforeItems?: NullableStringFieldUpdateOperationsInput | string | null
    textAfterItems?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InvoiceUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: JsonNullValueInput | InputJsonValue
    subtotal?: IntFieldUpdateOperationsInput | number
    vatRate?: NullableIntFieldUpdateOperationsInput | number | null
    vatAmount?: NullableIntFieldUpdateOperationsInput | number | null
    totalAmount?: IntFieldUpdateOperationsInput | number
    paidAmount?: IntFieldUpdateOperationsInput | number
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    variableSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    pdfGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    textBeforeItems?: NullableStringFieldUpdateOperationsInput | string | null
    textAfterItems?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderItemCreateManyOrderInput = {
    id?: string
    createdAt?: Date | string
    programId?: string | null
    activityId?: string | null
    extraId?: string | null
    date: string
    startTime?: string | null
    endTime?: string | null
    price?: number
    notes?: string | null
  }

  export type InvoiceCreateManyOrderInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceNumber: string
    status?: string
    customerId: string
    issueDate?: Date | string
    dueDate: Date | string
    paidDate?: Date | string | null
    items: JsonNullValueInput | InputJsonValue
    subtotal: number
    vatRate?: number | null
    vatAmount?: number | null
    totalAmount: number
    paidAmount?: number
    paymentMethod?: string | null
    bankAccount?: string | null
    variableSymbol?: string | null
    currency?: string
    pdfUrl?: string | null
    pdfGeneratedAt?: Date | string | null
    textBeforeItems?: string | null
    textAfterItems?: string | null
    notes?: string | null
  }

  export type OrderItemUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: StringFieldUpdateOperationsInput | string
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    program?: ProgramUpdateOneWithoutOrderItemsNestedInput
    activity?: ActivityUpdateOneWithoutOrderItemsNestedInput
    extra?: ExtraUpdateOneWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    programId?: NullableStringFieldUpdateOperationsInput | string | null
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    extraId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: StringFieldUpdateOperationsInput | string
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    programId?: NullableStringFieldUpdateOperationsInput | string | null
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    extraId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: StringFieldUpdateOperationsInput | string
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InvoiceUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: JsonNullValueInput | InputJsonValue
    subtotal?: IntFieldUpdateOperationsInput | number
    vatRate?: NullableIntFieldUpdateOperationsInput | number | null
    vatAmount?: NullableIntFieldUpdateOperationsInput | number | null
    totalAmount?: IntFieldUpdateOperationsInput | number
    paidAmount?: IntFieldUpdateOperationsInput | number
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    variableSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    pdfGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    textBeforeItems?: NullableStringFieldUpdateOperationsInput | string | null
    textAfterItems?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerUpdateOneRequiredWithoutInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: JsonNullValueInput | InputJsonValue
    subtotal?: IntFieldUpdateOperationsInput | number
    vatRate?: NullableIntFieldUpdateOperationsInput | number | null
    vatAmount?: NullableIntFieldUpdateOperationsInput | number | null
    totalAmount?: IntFieldUpdateOperationsInput | number
    paidAmount?: IntFieldUpdateOperationsInput | number
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    variableSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    pdfGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    textBeforeItems?: NullableStringFieldUpdateOperationsInput | string | null
    textAfterItems?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InvoiceUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: JsonNullValueInput | InputJsonValue
    subtotal?: IntFieldUpdateOperationsInput | number
    vatRate?: NullableIntFieldUpdateOperationsInput | number | null
    vatAmount?: NullableIntFieldUpdateOperationsInput | number | null
    totalAmount?: IntFieldUpdateOperationsInput | number
    paidAmount?: IntFieldUpdateOperationsInput | number
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    variableSymbol?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    pdfGeneratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    textBeforeItems?: NullableStringFieldUpdateOperationsInput | string | null
    textAfterItems?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateManyUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type UserSessionCreateManyUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserSessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}